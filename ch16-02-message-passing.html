<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Utiliser l&#x27;envoi de messages pour transf√©rer des donn√©es entre les t√¢ches - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html" class="active"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Using Message Passing to Transfer Data Between Threads
-->
<h2 id="utiliser-lenvoi-de-messages-pour-transf√©rer-des-donn√©es-entre-les-t√¢ches"><a class="header" href="#utiliser-lenvoi-de-messages-pour-transf√©rer-des-donn√©es-entre-les-t√¢ches">Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></h2>
<!--
One increasingly popular approach to ensuring safe concurrency is *message
passing*, where threads or actors communicate by sending each other messages
containing data. Here‚Äôs the idea in a slogan from [the Go language
documentation](https://golang.org/doc/effective_go.html#concurrency):
‚ÄúDo not communicate by sharing memory; instead, share memory by communicating.‚Äù
-->
<p>Une approche de plus en plus populaire pour garantir la s√©curit√© de la
concurrence est l'<em>envoi de message</em>, avec lequel les t√¢ches ou les acteurs
communiquent en envoyant aux autres des messages contenant des donn√©es. Voici
l'id√©e r√©sum√©e, tir√©e d'un slogan provenant de <a href="https://golang.org/doc/effective_go.html#concurrency">la documentation du langage
Go</a>¬†: ‚ÄúNe communiquez pas
en partageant la m√©moire¬†; partagez plut√¥t la m√©moire en communiquant‚Äù.</p>
<!--
One major tool Rust has for accomplishing message-sending concurrency is the
*channel*, a programming concept that Rust‚Äôs standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or boat into a stream, it will travel downstream to the end of the
waterway.
-->
<p>Un des outils majeurs que Rust a pour accomplir l'envoi de messages pour la
concurrence est le <em>canal</em>, un concept de programmation dont la biblioth√®que
standard de Rust fournit une impl√©mentation. Vous pouvez imaginer un canal de
programmation comme √©tant un canal d'eau, comme un ruisseau ou une rivi√®re. Si
vous posez quelque chose comme un canard en plastique ou un bateau sur un
ruisseau, il se d√©placera en descendant le long de la voie d'eau.</p>
<!--
A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of your code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be *closed* if either the transmitter or receiver half is
dropped.
-->
<p>Un canal de programmation est divis√© en deux parties¬†: un transmetteur et un
receveur. La partie du transmetteur est le lieu en amont o√π vous d√©posez les
canards en plastique sur la rivi√®re et la partie du receveur est celle o√π les
canards en plastique finissent leur voyage. Une partie de votre code appelle
des m√©thodes du transmetteur en lui passant les donn√©es que vous souhaitez
envoyer, tandis qu'une autre partie attend que des messages arrivent. Un canal
est d√©clar√© <em>ferm√©</em> lorsque l'une des parties, le transmetteur ou le r√©cepteur,
est lib√©r√©e.</p>
<!--
Here, we‚Äôll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We‚Äôll be sending simple values between threads using a channel
to illustrate the feature. Once you‚Äôre familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.
-->
<p>Ici, nous allons concevoir un programme qui a une t√¢che pour g√©n√©rer des
valeurs et les envoyer dans un canal, et une autre t√¢che qui va recevoir les
valeurs et les afficher. Nous allons envoyer de simples valeurs entre les
t√¢ches en utilisant un canal pour illustrer cette fonctionnalit√©. Une fois que
vous serez familier avec cette technique, vous pourrez utiliser les canaux
pour cr√©er un syst√®me de dialogue en ligne ou un syst√®me o√π de nombreuses
t√¢ches font chacune une partie d'un gros calcul et envoient leur r√©sultat √† une
t√¢che charg√©e de les agr√©ger.</p>
<!--
First, in Listing 16-6, we‚Äôll create a channel but not do anything with it.
Note that this won‚Äôt compile yet because Rust can‚Äôt tell what type of values we
want to send over the channel.
-->
<p>Pour commencer, dans l'encart 16-6, nous allons cr√©er un canal mais nous
n'allons rien faire avec. Remarquez qu'il ne se compilera pas encore car Rust
ne peut pas savoir le type de valeurs que nous souhaitons envoyer dans le
canal.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<!--
<span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to `tx` and `rx`</span>
-->
<p><span class="caption">Encart 16-6¬†: cr√©ation d'un canal et assignation de ses
deux parties √† <code>tx</code> et <code>rx</code></span></p>
<!--
We create a new channel using the `mpsc::channel` function; `mpsc` stands for
*multiple producer, single consumer*. In short, the way Rust‚Äôs standard library
implements channels means a channel can have multiple *sending* ends that
produce values but only one *receiving* end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We‚Äôll start with a single
producer for now, but we‚Äôll add multiple producers when we get this example
working.
-->
<p>Nous cr√©ons un nouveau canal en utilisant la fonction <code>mpsc::channel</code>¬†; <code>mpsc</code>
signifie <em>multiple producer, single consumer</em>, c'est-√†-dire
<em>plusieurs producteurs, un seul consommateur</em>. En bref, la fa√ßon dont la
biblioth√®que standard de Rust a impl√©ment√© ces canaux permet d'avoir plusieurs
extr√©mit√©s <em>√©mettrices</em> qui produisent des valeurs, mais seulement une seule
extr√©mit√© <em>r√©ceptrice</em> qui consomme ces valeurs. Imaginez plusieurs ruisseaux
qui se rejoignent en une seule grosse rivi√®re¬†: tout ce qui est d√©pos√© sur les
ruisseaux va finir dans une seule rivi√®re √† la fin. Nous allons commencer avec
un seul producteur pour le moment, mais nous allons ajouter d'autres
producteurs lorsque notre exemple fonctionnera.</p>
<!--
The `mpsc::channel` function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations `tx`
and `rx` are traditionally used in many fields for *transmitter* and *receiver*
respectively, so we name our variables as such to indicate each end. We‚Äôre
using a `let` statement with a pattern that destructures the tuples; we‚Äôll
discuss the use of patterns in `let` statements and destructuring in Chapter
18. Using a `let` statement this way is a convenient approach to extract the
pieces of the tuple returned by `mpsc::channel`.
-->
<p>La fonction <code>mpsc::channel</code> retourne un tuple, le premier √©l√©ment est celui qui
permet d'envoyer et le second est celui qui re√ßoit. Les abr√©viations <code>tx</code> et
<code>rx</code> sont utilis√©s traditionnellement dans de nombreux domaines pour signifier
respectivement <em>transmetteur</em> et <em>r√©cepteur</em>, nous avons donc nomm√© nos
variables ainsi pour indiquer clairement le r√¥le de chaque √©l√©ment.  Nous
utilisons une instruction <code>let</code> avec un motif qui d√©structure les tuples¬†; nous
verrons l'utilisation des motifs dans les instructions <code>let</code> et la
d√©structuration au chapitre 18. L'utilisation d'une instruction <code>let</code> est une
fa√ßon d'extraire facilement les √©l√©ments du tuple retourn√© par <code>mpsc::channel</code>.</p>
<!--
Let‚Äôs move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.
-->
<p>D√©pla√ßons maintenant l'√©l√©ment de transmission dans une nouvelle t√¢che et
faisons-lui envoyer une cha√Æne de caract√®res afin que la nouvelle t√¢che
communique avec la t√¢che principale, comme dans l'encart 16-7. C'est comme
poser un canard en plastique sur l'amont de la rivi√®re ou envoyer un message
instantan√© d'une t√¢che √† une autre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-7: Moving `tx` to a spawned thread and sending
‚Äúhi‚Äù</span>
-->
<p><span class="caption">Encart 16-7¬†: d√©placement de <code>tx</code> dans la nouvelle t√¢che
et envoi de ‚Äúsalut‚Äù</span></p>
<!--
Again, we‚Äôre using `thread::spawn` to create a new thread and then using `move`
to move `tx` into the closure so the spawned thread owns `tx`. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.
-->
<p>Nous utilisons √† nouveau <code>thread::spawn</code> pour cr√©er une nouvelle t√¢che et
ensuite utiliser <code>move</code> pour d√©placer <code>tx</code> dans la fermeture afin que la
nouvelle t√¢che poss√®de d√©sormais <code>tx</code>. La nouvelle t√¢che a besoin de poss√©der
la partie √©mettrice du canal pour √™tre en capacit√© d'envoyer des messages
dans ce canal.</p>
<!--
The transmitting end has a `send` method that takes the value we want to send.
The `send` method returns a `Result<T, E>` type, so if the receiving end has
already been dropped and there‚Äôs nowhere to send a value, the send operation
will return an error. In this example, we‚Äôre calling `unwrap` to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.
-->
<p>La partie √©mettrice a une m√©thode <code>send</code> qui prend en argument la valeur que
nous souhaitons envoyer. La m√©thode <code>send</code> retourne un type <code>Result&lt;T, E&gt;</code>,
donc si la partie r√©ceptrice a d√©j√† √©t√© lib√©r√©e et qu'il n'y a nulle part o√π
envoyer la valeur, l'op√©ration d'envoi va retourner une erreur. Dans cet
exemple, nous faisons appel √† <code>unwrap</code> pour paniquer en cas d'erreur. Mais dans
un vrai programme, nous devrions g√©rer ce cas correctement¬†: retournez au
chapitre 9 pour revoir les strat√©gies permettant de g√©rer correctement les erreurs.</p>
<!--
In Listing 16-8, we‚Äôll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.
-->
<p>Dans l'encart 16-8, nous allons obtenir la valeur de l'extr√©mit√© r√©ceptrice du
canal dans la t√¢che principale. C'est comme r√©cup√©rer le canard en plastique
dans l'eau √† la fin de la rivi√®re, ou r√©cup√©rer un message instantan√©.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a re√ßu¬†: {}&quot;, recu);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-8: Receiving the value ‚Äúhi‚Äù in the main thread
and printing it</span>
-->
<p><span class="caption">Encart 16-8¬†: r√©ception de la valeur ‚Äúsalut‚Äù dans la
t√¢che principale pour l'afficher</span></p>
<!--
The receiving end of a channel has two useful methods: `recv` and `try_recv`.
We‚Äôre using `recv`, short for *receive*, which will block the main thread‚Äôs
execution and wait until a value is sent down the channel. Once a value is
sent, `recv` will return it in a `Result<T, E>`. When the sending end of the
channel closes, `recv` will return an error to signal that no more values will
be coming.
-->
<p>La partie r√©ception d'un canal a deux modes int√©ressants¬†: <code>recv</code> et
<code>try_recv</code>. Nous avons utilis√© <code>recv</code>, un raccourci pour <em>recevoir</em>, qui va
bloquer l'ex√©cution de la t√¢che principale et attendre jusqu'√† ce qu'une valeur
soit envoy√©e dans le canal. Une fois qu'une valeur est envoy√©e, <code>recv</code> va
la retourner dans un <code>Result&lt;T, E&gt;</code>. Lorsque la partie transmission du canal se
ferme, <code>recv</code> va retourner une erreur pour signaler qu'il n'y aura plus de
valeurs qui arriveront.</p>
<!--
The `try_recv` method doesn‚Äôt block, but will instead return a `Result<T, E>`
immediately: an `Ok` value holding a message if one is available and an `Err`
value if there aren‚Äôt any messages this time. Using `try_recv` is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls `try_recv` every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.
-->
<p>La m√©thode <code>try_recv</code> ne bloque pas, mais va plut√¥t retourner imm√©diatement un
<code>Result&lt;T, E&gt;</code>¬†: une valeur <code>Ok</code> qui contiendra un message s'il y en a un de
disponible, et une valeur <code>Err</code> s'il n'y a pas de message cette fois-ci.
L'utilisation de <code>try_recv</code> est pratique si cette t√¢che √† d'autres choses √†
faire pendant qu'elle attend les messages¬†: nous pouvons ainsi √©crire une
boucle qui appelle r√©guli√®rement <code>try_recv</code>, g√®re le message s'il y en a un, et
sinon fait d'autres choses avant de v√©rifier √† nouveau.</p>
<!--
We‚Äôve used `recv` in this example for simplicity; we don‚Äôt have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.
-->
<p>Nous avons utilis√© <code>recv</code> dans cet exemple pour des raisons de simplicit√©¬†;
nous n'avons rien d'autres √† faire dans la t√¢che principale que d'attendre les
messages, donc bloquer la t√¢che principale est acceptable.</p>
<!--
When we run the code in Listing 16-8, we‚Äôll see the value printed from the main
thread:
-->
<p>Lorsque nous ex√©cutons le code de l'encart 16-8, nous allons voir la valeur
s'afficher gr√¢ce √† la t√¢che principale¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
```
-->
<pre><code class="language-text">On a re√ßu¬†: salut
</code></pre>
<!--
Perfect!
-->
<p>C'est parfait ainsi¬†!</p>
<!--
### Channels and Ownership Transference
-->
<h3 id="les-canaux-et-le-transfert-de-possession"><a class="header" href="#les-canaux-et-le-transfert-de-possession">Les canaux et le transfert de possession</a></h3>
<!--
The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let‚Äôs do
an experiment to show how channels and ownership work together to prevent
problems: we‚Äôll try to use a `val` value in the spawned thread *after* we‚Äôve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn‚Äôt allowed:
-->
<p>Les r√®gles de possession jouent un r√¥le vital dans l'envoi de messages car
elles vous aident √† √©crire du code s√ªr et concurrent. R√©fl√©chir √† la possession
avec vos programmes Rust vous offre l'avantage d'√©viter des erreurs de
d√©veloppement avec la concurrence. Faisons une exp√©rience pour montrer comment
la possession et les canaux fonctionnent ensemble pour √©viter les probl√®mes¬†:
nous allons essayer d'utiliser la <code>valeur</code> dans la nouvelle t√¢che <em>apr√®s</em> que
nous l'avons envoy√©e dans le canal. Essayez de compiler le code de l'encart 16-9
pour d√©couvrir pourquoi ce code n'est pas autoris√©¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;hi&quot;);
        tx.send(valeur).unwrap();
        println!(&quot;valeur vaut {}&quot;, valeur);
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a re√ßu¬†: {}&quot;, recu);
}
</code></pre>
<!--
<span class="caption">Listing 16-9: Attempting to use `val` after we‚Äôve sent it
down the channel</span>
-->
<p><span class="caption">Encart 16-9¬†: tentative d'utiliser <code>valeur</code> apr√®s que
nous l'avons envoy√©e dans le canal</span></p>
<!--
Here, we try to print `val` after we‚Äôve sent it down the channel via `tx.send`.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread‚Äôs modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:
-->
<p>Ici, nous essayons d'afficher <code>valeur</code> apr√®s que nous l'avons envoy√©e dans le
canal avec <code>tx.send</code>. Ce serait une mauvaise id√©e de permettre cela¬†: une fois
que la valeur a √©t√© envoy√©e √† une autre t√¢che, cette t√¢che peut la modifier ou
la lib√©rer avant que nous essayions de l'utiliser √† nouveau. Il est possible que
des modifications faites par l'autre t√¢che puissent causer des erreurs ou des r√©sultats
inattendus √† cause de donn√©es incoh√©rentes ou manquantes. Toutefois, Rust nous
affiche une erreur si nous essayons de compiler le code de l'encart 16-9¬†:</p>
<!--
```console
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  -- > src/main.rs:10:31
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {}", val);
   |                               ^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `valeur`
  --&gt; src/main.rs:10:31
   |
8  |         let valeur = String::from(&quot;salut&quot;);
   |             ------ move occurs because `valeur` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(valeur).unwrap();
   |                 ------ value moved here
10 |         println!(&quot;valeur vaut {}&quot;, valeur);
   |                                    ^^^^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<!--
Our concurrency mistake has caused a compile time error. The `send` function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.
-->
<p>Notre erreur de concurrence a provoqu√© une erreur √† la compilation. La fonction
<code>send</code> prend possession de ses param√®tres, et lorsque la valeur est d√©plac√©e,
le r√©cepteur en prend possession. Cela nous √©vite d'utiliser √† nouveau
accidentellement la valeur apr√®s l'avoir envoy√©e¬†; le syst√®me de possession
v√©rifie que tout est en ordre.</p>
<!--
### Sending Multiple Values and Seeing the Receiver Waiting
-->
<h3 id="envoyer-plusieurs-valeurs-et-voir-le-r√©cepteur-les-attendre"><a class="header" href="#envoyer-plusieurs-valeurs-et-voir-le-r√©cepteur-les-attendre">Envoyer plusieurs valeurs et voir le r√©cepteur les attendre</a></h3>
<!--
The code in Listing 16-8 compiled and ran, but it didn‚Äôt clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we‚Äôve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.
-->
<p>Le code de l'encart 16-8 s'est compil√© et ex√©cut√©, mais il ne nous a pas
clairement indiqu√© que deux t√¢ches s√©par√©es communiquaient entre elles via le
canal. Dans l'encart 16-10 nous avons fait quelques modifications qui prouvent
que le code de l'encart 16-8 est ex√©cut√© avec de la concurrence¬†: la nouvelle
t√¢che va maintenant envoyer plusieurs messages et faire une pause d'une seconde
entre chaque message.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,noplayground
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;√† partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle t√¢che&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a re√ßu¬†: {}&quot;, recu);
    }
}
</code></pre>
<!--
<span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span>
-->
<p><span class="caption">Encart 16-10¬†: envoi de plusieurs messages en faisant une
pause entre chacun</span></p>
<!--
This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the `thread::sleep` function with a `Duration` value of
1 second.
-->
<p>Cette fois-ci, la nouvelle t√¢che a un vecteur de cha√Ænes de caract√®res que nous
souhaitons envoyer √† la t√¢che principale. Nous it√©rons sur celui-ci, on envoie
les cha√Ænes une par une en faisant une pause entre chaque envoi en appelant la
fonction <code>thread::sleep</code> avec une valeur <code>Duration</code> de 1 seconde.</p>
<!--
In the main thread, we‚Äôre not calling the `recv` function explicitly anymore:
instead, we‚Äôre treating `rx` as an iterator. For each value received, we‚Äôre
printing it. When the channel is closed, iteration will end.
-->
<p>Dans la t√¢che principale, nous n'appelons plus explicitement la fonction
<code>recv</code>¬†: √† la place, nous utilisons <code>rx</code> comme un it√©rateur. Pour chaque valeur
re√ßue, nous l'affichons. Lorsque le canal se fermera, l'it√©ration se terminera.</p>
<!--
When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:
-->
<p>Lorsque nous ex√©cutons le code de l'encart 16-10, nous devrions voir la sortie
suivante, avec une pause de 1 seconde entre chaque ligne¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: from
Got: the
Got: thread
```
-->
<pre><code class="language-text">On a re√ßu¬†: salutations
On a re√ßu¬†: √† partir
On a re√ßu¬†: de la
On a re√ßu¬†: nouvelle t√¢che
</code></pre>
<!--
Because we don‚Äôt have any code that pauses or delays in the `for` loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.
-->
<p>Comme nous n'avons pas de code qui met en pause ou retarde la boucle <code>for</code> de
la t√¢che principale, nous pouvons dire que la t√¢che principale est en attente
de r√©ception des valeurs de la part de la nouvelle t√¢che.</p>
<!--
### Creating Multiple Producers by Cloning the Transmitter
-->
<h3 id="cr√©er-plusieurs-producteurs-en-clonant-le-transmetteur"><a class="header" href="#cr√©er-plusieurs-producteurs-en-clonant-le-transmetteur">Cr√©er plusieurs producteurs en clonant le transmetteur</a></h3>
<!--
Earlier we mentioned that `mpsc` was an acronym for *multiple producer,
single consumer*. Let‚Äôs put `mpsc` to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:
-->
<p>Pr√©c√©demment, nous avions √©voqu√© que <code>mpsc</code> √©tait un acronyme pour
<em>multiple producer, single consumer</em>. Mettons <code>mpsc</code> en ≈ìuvre en √©largissant le
code de l'encart 16-10 pour cr√©er plusieurs t√¢ches qui vont toutes envoyer des
valeurs au m√™me r√©cepteur. Nous pouvons faire ceci en clonant la partie
√©mettrice du canal, comme dans l'encart 16-11¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,noplayground
# use std::sync::mpsc;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }

    // --snip--
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // -- partie masqu√©e ici --

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;√† partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle t√¢che&quot;),
        ];

        for valeur in valeurs {
            tx1.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;encore plus&quot;),
            String::from(&quot;de messages&quot;),
            String::from(&quot;pour&quot;),
            String::from(&quot;vous&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a re√ßu¬†: {}&quot;, recu);
    }

    // -- partie masqu√©e ici --
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span>
-->
<p><span class="caption">Encart 16-11¬†: envoi de plusieurs messages √† partir de
plusieurs producteurs</span></p>
<!--
This time, before we create the first spawned thread, we call `clone` on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.
-->
<p>Cette fois-ci, avant de cr√©er la premi√®re nouvelle t√¢che, nous appelons <code>clone</code>
sur la partie √©mettrice du canal. Cela va nous donner un nouveau transmetteur
que nous pourrons passer √† la premi√®re nouvelle t√¢che. Nous passons ensuite le
transmetteur original √† une seconde nouvelle t√¢che. Cela va nous donner deux
t√¢ches, chacune envoyant des messages diff√©rents √† la partie r√©ceptrice du
canal.</p>
<!--
When you run the code, your output should look something like this:
-->
<p>Lorsque vous ex√©cuterez ce code, votre sortie devrait ressembler √† ceci¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```
-->
<pre><code class="language-text">On a re√ßu¬†: salutations
On a re√ßu¬†: encore plus
On a re√ßu¬†: de messages
On a re√ßu¬†: pour
On a re√ßu¬†: √† partir
On a re√ßu¬†: de la
On a re√ßu¬†: nouvelle t√¢che
On a re√ßu¬†: pour vous
</code></pre>
<!--
You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
`thread::sleep`, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.
-->
<p>Vous pourrez peut-√™tre constater que les valeurs sont dans un autre ordre chez
vous¬†; cela d√©pend de votre syst√®me. C'est ce qui rend la concurrence aussi
int√©ressante que difficile. Si vous jouez avec la valeur de <code>thread::sleep</code> en
lui donnant diff√©rentes valeurs dans diff√©rentes t√¢ches, chaque ex√©cution sera
encore moins d√©terministe et cr√©era une sortie diff√©rente √† chaque fois.</p>
<!--
Now that we‚Äôve looked at how channels work, let‚Äôs look at a different method of
concurrency.
-->
<p>Maintenant que nous avons d√©couvert le fonctionnement des canaux, examinons un
autre genre de concurrence.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-01-threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch16-03-shared-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-01-threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch16-03-shared-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
