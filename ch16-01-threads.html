<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html" class="active"><strong aria-hidden="true">16.1.</strong> Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Using Threads to Run Code Simultaneously
-->
<h2 id="utiliser-les-tÃ¢ches-pour-exÃ©cuter-simultanÃ©ment-du-code"><a class="header" href="#utiliser-les-tÃ¢ches-pour-exÃ©cuter-simultanÃ©ment-du-code">Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></h2>
<!--
In most current operating systems, an executed programâ€™s code is run in a
*process*, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called *threads*.
-->
<p>Dans la plupart des systÃ¨mes d'exploitation actuels, le code d'un programme
est exÃ©cutÃ© dans un <em>processus</em>, et le systÃ¨me d'exploitation gÃ¨re plusieurs
processus Ã  la fois. Dans votre programme, vous pouvez vous aussi avoir des
parties indÃ©pendantes qui s'exÃ©cutent simultanÃ©ment. Les Ã©lÃ©ments qui font
fonctionner ces parties indÃ©pendantes sont appelÃ©s les <em>tÃ¢ches</em>.</p>
<!--
Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, thereâ€™s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:
-->
<p>Le dÃ©coupage des calculs de votre programme dans plusieurs tÃ¢ches peut
amÃ©liorer sa performance car le programme fait plusieurs choses Ã  la fois, mais
cela rajoute aussi de la complexitÃ©. Comme les tÃ¢ches peuvent s'exÃ©cuter de
maniÃ¨re simultanÃ©e, il n'y a pas de garantie absolue sur l'ordre d'exÃ©cution
des diffÃ©rentes parties de votre code. Cela peut poser des problÃ¨mes,
tels queÂ :</p>
<!--
* Race conditions, where threads are accessing data or resources in an
  inconsistent order
* Deadlocks, where two threads are waiting for each other to finish using a
  resource the other thread has, preventing both threads from continuing
* Bugs that happen only in certain situations and are hard to reproduce and fix
  reliably
-->
<ul>
<li>Les situations de concurrence, durant lesquelles les tÃ¢ches accÃ¨dent Ã  des
donnÃ©es ou des ressources dans un ordre incohÃ©rent</li>
<li>Des interblocages, durant lesquels deux tÃ¢ches attendent mutuellement que
l'autre finisse d'utiliser une ressource que l'autre tÃ¢che utilise, bloquant
la progression des deux tÃ¢ches</li>
<li>Des bogues qui surgissent uniquement dans certaines situations et qui sont
difficiles Ã  reproduire et corriger durablement</li>
</ul>
<!--
Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.
-->
<p>Rust cherche Ã  attÃ©nuer les effets indÃ©sirables de l'utilisation des tÃ¢ches,
mais le dÃ©veloppement dans un contexte multitÃ¢ches exige toujours une attention
particuliÃ¨re et nÃ©cessite une structure de code diffÃ©rente de celle des
programmes qui s'exÃ©cutent dans une seule tÃ¢che.</p>
<!--
Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called *1:1*,
meaning one operating system thread per one language thread. The Rust standard
library only provides an implementation of 1:1 threading; there are crates that
implement other models of threading that make different tradeoffs.
-->
<p>Les langages de programmation implÃ©mentent les tÃ¢ches de diffÃ©rentes maniÃ¨res.
De nombreux systÃ¨mes d'exploitation offrent des API pour crÃ©er de nouvelles
tÃ¢ches. L'appel Ã  cette API du systÃ¨me d'exploitation pour crÃ©er des tÃ¢ches par
un langage est parfois qualifiÃ© de <em>1:1</em>, ce qui signifie une tÃ¢che du systÃ¨me
d'exploitation par tÃ¢che dans le langage de programmation. La bibliothÃ¨que
standard de Rust fournit une seule implÃ©mentation 1:1Â ; il existe des crates
qui implÃ©mentent d'autres modÃ¨les qui font des choix diffÃ©rents.</p>
<!--
### Creating a New Thread with `spawn`
-->
<h3 id="crÃ©er-une-nouvelle-tÃ¢che-avec-spawn"><a class="header" href="#crÃ©er-une-nouvelle-tÃ¢che-avec-spawn">CrÃ©er une nouvelle tÃ¢che avec <code>spawn</code></a></h3>
<!--
To create a new thread, we call the `thread::spawn` function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:
-->
<p>Pour crÃ©er une nouvelle tÃ¢che, nous appelons la fonction <code>thread::spawn</code> et
nous lui passons une fermeture (nous avons vu les fermetures au chapitre 13)
qui contient le code que nous souhaitons exÃ©cuter dans la nouvelle tÃ¢che.
L'exemple dans l'encart 16-1 affiche du texte Ã  partir de la tÃ¢che principale
et un autre texte Ã  partir d'une nouvelle tÃ¢cheÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour nÂ°{} Ã  partir de la nouvelle tÃ¢cheÂ !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour nÂ°{} Ã  partir de la tÃ¢che principaleÂ !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span>
-->
<p><span class="caption">Encart 16-1Â : crÃ©ation d'une nouvelle tÃ¢che pour afficher
une chose pendant que la tÃ¢che principale affiche autre chose</span></p>
<!--
Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:
-->
<p>Remarquez qu'avec cette fonction, la nouvelle tÃ¢che s'arrÃªtera lorsque la tÃ¢che
principale s'arrÃªtera, qu'elle ait fini ou non de s'exÃ©cuter. La sortie de ce
programme peut Ãªtre diffÃ©rente Ã  chaque fois, mais elle devrait ressembler Ã 
ceciÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour nÂ°1 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°1 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°2 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°3 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°3 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°4 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°5 Ã  partir de la nouvelle tÃ¢cheÂ !
</code></pre>
<!--
The calls to `thread::sleep` force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isnâ€™t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until `i` is 9, it only got to 5
before the main thread shut down.
-->
<p>L'appel Ã  <code>thread::sleep</code> force une tÃ¢che Ã  mettre en pause son exÃ©cution
pendant une petite durÃ©e, permettant Ã  une autre tÃ¢che de s'exÃ©cuter. Les
tÃ¢ches se relaieront probablement, mais ce n'est pas garantiÂ : cela dÃ©pend de
comment votre systÃ¨me d'exploitation agence les tÃ¢ches. Lors de cette
exÃ©cution, la tÃ¢che principale a Ã©crit en premier, mÃªme si l'instruction
d'Ã©criture de la nouvelle tÃ¢che apparaissait d'abord dans le code. Et mÃªme si
nous avons demandÃ© Ã  la nouvelle tÃ¢che d'Ã©crire jusqu'Ã  ce que <code>i</code> vaille <code>9</code>,
elle ne l'a fait que jusqu'Ã  <code>5</code>, moment oÃ¹ la tÃ¢che principale s'est arrÃªtÃ©e.</p>
<!--
If you run this code and only see output from the main thread, or donâ€™t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.
-->
<p>Si vous exÃ©cutez ce code et que vous ne voyez que du texte provenant de la
tÃ¢che principale, ou que vous ne voyez aucun chevauchement, essayez d'augmenter
les nombres dans les intervalles pour donner plus d'opportunitÃ©s au systÃ¨me
d'exploitation pour basculer entre les tÃ¢ches.</p>
<!--
### Waiting for All Threads to Finish Using `join` Handles
-->
<h3 id="attendre-que-toutes-les-tÃ¢ches-aient-fini-en-utilisant-join"><a class="header" href="#attendre-que-toutes-les-tÃ¢ches-aient-fini-en-utilisant-join">Attendre que toutes les tÃ¢ches aient fini en utilisant <code>join</code></a></h3>
<!--
The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also canâ€™t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!
-->
<p>Le code dans l'encart 16-1 non seulement stoppe la nouvelle tÃ¢che prÃ©maturÃ©ment
la plupart du temps Ã  cause de la fin de la tÃ¢che principale, mais il ne
garantit pas non plus que la nouvelle tÃ¢che va s'exÃ©cuter ne serait-ce qu'une
seule fois. La raison Ã  cela est qu'il n'y a pas de garantie sur l'ordre dans
lequel les tÃ¢ches vont s'exÃ©cuterÂ !</p>
<!--
We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of `thread::spawn` in a variable.
The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned
value that, when we call the `join` method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we created
in Listing 16-1 and call `join` to make sure the spawned thread finishes before
`main` exits:
-->
<p>Nous pouvons rÃ©gler le problÃ¨me des nouvelles tÃ¢ches qui ne s'exÃ©cutent pas, ou
pas complÃ¨tement, en sauvegardant la valeur de retour de <code>thread::spawn</code> dans
une variable. Le type de retour de <code>thread::spawn</code> est <code>JoinHandle</code>. Un
<code>JoinHandle</code> est une valeur possÃ©dÃ©e qui, lorsque nous appelons la mÃ©thode
<code>join</code> sur elle, va attendre que ses tÃ¢ches finissent. L'encart 16-2 montre
comment utiliser le <code>JoinHandle</code> de la tÃ¢che que nous avons crÃ©Ã©e dans l'encart
16-1 en appelant la mÃ©thode <code>join</code> pour s'assurer que la nouvelle tÃ¢che finit
bien avant que <code>main</code> ne se termineÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour nÂ°{} Ã  partir de la nouvelle tÃ¢cheÂ !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour nÂ°{} Ã  partir de la tÃ¢che principaleÂ !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-2: Saving a `JoinHandle` from `thread::spawn`
to guarantee the thread is run to completion</span>
-->
<p><span class="caption">Encart 16-2Â : sauvegarde d'un <code>JoinHandle</code> d'un
<code>thread::spawn</code> pour garantir que la tÃ¢che est exÃ©cutÃ©e jusqu'Ã  la fin</span></p>
<!--
Calling `join` on the handle blocks the thread currently running until the
thread represented by the handle terminates. *Blocking* a thread means that
thread is prevented from performing work or exiting. Because weâ€™ve put the call
to `join` after the main threadâ€™s `for` loop, running Listing 16-2 should
produce output similar to this:
-->
<p>L'appel Ã  <code>join</code> sur le manipulateur bloque la tÃ¢che qui s'exÃ©cute actuellement
jusqu'Ã  ce que la tÃ¢che reprÃ©sentÃ©e par le manipulateur se termine. <em>Bloquer</em>
une tÃ¢che signifie que cette tÃ¢che est empÃªchÃ©e d'accomplir un quelconque travail
ou de se terminer. Comme nous avons insÃ©rÃ© l'appel Ã  <code>join</code> aprÃ¨s la boucle
<code>for</code> de la tÃ¢che principale, l'exÃ©cution de l'encart 16-2 devrait produire un
rÃ©sultat similaire Ã  celui-ciÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour nÂ°1 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°1 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°3 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°3 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°5 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°6 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°7 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°8 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°9 Ã  partir de la nouvelle tÃ¢cheÂ !
</code></pre>
<!--
The two threads continue alternating, but the main thread waits because of the
call to `handle.join()` and does not end until the spawned thread is finished.
-->
<p>Les deux tÃ¢ches continuent Ã  alterner, mais la tÃ¢che principale attend Ã  cause
de l'appel Ã  <code>manipulateur.join()</code> et ne se termine pas avant que la nouvelle
tÃ¢che ne soit finie.</p>
<!--
But letâ€™s see what happens when we instead move `handle.join()` before the
`for` loop in `main`, like this:
-->
<p>Mais voyons maintenant ce qui se passe lorsque nous dÃ©plaÃ§ons le
<code>manipulateur.join()</code> avant la boucle <code>for</code> du <code>main</code> comme ceciÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour nÂ°{} Ã  partir de la nouvelle tÃ¢cheÂ !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    manipulateur.join().unwrap();

    for i in 1..5 {
        println!(&quot;Bonjour nÂ°{} Ã  partir de la tÃ¢che principaleÂ !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
The main thread will wait for the spawned thread to finish and then run its
`for` loop, so the output wonâ€™t be interleaved anymore, as shown here:
-->
<p>La tÃ¢che principale va attendre que la nouvelle tÃ¢che se finisse et ensuite
exÃ©cuter sa boucle <code>for</code>, ainsi la sortie ne sera plus chevauchÃ©e, comme
ci-dessousÂ :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```
-->
<pre><code class="language-text">Bonjour nÂ°1 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°2 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°3 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°4 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°5 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°6 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°7 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°8 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°9 Ã  partir de la nouvelle tÃ¢cheÂ !
Bonjour nÂ°1 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°2 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°3 Ã  partir de la tÃ¢che principaleÂ !
Bonjour nÂ°4 Ã  partir de la tÃ¢che principaleÂ !
</code></pre>
<!--
Small details, such as where `join` is called, can affect whether or not your
threads run at the same time.
-->
<p>Des petits dÃ©tails, comme l'endroit oÃ¹ <code>join</code> est appelÃ©, peuvent dÃ©terminer si
vos tÃ¢ches peuvent Ãªtre exÃ©cutÃ©es ou non en mÃªme temps.</p>
<!--
### Using `move` Closures with Threads
-->
<h3 id="utiliser-les-fermetures-move-avec-les-tÃ¢ches"><a class="header" href="#utiliser-les-fermetures-move-avec-les-tÃ¢ches">Utiliser les fermetures <code>move</code> avec les tÃ¢ches</a></h3>
<!--
The `move` keyword is often used with closures passed to `thread::spawn`
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another. In the [â€œCapturing the Environment with Closuresâ€][capture]<!-- ignore
-- > section of Chapter 13, we discussed `move` in the context of closures. Now,
weâ€™ll concentrate more on the interaction between `move` and `thread::spawn`
-->
<p>Le mot-clÃ© <code>move</code> est souvent utilisÃ© avec des fermetures passÃ©es Ã 
<code>thread::spawn</code> car la fermeture va alors prendre possession des valeurs de son
environnement qu'elle utilise, ce qui transfÃ¨re la possession des valeurs d'une
tÃ¢che Ã  une autre. Dans <a href="ch13-01-closures.html">une section du chapitre 13</a><!-- ignore -->,
nous avons prÃ©sentÃ© <code>move</code> dans le contexte des fermetures. A prÃ©sent, nous
allons plus nous concentrer sur l'interaction entre <code>move</code> et <code>thread::spawn</code>.</p>
<!--
Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no
arguments: weâ€™re not using any data from the main thread in the spawned
threadâ€™s code. To use data from the main thread in the spawned thread, the
spawned threadâ€™s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this wonâ€™t yet work, as youâ€™ll see in a moment.
-->
<p>Remarquez dans l'encart 16-1 que la fermeture que nous donnons Ã  <code>thread::spawn</code>
ne prend pas d'argumentsÂ : nous n'utilisons aucune donnÃ©e de la tÃ¢che
principale dans le code de la nouvelle tÃ¢che. Pour utiliser des donnÃ©es de la
tÃ¢che principale dans la nouvelle tÃ¢che, la fermeture de la nouvelle tÃ¢che doit
capturer les valeurs dont elle a besoin. L'encart 16-3 montre une tentative de
crÃ©ation d'un vecteur dans la tÃ¢che principale et son utilisation dans la
nouvelle tÃ¢che. Cependant, cela ne fonctionne pas encore, comme vous allez le
constater dans un moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span>
-->
<p><span class="caption">Encart 16-3Â : tentative d'utilisation d'un vecteur crÃ©Ã©
par la tÃ¢che principale dans une autre tÃ¢che</span></p>
<!--
The closure uses `v`, so it will capture `v` and make it part of the closureâ€™s
environment. Because `thread::spawn` runs this closure in a new thread, we
should be able to access `v` inside that new thread. But when we compile this
example, we get the following error:
-->
<p>La fermeture utilise <code>v</code>, donc elle va capturer <code>v</code> et l'intÃ©grer dans son
environnement. Comme <code>thread::spawn</code> exÃ©cute cette fermeture dans une nouvelle
tÃ¢che, nous devrions pouvoir accÃ©der Ã  <code>v</code> dans cette nouvelle tÃ¢che. Mais
lorsque nous compilons cet exemple, nous obtenons l'erreur suivanteÂ :</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 -- > src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 -- > src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let manipulateur = thread::spawn(|| {
  |                                      ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let manipulateur = thread::spawn(|| {
  |  ________________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<!--
Rust *infers* how to capture `v`, and because `println!` only needs a reference
to `v`, the closure tries to borrow `v`. However, thereâ€™s a problem: Rust canâ€™t
tell how long the spawned thread will run, so it doesnâ€™t know if the reference
to `v` will always be valid.
-->
<p>Rust <em>dÃ©duit</em> comment capturer <code>v</code>, et comme <code>println!</code> n'a besoin que d'une
rÃ©fÃ©rence Ã  <code>v</code>, la fermeture essaye d'emprunter <code>v</code>. Cependant, il y a un
problÃ¨meÂ : Rust ne peut pas savoir combien de temps la tÃ¢che va s'exÃ©cuter,
donc il ne peut pas savoir si la rÃ©fÃ©rence Ã  <code>v</code> sera toujours valide.</p>
<!--
Listing 16-4 provides a scenario thatâ€™s more likely to have a reference to `v`
that wonâ€™t be valid:
-->
<p>L'encart 16-4 propose un scÃ©nario qui est a plus de chance d'avoir une
rÃ©fÃ©rence Ã  <code>v</code> qui ne sera plus valideÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
    });

    drop(v); // oh, nonÂ !

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to `v` from a main thread that drops `v`</span>
-->
<p><span class="caption">Encart 16-4Â : une tÃ¢che dont la fermeture essaye de
capturer une rÃ©fÃ©rence Ã  <code>v</code> Ã  partir de la tÃ¢che principale, qui va ensuite
libÃ©rer <code>v</code></span></p>
<!--
If we were allowed to run this code, thereâ€™s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to `v` inside, but the main thread immediately drops
`v`, using the `drop` function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, `v` is no longer valid, so a reference to it
is also invalid. Oh no!
-->
<p>Si nous Ã©tions autorisÃ©s Ã  exÃ©cuter ce code, il y aurait une possibilitÃ© que
la nouvelle tÃ¢che soit immÃ©diatement placÃ©e en arriÃ¨re-plan sans Ãªtre
exÃ©cutÃ©e du tout. La nouvelle tÃ¢che a une rÃ©fÃ©rence Ã  <code>v</code> en son sein, mais la
tÃ¢che principale libÃ¨re immÃ©diatement <code>v</code>, en utilisant la fonction <code>drop</code> que
nous avons vue au chapitre 15. Ensuite, lorsque la nouvelle tÃ¢che commence Ã 
s'exÃ©cuter, <code>v</code> n'est plus en vigueur, donc une rÃ©fÃ©rence Ã  cette derniÃ¨re est
elle aussi invalideÂ !</p>
<!--
To fix the compiler error in Listing 16-3, we can use the error messageâ€™s
advice:
-->
<p>Pour corriger l'erreur de compilation de l'encart 16-3, nous pouvons appliquer
le conseil du message d'erreurÂ :</p>
<!--
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-- >
-->
<!--
```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let manipulateur = thread::spawn(move || {
  |                                      ++++
</code></pre>
<!--
By adding the `move` keyword before the closure, we force the closure to take
ownership of the values itâ€™s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:
-->
<p>En ajoutant le mot-clÃ© <code>move</code> avant la fermeture, nous forÃ§ons la fermeture Ã 
prendre possession des valeurs qu'elle utilise au lieu de laisser Rust dÃ©duire
qu'il doit emprunter les valeurs. Les modifications Ã  l'encart 16-3 proposÃ©es
dans l'encart 16-5 devraient se compiler et s'exÃ©cuter comme prÃ©vuÂ :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(move || {
        println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-5: Using the `move` keyword to force a closure
to take ownership of the values it uses</span>
-->
<p><span class="caption">Encart 16-5Â : utilisation du mot-clÃ© <code>move</code> pour forcer
une fermeture Ã  prendre possession des valeurs qu'elle utilise</span></p>
<!--
What would happen to the code in Listing 16-4 where the main thread called
`drop` if we use a `move` closure? Would `move` fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isnâ€™t allowed for a different reason. If we added `move` to the closure, we
would move `v` into the closureâ€™s environment, and we could no longer call
`drop` on it in the main thread. We would get this compiler error instead:
-->
<p>Qu'est-ce qui arriverait au code de l'encart 16-4 dans lequel la tÃ¢che
principale fait appel Ã  <code>drop</code> si nous utilisions la fermeture avec <code>move</code>Â ?
Est-ce que le <code>move</code> rÃ©soudrait le problÃ¨meÂ ? Malheureusement, nonÂ ; nous
obtiendrions une erreur diffÃ©rente parce que ce que l'encart 16-4 essaye de
faire n'est pas autorisÃ© pour une raison diffÃ©rente de la prÃ©cÃ©dente. Si nous
ajoutions <code>move</code> Ã  la fermeture, nous dÃ©placerions <code>v</code> dans l'environnement de
la fermeture, et nous ne pourrions plus appeler <code>drop</code> sur <code>v</code> dans la tÃ¢che
principale. Nous obtiendrons Ã  la place cette erreur de compilationÂ :</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  -- > src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {:?}", v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let manipulateur = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Voici un vecteurÂ : {:?}&quot;, v);
   |                                             - variable moved due to use in closure
...
10 |     drop(v); // oh, nonÂ !
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  -- &gt; src/main.rs:10:10
   |
6  |     let manipulateur = thread::spawn(move || {
   |                                      ------- value moved (into closure) here
...
10 |     drop(v); // oh non, le vecteur est libÃ©rÃ©Â !
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<!--
Rustâ€™s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing `v` for the
thread, which meant the main thread could theoretically invalidate the spawned
threadâ€™s reference. By telling Rust to move ownership of `v` to the spawned
thread, weâ€™re guaranteeing Rust that the main thread wonâ€™t use `v` anymore. If
we change Listing 16-4 in the same way, weâ€™re then violating the ownership
rules when we try to use `v` in the main thread. The `move` keyword overrides
Rustâ€™s conservative default of borrowing; it doesnâ€™t let us violate the
ownership rules.
-->
<p>Les rÃ¨gles de possession de Rust nous ont encore sauvÃ© la miseÂ ! Nous obtenions
une erreur avec le code de l'encart 16-3 car Rust a Ã©tÃ© conservateur et a juste empruntÃ©
<code>v</code> pour la tÃ¢che, ce qui signifie que la tÃ¢che principale pouvait thÃ©oriquement
neutraliser la rÃ©fÃ©rence de la tÃ¢che crÃ©Ã©e. En demandant Ã  Rust de dÃ©placer la
possession de <code>v</code> Ã  la nouvelle tÃ¢che, nous avons garanti Ã  Rust que la tÃ¢che
principale n'utiliserait plus <code>v</code>. Si nous changeons l'encart 16-4 de la mÃªme
maniÃ¨re, nous violons les rÃ¨gles de possession lorsque nous essayons d'utiliser
<code>v</code> dans la tÃ¢che principale. Le mot-clÃ© <code>move</code> remplace le comportement
d'emprunt conservateur par dÃ©fautÂ de Rust; il ne nous laisse pas enfreindre les rÃ¨gles
de possession.</p>
<!--
With a basic understanding of threads and the thread API, letâ€™s look at what we
can *do* with threads.
-->
<p>ArmÃ© de cette connaissance de base des tÃ¢ches et de leur API, dÃ©couvrons ce que
nous pouvons <em>faire</em> avec les tÃ¢ches.</p>
<!--
[capture]: ch13-01-closures.html#capturing-the-environment-with-closures
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-00-concurrency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch16-02-message-passing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-00-concurrency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch16-02-message-passing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
