<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les types de donn√©es - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Data Types
-->
<h2 id="les-types-de-donn√©es"><a class="header" href="#les-types-de-donn√©es">Les types de donn√©es</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. We‚Äôll look at
two data type subsets: scalar and compound.
-->
<p>Chaque valeur en Rust est d'un <em>type</em> bien d√©termin√©, qui indique √† Rust quel
genre de donn√©es il manipule pour qu'il sache comment traiter ces donn√©es.
Nous allons nous int√©resser √† deux cat√©gories de types de donn√©es¬†: les
scalaires et les compos√©s.</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the [‚ÄúComparing the Guess to the Secret
Number‚Äù][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Gardez √† l'esprit que Rust est un langage <em>statiquement typ√©</em>, ce qui signifie
qu'il doit conna√Ætre les types de toutes les variables au moment de la
compilation. Le compilateur peut souvent d√©duire quel type utiliser en se basant
sur la valeur et sur la fa√ßon dont elle est utilis√©e. Dans les cas o√π plusieurs
types sont envisageables, comme lorsque nous avons converti une cha√Æne de
caract√®res en un type num√©rique en utilisant <code>parse</code> dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">‚ÄúComparer le nombre saisi au nombre
secret‚Äù</a><!-- ignore -->
du chapitre 2, nous devons ajouter une annotation de type, comme ceci¬†:</p>
<!--
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let supposition: u32 = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre¬†!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
If we don‚Äôt add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>Si nous n'ajoutons pas l'annotation de type ici, Rust affichera l'erreur
suivante, signifiant que le compilateur a besoin de plus d'informations pour
d√©terminer quel type nous souhaitons utiliser¬†:</p>
<!--
```console
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 -- > src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let supposition = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre¬†!&quot;);
  |         ^^^^^^^^^^^ consider giving `supposition` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<!--
You‚Äôll see different type annotations for other data types.
-->
<p>Vous d√©couvrirez diff√©rentes annotations de type au fur et √† mesure que nous
aborderons les autres types de donn√©es.</p>
<!--
### Scalar Types
-->
<h3 id="types-scalaires"><a class="header" href="#types-scalaires">Types scalaires</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let‚Äôs jump into how they work in Rust.
-->
<p>Un type <em>scalaire</em> repr√©sente une seule valeur. Rust poss√®de quatre types
principaux de scalaires¬†: les entiers, les nombres √† virgule flottante, les
bool√©ens et les caract√®res. Vous les connaissez s√ªrement d'autres langages de
programmation. Regardons comment ils fonctionnent avec Rust.</p>
<!--
#### Integer Types
-->
<h4 id="types-de-nombres-entiers"><a class="header" href="#types-de-nombres-entiers">Types de nombres entiers</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value it‚Äôs associated with should be an unsigned integer (signed integer types
start with `i`, instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. We can use any of these variants to declare
the type of an integer value.
-->
<p>Un <em>entier</em> est un nombre sans partie d√©cimale. Nous avons utilis√© un entier
pr√©c√©demment dans le chapitre 2, le type <code>u32</code>. Cette d√©claration de type
indique que la valeur √† laquelle elle est associ√©e doit √™tre un entier non sign√©
encod√© sur 32 bits dans la m√©moire (les entiers pouvant prendre des valeurs
n√©gatives commencent par un <code>i</code> (comme <em>integer</em>¬†: ‚Äúentier‚Äù), plut√¥t que par un
<code>u</code> comme <em>unsigned</em>¬†: ‚Äúnon sign√©‚Äù). Le tableau 3-1 montre les types
d'entiers int√©gr√©s au langage. Nous pouvons utiliser chacune de ces variantes
pour d√©clarer le type d'une valeur enti√®re.</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">Tableau 3-1¬†: les types d'entiers en Rust</span></p>
<!--
| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |
-->
<table><thead><tr><th>Taille</th><th>Sign√©</th><th>Non sign√©</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>archi</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refer to whether it‚Äôs possible for the number to be
negative‚Äîin other words, whether the number needs to have a sign with it
(signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It‚Äôs like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it‚Äôs safe to assume the number is positive, it‚Äôs shown with no sign.
Signed numbers are stored using [two‚Äôs
complement](https://en.wikipedia.org/wiki/Two%27s_complement)<!-- ignore -- >
representation.
-->
<p>Chaque variante peut √™tre sign√©e ou non sign√©e et poss√®de une taille explicite.
<em>Sign√©</em> et <em>non sign√©</em> veut dire respectivement que le nombre peut prendre ou
non des valeurs n√©gatives ‚Äî en d'autres termes, si l'on peut lui attribuer un
signe (sign√©) ou s'il sera toujours positif et que l'on peut donc le repr√©senter
sans signe (non sign√©). C'est comme √©crire des nombres sur du papier¬†: quand le
signe est important, le nombre est √©crit avec un signe plus ou un signe moins¬†;
en revanche, quand le nombre est forc√©ment positif, on peut l'√©crire sans son
signe. Les nombres sign√©s sont stock√©s en utilisant le <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">compl√©ment √†
deux</a><!-- ignore -->.</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>Chaque variante sign√©e peut stocker des nombres allant de ‚àí(2<sup><em>n</em> ‚àí 1</sup>)
√† 2<sup><em>n</em> ‚àí 1</sup> ‚àí 1 inclus, o√π <em>n</em> est le nombre de bits que cette
variante utilise.
Un <code>i8</code> peut donc stocker des nombres allant de ‚àí(2<sup>7</sup>) √†
2<sup>7</sup> ‚àí 1, c'est-√†-dire de ‚àí128 √† 127. Les variantes non sign√©es peuvent
stocker des nombres de 0 √† 2<sup><em>n</em></sup> ‚àí 1, donc un <code>u8</code> peut stocker
des nombres allant de 0 √† 2<sup>8</sup> ‚àí 1, c'est-√†-dire de 0 √† 255.</p>
<!--
Additionally, the `isize` and `usize` types depend on the architecture of the
computer your program is running on, which is denoted in the table as ‚Äúarch‚Äù:
64 bits if you‚Äôre on a 64-bit architecture and 32 bits if you‚Äôre on a 32-bit
architecture.
-->
<p>De plus, les types <code>isize</code> et <code>usize</code> d√©pendent de l'architecture de
l'ordinateur sur lequel votre programme va s'ex√©cuter, d'o√π la ligne ‚Äúarchi‚Äù¬†:
64 bits si vous utilisez une architecture 64 bits, ou 32 bits si vous utilisez
une architecture 32 bits.</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as `57u8`, to designate the type. Number literals can also use `_` as a
visual separator to make the number easier to read, such as `1_000`, which will
have the same value as if you had specified `1000`.
-->
<p>Vous pouvez √©crire des litt√©raux d'entiers dans chacune des formes d√©crites dans
le tableau 3-2. Notez que les litt√©raux num√©riques qui peuvent √™tre de plusieurs types
num√©riques autorisent l'utilisation d'un suffixe de type, tel que <code>57u8</code>, afin de
pr√©ciser leur type. Les nombres litt√©raux peuvent aussi utiliser <code>_</code> comme
s√©parateur visuel afin de les rendre plus lisible, comme par exemple <code>1_000</code>,
qui a la m√™me valeur que si vous aviez renseign√© <code>1000</code>.</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">Tableau 3-2¬†: les litt√©raux d'entiers en Rust</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>Litt√©ral num√©rique</th><th>Exemple</th></tr></thead><tbody>
<tr><td>D√©cimal</td><td><code>98_222</code></td></tr>
<tr><td>Hexad√©cimal</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binaire</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Octet (<code>u8</code> seulement)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If you‚Äôre unsure, Rust‚Äôs
defaults are generally good places to start: integer types default to `i32`.
The primary situation in which you‚Äôd use `isize` or `usize` is when indexing
some sort of collection.
-->
<p>Comment pouvez-vous d√©terminer le type d'entier √† utiliser¬†? Si vous n'√™tes pas
s√ªr, les choix par d√©faut de Rust sont g√©n√©ralement de bons choix¬†: le type
d'entier par d√©faut est le <code>i32</code>. La principale utilisation d'un <code>isize</code> ou d'un
<code>usize</code> est lorsque l'on indexe une quelconque collection.</p>
<!--
> ##### Integer Overflow
>
> Let‚Äôs say you have a variable of type `u8` that can hold values between 0 and
> 255. If you try to change the variable to a value outside of that range, such
> as 256, *integer overflow* will occur, which can result in one of two
> behaviors. When you‚Äôre compiling in debug mode, Rust includes checks for
> integer overflow that cause your program to *panic* at runtime if this
> behavior occurs. Rust uses the term panicking when a program exits with an
> error; we‚Äôll discuss panics in more depth in the [‚ÄúUnrecoverable Errors with
> `panic!`‚Äù][unrecoverable-errors-with-panic]<!-- ignore -- > section in Chapter
> 9.
>
> When you‚Äôre compiling in release mode with the `--release` flag, Rust does
> *not* include checks for integer overflow that cause panics. Instead, if
> overflow occurs, Rust performs *two‚Äôs complement wrapping*. In short, values
> greater than the maximum value the type can hold ‚Äúwrap around‚Äù to the minimum
> of the values the type can hold. In the case of a `u8`, the value 256 becomes
> 0, the value 257 becomes 1, and so on. The program won‚Äôt panic, but the
> variable will have a value that probably isn‚Äôt what you were expecting it to
> have. Relying on integer overflow‚Äôs wrapping behavior is considered an error.
>
> To explicitly handle the possibility of overflow, you can use these families
> of methods provided by the standard library for primitive numeric types:
>
> - Wrap in all modes with the `wrapping_*` methods, such as `wrapping_add`
> - Return the `None` value if there is overflow with the `checked_*` methods
> - Return the value and a boolean indicating whether there was overflow with
>   the `overflowing_*` methods
> - Saturate at the value‚Äôs minimum or maximum values with `saturating_*`
>   methods
-->
<blockquote>
<h5 id="d√©passement-dentier"><a class="header" href="#d√©passement-dentier">D√©passement d'entier</a></h5>
<p>Imaginons que vous avez une variable de type <code>u8</code> qui peut stocker des
valeurs entre 0 et 255. Si vous essayez de changer la variable pour une valeur
en dehors de cet intervalle, comme 256, vous aurez un d√©passement d'entier
<em>(integer overflow)</em>, qui peut se compter de deux mani√®re. Lorsque vous
compilez en mode d√©bogage, Rust embarque des v√©rifications pour d√©tecter les
cas de d√©passements d'entiers qui pourraient faire <em>paniquer</em> votre programme
√† l'ex√©cution si ce ph√©nom√®ne se produit. Rust utilise le terme <em>paniquer</em>
quand un programme se termine avec une erreur¬†; nous verrons plus en d√©tail
les <em>paniques</em> dans une section du <a href="ch09-01-unrecoverable-errors-with-panic.html">chapitre
9</a><!-- ignore -->.</p>
<p>Lorsque vous compilez en mode publication <em>(release)</em> avec le drapeau
<code>--release</code>, Rust ne va <em>pas</em> v√©rifier les potentiels d√©passements d'entiers
qui peuvent faire paniquer le programme. En revanche, en cas de d√©passement,
Rust va effectuer un <em>rebouclage du compl√©ment √† deux</em>. Pour faire simple, les
valeurs sup√©rieures √† la valeur maximale du type seront ‚Äúreboucl√©es‚Äù depuis la
valeur minimale que le type peut stocker. Dans le cas d'un <code>u8</code>, la valeur 256
devient 0, la valeur 257 devient 1, et ainsi de suite. Le programme ne va
paniquer, mais la variable va avoir une valeur qui n'est probablement pas ce
que vous attendez √† avoir. Se fier au comportement du rebouclage lors du
d√©passement d'entier est consid√©r√© comme une faute.</p>
<p>Pour g√©rer explicitement le d√©passement, vous pouvez utiliser les familles
de m√©thodes suivantes qu'offrent la biblioth√®que standard sur les types de
nombres primitifs¬†:</p>
<ul>
<li>Enveloppez les op√©rations avec les m√©thodes <code>wrapping_*</code>, comme par exemple
<code>wrapping_add</code></li>
<li>Retourner la valeur <code>None</code> s'il y a un d√©passement avec des m√©thodes
<code>checked_*</code></li>
<li>Retourner la valeur et un bool√©en qui indique s'il y a eu un d√©passement
avec des m√©thodes <code>overflowing_*</code></li>
<li>Saturer √† la valeur minimale ou maximale avec des m√©thodes <code>saturating_*</code></li>
</ul>
</blockquote>
<!--
#### Floating-Point Types
-->
<h4 id="types-de-nombres-√†-virgule-flottante"><a class="header" href="#types-de-nombres-√†-virgule-flottante">Types de nombres √† virgule flottante</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rust‚Äôs floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs it‚Äôs roughly the same speed as `f32` but is capable of
more precision. All floating-point types are signed.
-->
<p>Rust poss√®de √©galement deux types primitifs pour les <em>nombres √† virgule
flottante</em> (ou <em>flottants</em>), qui sont des nombres avec des d√©cimales. Les types
de flottants en Rust sont les <code>f32</code> et les <code>f64</code>, qui ont respectivement une
taille en m√©moire de 32 bits et 64 bits. Le type par d√©faut est le <code>f64</code> car sur
les processeurs r√©cents ce type est quasiment aussi rapide qu'un <code>f32</code> mais est
plus pr√©cis. Tous les flottants ont un signe.</p>
<!--
Here‚Äôs an example that shows floating-point numbers in action:
-->
<p>Voici un exemple montrant l'utilisation de nombres √† virgule flottante¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Ficher¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>Les nombres √† virgule flottante sont repr√©sent√©s selon la norme IEEE-754. Le
type <code>f32</code> est un flottant √† simple pr√©cision, et le <code>f64</code> est √† double
pr√©cision.</p>
<!--
#### Numeric Operations
-->
<h4 id="les-op√©rations-num√©riques"><a class="header" href="#les-op√©rations-num√©riques">Les op√©rations num√©riques</a></h4>
<!--
Rust supports the basic mathematical operations you‚Äôd expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
Integer division rounds down to the nearest integer. The following code shows
how you‚Äôd use each numeric operation in a `let` statement:
-->
<p>Rust offre les op√©rations math√©matiques de base dont vous auriez besoin pour
tous les types de nombres¬†: addition, soustraction, multiplication, division et
modulo. Les divisions d'entiers arrondissent le r√©sultat √† l'entier le plus
pr√®s. Le code suivant montre comment utiliser chacune des op√©rations num√©riques
avec une instruction <code>let</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let somme = 5 + 10;

    // soustraction
    let difference = 95.5 - 4.3;

    // multiplication
    let produit = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let arrondi = 2 / 3; // retournera 0

    // modulo
    let reste = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. [Appendix B][appendix_b]<!-- ignore -- > contains a
list of all operators that Rust provides.
-->
<p>Chaque expression de ces instructions utilise un op√©rateur math√©matique et
calcule une valeur unique, qui est ensuite attribu√©e √† une variable. <a href="appendix-02-operators.html">L'annexe B</a><!-- ignore -->
pr√©sente une liste de tous les op√©rateurs que Rust fournit.</p>
<!--
#### The Boolean Type
-->
<h4 id="le-type-bool√©en"><a class="header" href="#le-type-bool√©en">Le type bool√©en</a></h4>
<!--
As in most other programming languages, a Boolean type in Rust has two possible
values: `true` and `false`. Booleans are one byte in size. The Boolean type in
Rust is specified using `bool`. For example:
-->
<p>Comme dans la plupart des langages de programmation, un type bool√©en a deux
valeurs possibles en Rust¬†: <code>true</code> (vrai) et <code>false</code> (faux). Les bool√©ens
prennent un octet en m√©moire. Le type bool√©en est d√©sign√© en utilisant <code>bool</code>.
Par exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // avec une annotation de type explicite
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. We‚Äôll cover how `if` expressions work in Rust in the [‚ÄúControl
Flow‚Äù][control-flow]<!-- ignore -- > section.
-->
<p>Les valeurs bool√©ennes sont principalement utilis√©es par les structures
conditionnelles, comme l'expression <code>if</code>. Nous aborderons le fonctionnement
de <code>if</code> en Rust dans la section
<a href="ch03-05-control-flow.html#les-structures-de-contr%C3%B4le">‚ÄúLes structures de contr√¥le‚Äù</a><!-- ignore -->.</p>
<!--
#### The Character Type
-->
<h4 id="le-type-caract√®re"><a class="header" href="#le-type-caract√®re">Le type caract√®re</a></h4>
<!--
Rust‚Äôs `char` type is the language‚Äôs most primitive alphabetic type. Here‚Äôs
some examples of declaring `char` values:
-->
<p>Le type <code>char</code> (comme <em>character</em>) est le type de caract√®re le plus
rudimentaire. Voici quelques exemples de d√©claration de valeurs de type
<code>char</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let heart_eyed_cat = 'üòª';
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let chat_aux_yeux_de_coeur = 'üòª';
}
</code></pre></pre>
<!--
Note that we specify `char` literals with single quotes, as opposed to string
literals, which use double quotes. Rust‚Äôs `char` type is four bytes in size and
represents a Unicode Scalar Value, which means it can represent a lot more than
just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji;
and zero-width spaces are all valid `char` values in Rust. Unicode Scalar
Values range from `U+0000` to `U+D7FF` and `U+E000` to `U+10FFFF` inclusive.
However, a ‚Äúcharacter‚Äù isn‚Äôt really a concept in Unicode, so your human
intuition for what a ‚Äúcharacter‚Äù is may not match up with what a `char` is in
Rust. We‚Äôll discuss this topic in detail in [‚ÄúStoring UTF-8 Encoded Text with
Strings‚Äù][strings]<!-- ignore -- > in Chapter 8.
-->
<p>Notez que nous renseignons un lit√©ral <code>char</code> avec des guillemets simples,
contrairement aux litt√©raux de cha√Æne de caract√®res, qui n√©c√©ssite des doubles
guillemets. Le type <code>char</code> de Rust prend quatre octets en m√©moire et repr√©sente
une valeur scalaire Unicode, ce qui veut dire que cela repr√©sente plus de
caract√®res que l'ASCII. Les lettres accentu√©es¬†; les caract√®res chinois,
japonais et cor√©ens¬†; les emoji¬†; les espaces de largeur nulle ont tous une
valeur pour <code>char</code> avec Rust. Les valeurs scalaires Unicode vont de <code>U+0000</code> √†
<code>U+D7FF</code> et de <code>U+E000</code> √† <code>U+10FFFF</code> inclus. Cependant, le concept de
‚Äúcaract√®re‚Äù n'est pas clairement d√©fini par Unicode, donc votre notion de
‚Äúcaract√®re‚Äù peut ne pas correspondre √† ce qu'est un <code>char</code> en Rust. Nous
aborderons ce sujet plus en d√©tail au <a href="ch08-02-strings.html">chapitre 8</a><!-- ignore -->.</p>
<!--
### Compound Types
-->
<h3 id="les-types-compos√©s"><a class="header" href="#les-types-compos√©s">Les types compos√©s</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p>Les <em>types compos√©s</em> peuvent regrouper plusieurs valeurs dans un seul type. Rust
a deux types compos√©s de base¬†: les <em>tuples</em> et les tableaux <em>(arrays)</em>.</p>
<!--
#### The Tuple Type
-->
<h4 id="le-type-tuple"><a class="header" href="#le-type-tuple">Le type <em>tuple</em></a></h4>
<!--
A tuple is a general way of grouping together a number of values with a variety
of types into one compound type. Tuples have a fixed length: once declared,
they cannot grow or shrink in size.
-->
<p>Un <em>tuple</em> est une mani√®re g√©n√©rale de regrouper plusieurs valeurs
de types diff√©rents en un seul type compos√©. Les tuples ont une taille fix√©e¬†:
√† partir du moment o√π ils ont √©t√© d√©clar√©s, on ne peut pas y ajouter ou enlever
des valeurs.</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don‚Äôt have to be the same. We‚Äôve added optional
type annotations in this example:
-->
<p>Nous cr√©ons un <em>tuple</em> en √©crivant une liste s√©par√©e par des virgules entre des
parenth√®ses. Chaque emplacement dans le tuple a un type, et les types de chacune
des valeurs dans le tuple n'ont pas forc√©ment besoin d'√™tre les m√™mes.
Nous avons ajout√© des annotations de type dans cet exemple, mais c'est
optionnel¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>La variable <code>tup</code> est li√©e √† tout le tuple, car un tuple est consid√©r√©
comme √©tant un unique √©l√©ment compos√©. Pour obtenir un √©l√©ment pr√©cis de ce
tuple, nous pouvons utiliser un filtrage par motif <em>(pattern matching)</em> pour
d√©structurer ce tuple, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;La valeur de y est¬†: {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>Le programme commence par cr√©er un tuple et il l'assigne √† la variable <code>tup</code>.
Il utilise ensuite un motif avec <code>let</code> pour prendre <code>tup</code> et le scinder en
trois variables distinctes¬†: <code>x</code>, <code>y</code>, et <code>z</code>.
On appelle cela <em>d√©structurer</em>, car il divise le tuple en trois parties.
Puis finalement, le programme affiche la valeur de <code>y</code>, qui est <code>6.4</code>.</p>
<!--
We can also access a tuple element directly by using a period (`.`) followed by
the index of the value we want to access. For example:
-->
<p>Nous pouvons aussi acc√©der directement √† chaque √©l√©ment du tuple en utilisant
un point (<code>.</code>) suivi de l'indice de la valeur que nous souhaitons obtenir. Par
exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let cinq_cents = x.0;

    let six_virgule_quatre = x.1;

    let un = x.2;
}
</code></pre></pre>
<!--
This program creates the tuple `x` and then makes new variables for each
element by using their respective indices. As with most programming languages,
the first index in a tuple is 0.
-->
<p>Ce programme cr√©e le tuple <code>x</code> puis cr√©e une nouvelle variable pour
chaque √©l√©ment en utilisant leur indices respectifs. Comme dans de nombreux
langages de programmation, le premier indice d'un tuple est 0.</p>
<!--
The tuple without any values, `()`, is a special type that has only one value,
also written `()`. The type is called the *unit type* and the value is called
the *unit value*. Expressions implicitly return the unit value if they don‚Äôt
return any other value.
-->
<p>Le tuple sans aucune valeur, <code>()</code>, est un type sp√©cial qui a une seule et unique
valeur, qui s'√©crit aussi <code>()</code>. Ce type est aussi appel√© le <em>type unit√©</em> et la
valeur est appel√©e <em>valeur unit√©</em>. Les expressions retournent implicitement la
valeur unit√© si elles ne retournent aucune autre valeur.</p>
<!--
#### The Array Type
-->
<h4 id="le-type-tableau"><a class="header" href="#le-type-tableau">Le type tableau</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Unlike arrays in
some other languages, arrays in Rust have a fixed length.
-->
<p>Un autre moyen d'avoir une collection de plusieurs valeurs est d'utiliser
un <em>tableau</em>. Contrairement aux tuples, chaque √©l√©ment d'un tableau doit √™tre du
m√™me type. Contrairement aux tableaux de certains autres langages, les tableaux
de Rust ont une taille fixe.</p>
<!--
We write the values in an array as a comma-separated list inside square
brackets:
-->
<p>Nous √©crivons les valeurs dans un tableau via une liste entre des crochets,
s√©par√©e par des virgules¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in [Chapter
4][stack-and-heap]<!-- ignore -- >) or when you want to ensure you always have a
fixed number of elements. An array isn‚Äôt as flexible as the vector type,
though. A vector is a similar collection type provided by the standard library
that *is* allowed to grow or shrink in size. If you‚Äôre unsure whether to use an
array or a vector, chances are you should use a vector. [Chapter
8][vectors]<!-- ignore -- > discusses vectors in more detail.
-->
<p>Les tableaux sont utiles quand vous voulez que vos donn√©es soient allou√©es sur
la pile <em>(stack)</em> plut√¥t que sur le tas <em>(heap)</em> (nous expliquerons la pile et
le tas au chapitre 4) ou lorsque vous voulez vous assurer que vous avez toujours
un nombre fixe d'√©l√©ments. Cependant, un tableau n'est pas aussi flexible qu'un
vecteur <em>(vector)</em>. Un vecteur est un type de collection de donn√©es similaire
qui est fourni par la biblioth√®que standard qui, lui, peut grandir ou r√©tr√©cir
en taille. Si vous ne savez pas si vous devez utiliser un tableau ou un
vecteur, il y a de fortes chances que vous devriez utiliser un vecteur. Le
<a href="ch08-01-vectors.html">chapitre 8</a><!-- ignore --> expliquera les vecteurs.</p>
<!--
However, arrays are more useful when you know the number of elements will not
need to change. For example, if you were using the names of the month in a
program, you would probably use an array rather than a vector because you know
it will always contain 12 elements:
-->
<p>Toutefois, les tableaux s'av√®rent plus utiles lorsque vous savez que le nombre
d'√©l√©ments n'aura pas besoin de changer. Par exemple, si vous utilisez les noms
des mois dans un programme, vous devriez probablement utiliser un tableau
plut√¥t qu'un vecteur car vous savez qu'il contient toujours 12 √©l√©ments¬†:</p>
<!--
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mois = [&quot;Janvier&quot;, &quot;F√©vrier&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;,
            &quot;Ao√ªt&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;D√©cembre&quot;];
<span class="boring">}
</span></code></pre></pre>
<!--
You write an array‚Äôs type using square brackets with the type of each element,
a semicolon, and then the number of elements in the array, like so:
-->
<p>Vous pouvez √©crire le type d'un tableau en utilisant des crochets et entre ces
crochets y ajouter le type de chaque √©l√©ment, un point-virgule, et ensuite le
nombre d'√©l√©ments dans le tableau, comme ceci¬†:</p>
<!--
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the array contains five elements.
-->
<p>Ici, <code>i32</code> est le type de chaque √©l√©ment. Apr√®s le point-virgule, le nombre <code>5</code>
indique que le tableau contient cinq √©l√©ments.</p>
<!--
You can also initialize an array to contain the same value for each element by
specifying the initial value, followed by a semicolon, and then the length of
the array in square brackets, as shown here:
-->
<p>Vous pouvez initialiser un tableau pour qu'il contienne toujours la m√™me valeur
pour chaque √©l√©ment, vous pouvez pr√©ciser la valeur initiale, suivie par un
point-virgule, et ensuite la taille du tableau, le tout entre crochets, comme
ci-dessous¬†:</p>
<!--
```rust
let a = [3; 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>Le tableau <code>a</code> va contenir <code>5</code> √©l√©ments qui auront tous la valeur
initiale <code>3</code>. C'est la m√™me chose que d'√©crire <code>let a = [3, 3, 3, 3, 3];</code> mais
de mani√®re plus concise.</p>
<!--
##### Accessing Array Elements
-->
<h5 id="acc√©der-aux-√©l√©ments-dun-tableau"><a class="header" href="#acc√©der-aux-√©l√©ments-dun-tableau">Acc√©der aux √©l√©ments d'un tableau</a></h5>
<!--
An array is a single chunk of memory of a known, fixed size that can be
allocated on the stack. You can access elements of an array using indexing,
like this:
-->
<p>Un tableau est un simple bloc de m√©moire de taille connue et fixe, qui peut √™tre
allou√© sur la pile. Vous pouvez acc√©der aux √©l√©ments d'un tableau en utilisant
l'indexation, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let premier = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>Dans cet exemple, la variable qui s'appelle <code>premier</code> aura la valeur <code>1</code>, car
c'est la valeur √† l'indice <code>[0]</code> dans le tableau. La variable <code>second</code>
r√©cup√®rera la valeur <code>2</code> depuis l'indice <code>[1]</code> du tableau.</p>
<!--
##### Invalid Array Element Access
-->
<h5 id="acc√®s-incorrect-√†-un-√©l√©ment-dun-tableau"><a class="header" href="#acc√®s-incorrect-√†-un-√©l√©ment-dun-tableau">Acc√®s incorrect √† un √©l√©ment d'un tableau</a></h5>
<!--
Let‚Äôs see what happens if you try to access an element of an array that is past
the end of the array. Say you run this code, similar to the guessing game in
Chapter 2, to get an array index from the user:
-->
<p>D√©couvrons ce qui se passe quand vous essayez d'acc√©der √† un √©l√©ment d'un
tableau qui se trouve apr√®s la fin du tableau¬†? Imaginons que vous ex√©cutiez le
code suivant, similaire au jeu du plus ou du moins du chapitre 2, pour demander
un indice de tableau √† l'utilisateur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,panics
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```
-->
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Veuillez entrer un indice de tableau.&quot;);

    let mut indice = String::new();

    io::stdin()
        .read_line(&amp;mut indice)
        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

    let indice: usize = indice
        .trim()
        .parse()
        .expect(&quot;L'indice entr√© n'est pas un nombre&quot;);

    let element = a[indice];

    println!(
        &quot;La valeur de l'√©l√©ment d'indice {} est¬†: {}&quot;,
        indice, element
    );
}
</code></pre>
<!--
This code compiles successfully. If you run this code using `cargo run` and
enter 0, 1, 2, 3, or 4, the program will print out the corresponding value at
that index in the array. If you instead enter a number past the end of the
array, such as 10, you‚Äôll see output like this:
-->
<p>Ce code compile avec succ√®s. Si vous ex√©cutez ce code avec <code>cargo run</code> et que
vous entrez 0, 1, 2, 3 ou 4, le programme affichera la valeur correspondante √†
cet indice dans le tableau. Si au contraire, vous entrez un indice apr√®s la fin
du tableau tel que 10, ceci s'affichera¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-- >

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The program resulted in a *runtime* error at the point of using an invalid
value in the indexing operation. The program exited with an error message and
didn‚Äôt execute the final `println!` statement. When you attempt to access an
element using indexing, Rust will check that the index you‚Äôve specified is less
than the array length. If the index is greater than or equal to the length,
Rust will panic. This check has to happen at runtime, especially in this case,
because the compiler can‚Äôt possibly know what value a user will enter when they
run the code later.
-->
<p>Le programme a rencontr√© une erreur <em>√† l'ex√©cution</em>, au moment d'utiliser une
valeur invalide comme indice. Le programme s'est arr√™t√© avec un message d'erreur
et n'a pas ex√©cut√© la derni√®re instruction <code>println!</code>. Quand vous essayez
d'acc√©der √† un √©l√©ment en utilisant l'indexation, Rust va v√©rifier que l'indice
que vous avez demand√© est plus petit que la taille du tableau. Si l'indice est
sup√©rieur ou √©gal √† la taille du tableau, Rust va <em>paniquer</em>. Cette v√©rification
doit avoir lieu √† l'ex√©cution, surtout dans ce cas, parce que le compilateur ne
peut pas deviner la valeur qu'entrera l'utilisateur quand il ex√©cutera le code
plus tard.</p>
<!--
This is an example of Rust‚Äôs memory safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust‚Äôs error handling.
-->
<p>C'est un exemple de mise en pratique des principes de s√©curit√© de la m√©moire par
Rust. Dans de nombreux langages de bas niveau, ce genre de v√©rification n'est
pas effectu√©e, et quand vous utilisez un indice incorrect, de la m√©moire
invalide peut √™tre r√©cup√©r√©e. Rust vous prot√®ge de ce genre d'erreur en quittant
imm√©diatement l'ex√©cution au lieu de permettre l'acc√®s en m√©moire et continuer
son d√©roulement. Le chapitre 9 expliquera la gestion d'erreurs de Rust.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[wrapping]: ../std/num/struct.Wrapping.html
[appendix_b]: appendix-02-operators.md
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
