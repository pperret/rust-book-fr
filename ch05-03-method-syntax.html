<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>La syntaxe des m√©thodes - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html" class="active"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Method Syntax
-->
<h2 id="la-syntaxe-des-m√©thodes"><a class="header" href="#la-syntaxe-des-m√©thodes">La syntaxe des m√©thodes</a></h2>
<!--
*Methods* are similar to functions: we declare them with the `fn` keyword and a
name, they can have parameters and a return value, and they contain some code
that‚Äôs run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum or a trait
object, which we cover in Chapters 6 and 17, respectively), and their first
parameter is always `self`, which represents the instance of the struct the
method is being called on.
-->
<p>Les <em>m√©thodes</em> sont similaires aux fonctions¬†: nous les d√©clarons avec le
mot-cl√© <code>fn</code> et un nom, elles peuvent avoir des param√®tres et une valeur de
retour, et elles contiennent du code qui est ex√©cut√© quand on la m√©thode est
appell√©e depuis un autre endroit. Contrairement aux fonctions, les m√©thodes
diff√®rent des fonctions parce qu'elles sont d√©finies dans le contexte d'une
structure (ou d'une √©num√©ration ou d'un objet de trait, que nous aborderons
respectivement aux chapitres 6 et 17) et que leur premier param√®tre est
toujours <code>self</code>, un mot-cl√© qui repr√©sente l'instance de la structure sur
laquelle on appelle la m√©thode.</p>
<!--
### Defining Methods
-->
<h3 id="d√©finir-des-m√©thodes"><a class="header" href="#d√©finir-des-m√©thodes">D√©finir des m√©thodes</a></h3>
<!--
Let‚Äôs change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p>Rempla√ßons la fonction <code>aire</code> qui prend une instance de <code>Rectangle</code> en param√®tre
par une m√©thode <code>aire</code> d√©finie sur la structure <code>Rectangle</code>, comme dans
l'encart 5-13.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carr√©s.&quot;,
        rect1.aire()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-13¬†: D√©finition d'une m√©thode <code>aire</code> sur la
structure <code>Rectangle</code></span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block for `Rectangle`. Everything within this `impl` block
will be associated with the `Rectangle` type. Then we move the `area` function
within the `impl` curly brackets and change the first (and in this case, only)
parameter to be `self` in the signature and everywhere within the body. In
`main`, where we called the `area` function and passed `rect1` as an argument,
we can instead use *method syntax* to call the `area` method on our `Rectangle`
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.
-->
<p>Pour d√©finir la fonction dans le contexte de <code>Rectangle</code>, nous d√©marrons un bloc
<code>impl</code> (<em>impl√©mentation</em>) pour <code>Rectangle</code>. Tout ce qui sera dans ce bloc <code>impl</code>
sera li√© au type <code>Rectangle</code>. Puis nous d√©pla√ßons la fonction <code>aire</code> entre les
accolades du <code>impl</code> et nous rempla√ßons le premier param√®tre (et dans notre cas,
le seul) par <code>self</code> dans la signature et dans tout le corps. Dans <code>main</code>, o√π
nous avons appel√© la fonction <code>aire</code> et pass√© <code>rect1</code> en argument, nous pouvons
utiliser √† la place la <em>syntaxe des m√©thodes</em> pour appeler la m√©thode <code>aire</code> sur
notre instance de <code>Rectangle</code>. La syntaxe des m√©thodes se place apr√®s
l'instance¬†: on ajoute un point suivi du nom de la m√©thode et des parenth√®ses
contenant les arguments s'il y en a.</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`.
The `&self` is actually short for `self: &Self`. Within an `impl` block, the
type `Self` is an alias for the type that the `impl` block is for. Methods must
have a parameter named `self` of type `Self` for their first parameter, so Rust
lets you abbreviate this with only the name `self` in the first parameter spot.
Note that we still need to use the `&` in front of the `self` shorthand to
indicate this method borrows the `Self` instance, just as we did in `rectangle:
&Rectangle`. Methods can take ownership of `self`, borrow `self` immutably as
we‚Äôve done here, or borrow `self` mutably, just as they can any other parameter.
-->
<p>Dans la signature de <code>aire</code>, nous utilisons <code>&amp;self</code> √† la place de
<code>rectangle: &amp;Rectangle</code>. Le <code>&amp;self</code> est un raccourci pour <code>self: &amp;Self</code>. Au
sein d'un bloc <code>impl</code>, le type de <code>Self</code> est un alias pour le type sur lequel
porte le <code>impl</code>. Les m√©thodes doivent avoir un param√®tre <code>self</code> du type <code>Self</code>
comme premier param√®tre afin que Rust puisse vous permettre d'abr√©ger en
renseignant uniquement <code>self</code> en premier param√®tre. Veuillez noter qu'il nous
faut quand m√™me utiliser le <code>&amp;</code> devant le raccourci <code>self</code>, pour indiquer que
cette m√©thode emprunte l'instance de <code>Self</code>, comme nous l'avions fait pour
<code>rectangle: &amp;Rectangle</code>. Les m√©thodes peuvent prendre possession de <code>self</code>,
emprunter <code>self</code> de fa√ßon immuable comme nous l'avons fait ici, ou emprunter
<code>self</code> de fa√ßon mutable, comme pour n'importe quel autre param√®tre.</p>
<!--
We‚Äôve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we don‚Äôt want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we‚Äôve called the method on as part of what the method does, we‚Äôd use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and you want
to prevent the caller from using the original instance after the transformation.
-->
<p>Nous avons choisi <code>&amp;self</code> ici pour la m√™me raison que nous avions utilis√©
<code>&amp;Rectangle</code> quand il s'agissait d'une fonction¬†; nous ne voulons pas en prendre
possession, et nous voulons seulement lire les donn√©es de la structure, pas les
modifier. Si nous voulions que la m√©thode modifie l'instance sur laquelle on
l'appelle, on utiliserait <code>&amp;mut self</code> comme premier param√®tre. Il est rare
d'avoir une m√©thode qui prend possession de l'instance en utilisant uniquement
<code>self</code> comme premier argument¬†; cette technique est g√©n√©ralement utilis√©e
lorsque la m√©thode transforme <code>self</code> en quelque chose d'autre et que vous voulez
emp√™cher le code appelant d'utiliser l'instance d'origine apr√®s la
transformation.</p>
<!--
The main reason for using methods instead of functions, in addition to providing
method syntax and not having to repeat the type of `self` in every method‚Äôs
signature, is for organization. We‚Äôve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>En compl√©ment de l'application de la syntaxe des m√©thodes et ainsi de ne pas
√™tre oblig√© de r√©p√©ter le type de <code>self</code> dans la signature de chaque m√©thode,
la principale raison d'utiliser les m√©thodes plut√¥t que de fonctions est pour
l'organisation. Nous avons mis tout ce qu'on pouvait faire avec une instance de
notre type dans un bloc <code>impl</code> plut√¥t que d'imposer aux futurs utilisateurs de
notre code √† rechercher les fonctionnalit√©s de <code>Rectangle</code> √† divers endroits de
la biblioth√®que que nous fournissons.</p>
<!--
Note that we can choose to give a method the same name as one of the struct‚Äôs
fields. For example, we can define a method on `Rectangle` also named `width`:
-->
<p>Notez que nous pourions faire en sorte qu'une m√©thode porte le m√™me nom qu'un
des champs de la structure. Par exemple, nous pourions d√©finir une m√©thode sur
<code>Rectangle</code> qui s'appelle elle aussi <code>largeur</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn largeur(&amp;self) -&gt; bool {
        self.largeur &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50,
    };

    if rect1.largeur() {
        println!(&quot;Le rectangle a une largeur non nulle¬†; elle vaut {}&quot;, rect1.largeur);
    }
}
</code></pre></pre>
<!--
Here, we‚Äôre choosing to make the `width` method return `true` if the value in
the instance‚Äôs `width` field is greater than 0, and `false` if the value is 0:
we can use a field within a method of the same name for any purpose. In `main`,
when we follow `rect1.width` with parentheses, Rust knows we mean the method
`width`. When we don‚Äôt use parentheses, Rust knows we mean the field `width`.
-->
<p>Ici, nous avons d√©fini la m√©thode <code>largeur</code> pour qu'elle retourne <code>true</code> si la
valeur dans le champ <code>largeur</code> est sup√©rieur ou √©gal √† 0, et <code>false</code> si la
valeur est 0¬†: nous pouvons utiliser un champ √† l'int√©rieur d'une m√©thode du
m√™me nom, pour n'importe quel usage. Dans le <code>main</code>, lorsque nous ajoutons des
parenth√®ses apr√®s <code>rect1.largeur</code>, Rust comprend que nous parlons de la m√©thode
<code>largeur</code>. Lorsque nous n'utilisons pas les parenth√®ses, Rust sait nous parlons
du champ <code>largeur</code>.</p>
<!--
Often, but not always, when we give methods with the same name as a field we
want it to only return the value in the field and do nothing else. Methods like
this are called *getters*, and Rust does not implement them automatically for
struct fields as some other languages do. Getters are useful because you can
make the field private but the method public and thus enable read-only access
to that field as part of the type‚Äôs public API. We will be discussing what
public and private are and how to designate a field or method as public or
private in Chapter 7.
-->
<p>Souvent, mais pas toujours, lorsque nous appellons une m√©thode avec le m√™me nom
qu'un champ, nous voulons qu'elle renvoie uniquement la valeur de ce champ et
ne fasse rien d'autre. Ces m√©thodes sont appel√©es des <em>accesseurs</em>, et Rust ne
les impl√©mente pas automatiquement pour les champs des structures comme le font
certains langages. Les accesseurs sont utiles pour rendre le champ priv√© mais
rendre la m√©thode publique et ainsi donner un acc√®s en lecture seule √† ce champ
dans l'API publique de ce type. Nous d√©velopperons les notions de publique et
priv√© et comment d√©finir un champ ou une m√©thode publique ou priv√©e au
chapitre 7.</p>
<!--
> ### Where‚Äôs the `->` Operator?
>
> In C and C++, two different operators are used for calling methods: you use
> `.` if you‚Äôre calling a method on the object directly and `->` if you‚Äôre
> calling the method on a pointer to the object and need to dereference the
> pointer first. In other words, if `object` is a pointer,
> `object->something()` is similar to `(*object).something()`.
>
> Rust doesn‚Äôt have an equivalent to the `->` operator; instead, Rust has a
> feature called *automatic referencing and dereferencing*. Calling methods is
> one of the few places in Rust that has this behavior.
>
> Here‚Äôs how it works: when you call a method with `object.something()`, Rust
> automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
> the method. In other words, the following are the same:
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -- >
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> The first one looks much cleaner. This automatic referencing behavior works
> because methods have a clear receiver‚Äîthe type of `self`. Given the receiver
> and name of a method, Rust can figure out definitively whether the method is
> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
> that Rust makes borrowing implicit for method receivers is a big part of
> making ownership ergonomic in practice.
-->
<blockquote>
<h3 id="o√π-est-lop√©rateur---"><a class="header" href="#o√π-est-lop√©rateur---">O√π est l'op√©rateur <code>-&gt;</code>¬†?</a></h3>
<p>En C et en C++, deux op√©rateurs diff√©rents sont utilis√©s pour appeler les
m√©thodes¬†: on utilise <code>.</code> si on appelle une m√©thode directement sur l'objet
et <code>-&gt;</code> si on appelle la m√©thode sur un pointeur vers l'objet et qu'il faut
d'abord d√©r√©f√©rencer le pointeur. En d'autres termes, si <code>objet</code> est un
pointeur, <code>objet-&gt;methode()</code> est similaire √† <code>(*objet).methode()</code>.</p>
<p>Rust n'a pas d'√©quivalent √† l'op√©rateur <code>-&gt;</code>¬†; √† la place, Rust a une
fonctionnalit√© appel√©e <em>r√©f√©rencement et d√©r√©f√©rencement automatiques</em>.
L'appel de m√©thodes est l'un des rares endroits de Rust o√π on retrouve ce
comportement.</p>
<p>Voil√† comment cela fonctionne¬†: quand on appelle une m√©thode avec
<code>objet.methode()</code>, Rust ajoute automatiquement le <code>&amp;</code>, <code>&amp;mut</code> ou <code>*</code> pour que
<code>objet</code> corresponde √† la signature de la m√©thode. Autrement dit, ces deux
lignes sont identiques¬†:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, autre: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_carre = f64::powi(autre.x - self.x, 2);
</span><span class="boring">       let y_carre = f64::powi(autre.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_carre + y_carre)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>La premi√®re ligne semble bien plus propre. Ce comportement du
(d√©)r√©f√©rencement automatique fonctionne parce que les m√©thodes ont une
cible claire¬†: le type de <code>self</code>. Compte tenu du nom de la m√©thode et
de l'instance sur laquelle elle s'applique, Rust peut d√©terminer de mani√®re
irr√©futable si la m√©thode lit (<code>&amp;self</code>), modifie (<code>&amp;mut self</code>) ou consomme
(<code>self</code>) l'instance. Le fait que Rust rend implicite l'emprunt pour les
instances sur lesquelles on appelle les m√©thodes am√©liore significativement
l'ergonomie de la possession.</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3 id="les-m√©thodes-avec-davantage-de-param√®tres"><a class="header" href="#les-m√©thodes-avec-davantage-de-param√®tres">Les m√©thodes avec davantage de param√®tres</a></h3>
<!--
Let‚Äôs practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self` (the first `Rectangle`); otherwise it should return `false`. That
is, once we‚Äôve defined the `can_hold` method, we want to be able to write the
program shown in Listing 5-14.
-->
<p>Entra√Ænons-nous √† utiliser des m√©thodes en impl√©mentant une seconde m√©thode sur
la structure <code>Rectangle</code>. Cette fois-ci, nous voulons qu'une instance de
<code>Rectangle</code> prenne une autre instance de <code>Rectangle</code> et qu'on retourne <code>true</code> si
le second <code>Rectangle</code> peut se dessiner int√©gralement √† l'int√©rieur de <code>self</code>
(le premier <code>Rectangle</code>)¬†; sinon, on renverra <code>false</code>. En d'autres termes, une
fois qu'on aura d√©fini la m√©thode <code>peut_contenir</code>, on veut pouvoir √©crire le
programme de l'encart 5-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };
    let rect2 = Rectangle {
        largeur: 10,
        hauteur: 40
    };
    let rect3 = Rectangle {
        largeur: 60,
        hauteur: 45
    };

    println!(&quot;rect1 peut-il contenir rect2¬†? {}&quot;, rect1.peut_contenir(&amp;rect2));
    println!(&quot;rect1 peut-il contenir rect3¬†? {}&quot;, rect1.peut_contenir(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">Encart 5-14¬†: Utilisation de la m√©thode <code>peut_contenir</code>
qui reste √† √©crire</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>Et on s'attend √† ce que le texte suivant s'affiche, puisque les deux dimensions
de <code>rect2</code> sont plus petites que les dimensions de <code>rect1</code>, mais <code>rect3</code> est
plus large que <code>rect1</code>¬†:</p>
<!--
```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
-->
<pre><code class="language-text">rect1 peut-il contenir rect2¬†? true
rect1 peut-il contenir rect3¬†? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean we‚Äôd need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Let‚Äôs add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>Nous voulons d√©finir une m√©thode, donc elle doit se trouver dans le bloc
<code>impl Rectangle</code>. Le nom de la m√©thode sera <code>peut_contenir</code> et elle prendra une
r√©f√©rence immuable vers un autre <code>Rectangle</code> en param√®tre. On peut d√©terminer le
type du param√®tre en regardant le code qui appelle la m√©thode¬†:
<code>rect1.peut_contenir(&amp;rect2)</code> prend en argument <code>&amp;rect2</code>, une r√©f√©rence immuable
vers <code>rect2</code>, une instance de <code>Rectangle</code>. Cela est logique puisque nous voulons
uniquement lire <code>rect2</code> (plut√¥t que de la modifier, ce qui aurait n√©cessit√© une
r√©f√©rence mutable) et nous souhaitons que <code>main</code> garde possession de <code>rect2</code>
pour qu'on puisse le r√©utiliser apr√®s avoir appel√© la m√©thode <code>peut_contenir</code>.
La valeur de retour de <code>peut_contenir</code> sera un bool√©en et l'impl√©mentation de la
m√©thode v√©rifiera si la largeur et la hauteur de <code>self</code> sont respectivement plus
grandes que la largeur et la hauteur de l'autre <code>Rectangle</code>. Ajoutons la
nouvelle m√©thode <code>peut_contenir</code> dans le bloc <code>impl</code> de l'encart 5-13, comme le
montre l'encart 5-15.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }

    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2¬†? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3¬†? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">Encart 5-15¬†: Impl√©mentation de la m√©thode <code>peut_contenir</code>
sur <code>Rectangle</code> qui prend une autre instance de <code>Rectangle</code> en param√®tre</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, we‚Äôll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>Lorsque nous ex√©cutons ce code avec la fonction <code>main</code> de l'encart 5-14, nous
obtenons l'affichage attendu. Les m√©thodes peuvent prendre plusieurs param√®tres
qu'on peut ajouter √† la signature apr√®s le param√®tre <code>self</code>, et ces param√®tres
fonctionnent de la m√™me mani√®re que les param√®tres des fonctions.</p>
<!--
### Associated Functions
-->
<h3 id="les-fonctions-associ√©es"><a class="header" href="#les-fonctions-associ√©es">Les fonctions associ√©es</a></h3>
<!--
All functions defined within an `impl` block are called *associated functions*
because they‚Äôre associated with the type named after the `impl`. We can define
associated functions that don‚Äôt have `self` as their first parameter (and thus
are not methods) because they don‚Äôt need an instance of the type to work with.
We‚Äôve already used one function like this: the `String::from` function that‚Äôs
defined on the `String` type.
-->
<p>Toutes les fonctions d√©finies dans un bloc <code>impl</code> s'appellent des <em>fonctions
associ√©es</em> car elles sont associ√©es au type renseign√© apr√®s le <code>impl</code>. Nous
pouvons aussi y d√©finir des fonctions associ√©es qui n'ont pas de <code>self</code> en
premier param√®tre (et donc ce ne sont pas des m√©thodes) car elles n'ont pas
besoin d'une instance du type sur lequel elles travaillent. Nous avons d√©j√†
utilis√© une fonction comme celle-ci¬†: la fonction <code>String::from</code> qui est
d√©finie sur le type <code>String</code>.</p>
<!--
Associated functions that aren‚Äôt methods are often used for constructors that
will return a new instance of the struct. For example, we could provide an
associated function that would have one dimension parameter and use that as
both width and height, thus making it easier to create a square `Rectangle`
rather than having to specify the same value twice:
-->
<p>Les fonctions associ√©es qui ne ne sont pas des m√©thodes sont souvent utilis√©es
comme constructeurs qui vont retourner une nouvelle instance de la structure.
Par exemple, on pourrait √©crire une fonction associ√©e qui prend une unique
dimension en param√®tre et l'utilise √† la fois pour la largeur et pour la
hauteur, ce qui rend plus ais√© la cr√©ation d'un <code>Rectangle</code> carr√© plut√¥t que
d'avoir √† indiquer la m√™me valeur deux fois¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
# 
# fn main() {
#     let sq = Rectangle::square(3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn carre(cote: u32) -&gt; Rectangle {
        Rectangle {
            largeur: cote,
            hauteur: cote
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mon_carre = Rectangle::carre(3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. We‚Äôll discuss modules in Chapter 7.
-->
<p>Pour appeler cette fonction associ√©e, on utilise la syntaxe <code>::</code> avec le nom de
la structure¬†; <code>let mon_carre = Rectangle::carre(3);</code> en est un exemple. Cette
fonction est cloisonn√©e dans l'espace de noms de la structure¬†: la syntaxe <code>::</code>
s'utilise aussi bien pour les fonctions associ√©es que pour les espaces de noms
cr√©√©s par des modules. Nous aborderons les modules au chapitre 7.</p>
<!--
### Multiple `impl` Blocks
-->
<h3 id="plusieurs-blocs-impl"><a class="header" href="#plusieurs-blocs-impl">Plusieurs blocs <code>impl</code></a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>Chaque structure peut avoir plusieurs blocs <code>impl</code>. Par exemple, l'encart 5-15
est √©quivalent au code de l'encart 5-16, o√π chaque m√©thode est dans son propre
bloc <code>impl</code>.</p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

impl Rectangle {
    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2¬†? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3¬†? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">Encart 5-16¬†: R√©√©criture de l'encart 5-15 en utilisant
plusieurs blocs <code>impl</code></span></p>
<!--
There‚Äôs no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. We‚Äôll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>Il n'y a aucune raison de s√©parer ces m√©thodes dans plusieurs blocs <code>impl</code> dans
notre exemple, mais c'est une syntaxe valide. Nous verrons un exemple de
l'utilit√© d'avoir plusieurs blocs <code>impl</code> au chapitre 10, o√π nous aborderons les
types g√©n√©riques et les traits.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©"><a class="header" href="#r√©sum√©">R√©sum√©</a></h2>
<!--
Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In `impl` blocks, you can define
functions that are associated with your type, and methods are a kind of
associated function that let you specify the behavior that instances of your
structs have.
-->
<p>Les structures vous permettent de cr√©er des types personnalis√©s significatifs
pour votre domaine. En utilisant des structures, on peut relier entre elles
des donn√©es associ√©es et nommer chaque donn√©e pour rendre le code plus clair.
Dans des blocs <code>impl</code>, vous pouvez d√©finir des fonctions qui sont associ√©es √†
votre type, et les m√©thodes sont un genre de fonction associ√©e qui vous permet
de renseigner le comportement que doivent suivre les instances de votre
structure.</p>
<!--
But structs aren‚Äôt the only way you can create custom types: let‚Äôs turn to
Rust‚Äôs enum feature to add another tool to your toolbox.
-->
<p>Mais les structures ne sont pas le seul moyen de cr√©er des types personnalis√©s¬†:
nous allons maintenant voir les √©num√©rations de Rust, une fonctionnalit√© que
vous pourrez bient√¥t ajouter √† votre bo√Æte √† outils.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-02-example-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch06-00-enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-02-example-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch06-00-enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
