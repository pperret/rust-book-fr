<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paniquer ou ne pas paniquer, telle est la question - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html" class="active"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## To `panic!` or Not to `panic!`
-->
<h2 id="paniquer-ou-ne-pas-paniquer-telle-est-la-question"><a class="header" href="#paniquer-ou-ne-pas-paniquer-telle-est-la-question">Paniquer ou ne pas paniquer, telle est la question</a></h2>
<!--
So how do you decide when you should call `panic!` and when you should return
`Result`? When code panics, there‚Äôs no way to recover. You could call `panic!`
for any error situation, whether there‚Äôs a possible way to recover or not, but
then you‚Äôre making the decision that a situation is unrecoverable on behalf of
the calling code. When you choose to return a `Result` value, you give the
calling code options. The calling code could choose to attempt to recover in a
way that‚Äôs appropriate for its situation, or it could decide that an `Err`
value in this case is unrecoverable, so it can call `panic!` and turn your
recoverable error into an unrecoverable one. Therefore, returning `Result` is a
good default choice when you‚Äôre defining a function that might fail.
-->
<p>Comment d√©cider si vous devez utiliser <code>panic!</code> ou si vous devez retourner un
<code>Result</code>¬†? Quand un code panique, il n'y a pas de moyen de r√©cup√©rer la
situation. Vous pourriez utiliser <code>panic!</code> pour n'importe quelle situation
d'erreur, peu importe s'il est possible de r√©cup√©rer la situation ou non, mais
vous prenez alors la d√©cision de tout arr√™ter √† la place du code appellant.
Lorsque vous choisissez de retourner une valeur <code>Result</code>, vous donnez le choix
au code appelant. Le code appelant peut choisir d'essayer de r√©cup√©rer l'erreur
de mani√®re appropri√©e √† la situation, ou il peut d√©cider que dans ce cas une
valeur <code>Err</code> est irr√©cup√©rable, et va donc utiliser <code>panic!</code> et transformer
votre erreur r√©cup√©rable en erreur irr√©cup√©rable. Ainsi, retourner <code>Result</code> est
un bon choix par d√©faut lorsque vous d√©finissez une fonction qui peut √©chouer.</p>
<!--
In situations such as examples, prototype code, and tests, it‚Äôs more
appropriate to write code that panics instead of returning a `Result`. Let‚Äôs
explore why, then discuss situations in which the compiler can‚Äôt tell that
failure is impossible, but you as a human can. The chapter will conclude with
some general guidelines on how to decide whether to panic in library code.
-->
<p>Dans certains cas comme les exemples, les prototypes, et les tests, il est plus
appropri√© d'√©crire du code qui panique plut√¥t que de retourner un <code>Result</code>.
Nous allons voir pourquoi, puis nous verrons des situations dans lesquelles
vous savez en tant qu'humain qu'un code ne peut pas √©chouer, mais que le
compilateur ne peut pas le d√©duire par lui-m√™me. Enfin, nous allons conclure le
chapitre par quelques lignes directrices g√©n√©rales pour d√©cider s'il faut
paniquer dans le code d'une biblioth√®que.</p>
<!--
### Examples, Prototype Code, and Tests
-->
<h3 id="les-exemples-les-prototypes-et-les-tests"><a class="header" href="#les-exemples-les-prototypes-et-les-tests">Les exemples, les prototypes et les tests</a></h3>
<!--
When you‚Äôre writing an example to illustrate some concept, also including robust
error-handling code can make the example less clear. In
examples, it‚Äôs understood that a call to a method like `unwrap` that could
panic is meant as a placeholder for the way you‚Äôd want your application to
handle errors, which can differ based on what the rest of your code is doing.
-->
<p>Lorsque vous √©crivez un exemple pour illustrer un concept, y rajouter un code
de gestion des erreurs tr√®s r√©silient peut nuire √† la clart√© de l'exemple. Dans
les exemples, il est courant d'utiliser une m√©thode comme <code>unwrap</code> (qui peut
faire un panic) pour remplacer le code de gestion de l'erreur que vous
utiliseriez en temps normal dans votre application, et qui peut changer en
fonction de ce que le reste de votre code va faire.</p>
<!--
Similarly, the `unwrap` and `expect` methods are very handy when prototyping,
before you‚Äôre ready to decide how to handle errors. They leave clear markers in
your code for when you‚Äôre ready to make your program more robust.
-->
<p>De la m√™me mani√®re, les m√©thodes <code>unwrap</code> et <code>expect</code> sont tr√®s pratiques pour
coder des prototypes, avant m√™me de d√©cider comment g√©rer les erreurs. Ce sont
des indicateurs clairs dans votre code pour plus tard quand vous serez pr√™t √†
rendre votre code plus r√©silient aux √©checs.</p>
<!--
If a method call fails in a test, you‚Äôd want the whole test to fail, even if
that method isn‚Äôt the functionality under test. Because `panic!` is how a test
is marked as a failure, calling `unwrap` or `expect` is exactly what should
happen.
-->
<p>Si l'appel √† une m√©thode √©choue dans un test, nous voulons que tout le test
√©choue, m√™me si cette m√©thode n'est pas la fonctionnalit√© que nous testons.
Puisque c'est <code>panic!</code> qui indique qu'un test a √©chou√©, utiliser <code>unwrap</code> ou
<code>expect</code> est exactement ce qu'il faut faire.</p>
<!--
### Cases in Which You Have More Information Than the Compiler
-->
<h3 id="les-cas-o√π-vous-avez-plus-dinformations-que-le-compilateur"><a class="header" href="#les-cas-o√π-vous-avez-plus-dinformations-que-le-compilateur">Les cas o√π vous avez plus d'informations que le compilateur</a></h3>
<!--
It would also be appropriate to call `unwrap` when you have some other logic
that ensures the `Result` will have an `Ok` value, but the logic isn‚Äôt
something the compiler understands. You‚Äôll still have a `Result` value that you
need to handle: whatever operation you‚Äôre calling still has the possibility of
failing in general, even though it‚Äôs logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you‚Äôll never
have an `Err` variant, it‚Äôs perfectly acceptable to call `unwrap`. Here‚Äôs an
example:
-->
<p>Vous pouvez utiliser <code>unwrap</code> lorsque vous avez une certaine logique qui
garantit que le <code>Result</code> sera toujours une valeur <code>Ok</code>, mais que ce n'est pas le
genre de logique que le compilateur arrive √† comprendre. Vous aurez quand m√™me
une valeur <code>Result</code> √† g√©rer¬†: l'op√©ration que vous utilisez peut √©chouer de
mani√®re g√©n√©rale, m√™me si dans votre cas c'est logiquement impossible. Si en
inspectant manuellement le code vous vous rendez compte que vous n'aurez jamais
une variante <code>Err</code>, vous pouvez tout √† fait utiliser <code>unwrap</code>. Voici un
exemple¬†:</p>
<!--
```rust
# fn main() {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1".parse().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<!--
We‚Äôre creating an `IpAddr` instance by parsing a hardcoded string. We can see
that `127.0.0.1` is a valid IP address, so it‚Äôs acceptable to use `unwrap`
here. However, having a hardcoded, valid string doesn‚Äôt change the return type
of the `parse` method: we still get a `Result` value, and the compiler will
still make us handle the `Result` as if the `Err` variant is a possibility
because the compiler isn‚Äôt smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore *did* have a possibility of failure,
we‚Äôd definitely want to handle the `Result` in a more robust way instead.
-->
<p>Nous cr√©ons une instance de <code>IpAddr</code> en interpr√©tant une cha√Æne de caract√®res
cod√©e en dur dans le code. Nous savons que <code>127.0.0.1</code> est une adresse IP
valide, donc il est acceptable d'utiliser <code>unwrap</code> ici. Toutefois, avoir une
cha√Æne de caract√®res valide et cod√©e en dur ne change pas le type de retour de
la m√©thode <code>parse</code>¬†: nous obtenons toujours une valeur de type <code>Result</code> et le
compilateur va nous demander de g√©rer le <code>Result</code> comme si on pouvait obtenir la
variante <code>Err</code>, car le compilateur n'est pas suffisamment intelligent pour
comprendre que cette cha√Æne de caract√®res est toujours une adresse IP valide. Si
le texte de l'adresse IP provient de l'utilisateur au lieu d'√™tre cod√© en dur
dans le programme et donc qu'il y a d√©sormais une possibilit√© d'erreur, alors
nous devrions vouloir g√©rer le <code>Result</code> d'une mani√®re plus r√©siliente.</p>
<!--
### Guidelines for Error Handling
-->
<h3 id="recommandations-pour-g√©rer-les-erreurs"><a class="header" href="#recommandations-pour-g√©rer-les-erreurs">Recommandations pour g√©rer les erreurs</a></h3>
<!--
It‚Äôs advisable to have your code panic when it‚Äôs possible that your code
could end up in a bad state. In this context, a *bad state* is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
code‚Äîplus one or more of the following:
-->
<p>Il est recommand√© de faire paniquer votre code d√®s qu'il risque d'aboutir √† un
√©tat invalide. Dans ce contexte, un <em>√©tat invalide</em> est lorsqu'un postulat, une
garantie, un contrat ou un invariant a √©t√© rompu, comme des valeurs invalides,
contradictoires ou manquantes qui sont fournies √† votre code, ainsi qu'un ou
plusieurs des √©l√©ments suivants¬†:</p>
<!--
* The bad state is something that is unexpected, as opposed to something that
  will likely happen occasionally, like a user entering data in the wrong
  format.
* Your code after this point needs to rely on not being in this bad state,
  rather than checking for the problem at every step.
* There‚Äôs not a good way to encode this information in the types you use. We‚Äôll
  work through an example of what we mean in the [‚ÄúEncoding States and Behavior
  as Types‚Äù][encoding]<!-- ignore -- > section of Chapter 17.
-->
<ul>
<li>L'√©tat invalide est quelque chose qui est inattendu, contrairement √† quelque
chose qui devrait arriver occasionnellement, comme par exemple un utilisateur
qui saisit une donn√©e dans un mauvais format.</li>
<li>Apr√®s cette instruction, votre code a besoin de ne pas √™tre dans cet √©tat
invalide, plut√¥t que d'avoir √† v√©rifier le probl√®me √† chaque √©tape.</li>
<li>Il n'y a pas de bonne fa√ßon d'encoder cette information dans les types que
vous utilisez. Nous allons pratiquer ceci via un exemple dans <a href="ch17-03-oo-design-patterns.html">une section du
chapitre 17</a><!-- ignore -->.</li>
</ul>
<!--
If someone calls your code and passes in values that don‚Äôt make sense, the best
choice might be to call `panic!` and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, `panic!` is
often appropriate if you‚Äôre calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.
-->
<p>Si une personne utilise votre biblioth√®que et lui fournit des valeurs qui n'ont
pas de sens, la meilleure des choses √† faire est d'utiliser <code>panic!</code> et
d'avertir cette personne du bogue dans son code afin qu'elle le r√®gle pendant la
phase de d√©veloppement. De la m√™me mani√®re, <code>panic!</code> est parfois appropri√© si
vous appelez du code externe sur lequel vous n'avez pas la main, et qu'il
retourne un √©tat invalide que vous ne pouvez pas corriger.</p>
<!--
However, when failure is expected, it‚Äôs more appropriate to return a `Result`
than to make a `panic!` call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a `Result` indicates that failure is an
expected possibility that the calling code must decide how to handle.
-->
<p>Cependant, si l'on s'attend √† rencontrer des √©checs, il est plus appropri√© de
retourner un <code>Result</code> plut√¥t que de faire appel √† <code>panic!</code>. Il peut s'agir par
exemple d'un interpr√©teur qui re√ßoit des donn√©es erron√©es, ou une requ√™te HTTP
qui retourne un statut qui indique que vous avez atteint une limite de d√©bit.
Dans ces cas-l√†, vous devriez indiquer qu'il est possible que cela puisse
√©chouer en retournant un <code>Result</code> afin que le code appelant puisse d√©cider quoi
faire pour g√©rer le probl√®me.</p>
<!--
When your code performs operations on values, your code should verify the
values are valid first and panic if the values aren‚Äôt valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
`panic!` if you attempt an out-of-bounds memory access: trying to access memory
that doesn‚Äôt belong to the current data structure is a common security problem.
Functions often have *contracts*: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug and
it‚Äôs not a kind of error you want the calling code to have to explicitly
handle. In fact, there‚Äôs no reasonable way for calling code to recover; the
calling *programmers* need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.
-->
<p>Lorsque votre code effectue des op√©rations sur des valeurs, votre code devrait
d'abord v√©rifier que ces valeurs sont valides, et faire un panic si les valeurs
ne sont pas correctes. C'est essentiellement pour des raisons de s√©curit√©¬†:
tenter de travailler avec des donn√©es invalides peut exposer votre code √† des
vuln√©rabilit√©s. C'est la principale raison pour laquelle la biblioth√®que
standard va appeler <code>panic!</code> si vous essayez d'acc√©der √† la m√©moire hors
limite¬†: essayer d'acc√©der √† de la m√©moire qui n'appartient pas √† la structure
de donn√©es actuelle est un probl√®me de s√©curit√© fr√©quent. Les fonctions ont
souvent des <em>contrats</em>¬†: leur comportement est garanti uniquement si les donn√©es
d'entr√©e remplissent des conditions particuli√®res. Paniquer lorsque le contrat
est viol√© est justifi√©, car une violation de contrat signifie toujours un bogue
du c√¥t√© de l'appelant, et ce n'est pas le genre d'erreur que vous voulez que le
code appelant g√®re explicitement. En fait, il n'y a aucun moyen rationnel pour
que le code appelant se corrige¬†: le <em>d√©veloppeur</em> du code appelant doit
corriger le code. Les contrats d'une fonction, en particulier lorsqu'une
violation va causer un panic, doivent √™tre expliqu√©s dans la documentation de
l'API de ladite fonction.</p>
<!--
However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust‚Äôs type system (and thus the type
checking done by the compiler) to do many of the checks for you. If your
function has a particular type as a parameter, you can proceed with your code‚Äôs
logic knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an `Option`, your program expects to
have *something* rather than *nothing*. Your code then doesn‚Äôt have to handle
two cases for the `Some` and `None` variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won‚Äôt
even compile, so your function doesn‚Äôt have to check for that case at runtime.
Another example is using an unsigned integer type such as `u32`, which ensures
the parameter is never negative.
-->
<p>Cependant, avoir beaucoup de v√©rifications d'erreurs dans toutes vos fonctions
serait verbeux et p√©nible. Heureusement, vous pouvez utiliser le syst√®me de
types de Rust (et donc la v√©rification de type que fait le compilateur) pour
assurer une partie des v√©rifications √† votre place. Si votre fonction a un
param√®tre d'un type pr√©cis, vous pouvez continuer √† √©crire votre code en
sachant que le compilateur s'est d√©j√† assur√© que vous avez une valeur valide.
Par exemple, si vous obtenez un type de valeur plut√¥t qu'une <code>Option</code>, votre
programme s'attend √† obtenir <em>quelque chose</em> plut√¥t que <em>rien</em>. Votre code n'a
donc pas √† g√©rer les deux cas de variantes <code>Some</code> et <code>None</code>¬†: la seule
possibilit√© est qu'il y a une valeur. Du code qui essaye de ne rien fournir √†
votre fonction ne compilera m√™me pas, donc votre fonction n'a pas besoin de
v√©rifier ce cas-l√† lors de l'ex√©cution. Un autre exemple est d'utiliser un type
d'entier non sign√© comme <code>u32</code>, qui garantit que le param√®tre n'est jamais
strictement n√©gatif.</p>
<!--
### Creating Custom Types for Validation
-->
<h3 id="cr√©er-des-types-personnalis√©s-pour-la-v√©rification"><a class="header" href="#cr√©er-des-types-personnalis√©s-pour-la-v√©rification">Cr√©er des types personnalis√©s pour la v√©rification</a></h3>
<!--
Let‚Äôs take the idea of using Rust‚Äôs type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user‚Äôs guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of ‚ÄúToo high‚Äù or ‚ÄúToo low‚Äù would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number that‚Äôs out of range versus when a user
types, for example, letters instead.
-->
<p>Allons plus loin dans l'id√©e d'utiliser le syst√®me de types de Rust pour
s'assurer d'avoir une valeur valide en cr√©ant un type personnalis√© pour la
v√©rification. Souvenez-vous du jeu du plus ou du moins du chapitre 2 dans lequel
notre code demandait √† l'utilisateur de deviner un nombre entre 1 et 100. Nous
n'avons jamais valid√© que le nombre saisi par l'utilisateur √©tait entre ces
nombres avant de le comparer √† notre nombre secret¬†; nous avons seulement
v√©rifi√© que le nombre √©tait positif. Dans ce cas, les cons√©quences ne sont pas
tr√®s graves¬†: notre r√©sultat ‚ÄúC'est plus¬†!‚Äù ou ‚ÄúC'est moins¬†!‚Äù sera toujours
correct. Mais ce serait une am√©lioration utile pour aider l'utilisateur √† faire
des suppositions valides et pour avoir un comportement diff√©rent selon qu'un
utilisateur propose un nombre en dehors des limites ou qu'il saisit, par
exemple, des lettres √† la place.</p>
<!--
One way to do this would be to parse the guess as an `i32` instead of only a
`u32` to allow potentially negative numbers, and then add a check for the
number being in range, like so:
-->
<p>Une fa√ßon de faire cela serait de stocker le nombre saisi dans un <code>i32</code> plut√¥t
que dans un <code>u32</code> afin de permettre d'obtenir potentiellement des nombres
n√©gatifs, et ensuite v√©rifier que le nombre est dans la plage autoris√©e, comme
ceci¬†:</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Devinez le nombre¬†!");
# 
#     let nombre_secret = rand::thread_rng().gen_range(1..101);
# 
    loop {
        // -- partie masqu√©e ici --

#         println!("Veuillez saisir un nombre.");
# 
#         let mut supposition = String::new();
# 
#         io::stdin()
#             .read_line(&mut supposition)
#             .expect("√âchec de la lecture de la saisie");
# 
        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) => nombre,
            Err(_) => continue,
        };

        if supposition < 1 || supposition > 100 {
            println!("Le nombre secret est entre 1 et 100.");
            continue;
        }

        match supposition.cmp(&nombre_secret) {
            // -- partie masqu√©e ici --
#             Ordering::Less => println!("C'est plus¬†!"),
#             Ordering::Greater => println!("C'est moins¬†!"),
#             Ordering::Equal => {
#                 println!("Gagn√©¬†!");
#                 break;
#             }
#         }
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    loop {
        // -- partie masqu√©e ici --

<span class="boring">        println!(&quot;Veuillez saisir un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;√âchec de la lecture de la saisie&quot;);
</span><span class="boring">
</span>        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        if supposition &lt; 1 || supposition &gt; 100 {
            println!(&quot;Le nombre secret est entre 1 et 100.&quot;);
            continue;
        }

        match supposition.cmp(&amp;nombre_secret) {
            // -- partie masqu√©e ici --
<span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Gagn√©¬†!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<!--
The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.
-->
<p>L'expression <code>if</code> v√©rifie si la valeur est en dehors des limites et informe
l'utilisateur du probl√®me le cas √©ch√©ant, puis utilise <code>continue</code> pour passer √†
la prochaine it√©ration de la boucle et ainsi demander de saisir une nouvelle
supposition. Apr√®s l'expression <code>if</code>, nous pouvons continuer avec la comparaison
entre <code>supposition</code> et le nombre secret tout en sachant que <code>supposition</code> est
entre 1 et 100.</p>
<!--
However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).
-->
<p>Cependant, ce n'est pas une solution id√©ale¬†: si c'√©tait absolument critique
que le programme ne travaille qu'avec des valeurs entre 1 et 100 et qu'il aurait
de nombreuses fonctions qui reposent sur cette condition, cela pourrait √™tre
fastidieux (et cela impacterait potentiellement la performance) de faire une
v√©rification comme celle-ci dans chacune de ces fonctions.</p>
<!--
Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, it‚Äôs safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-13 shows one way to define a
`Guess` type that will only create an instance of `Guess` if the `new` function
receives a value between 1 and 100.
-->
<p>√Ä la place, nous pourrions construire un nouveau type et int√©grer les
v√©rifications dans la fonction de cr√©ation d'une instance de ce type plut√¥t que
de r√©p√©ter partout les v√©rifications. Il est ainsi plus s√ªr pour les fonctions
d'utiliser ce nouveau type dans leurs signatures et d'utiliser avec confiance
les valeurs qu'elles re√ßoivent. L'encart 9-13 montre une fa√ßon de d√©finir un
type <code>Supposition</code> qui ne cr√©era une instance de <code>Supposition</code> que si la
fonction <code>new</code> re√ßoit une valeur entre 1 et 100¬†:</p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -- >
-->
<!--
```rust
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("Supposition valeur must be between 1 and 100, got {}.", valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&self) -> i32 {
        self.valeur
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;Supposition valeur must be between 1 and 100, got {}.&quot;, valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&amp;self) -&gt; i32 {
        self.valeur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-13: A `Guess` type that will only continue with
values between 1 and 100</span>
-->
<p><span class="caption">Encart 9-13¬†: un type <code>Supposition</code> qui ne va continuer
que si la valeur est entre 1 et 100</span></p>
<!--
First, we define a struct named `Guess` that has a field named `value` that
holds an `i32`. This is where the number will be stored.
-->
<p>D'abord, nous d√©finissons une structure qui s'appelle <code>Supposition</code> qui a un
champ <code>valeur</code> qui stocke un <code>i32</code>. C'est dans ce dernier que le nombre sera
stock√©.</p>
<!--
Then we implement an associated function named `new` on `Guess` that creates
instances of `Guess` values. The `new` function is defined to have one
parameter named `value` of type `i32` and to return a `Guess`. The code in the
body of the `new` function tests `value` to make sure it‚Äôs between 1 and 100.
If `value` doesn‚Äôt pass this test, we make a `panic!` call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a `Guess` with a `value` outside this range would
violate the contract that `Guess::new` is relying on. The conditions in which
`Guess::new` might panic should be discussed in its public-facing API
documentation; we‚Äôll cover documentation conventions indicating the possibility
of a `panic!` in the API documentation that you create in Chapter 14. If
`value` does pass the test, we create a new `Guess` with its `value` field set
to the `value` parameter and return the `Guess`.
-->
<p>Ensuite, nous impl√©mentons une fonction associ√©e <code>new</code> sur <code>Supposition</code> qui
cr√©e des instances de <code>Supposition</code>. La fonction <code>new</code> est con√ßue pour recevoir
un param√®tre <code>valeur</code> de type <code>i32</code> et retourner une <code>Supposition</code>. Le code dans
le corps de la fonction <code>new</code> teste <code>valeur</code> pour s'assurer qu'elle est bien
entre 1 et 100. Si <code>valeur</code> √©choue √† ce test, nous faisons appel √† <code>panic!</code>, qui
alertera le d√©veloppeur qui √©crit le code appelant qu'il a un bogue qu'il doit
r√©gler, car cr√©er une <code>Supposition</code> avec <code>valeur</code> en dehors de cette plage va
violer le contrat sur lequel s'appuie <code>Supposition::new</code>. Les conditions dans
lesquelles <code>Supposition::new</code> va paniquer devraient √™tre expliqu√©es dans la
documentation publique de l'API¬†; nous verrons les conventions pour indiquer
l'√©ventualit√© d'un <code>panic!</code> dans la documentation de l'API que vous cr√©erez
au chapitre 14. Si <code>valeur</code> passe le test, nous cr√©ons une nouvelle
<code>Supposition</code> avec son champ <code>valeur</code> qui prend la valeur du param√®tre <code>valeur</code>
et retourne cette <code>Supposition</code>.</p>
<!--
Next, we implement a method named `value` that borrows `self`, doesn‚Äôt have any
other parameters, and returns an `i32`. This kind of method is sometimes called
a *getter*, because its purpose is to get some data from its fields and return
it. This public method is necessary because the `value` field of the `Guess`
struct is private. It‚Äôs important that the `value` field be private so code
using the `Guess` struct is not allowed to set `value` directly: code outside
the module *must* use the `Guess::new` function to create an instance of
`Guess`, thereby ensuring there‚Äôs no way for a `Guess` to have a `value` that
hasn‚Äôt been checked by the conditions in the `Guess::new` function.
-->
<p>Enfin, nous impl√©mentons une m√©thode <code>valeur</code> qui emprunte <code>self</code>, n'a aucun
autre param√®tre, et retourne un <code>i32</code>. Ce genre de m√©thode est parfois appel√© un
<em>accesseur</em>, car son r√¥le est d'acc√©der aux donn√©es des champs et de les
retourner. Cette m√©thode publique est n√©cessaire car le champ <code>valeur</code> de la
structure <code>Supposition</code> est priv√©. Il est important que le champ <code>valeur</code> soit
priv√© pour que le code qui utilise la structure <code>Supposition</code> ne puisse pas
directement assigner une valeur √† <code>valeur</code>¬†: le code en dehors du module <em>doit</em>
utiliser la fonction <code>Supposition::new</code> pour cr√©er une instance de
<code>Supposition</code>, ce qui permet d'emp√™cher la cr√©ation d'une <code>Supposition</code> avec un
champ <code>valeur</code> qui n'a pas √©t√© v√©rifi√© par les conditions dans la fonction
<code>Supposition:new</code>.</p>
<!--
A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a `Guess` rather than an
`i32` and wouldn‚Äôt need to do any additional checks in its body.
-->
<p>Une fonction qui prend en param√®tre ou qui retourne des nombres uniquement entre
1 et 100 peut ensuite d√©clarer dans sa signature qu'elle prend en param√®tre ou
qu'elle retourne une <code>Supposition</code> plut√¥t qu'un <code>i32</code> et n'aura pas besoin de
faire de v√©rifications suppl√©mentaires dans son corps.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©"><a class="header" href="#r√©sum√©">R√©sum√©</a></h2>
<!--
Rust‚Äôs error handling features are designed to help you write more robust code.
The `panic!` macro signals that your program is in a state it can‚Äôt handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The `Result` enum uses Rust‚Äôs type system to indicate that
operations might fail in a way that your code could recover from. You can use
`Result` to tell code that calls your code that it needs to handle potential
success or failure as well. Using `panic!` and `Result` in the appropriate
situations will make your code more reliable in the face of inevitable problems.
-->
<p>Les fonctionnalit√©s de gestion d'erreurs de Rust sont con√ßues pour vous aider √†
√©crire du code plus r√©silient. La macro <code>panic!</code> signale que votre programme
est dans un √©tat qu'il ne peut pas g√©rer et vous permet de dire au processus de
s'arr√™ter au lieu d'essayer de continuer avec des valeurs invalides ou
incorrectes. L'√©num√©ration <code>Result</code> utilise le syst√®me de types de Rust pour
signaler que des op√©rations peuvent √©chouer de telle fa√ßon que votre code puisse
rattraper l'erreur. Vous pouvez utiliser <code>Result</code> pour dire au code qui appelle
votre code qu'il a besoin de g√©rer le r√©sultat et aussi les potentielles
erreurs. Utiliser <code>panic!</code> et <code>Result</code> de mani√®re appropri√©e rendra votre code
plus fiable face √† des probl√®mes in√©vitables.</p>
<!--
Now that you‚Äôve seen useful ways that the standard library uses generics with
the `Option` and `Result` enums, we‚Äôll talk about how generics work and how you
can use them in your code.
-->
<p>Maintenant que vous avez vu la fa√ßon dont la biblioth√®que standard tire parti de
la g√©n√©ricit√© avec les √©num√©rations <code>Option</code> et <code>Result</code>, nous allons voir
comment la g√©n√©ricit√© fonctionne et comment vous pouvez l'utiliser dans votre code.</p>
<!--
[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
