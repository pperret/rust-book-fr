<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>La syntaxe des motifs - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html" class="active"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Pattern Syntax
-->
<h2 id="la-syntaxe-des-motifs"><a class="header" href="#la-syntaxe-des-motifs">La syntaxe des motifs</a></h2>
<!--
Throughout the book, you‚Äôve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each one.
-->
<p>Tout au long de ce livre, vous avez rencontr√© de nombreux types de motifs. Dans cette
section, nous allons rassembler toutes les syntaxes valides des motifs et
examiner les raisons pour lesquelles vous devriez utiliser chacune d'entre
elles.</p>
<!--
### Matching Literals
-->
<h3 id="correspondre-aux-litt√©raux"><a class="header" href="#correspondre-aux-litt√©raux">Correspondre aux litt√©raux</a></h3>
<!--
As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:
-->
<p>Comme vous l'avez vu chapitre 6, vous pouvez faire directement correspondre des
motifs avec des litt√©raux. Le code suivant vous donne quelques exemples¬†:</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;un&quot;),
        2 =&gt; println!(&quot;deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;n'importe quoi&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one` because the value in `x` is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.
-->
<p>Ce code affiche <code>un</code> car la valeur dans <code>x</code> est <code>1</code>. Cette syntaxe est tr√®s
utile lorsque vous souhaitez que votre code fasse quelque chose s'il obtient une
valeur pr√©cise.</p>
<!--
### Matching Named Variables
-->
<h3 id="correspondre-√†-des-variables-nomm√©es"><a class="header" href="#correspondre-√†-des-variables-nomm√©es">Correspondre √† des variables nomm√©es</a></h3>
<!--
Named variables are irrefutable patterns that match any value, and we‚Äôve used
them many times in the book. However, there is a complication when you use
named variables in `match` expressions. Because `match` starts a new scope,
variables declared as part of a pattern inside the `match` expression will
shadow those with the same name outside the `match` construct, as is the case
with all variables. In Listing 18-11, we declare a variable named `x` with the
value `Some(5)` and a variable `y` with the value `10`. We then create a
`match` expression on the value `x`. Look at the patterns in the match arms and
`println!` at the end, and try to figure out what the code will print before
running this code or reading further.
-->
<p>Les variables nomm√©es sont des motifs irr√©futables qui correspondent √†
n'importe quelle valeur, et nous les avons utilis√©es de nombreuses fois dans le
livre. Cependant, il subsiste un probl√®me lorsque vous utilisez les variables
nomm√©es dans les expressions <code>match</code>. Comme <code>match</code> d√©bute une nouvelle port√©e,
les variables utilis√©es comme faisant partie du motif de la construction
<code>match</code> vont masquer celles ayant le m√™me nom et provenant de l'ext√©rieur de la
construction <code>match</code>, comme c'est le cas avec toutes les variables. Dans
l'encart 18-11, nous d√©clarons une variable <code>x</code> avec la valeur <code>Some(5)</code> et une
variable <code>y</code> avec la valeur <code>10</code>. Nous cr√©ons alors une expression <code>match</code> sur
la valeur <code>x</code>. Observez les motifs sur les branches du <code>match</code> et du <code>println!</code>
√† la fin, et essayez de deviner ce qui sera √©crit avant d'ex√©cuter ce code ou
de lire la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;On a 50&quot;),
        Some(y) =&gt; println!(&quot;Correspondance, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Cas par d√©faut, x = {:?}&quot;, x),
    }

    println!(&quot;A la fin¬†: x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-11: A `match` expression with an arm that
introduces a shadowed variable `y`</span>
-->
<p><span class="caption">Encart 18-11¬†: une expression <code>match</code> avec une branche
qui cr√©e une variable masqu√©e <code>y</code></span></p>
<!--
Let‚Äôs walk through what happens when the `match` expression runs. The pattern
in the first match arm doesn‚Äôt match the defined value of `x`, so the code
continues.
-->
<p>Voyons ce qui se passe lorsque l'expression <code>match</code> est utilis√©e. Le motif
pr√©sent dans la premi√®re branche du <code>match</code> ne correspond pas √† la valeur
actuelle de <code>x</code>, donc le code passe √† la branche suivante.</p>
<!--
The pattern in the second match arm introduces a new variable named `y` that
will match any value inside a `Some` value. Because we‚Äôre in a new scope inside
the `match` expression, this is a new `y` variable, not the `y` we declared at
the beginning with the value 10. This new `y` binding will match any value
inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to
the inner value of the `Some` in `x`. That value is `5`, so the expression for
that arm executes and prints `Matched, y = 5`.
-->
<p>Le motif dans la deuxi√®me branche du <code>match</code> ajoute une nouvelle variable <code>y</code>
qui va correspondre √† n'importe quelle valeur log√©e dans une valeur <code>Some</code>.
Comme nous sommes dans une nouvelle port√©e √† l'int√©rieur de l'expression
<code>match</code>, c'est une nouvelle variable <code>y</code>, et pas le <code>y</code> que nous avons
d√©clar√© au d√©but avec la valeur 10. Cette nouvelle correspondance <code>y</code> va
correspondre √† n'importe quelle valeur √† l'int√©rieur d'un <code>Some</code>, ce qui est
la situation pr√©sente actuellement dans <code>x</code>. Ainsi, ce nouveau <code>y</code> correspondra
√† la valeur interne du <code>Some</code> pr√©sent dans <code>x</code>. Cette valeur est <code>5</code>, donc
l'expression de cette branche s'ex√©cute et affiche <code>Correspondance, y = 5</code>.</p>
<!--
If `x` had been a `None` value instead of `Some(5)`, the patterns in the first
two arms wouldn‚Äôt have matched, so the value would have matched to the
underscore. We didn‚Äôt introduce the `x` variable in the pattern of the
underscore arm, so the `x` in the expression is still the outer `x` that hasn‚Äôt
been shadowed. In this hypothetical case, the `match` would print `Default
case, x = None`.
-->
<p>En supposant maintenant que <code>x</code> ait la valeur <code>None</code> plut√¥t que <code>Some(5)</code>, les
motifs pr√©sents dans les deux premi√®res branches ne correspondront pas, donc la
valeur qui correspondra sera celle avec le tiret du bas. Comme nous n'avons pas
introduit de nouvelle variable <code>x</code> dans la branche du motif, le <code>x</code> de
l'expression associ√©e d√©signe toujours la variable <code>x</code> en dehors et qui n'a pas
√©t√© masqu√©e. Le <code>match</code> va donc afficher <code>Cas par d√©faut, x = None</code>.</p>
<!--
When the `match` expression is done, its scope ends, and so does the scope of
the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.
-->
<p>Lorsque l'expression <code>match</code> est termin√©e, sa port√©e se termine √©galement, et
avec elle la port√©e de la variable interne <code>y</code>. Le dernier <code>println!</code> affiche
donc <code>A la fin¬†: x = Some(5), y = 10</code>.</p>
<!--
To create a `match` expression that compares the values of the outer `x` and
`y`, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We‚Äôll talk about match guards later in the [‚ÄúExtra
Conditionals with Match Guards‚Äù](#extra-conditionals-with-match-guards)<!--
ignore -- > section.
-->
<p>Pour cr√©er une expression <code>match</code> qui compare les valeurs de la variable
externe <code>x</code> avec <code>y</code>, plut√¥t que d'utiliser une variable masqu√©e, nous aurions
besoin d'utiliser √† la place un contr√¥le de correspondance. Nous verrons les
contr√¥les de correspondance dans une des sections suivantes.</p>
<!--
### Multiple Patterns
-->
<h3 id="plusieurs-motifs"><a class="header" href="#plusieurs-motifs">Plusieurs motifs</a></h3>
<!--
In `match` expressions, you can match multiple patterns using the `|` syntax,
which means *or*. For example, the following code matches the value of `x`
against the match arms, the first of which has an *or* option, meaning if the
value of `x` matches either of the values in that arm, that arm‚Äôs code will
run:
-->
<p>Dans les expressions <code>match</code>, vous pouvez faire correspondre une m√™me branche √†
plusieurs motifs en utilisant la syntaxe <code>|</code>, qui signifie <em>ou</em>. Par exemple,
dans le code suivant appliquant un <code>match</code> sur la valeur de <code>x</code>, la premi√®re
des branches poss√®de une option <em>ou</em>, ce qui signifie que si la valeur de <code>x</code>
correspond √† l'un ou l'autre des motifs de cette branche, le code associ√© sera
ex√©cut√©¬†:</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;un ou deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one or two`.
-->
<p>Ce code va afficher <code>un ou deux</code>.</p>
<!--
### Matching Ranges of Values with `..=`
-->
<h3 id="faire-correspondre-un-intervalle-de-valeurs-avec-"><a class="header" href="#faire-correspondre-un-intervalle-de-valeurs-avec-">Faire correspondre un intervalle de valeurs avec <code>..=</code></a></h3>
<!--
The `..=` syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:
-->
<p>La syntaxe <code>..=</code> nous permet de faire correspondre un intervalle inclusif de
valeurs. Dans le code suivant, lorsqu'un motif correspond √† une des valeurs
pr√©sentes dans l'intervalle, cette branche va s'ex√©cuter¬†:</p>
<!--
```rust
# fn main() {
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;de un √† cinq&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the `|` operator to express the same idea; instead of
`1..=5`, we would have to specify `1 | 2 | 3 | 4 | 5` if we used `|`.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!
-->
<p>Si <code>x</code> vaut 1, 2, 3, 4 ou 5, la premi√®re branche va correspondre. Cette syntaxe
est plus pratique √† utiliser que d'avoir √† utiliser l'op√©rateur <code>|</code> pour
exprimer la m√™me id√©e¬†; √† la place de <code>1..=5</code> nous aurions d√ª √©crire
<code>1 | 2 | 3 | 4 | 5</code> si nous avions utilis√© <code>|</code>. Renseigner un intervalle est
bien plus court, en particulier si nous souhaitons avoir une correspondance
avec les valeurs comprises entre 1 et 1000 par exemple¬†!</p>
<!--
Ranges are only allowed with numeric values or `char` values, because the
compiler checks that the range isn‚Äôt empty at compile time. The only types for
which Rust can tell if a range is empty or not are `char` and numeric values.
-->
<p>Les intervalles peuvent √™tre des nombres ou des <code>char</code> (caract√®res), car le
compilateur v√©rifie que l'intervalle n'est pas vide au moment de la
compilation et les seuls types pour lesquels Rust peut dire si un intervalle est
vide ou non sont ceux constitu√©s de nombres ou de <code>char</code>.</p>
<!--
Here is an example using ranges of `char` values:
-->
<p>Voici un exemple d'utilisation d'intervalles de <code>char</code>¬†:</p>
<!--
```rust
# fn main() {
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;lettre ASCII du d√©but&quot;),
        'k'..='z' =&gt; println!(&quot;lettre ASCII de la fin&quot;),
        _ =&gt; println!(&quot;autre chose&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Rust can tell that `c` is within the first pattern‚Äôs range and prints `early
ASCII letter`.
-->
<p>Rust peut nous dire que <code>c</code> est dans le premier intervalle du premier motif et
afficher <code>lettre ASCII du d√©but</code>.</p>
<!--
### Destructuring to Break Apart Values
-->
<h3 id="destructurer-pour-s√©parer-les-valeurs"><a class="header" href="#destructurer-pour-s√©parer-les-valeurs">Destructurer pour s√©parer les valeurs</a></h3>
<!--
We can also use patterns to destructure structs, enums, and tuples to use
different parts of these values. Let‚Äôs walk through each value.
-->
<p>Nous pouvons aussi utiliser les motifs pour destructurer les structures, les
√©num√©rations, et les tuples pour utiliser diff√©rentes parties de ces valeurs.
Passons en revue chacun des cas.</p>
<!--
#### Destructuring Structs
-->
<h4 id="destructurer-les-structures"><a class="header" href="#destructurer-les-structures">Destructurer les structures</a></h4>
<!--
Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can
break apart using a pattern with a `let` statement.
-->
<p>L'encart 18-12 montre une structure <code>Point</code> avec deux champs, <code>x</code> et <code>y</code>, que
nous pouvons s√©parer en utilisant un motif avec une instruction <code>let</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-12: Destructuring a struct‚Äôs fields into
separate variables</span>
-->
<p><span class="caption">Encart 18-12¬†: d√©structuration des champs d'une structure
dans des variables s√©par√©es</span></p>
<!--
This code creates the variables `a` and `b` that match the values of the `x`
and `y` fields of the `p` struct. This example shows that the names of the
variables in the pattern don‚Äôt have to match the field names of the struct. But
it‚Äôs common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.
-->
<p>Ce code cr√©e les variables <code>a</code> et <code>b</code> qui correspondent aux valeurs des champs
<code>x</code> et <code>y</code> de la structure <code>p</code>. Cet exemple montre que les noms des variables
du motif n'ont pas √† correspondre aux noms des champs de la structure. Mais il
est courant de vouloir faire correspondre le nom des variables avec le nom des
champs pour se rappeler plus facilement quelle variable provient de quel champ.</p>
<!--
Because having variable names match the fields is common and because writing
`let Point { x: x, y: y } = p;` contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the `let` pattern are `x` and
`y` instead of `a` and `b`.
-->
<p>Comme faire correspondre les noms des variables avec ceux des champs est une
pratique courante et qu'√©crire <code>let Point { x: x, y: y } = p;</code> est inutilement
redondant, il existe un raccourci pour les motifs qui correspondent aux champs
des structures¬†: il vous suffit de lister simplement le nom des champs de la
structure pour que les variables cr√©√©es √† partir du motif aient les m√™mes noms.
L'encart 18-12 montre du code qui se comporte de la m√™me mani√®re que le code de
l'encart 18-12, mais dans lequel les variables cr√©√©es dans le motif du <code>let</code>
sont <code>x</code> et <code>y</code> au lieu de <code>a</code> et <code>b</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span>
-->
<p><span class="caption">Encart 18-13¬†: d√©structuration des champs d'une structure
en utilisant le raccourci pour les champs des structures</span></p>
<!--
This code creates the variables `x` and `y` that match the `x` and `y` fields
of the `p` variable. The outcome is that the variables `x` and `y` contain the
values from the `p` struct.
-->
<p>Ce code cr√©e les variables <code>x</code> et <code>y</code> qui correspondent aux champs <code>x</code> et <code>y</code>
de la variable <code>p</code>. Il en r√©sulte que les variables <code>x</code> et <code>y</code> contiennent les
valeurs correspondantes de la structure <code>p</code>.</p>
<!--
We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.
-->
<p>Nous pouvons aussi destructurer en utilisant des valeurs litt√©rales faisant partie
du motif de la structure plut√¥t que d'avoir √† cr√©er les variables pour tous les
champs. Ceci nous permet de tester que certains champs poss√®dent des valeurs
particuli√®res tout en cr√©ant des variables pour destructurer les autres champs.</p>
<!--
Listing 18-14 shows a `match` expression that separates `Point` values into
three cases: points that lie directly on the `x` axis (which is true when `y =
0`), on the `y` axis (`x = 0`), or neither.
-->
<p>L'encart 18-14 montre une expression <code>match</code> qui s√©pare les valeurs <code>Point</code>
en trois cat√©gories¬†: les points qui sont sur l'axe <code>x</code> (ce qui est
vrai lorsque <code>y = 0</code>), ceux sur l'axe <code>y</code> (<code>x = 0</code>) et ceux qui ne sont sur aucun
de ces deux axes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;Sur l'axe x √† la position {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;Sur l'axe y √† la position {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Sur aucun des axes¬†: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span>
-->
<p><span class="caption">Encart 18-14¬†: d√©structurer et faire correspondre des
valeurs litt√©rales gr√¢ce √† un seul motif</span></p>
<!--
The first arm will match any point that lies on the `x` axis by specifying that
the `y` field matches if its value matches the literal `0`. The pattern still
creates an `x` variable that we can use in the code for this arm.
-->
<p>La premi√®re branche va correspondre avec tous les points qui se trouvent sur
l'axe <code>x</code> en pr√©cisant que le champ <code>y</code> correspond au litt√©ral <code>0</code>. Le motif va
syst√©matiquement cr√©er une variable <code>x</code> que nous pourrons utiliser dans le code
de cette branche.</p>
<!--
Similarly, the second arm matches any point on the `y` axis by specifying that
the `x` field matches if its value is `0` and creates a variable `y` for the
value of the `y` field. The third arm doesn‚Äôt specify any literals, so it
matches any other `Point` and creates variables for both the `x` and `y` fields.
-->
<p>De la m√™me mani√®re, la deuxi√®me branche correspondra avec tous les points sur
l'axe <code>y</code> en pr√©cisant que le champ <code>x</code> correspondra uniquement si sa valeur
est <code>0</code> et cr√©era une variable <code>y</code> pour la valeur du champ <code>y</code>. La troisi√®me
branche n'a pas besoin d'un litt√©ral en particulier, donc elle correspondra √†
n'importe quel autre <code>Point</code> et cr√©era les variables pour les champs <code>x</code> et
<code>y</code>.</p>
<!--
In this example, the value `p` matches the second arm by virtue of `x`
containing a 0, so this code will print `On the y axis at 7`.
-->
<p>Dans cet exemple, la valeur <code>p</code> correspond avec la deuxi√®me branche car son <code>x</code>
vaut <code>0</code>, donc ce code va afficher <code>Sur l'axe y √† la position 7</code>.</p>
<!--
#### Destructuring Enums
-->
<h4 id="destructurer-une-√©num√©ration"><a class="header" href="#destructurer-une-√©num√©ration">Destructurer une √©num√©ration</a></h4>
<!--
We‚Äôve destructured enums earlier in this book, for example, when we
destructured `Option<i32>` in Listing 6-5 in Chapter 6. One detail we haven‚Äôt
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write
a `match` with patterns that will destructure each inner value.
-->
<p>Nous avons d√©j√† destructur√© des √©num√©rations pr√©c√©demment dans ce livre, par exemple
lorsque nous avions destructur√© <code>Option&lt;i32&gt;</code> dans l'encart 6-5 du chapitre 6.
Un d√©tail que nous n'avions pas pr√©cis√© explicitement √©tait que le motif pour
destructurer une √©num√©ration doit correspondre √† la fa√ßon dont sont d√©finies les
donn√©es dans l'√©num√©ration. Par exemple, dans l'encart 18-15 nous utilisons
l'√©num√©ration <code>Message</code> de l'encart 6-2 et nous ajoutons un <code>match</code> avec des
motifs qui devraient destructurer chaque valeur interne.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x, y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangerCouleur(0, 160, 255);

    match msg {
        Message::Quitter =&gt; {
            println!(&quot;La variante Quitter n'a pas de donn√©es √† d√©structurer.&quot;)
        }
        Message::Deplacer { x, y } =&gt; {
            println!(
                &quot;D√©placement de {} sur l'axe x et de {} sur l'axe y&quot;,
                x, y
            );
        }
        Message::Ecrire(text) =&gt; println!(&quot;Message textuel¬†: {}&quot;, text),
        Message::ChangerCouleur(r, g, b) =&gt; println!(
            &quot;Changement des taux de rouge √† {}, de vert √† {} et de bleu √† {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span>
-->
<p><span class="caption">Encart 18-15¬†: d√©structuration des variantes d'une
√©num√©ration qui stocke diff√©rents types de valeurs</span></p>
<!--
This code will print `Change the color to red 0, green 160, and blue 255`. Try
changing the value of `msg` to see the code from the other arms run.
-->
<p>Ce code va afficher
<code>Changement des taux de rouge √† 0, de vert √† 160 et de bleu √† 255</code>. Essayez de
changer la valeur de <code>message</code> pour voir le code qu'ex√©cute les autres
branches.</p>
<!--
For enum variants without any data, like `Message::Quit`, we can‚Äôt destructure
the value any further. We can only match on the literal `Message::Quit` value,
and no variables are in that pattern.
-->
<p>Pour les variantes d'√©num√©ration sans aucune donn√©e, telle que <code>Message::Quitter</code>,
nous ne pouvons pas destructurer de valeurs. Nous pouvons uniquement
correspondre √† la valeur litt√©rale <code>Message::Quitter</code> et il n'y a pas de
variable dans ce motif.</p>
<!--
For struct-like enum variants, such as `Message::Move`, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.
-->
<p>Pour les variantes d'√©num√©ration qui ressemblent aux structures, comme
<code>Message::Deplacer</code>, nous pouvons utiliser un motif similaire aux motifs que
nous utilisons pour correspondre aux structures. Apr√®s le nom de la variante,
nous utilisons des accolades puis nous listons les champs avec des
variables afin de diviser les √©l√©ments √† utiliser dans le code de cette
branche. Ici nous utilisons la forme raccourcie comme nous l'avons fait √†
l'encart 18-13.</p>
<!--
For tuple-like enum variants, like `Message::Write` that holds a tuple with one
element and `Message::ChangeColor` that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we‚Äôre
matching.
-->
<p>Pour les variantes d'√©num√©rations qui ressemblent √† des tuples, telles que
<code>Message::Ecrire</code> qui stocke un tuple avec un seul √©l√©ment, ou
<code>Message::ChangerCouleur</code> qui stocke un tuple avec trois √©l√©ments, le motif
est semblable √† celui que nous renseignons pour correspondre aux tuples. Le nombre
de variables dans le motif doit correspondre au nombre d'√©l√©ments dans la
variante qui correspond.</p>
<!--
#### Destructuring Nested Structs and Enums
-->
<h4 id="destructurer-des-structures-et-des-√©num√©rations-imbriqu√©es"><a class="header" href="#destructurer-des-structures-et-des-√©num√©rations-imbriqu√©es">Destructurer des structures et des √©num√©rations imbriqu√©es</a></h4>
<!--
Until now, all our examples have been matching structs or enums that were one
level deep. Matching can work on nested items too!
-->
<p>Jusqu'√† pr√©sent, tous nos exemples avaient des correspondances avec des structures
ou des √©num√©rations qui n'avaient qu'un seul niveau de profondeur. Les
correspondances fonctionnent aussi sur les √©l√©ments imbriqu√©s¬†!</p>
<!--
For example, we can refactor the code in Listing 18-15 to support RGB and HSV
colors in the `ChangeColor` message, as shown in Listing 18-16.
-->
<p>Par exemple, nous pouvons remanier le code de l'encart 18-15 pour pouvoir
utiliser des couleurs RVB et TSV dans le message <code>ChangerCouleur</code>, comme dans
l'encart 18-16.</p>
<!--
```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) => println!(
            "Change the color to hue {}, saturation {}, and value {}",
            h, s, v
        ),
        _ => (),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Couleur {
    Rvb(i32, i32, i32),
    Tsv(i32, i32, i32),
}

enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(Couleur),
}

fn main() {
    let msg = Message::ChangerCouleur(Couleur::Tsv(0, 160, 255));

    match msg {
        Message::ChangerCouleur(Couleur::Rvb(r, v, b)) =&gt; println!(
            &quot;Changement des taux de rouge √† {}, de vert √† {} et de bleu √† {}&quot;,
            r, v, b
        ),
        Message::ChangerCouleur(Couleur::Tsv(t, s, v)) =&gt; println!(
            &quot;Changement des taux de teinte √† {}, de saturation √† {} et de valeur √† {}&quot;,
            t, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-16: Matching on nested enums</span>
-->
<p><span class="caption">Encart 18-16¬†: correspondance avec des √©num√©rations
imbriqu√©es</span></p>
<!--
The pattern of the first arm in the `match` expression matches a
`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; then
the pattern binds to the three inner `i32` values. The pattern of the second
arm also matches a `Message::ChangeColor` enum variant, but the inner enum
matches the `Color::Hsv` variant instead. We can specify these complex
conditions in one `match` expression, even though two enums are involved.
-->
<p>Le motif de la premi√®re branche dans l'expression <code>match</code> correspond √† la
variante d'√©num√©ration <code>Message::ChangerCouleur</code> qui contient une variante
<code>Couleur::Rvb</code>¬†; ensuite le motif fait correspondre des variables aux trois
valeurs <code>i32</code> que cette derni√®re contient. Le motif de la seconde branche
correspond aussi √† une variante de l'√©num√©ration de <code>Message::ChangerCouleur</code>,
mais la valeur interne correspond plut√¥t √† la variante <code>Couleur::Tsv</code>. Nous
pouvons renseigner ces conditions complexes dans une seule expression <code>match</code>,
bien que deux √©num√©rations diff√©rentes soient impliqu√©es.</p>
<!--
#### Destructuring Structs and Tuples
-->
<h4 id="destructurer-des-structures-et-des-tuples"><a class="header" href="#destructurer-des-structures-et-des-tuples">Destructurer des structures et des tuples</a></h4>
<!--
We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:
-->
<p>Nous pouvons m√©langer les correspondances et les motifs pour d√©structurer des
√©l√©ments imbriqu√©s de mani√®re bien plus complexe. L'exemple suivant montre une
d√©structuration complexe dans laquelle nous imbriquons des structures et des
tuples √† l'int√©rieur d'un tuple et nous y destructurons toutes les valeurs
primitives¬†:</p>
<!--
```rust
# fn main() {
#     struct Point {
#         x: i32,
#         y: i32,
#     }
# 
    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((pieds, pouces), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<!--
This code lets us break complex types into their component parts so we can use
the values we‚Äôre interested in separately.
-->
<p>Ce code nous permet de d√©composer les parties qui composent des types complexes
pour pouvoir utiliser s√©par√©ment les valeurs qui nous int√©ressent.</p>
<!--
Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.
-->
<p>La d√©structuration avec les motifs est un moyen efficace d'utiliser des parties
de valeurs, comme par exemple la valeur de chaque champ d'une structure,
ind√©pendamment les unes des autres.</p>
<!--
### Ignoring Values in a Pattern
-->
<h3 id="ignorer-des-valeurs-dans-un-motif"><a class="header" href="#ignorer-des-valeurs-dans-un-motif">Ignorer des valeurs dans un motif</a></h3>
<!--
You‚Äôve seen that it‚Äôs sometimes useful to ignore values in a pattern, such as
in the last arm of a `match`, to get a catchall that doesn‚Äôt actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the `_`
pattern (which you‚Äôve seen), using the `_` pattern within another pattern,
using a name that starts with an underscore, or using `..` to ignore remaining
parts of a value. Let‚Äôs explore how and why to use each of these patterns.
-->
<p>Vous avez pu constater qu'il est parfois utile d'ignorer des valeurs dans un
motif, comme celle dans la derni√®re branche d'un <code>match</code>, pour obtenir un joker
qui ne fait rien mis √† part qu'il repr√©sente toutes les autres valeurs
possibles. Il existe plusieurs fa√ßons d'ignorer totalement ou en partie des
valeurs dans un motif¬†: en utilisant le motif <code>_</code> (que vous avez d√©j√† vu), le
motif <code>_</code> √† l'int√©rieur d'un autre motif, un nom qui commence avec un tiret
bas, ou enfin <code>..</code> pour ignorer les parties restantes d'une valeur. Voyons
comment et pourquoi utiliser ces diff√©rents motifs.</p>
<!--
#### Ignoring an Entire Value with `_`
-->
<h4 id="ignorer-compl√®tement-une-valeur-avec-_"><a class="header" href="#ignorer-compl√®tement-une-valeur-avec-_">Ignorer compl√®tement une valeur avec <code>_</code></a></h4>
<!--
We‚Äôve used the underscore (`_`) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore `_` pattern is especially
useful as the last arm in a `match` expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.
-->
<p>Nous avons utilis√© le tiret bas (<code>_</code>) comme un motif joker qui correspondra
avec n'importe quelle valeur mais ne l'assignera pas. Bien que le motif du
tiret bas <code>_</code> soit particuli√®rement utile dans la derni√®re branche d'une
expression <code>match</code>, nous pouvons aussi l'utiliser dans n'importe quel motif, y
compris dans les param√®tres de fonctions, comme montr√© dans l'encart 18-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(_: i32, y: i32) {
    println!(&quot;Ce code utilise uniquement le param√®tre y¬†: {}&quot;, y);
}

fn main() {
    fonction(3, 4);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-17: Using `_` in a function signature</span>
-->
<p><span class="caption">Encart 18-17¬†: utilisation d'un <code>_</code> dans la signature
d'une fonction</span></p>
<!--
This code will completely ignore the value passed as the first argument, `3`,
and will print `This code only uses the y parameter: 4`.
-->
<p>Ce code va compl√®tement ignorer la valeur envoy√©e en premier argument, <code>3</code>, et
va afficher <code>Ce code utilise uniquement le param√®tre y¬†: 4</code>.</p>
<!--
In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn‚Äôt include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesn‚Äôt need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.
-->
<p>Dans la plupart des cas lorsque vous n'avez pas besoin d'un param√®tre d'une
fonction, vous pouvez changer la signature pour qu'elle n'inclut pas le
param√®tre non utilis√©. Ignorer un param√®tre de fonction peut √™tre
particuli√®rement utile dans certains cas, comme par exemple, lors de
l'impl√©mentation d'un trait lorsque vous avez besoin d'un certain type de
signature mais que le corps de la fonction dans votre impl√©mentation n'a pas
besoin d'un des param√®tres. Le compilateur ne vous avertira plus que ces
param√®tres de fonction ne sont pas utilis√©s, ce qui serait le cas si vous
utilisiez un nom √† la place.</p>
<!--
#### Ignoring Parts of a Value with a Nested `_`
-->
<h4 id="ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriqu√©"><a class="header" href="#ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriqu√©">Ignorer des parties d'une valeur en utilisant un <code>_</code> imbriqu√©</a></h4>
<!--
We can also use `_` inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting‚Äôs value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.
-->
<p>Nous pouvons aussi utiliser <code>_</code> au sein d'un autre motif pour ignorer
uniquement une partie d'une valeur, par exemple, si nous ne souhaitons tester
qu'une seule partie d'une valeur mais que nous n'utilisons pas les autres
parties dans le code que nous souhaitons ex√©cuter. L'encart 18-18 montre du
code qui s'occupe de g√©rer la valeur d'un r√©glage. Les r√®gles m√©tier sont que
l'utilisateur ne doit pas pouvoir modifier un r√©glage existant mais peut
annuler le r√©glage ou lui donner une valeur s'il n'en a pas encore.</p>
<!--
```rust
# fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut valeur_du_reglage = Some(5);
    let nouvelle_valeur_du_reglage = Some(10);

    match (valeur_du_reglage, nouvelle_valeur_du_reglage) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Vous ne pouvez pas √©craser une valeur d√©j√† existante&quot;);
        }
        _ =&gt; {
            valeur_du_reglage = nouvelle_valeur_du_reglage;
        }
    }

    println!(&quot;Le r√©glage vaut {:?}&quot;, valeur_du_reglage);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-18: Using an underscore within patterns that
match `Some` variants when we don‚Äôt need to use the value inside the
`Some`</span>
-->
<p><span class="caption">Encart 18-18¬†: utilisation d'un tiret bas dans des motifs
qui correspondent avec des variantes <code>Some</code> lorsque nous n'avons pas besoin
d'utiliser la valeur √† l'int√©rieur du <code>Some</code></span></p>
<!--
This code will print `Can't overwrite an existing customized value` and then
`setting is Some(5)`. In the first match arm, we don‚Äôt need to match on or use
the values inside either `Some` variant, but we do need to test for the case
when `setting_value` and `new_setting_value` are the `Some` variant. In that
case, we print why we‚Äôre not changing `setting_value`, and it doesn‚Äôt get
changed.
-->
<p>Ce code va afficher <code>Vous ne pouvez pas √©craser une valeur d√©j√† existante</code> et
ensuite <code>Le r√©glage vaut Some(5)</code>. Dans la premi√®re branche, nous n'avons pas
besoin de r√©cup√©rer ou d'utiliser les valeurs √† l'int√©rieur de chacune des
variantes <code>Some</code>, mais nous avons besoin de tester les situations
o√π <code>valeur_du_reglage</code> et <code>nouvelle_valeur_du_reglage</code> sont toutes deux des variantes
<code>Some</code>. Dans ce cas, nous √©crivons que nous n'allons pas changer
<code>valeur_du_reglage</code> et elle ne changera pas.</p>
<!--
In all other cases (if either `setting_value` or `new_setting_value` are
`None`) expressed by the `_` pattern in the second arm, we want to allow
`new_setting_value` to become `setting_value`.
-->
<p>Dans tous les autres cas (lorsque soit <code>valeur_du_reglage</code>, soit
<code>nouvelle_valeur_du_reglage</code> vaut <code>None</code>) qui correspondront avec le motif
<code>_</code> de la seconde branche, nous voulons permettre √† la valeur de
<code>nouvelle_valeur_du_reglage</code> de remplacer celle de <code>valeur_du_reglage</code>.</p>
<!--
We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.
-->
<p>Nous pouvons aussi utiliser les tirets bas √† plusieurs endroits dans un m√™me
motif pour ignorer des valeurs pr√©cises. L'encart 18-19 montre un exemple qui
ignore la deuxi√®me et la quatri√®me valeur dans un tuple de cinq √©l√©ments.</p>
<!--
```rust
# fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        }
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, _, troisieme, _, cinquieme) =&gt; {
            println!(&quot;Voici quelques nombres¬†: {}, {}, {}&quot;, premier, troisieme, cinquieme)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span>
-->
<p><span class="caption">Encart 18-19¬†: on ignore plusieurs √©l√©ments d'un tuple
</span></p>
<!--
This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be
ignored.
-->
<p>Ce code va afficher <code>Voici quelques nombres¬†: 2, 8, 32</code> tandis que les valeurs
4 et 16 sont ignor√©es.</p>
<!--
#### Ignoring an Unused Variable by Starting Its Name with `_`
-->
<h4 id="ignorer-une-variable-non-utilis√©e-en-pr√©fixant-son-nom-avec-un-_"><a class="header" href="#ignorer-une-variable-non-utilis√©e-en-pr√©fixant-son-nom-avec-un-_">Ignorer une variable non utilis√©e en pr√©fixant son nom avec un <code>_</code></a></h4>
<!--
If you create a variable but don‚Äôt use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes it‚Äôs useful to create a
variable you won‚Äôt use yet, such as when you‚Äôre prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we compile this code, we should
only get a warning about one of them.
-->
<p>Si vous cr√©ez une variable mais que vous ne l'utilisez nulle part, Rust va
lancer un avertissement car cela pourrait √™tre un bogue. Mais parfois il est
utile de cr√©er une variable que vous n'utilisez pas encore, ce qui peut arriver
lorsque vous cr√©ez un prototype ou un projet. Dans ce genre de situation,
vous pouvez demander √† Rust de ne pas vous avertir que la variable n'est pas utilis√©e
en pr√©fixant son nom avec un tiret bas. Dans l'encart 18-20, nous
cr√©ons deux variables non utilis√©es, mais lorsque nous compilerons ce code,
nous n'aurons d'avertissement que pour une seule d'entre elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span>
-->
<p><span class="caption">Encart 18-20¬†: pr√©fixer le nom d'une variable avec un
tiret bas pour √©viter d'avoir des avertissements signalant une variable non
utilis√©e</span></p>
<!--
Here we get a warning about not using the variable `y`, but we don‚Äôt get a
warning about not using the variable preceded by the underscore.
-->
<p>Ici nous avons un avertissement qui nous pr√©vient que nous n'utilisons pas la
variable <code>y</code>, mais nous n'avons pas d'avertissement concernant la variable dont
le nom est pr√©fix√© par un tiret bas.</p>
<!--
Note that there is a subtle difference between using only `_` and using a name
that starts with an underscore. The syntax `_x` still binds the value to the
variable, whereas `_` doesn‚Äôt bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.
-->
<p>Notez qu'il existe une diff√©rence subtile entre utiliser uniquement <code>_</code>
et pr√©fixer un nom avec un tiret bas. La syntaxe <code>_x</code> continue √† associer la
valeur √† une variable, alors que <code>_</code> ne le fait pas du tout. Pour montrer un
cas o√π cette diff√©rence est importante, l'encart 18-21 va nous donner une
erreur.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Salutations¬†!&quot;));

    if let Some(_s) = s {
        println!(&quot;j'ai trouv√© une chaine de caract√®res&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span>
-->
<p><span class="caption">Encart 18-21¬†: une variable non utilis√©e pr√©fix√©e par un
tiret bas continue √† assigner la valeur, ce qui pourrait entra√Æner une prise de
possession de la valeur</span></p>
<!--
We‚Äôll receive an error because the `s` value will still be moved into `_s`,
which prevents us from using `s` again. However, using the underscore by itself
doesn‚Äôt ever bind to the value. Listing 18-22 will compile without any errors
because `s` doesn‚Äôt get moved into `_`.
-->
<p>Nous allons obtenir une erreur car la valeur <code>s</code> est toujours d√©plac√©e dans
<code>_s</code>, ce qui nous emp√™che d'utiliser <code>s</code> ensuite. A l'inverse, l'utilisation du
tiret bas tout seul n'assigne jamais la valeur √† quelque chose. Par cons√©quent,
l'encart 18-22 va se compiler sans aucune erreur car <code>s</code> n'est pas d√©plac√© dans
<code>_</code>.</p>
<!--
```rust
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Salutations¬†!&quot;));

    if let Some(_) = s {
        println!(&quot;j'ai trouv√© une chaine de caract√®res&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-22: Using an underscore does not bind the
value</span>
-->
<p><span class="caption">Encart 18-22¬†: l'utilisation d'un tiret bas n'assigne pas
la valeur</span></p>
<!--
This code works just fine because we never bind `s` to anything; it isn‚Äôt moved.
-->
<p>Ce code fonctionne correctement car nous n'assignons jamais <code>s</code> √† quelque
chose¬†; elle n'est jamais d√©plac√©e.</p>
<!--
#### Ignoring Remaining Parts of a Value with `..`
-->
<h4 id="ignorer-les-√©l√©ments-restants-dune-valeur-avec-"><a class="header" href="#ignorer-les-√©l√©ments-restants-dune-valeur-avec-">Ignorer les √©l√©ments restants d'une valeur avec <code>..</code></a></h4>
<!--
With values that have many parts, we can use the `..` syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The `..` pattern ignores any parts of a value that we haven‚Äôt
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
`Point` struct that holds a coordinate in three-dimensional space. In the
`match` expression, we want to operate only on the `x` coordinate and ignore
the values in the `y` and `z` fields.
-->
<p>Avec les valeurs qui ont de nombreux √©l√©ments, nous pouvons utiliser la syntaxe
<code>..</code> pour n'utiliser que quelques √©l√©ments et ignorer les autres, ce qui
√©vite d'avoir √† faire une liste de tirets bas pour chacune des valeurs
ignor√©es. Le motif <code>..</code> ignore tous les √©l√©ments d'une valeur qui ne
correspondent pas explicitement au reste du motif. Dans l'encart 18-23, nous
avons une structure <code>Point</code> qui stocke des coordonn√©es dans un espace
tridimensionnel. Dans l'expression <code>match</code>, nous souhaitons utiliser uniquement
la coordonn√©e <code>x</code> et ignorer les valeurs des champs <code>y</code> et <code>z</code>.</p>
<!--
```rust
# fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origine = Point { x: 0, y: 0, z: 0 };

    match origine {
        Point { x, .. } =&gt; println!(&quot;x vaut {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-23: Ignoring all fields of a `Point` except
for `x` by using `..`</span>
-->
<p><span class="caption">Encart 18-23¬†: on ignore tous les champs d'un <code>Point</code> √†
l'exception de <code>x</code> en utilisant <code>..</code></span></p>
<!--
We list the `x` value and then just include the `..` pattern. This is quicker
than having to list `y: _` and `z: _`, particularly when we‚Äôre working with
structs that have lots of fields in situations where only one or two fields are
relevant.
-->
<p>Nous ajoutons la valeur <code>x</code> puis nous ins√©rons simplement le motif <code>..</code>. C'est
plus rapide que d'avoir √† ajouter <code>y: _</code> et <code>z: _</code>, en particulier lorsque
nous travaillons avec des structures qui ont beaucoup de champs alors qu'un
seul champ ou deux nous int√©ressent.</p>
<!--
The syntax `..` will expand to as many values as it needs to be. Listing 18-24
shows how to use `..` with a tuple.
-->
<p>La syntaxe <code>..</code> va s'√©tendre √† toutes les valeurs qu'elle devra couvrir.
L'encart 18-24 montre comment utiliser <code>..</code> avec un tuple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, .., dernier) =&gt; {
            println!(&quot;Voici quelques nombres¬†: {}, {}&quot;, premier, dernier);
        }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span>
-->
<p><span class="caption">Encart 18-24¬†: on correspond uniquement avec la premi√®re
et la derni√®re valeur d'un tuple en ignorant toutes les autres valeurs
</span></p>
<!--
In this code, the first and last value are matched with `first` and `last`. The
`..` will match and ignore everything in the middle.
-->
<p>Dans ce code, la premi√®re et la derni√®re valeur correspondent √† <code>premier</code> et
<code>dernier</code>. Le <code>..</code> va correspondre et ignorer tout ce qui se trouve entre les
deux.</p>
<!--
However, using `..` must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using `..` ambiguously, so it will not
compile.
-->
<p>Cependant, l'utilisation de <code>..</code> peut √™tre ambigu. S'il n'est pas possible de
d√©terminer clairement quelles valeurs doivent correspondre et quelles valeurs
doivent √™tre ignor√©es, Rust va nous retourner une erreur. L'encart 18-25 nous
montre un exemple d'utilisation ambigu de <code>..</code> qui, par cons√©quent, ne se
compilera pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (.., second, ..) =&gt; {
            println!(&quot;Voici quelques nombres¬†: {}&quot;, second)
        },
    }
}
</code></pre>
<!--
<span class="caption">Listing 18-25: An attempt to use `..` in an ambiguous
way</span>
-->
<p><span class="caption">Encart 18-25¬†: une tentative d'utilisation de <code>..</code> de
mani√®re ambig√ºe</span></p>
<!--
When we compile this example, we get this error:
-->
<p>Lorsque nous compilons cet exemple, nous obtenons l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 -- > src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<!--
It‚Äôs impossible for Rust to determine how many values in the tuple to ignore
before matching a value with `second` and then how many further values to
ignore thereafter. This code could mean that we want to ignore `2`, bind
`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore
`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth.
The variable name `second` doesn‚Äôt mean anything special to Rust, so we get a
compiler error because using `..` in two places like this is ambiguous.
-->
<p>Il est impossible pour Rust de d√©terminer combien de valeurs doivent √™tre ignor√©es
dans le tuple avant de faire correspondre une valeur avec <code>second</code> et ensuite
combien d'autres doivent √™tre ignor√©es apr√®s. Ce code pourrait signifier que nous
voulons ignorer <code>2</code>, faire correspondre <code>second</code> avec <code>4</code>, puis ignorer ensuite
<code>8</code>, <code>16</code> et <code>32</code>¬†; ou que nous souhaitons ignorer <code>2</code> et <code>4</code>, faire
correspondre <code>second</code> √† <code>8</code>, puis ignorer ensuite <code>16</code> et <code>32</code>¬†; et ainsi de
suite. Le nom de la variable <code>second</code> ne signifie pas grand-chose pour Rust,
donc nous obtenons une erreur de compilation √† cause de l'utilisation de <code>..</code>
√† deux endroits qui rendent la situation ambig√ºe.</p>
<!--
### Extra Conditionals with Match Guards
-->
<h3 id="plus-de-conditions-avec-les-contr√¥les-de-correspondance"><a class="header" href="#plus-de-conditions-avec-les-contr√¥les-de-correspondance">Plus de conditions avec les contr√¥les de correspondance</a></h3>
<!--
A *match guard* is an additional `if` condition specified after the pattern in
a `match` arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.
-->
<p>Un <em>contr√¥le de correspondance</em> est une condition <code>if</code> suppl√©mentaire
renseign√©e apr√®s le motif d'une branche d'un <code>match</code> qui doit elle aussi
correspondre en m√™me temps que le filtrage par motif, pour que cette branche
soit choisie. Les contr√¥les de correspondance sont utiles pour exprimer des
id√©es plus complexes que celles permises uniquement par les motifs.</p>
<!--
The condition can use variables created in the pattern. Listing 18-26 shows a
`match` where the first arm has the pattern `Some(x)` and also has a match
guard of `if x % 2 == 0` (which will be true if the number is even).
-->
<p>La condition peut utiliser des variables cr√©√©es dans le motif. L'encart 18-26
montre un <code>match</code> dans lequel la premi√®re branche a le motif <code>Some(x)</code> et
proc√®de aussi au contr√¥le de correspondance <code>if x &lt; % 2 == 0</code> (qui sera vrai si
le nombre est pair).</p>
<!--
```rust
# fn main() {
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 => println!("The number {} is even", x),
        Some(x) => println!("The number {} is odd", x),
        None => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombre = Some(4);

    match nombre {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;Le nombre {} est pair&quot;, x),
        Some(x) =&gt; println!(&quot;Le nombre {} est impair&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-26: Adding a match guard to a pattern</span>
-->
<p><span class="caption">Encart 18-26¬†: ajout d'un contr√¥le de correspondance √† un
motif</span></p>
<!--
This example will print `The number 4 is even`. When `num` is compared to the
pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then
the match guard checks whether the remainder of dividing `x` by 2 is equal to
0, and because it is, the first arm is selected.
-->
<p>Cet exemple va afficher <code>Le nombre 4 est pair</code>. Lorsque <code>nombre</code> est compar√© au
motif de la premi√®re branche, il va correspondre, car <code>Some(4)</code> correspond √†
<code>Some(x)</code>. Ensuite, le contr√¥le de correspondance v√©rifie si le reste de la
division de <code>x</code> par 2 vaut 0, et comme c'est le cas, la premi√®re branche est
choisie.</p>
<!--
If `num` had been `Some(5)` instead, the match guard in the first arm would
have been false because the remainder of 5 divided by 2 is 1, which is not
equal to 0. Rust would then go to the second arm, which would match because the
second arm doesn‚Äôt have a match guard and therefore matches any `Some` variant.
-->
<p>Si <code>nombre</code> avait √©t√© plut√¥t <code>Some(5)</code>, le contr√¥le de correspondance de la
premi√®re branche aurait √©t√© faux car le reste de la division de 5 par 2 est 1,
ce qui n'est pas √©gal √† 0. Rust serait donc all√© √† la deuxi√®me branche, qui
devrait √™tre choisie car cette deuxi√®me branche correspond √† n'importe quelle
variante <code>Some</code> et n'a pas de contr√¥le de correspondance.</p>
<!--
There is no way to express the `if x % 2 == 0` condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of
this additional expressiveness is that the compiler doesn't try to check for
exhaustiveness when match guard expressions are involved.
-->
<p>Comme il n'existe pas d'autre moyen d'exprimer la condition <code>if x % 2 == 0</code>
dans un motif, le contr√¥le de correspondance nous donne la possibilit√©
d'exprimer une telle logique. L'inconv√©nient de cette expressivit√© renforc√©e
est que le compilateur n'essaie pas de v√©rifier l'exhaustivit√© lorsqu'on
utilise les contr√¥les de correspondance.</p>
<!--
In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the `match` expression instead of using the variable outside the
`match`. That new variable meant we couldn‚Äôt test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.
-->
<p>Dans l'encart 18-11, nous avions mentionn√© le fait que nous pouvions utiliser
des contr√¥les de correspondance pour r√©soudre notre probl√®me de masquage dans
le motif. Souvenez-vous qu'une nouvelle variable avait √©t√© cr√©√©e √† l'int√©rieur
du motif dans l'expression <code>match</code> au lieu d'utiliser la variable situ√©e √†
l'ext√©rieur du <code>match</code>. Cette nouvelle variable implique que nous ne pouvons
pas comparer avec la variable qui se situe √† l'ext√©rieur. L'encart 18-27 nous
montre comment nous pouvons utiliser un contr√¥le de correspondance pour
r√©pondre √† ce besoin.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Nous obtenons 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Nous avons une correspondance, n = {}&quot;, n),
        _ =&gt; println!(&quot;Cas par d√©faut, x = {:?}&quot;, x),
    }

    println!(&quot;Au final¬†: x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span>
-->
<p><span class="caption">Encart 18-27¬†: utilisation d'un contr√¥le de
correspondance pour v√©rifier l'√©galit√© avec une variable externe au bloc</span></p>
<!--
This code will now print `Default case, x = Some(5)`. The pattern in the second
match arm doesn‚Äôt introduce a new variable `y` that would shadow the outer `y`,
meaning we can use the outer `y` in the match guard. Instead of specifying the
pattern as `Some(y)`, which would have shadowed the outer `y`, we specify
`Some(n)`. This creates a new variable `n` that doesn‚Äôt shadow anything because
there is no `n` variable outside the `match`.
-->
<p>Ce code va maintenant afficher <code>Cas par d√©faut, x = Some(5)</code>. Le motif de la
deuxi√®me branche du <code>match</code> ne cr√©e pas de nouvelle variable <code>y</code> qui masquerait
le <code>y</code> externe, ce qui signifie que nous pouvons utiliser le <code>y</code> externe dans
le contr√¥le de correspondance. Au lieu de renseigner le motif comme √©tant
<code>Some(y)</code>, ce qui aurait masqu√© le <code>y</code> externe, nous renseignons <code>Some(n)</code>.
Cela va cr√©er une nouvelle variable <code>n</code> qui ne masque rien car il n'y a pas de
variable <code>n</code> √† l'ext√©rieur du <code>match</code>.</p>
<!--
The match guard `if n == y` is not a pattern and therefore doesn‚Äôt introduce
new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and
we can look for a value that has the same value as the outer `y` by comparing
`n` to `y`.
-->
<p>Le contr√¥le de correspondance <code>if n == y</code> n'est pas un motif et donc il
n'introduit pas de nouvelle variable. Ce <code>y</code> <em>est</em> la variable externe <code>y</code> au
lieu d'√™tre une nouvelle variable masqu√©e <code>y</code>, et nous pouvons comparer une
valeur qui a la m√™me valeur que le <code>y</code> externe en comparant <code>n</code> √† <code>y</code>.</p>
<!--
You can also use the *or* operator `|` in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence of combining a match guard with a pattern that uses
`|`. The important part of this example is that the `if y` match guard applies
to `4`, `5`, *and* `6`, even though it might look like `if y` only applies to
`6`.
-->
<p>Vous pouvez aussi utiliser l'op√©rateur <em>ou</em> <code>|</code> dans un contr√¥le de
correspondance pour y renseigner plusieurs motifs¬†; la condition du contr√¥le de
correspondance s'effectuera alors sur tous les motifs. L'encart 18-28 montre la
priorit√© de combinaison d'un contr√¥le de correspondance sur un motif qui
utilise <code>|</code>. La partie importante de cet exemple est que le contr√¥le de
correspondance <code>if y</code> s'applique sur <code>4</code>, <code>5</code> <em>et</em> <code>6</code>, m√™me si <code>if y</code> semble
s'appliquer uniquement √† <code>6</code>.</p>
<!--
```rust
# fn main() {
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span>
-->
<p><span class="caption">Encart 18-28¬†: combinaison de plusieurs motifs avec un
contr√¥le de correspondance</span></p>
<!--
The match condition states that the arm only matches if the value of `x` is
equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the
pattern of the first arm matches because `x` is `4`, but the match guard `if y`
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints `no`. The reason is that the `if`
condition applies to the whole pattern `4 | 5 | 6`, not only to the last value
`6`. In other words, the precedence of a match guard in relation to a pattern
behaves like this:
-->
<p>La condition de correspondance signifie que la branche correspond uniquement si
la valeur de <code>x</code> vaut <code>4</code>, <code>5</code> ou <code>6</code> <em>et</em> que <code>y</code> vaut <code>true</code>. Lorsque ce
code s'ex√©cute, le motif de la premi√®re branche correspond car <code>x</code> vaut 4, mais
le contr√¥le de correspondance <code>if y</code> est faux, donc ce programme affiche <code>no</code>.
La raison est que la condition <code>if</code> s'applique √† tout le motif <code>4 | 5 | 6</code> et
pas seulement √† la derni√®re valeur <code>6</code>. Autrement dit, la priorit√© d'un
contr√¥le de correspondance avec un motif se comporte comme ceci¬†:</p>
<!--
```text
(4 | 5 | 6) if y => ...
```
-->
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<!--
rather than this:
-->
<p>et pas comme ceci¬†:</p>
<!--
```text
4 | 5 | (6 if y) => ...
```
-->
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<!--
After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
`|` operator, the arm would have matched and the program would have printed
`yes`.
-->
<p>Apr√®s avoir ex√©cut√© le code, le fonctionnement des priorit√©s devient √©vident¬†:
si le contr√¥le de correspondance √©tait seulement appliqu√© √† la derni√®re valeur
renseign√©e avec l'op√©rateur <code>|</code>, la branche correspondrait et le programme
aurait affich√© <code>yes</code>.</p>
<!--
### `@` Bindings
-->
<h3 id="capturer-des-valeurs-avec-"><a class="header" href="#capturer-des-valeurs-avec-">Capturer des valeurs avec <code>@</code></a></h3>
<!--
The *at* operator (`@`) lets us create a variable that holds a value at the
same time we‚Äôre testing that value to see whether it matches a pattern. Listing
18-29 shows an example where we want to test that a `Message::Hello` `id` field
is within the range `3..=7`. But we also want to bind the value to the variable
`id_variable` so we can use it in the code associated with the arm. We could
name this variable `id`, the same as the field, but for this example we‚Äôll use
a different name.
-->
<p>L'op√©rateur <code>@</code> nous permet de cr√©er une variable qui stocke une valeur en m√™me
temps que nous testons cette valeur pour v√©rifier si elle correspond √† un
motif. L'encart 18-29 montre un exemple dans lequel nous souhaitons tester
qu'un champ <code>id</code> d'un <code>Message::Hello</code> est dans un intervalle <code>3..=7</code>. Mais
nous voulons aussi associer la valeur √† la variable <code>id_variable</code> pour que nous
puissions l'utiliser dans le code associ√© √† la branche. Nous aurions pu nommer
cette variable avec le m√™me nom que le champ <code>id</code>, mais pour cet exemple nous
allons utiliser un nom diff√©rent.</p>
<!--
```rust
# fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Nous avons trouv√© un id dans l'intervalle¬†: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Nous avons trouv√© un id dans un autre intervalle&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Nous avons trouv√© un autre id¬†: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-29: Using `@` to bind to a value in a pattern
while also testing it</span>
-->
<p><span class="caption">Encart 18-29¬†: utilisation de <code>@</code> pour lier une valeur
d'un motif √† une variable pendant qu'on la teste</span></p>
<!--
This example will print `Found an id in range: 5`. By specifying `id_variable
@` before the range `3..=7`, we‚Äôre capturing whatever value matched the range
while also testing that the value matched the range pattern.
-->
<p>Cet exemple va afficher <code>Nous avons trouv√© un id dans l'intervalle¬†: 5</code>. En
renseignant <code>id_variable @</code> avant l'intervalle <code>3..=7</code>, nous capturons la
valeur qui correspond √† l'intervalle pendant que nous v√©rifions que la valeur
correspond au motif de l'intervalle.</p>
<!--
In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn‚Äôt have a variable that contains the actual value
of the `id` field. The `id` field‚Äôs value could have been 10, 11, or 12, but
the code that goes with that pattern doesn‚Äôt know which it is. The pattern code
isn‚Äôt able to use the value from the `id` field, because we haven‚Äôt saved the
`id` value in a variable.
-->
<p>Dans la deuxi√®me branche, o√π nous avons uniquement un intervalle renseign√© dans
le motif, le code associ√© √† la branche n'a pas besoin d'une variable qui
contienne la valeur actuelle du champ <code>id</code>. La valeur du champ <code>id</code> aurait pu
√™tre 10, 11 ou 12, mais le code associ√© √† ce motif ne la conna√Ætra pas. Le code
du motif n'est pas capable d'utiliser la valeur du champ <code>id</code>, car nous n'avons
pas enregistr√© <code>id</code> dans une variable.</p>
<!--
In the last arm, where we‚Äôve specified a variable without a range, we do have
the value available to use in the arm‚Äôs code in a variable named `id`. The
reason is that we‚Äôve used the struct field shorthand syntax. But we haven‚Äôt
applied any test to the value in the `id` field in this arm, as we did with the
first two arms: any value would match this pattern.
-->
<p>Dans la derni√®re branche, nous avons renseign√© une variable sans intervalle,
nous avons donc dans la variable <code>id</code> la valeur qui peut √™tre utilis√©e dans le
code de la branche. La raison √† cela est que nous avons utilis√© la syntaxe
raccourcie pour les champs des structures. Mais, dans cette branche, nous
n'avons pas appliqu√© de tests √† la valeur sur le champ <code>id</code>, comme nous
l'avions fait avec les deux premi√®res branches¬†: n'importe quelle valeur
correspondra √† ce motif.</p>
<!--
Using `@` lets us test a value and save it in a variable within one pattern.
-->
<p>L'utilisation de <code>@</code> nous permet de tester une valeur et de l'enregistrer dans
une variable au sein d'un seul et m√™me motif.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©"><a class="header" href="#r√©sum√©">R√©sum√©</a></h2>
<!--
Rust‚Äôs patterns are very useful in that they help distinguish between different
kinds of data. When used in `match` expressions, Rust ensures your patterns
cover every possible value, or your program won‚Äôt compile. Patterns in `let`
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.
-->
<p>Les motifs de Rust sont tr√®s utiles lorsque nous devons distinguer diff√©rents
types de donn√©es. Lorsque nous les avions utilis√©s dans les expressions
<code>match</code>, Rust s'est assur√© que vos motifs couvraient l'int√©gralit√© de toutes
valeurs possibles, et, dans le cas contraire, votre programme ne se compilait
pas. Les motifs dans les instructions <code>let</code> et les param√®tres de fonction
rendent ces constructions encore plus utiles, permettant de d√©structurer les
valeurs en parties plus petites tout en les assignant √† des variables. Nous
pouvons cr√©er des motifs tr√®s simples ou alors plus complexes pour r√©pondre √†
nos besoins.</p>
<!--
Next, for the penultimate chapter of the book, we‚Äôll look at some advanced
aspects of a variety of Rust‚Äôs features.
-->
<p>Dans le chapitre suivant, qui sera l'avant-dernier du livre, nous allons
d√©couvrir quelques aspects avanc√©s de l'√©ventail de fonctionnalit√©s de Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch19-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch19-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
