<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D√©finir une √©num√©ration - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html" class="active"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Defining an Enum
-->
<h2 id="d√©finir-une-√©num√©ration"><a class="header" href="#d√©finir-une-√©num√©ration">D√©finir une √©num√©ration</a></h2>
<!--
Enums are a way of defining custom data types in a different way than you do
with structs. Let‚Äôs look at a situation we might want to express in code and
see why enums are useful and more appropriate than structs in this case. Say we
need to work with IP addresses. Currently, two major standards are used for IP
addresses: version four and version six. Because these are the only
possibilities for an IP address that our program will come across, we can
*enumerate* all possible variants, which is where enumeration gets its name.
-->
<p>Les √©num√©rations permettent de d√©finir des types de donn√©es personnalis√©s de
mani√®re diff√©rente que vous l'avez fait avec les structures. Imaginons une
situation que nous voudrions exprimer avec du code et regardons pourquoi les
√©num√©rations sont utiles et plus appropri√©es que les structures dans ce cas.
Disons que nous avons besoin de travailler avec des adresses IP. Pour le
moment, il existe deux normes principales pour les adresses IP¬†: la version
quatre et la version six. Comme ce seront les seules possibilit√©s d'adresse IP
que notre programme va rencontrer, nous pouvons <em>√©num√©rer</em> toutes les variantes
possibles, d'o√π vient le nom de l'√©num√©ration.</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because an enum value can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>N'importe quelle adresse IP peut √™tre soit une adresse en version quatre, soit
en version six, mais pas les deux en m√™me temps. Cette propri√©t√© des adresses
IP est appropri√©e √† la structure de donn√©es d'√©num√©rations, car une valeur de
l'√©num√©ration ne peut √™tre qu'une de ses variantes. Les adresses en version
quatre et six sont toujours fondamentalement des adresses IP, donc elles
doivent √™tre trait√©es comme √©tant du m√™me type lorsque le code travaille avec
des situations qui s'appliquent √† n'importe quelle sorte d'adresse IP.</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are the
variants of the enum:
-->
<p>Nous pouvons exprimer ce concept dans le code en d√©finissant une √©num√©ration
<code>SorteAdresseIp</code> et en listant les diff√©rentes sortes possibles d'adresses IP
qu'elle peut avoir, <code>V4</code> et <code>V6</code>. Ce sont les variantes de l'√©num√©ration¬†:</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum SorteAdresseIp {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p><code>SorteAdresseIp</code> est maintenant un type de donn√©es personnalis√© que nous pouvons
utiliser n'importe o√π dans notre code.</p>
<!--
### Enum Values
-->
<h3 id="les-valeurs-d√©num√©rations"><a class="header" href="#les-valeurs-d√©num√©rations">Les valeurs d'√©num√©rations</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>Nous pouvons cr√©er des instances de chacune des deux variantes de
<code>SorteAdresseIp</code> de cette mani√®re¬†:</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let quatre = SorteAdresseIp::V4;
    let six = SorteAdresseIp::V6;
<span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. This is useful because now both values
`IpAddrKind::V4` and `IpAddrKind::V6` are of the same type: `IpAddrKind`. We
can then, for instance, define a function that takes any `IpAddrKind`:
-->
<p>Remarquez que les variantes de l'√©num√©ration sont dans un espace de nom qui se
situe avant leur nom, et nous utilisons un double deux-points pour les s√©parer
tous les deux. C'est utile car maintenant les deux valeurs <code>SorteAdresseIp::V4</code>
et <code>SorteAdresseIp::V6</code> sont du m√™me type¬†: <code>SorteAdresseIp</code>. Ensuite, nous
pouvons, par exemple, d√©finir une fonction qui accepte n'importe quelle
<code>SorteAdresseIp</code>¬†:</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn router(sorte_ip: SorteAdresseIp) { }
</code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>Et nous pouvons appeler cette fonction avec chacune des variantes¬†:</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span>    router(SorteAdresseIp::V4);
    router(SorteAdresseIp::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don‚Äôt have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might be tempted to tackle this problem with structs as shown in
Listing 6-1.
-->
<p>L'utilisation des √©num√©rations a encore plus d'avantages. En √©tudiant un peu
plus notre type d'adresse IP, nous constatons que pour le moment, nous ne
pouvons pas stocker <em>la donn√©e</em> de l'adresse IP¬†; nous savons seulement de
quelle sorte elle est. Avec ce que vous avez appris au chapitre 5, vous
pourriez √™tre tent√© de r√©soudre ce probl√®me avec des structures comme dans
l'encart 6-1.</p>
<!--
```rust
# fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SorteAdresseIp {
        V4,
        V6,
    }

    struct AdresseIp {
        sorte: SorteAdresseIp,
        adresse: String,
    }

    let local = AdresseIp {
        sorte: SorteAdresseIp::V4,
        adresse: String::from(&quot;127.0.0.1&quot;),
    };
    
    let rebouclage = AdresseIp {
        sorte: SorteAdresseIp::V6,
        adresse: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">Encart 6-1¬†: Stockage de la donn√©e et de la variante de
<code>SorteAdresseIp</code> d'une adresse IP en utilisant une <code>struct</code></span></p>
<!--
Here, we‚Äôve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first is `home`,
and it has the value `IpAddrKind::V4` as its `kind` with associated address
data of `127.0.0.1`. The second instance is `loopback`. It has the other
variant of `IpAddrKind` as its `kind` value, `V6`, and has address `::1`
associated with it. We‚Äôve used a struct to bundle the `kind` and `address`
values together, so now the variant is associated with the value.
-->
<p>Ainsi, nous avons d√©fini une structure <code>AdresseIp</code> qui a deux champs¬†: un champ
<code>sorte</code> qui est du type <code>SorteAdresseIp</code> (l'√©num√©ration que nous avons d√©finie
pr√©c√©demment) et un champ <code>adresse</code> qui est du type <code>String</code>. Nous avons deux
instances de cette structure. La premi√®re est <code>local</code>, et a la valeur
<code>SorteAdresseIp::V4</code> pour son champ <code>sorte</code>, associ√© √† la donn√©e d'adresse qui
est <code>127.0.0.1</code>. La seconde instance est <code>rebouclage</code>. Elle a comme valeur de
champ <code>sorte</code> l'autre variante de <code>SorteAdresseIp</code>, <code>V6</code>, et a l'adresse<code>::1</code>
qui lui est associ√©e. Nous avons utilis√© une structure pour relier ensemble la
<code>sorte</code> et l'<code>adresse</code>, donc maintenant la variante est li√©e √† la valeur.</p>
<!--
However, representing the same concept using just an enum is more concise:
rather than an enum inside a struct, we can put data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>Cependant, suivre le m√™me principe en utilisant uniquement une √©num√©ration est
plus concis¬†: plut√¥t que d'utiliser une √©num√©ration dans une structure, nous
pouvons ins√©rer directement la donn√©e dans chaque variante de l'√©num√©ration.
Cette nouvelle d√©finition de l'√©num√©ration <code>AdresseIp</code> indique que chacune des
variantes <code>V4</code> et <code>V6</code> auront des valeurs associ√©es de type <code>String</code>¬†:</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(String),
        V6(String),
    }
    
    let local = AdresseIp::V4(String::from(&quot;127.0.0.1&quot;));
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct. Here it‚Äôs also easier to see another detail of how enums work:
the name of each enum variant that we define also becomes a function that
constructs an instance of the enum. That is, `IpAddr::V4()` is a function call
that takes a `String` argument and returns an instance of the `IpAddr` type. We
automatically get this constructor function defined as a result of defining the
enum.
-->
<p>Nous relions les donn√©es de chaque variante directement √† l'√©num√©ration, donc il
n'est pas n√©cessaire d'avoir une structure en plus. Ceci nous permet de voir
plus facilement un d√©tail de fonctionnement des √©num√©rations¬†: le nom de chaque
variante d'√©num√©ration que nous d√©finissons devient aussi une fonction qui
construit une instance de l'√©num√©ration. Ainsi, <code>AdresseIp::V4()</code> est un appel
de fonction qui prend une <code>String</code> en argument et qui retourne une instance du
type <code>AdresseIp</code>. Nous obtenons automatiquement cette fonction de constructeur
qui est d√©finie lorsque nous d√©finissons l'√©num√©ration.</p>
<!--
There‚Äôs another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldn‚Äôt be able to with
a struct. Enums handle this case with ease:
-->
<p>Il y a un autre avantage √† utiliser une √©num√©ration plut√¥t qu'une structure¬†:
chaque variante peut stocker des types diff√©rents, et aussi avoir une quantit√©
diff√©rente de donn√©es associ√©es. Les adresses IP version quatre vont toujours
avoir quatre composantes num√©riques qui auront une valeur entre 0 et 255. Si
nous voulions stocker les adresses <code>V4</code> avec quatre valeurs de type <code>u8</code> mais
continuer √† stocker les adresses <code>V6</code> dans une <code>String</code>, nous ne pourrions pas
le faire avec une structure. Les √©num√©rations permettent de faire cela
facilement¬†:</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    
    let local = AdresseIp::V4(127, 0, 0, 1);
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We‚Äôve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr]<!-- ignore -- > Let‚Äôs look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
we‚Äôve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>Nous avons vu diff√©rentes mani√®res de d√©finir des structures de donn√©es pour
enregistrer des adresses IP en version quatre et version six. Cependant, il
s'av√®re que vouloir stocker des adresses IP et identifier de quelle sorte elles
sont est si fr√©quent que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la biblioth√®que standard a une d√©finition que nous
pouvons utiliser¬†!</a><!-- ignore --> Analysons comment la biblioth√®que
standard a d√©fini <code>IpAddr</code> (l'√©quivalent de notre <code>AdresseIp</code>)¬†: nous retrouvons
la m√™me √©num√©ration et les variantes que nous avons d√©finies et utilis√©es, mais
stocke les donn√©es d'adresse dans des variantes dans deux structures
diff√©rentes, qui sont d√©finies chacune pour chaque variante¬†:</p>
<!--
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // -- code masqu√© ici --
}

struct Ipv6Addr {
    // -- code masqu√© ici --
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>Ce code montre comment vous pouvez ins√©rer n'importe quel type de donn√©es dans
une variante d'√©num√©ration¬†: des cha√Ænes de caract√®res, des nombres ou des
structures, par exemple. Vous pouvez m√™me y int√©grer d'autres √©num√©rations¬†! Par
ailleurs, les types de la biblioth√®que standard ne sont parfois pas plus
compliqu√©s que ce que vous pourriez inventer.</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
haven‚Äôt brought the standard library‚Äôs definition into our scope. We‚Äôll talk
more about bringing types into scope in Chapter 7.
-->
<p>Notez aussi que m√™me si la biblioth√®que standard embarque une d√©finition de
<code>IpAddr</code>, nous pouvons quand m√™me cr√©er et utiliser notre propre d√©finition de
ce type sans avoir de conflit de nom car nous n'avons pas import√© cette
d√©finition de la biblioth√®que standard dans la port√©e. Nous verrons plus en
d√©tail comment importer les types dans la port√©e au chapitre 7.</p>
<!--
Let‚Äôs look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>Analysons un autre exemple d'une √©num√©ration dans l'encart 6-2¬†: celle-ci a une
grande diversit√© de types dans ses variantes.</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">Encart 6-2¬†: Une √©num√©ration <code>Message</code> dont chaque
variante stocke des valeurs de diff√©rents types et en diff√©rentes
quantit√©s</span></p>
<!--
This enum has four variants with different types:
-->
<p>Cette √©num√©ration a quatre variantes avec des types diff√©rents¬†:</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` has named fields like a struct does.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quitter</code> n'a pas du tout de donn√©e associ√©e.</li>
<li><code>Deplacer</code> int√®gre une structure anonyme en son sein.</li>
<li><code>Ecrire</code> int√®gre une seule <code>String</code>.</li>
<li><code>ChangerCouleur</code> int√®gre trois valeurs de type <code>i32</code>.</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn‚Äôt use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>D√©finir une √©num√©ration avec des variantes comme celles dans l'encart 6-2
ressemble √† la d√©finition de diff√©rentes sortes de structures, sauf que
l'√©num√©ration n'utilise pas le mot-cl√© <code>struct</code> et que toutes les variantes sont
regroup√©es ensemble sous le type <code>Message</code>. Les structures suivantes peuvent
stocker les m√™mes donn√©es que celles stock√©es par les variantes pr√©c√©dentes¬†:</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MessageQuitter; // une structure unit√©
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldn‚Äôt as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<p>Mais si nous utilisions les diff√©rentes structures, qui ont chacune leur propre
type, nous ne pourrions pas d√©finir facilement une fonction qui prend en
param√®tre toutes les sortes de messages, tel que nous pourrions le faire avec
l'√©num√©ration <code>Message</code> que nous avons d√©finie dans l'encart 6-2, qui est un
seul type.</p>
<!--
There is one more similarity between enums and structs: just as we‚Äôre able to
define methods on structs using `impl`, we‚Äôre also able to define methods on
enums. Here‚Äôs a method named `call` that we could define on our `Message` enum:
-->
<p>Il y a un autre point commun entre les √©num√©rations et les structures¬†: tout
comme on peut d√©finir des m√©thodes sur les structures en utilisant <code>impl</code>, on
peut aussi d√©finir des m√©thodes sur des √©num√©rations. Voici une m√©thode appel√©e
<code>appeler</code> que nous pouvons d√©finir sur notre √©num√©ration <code>Message</code>¬†:</p>
<!--
```rust
# fn main() {
#     enum Message {
#         Quit,
#         Move { x: i32, y: i32 },
#         Write(String),
#         ChangeColor(i32, i32, i32),
#     }
# 
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quitter,
</span><span class="boring">        Deplacer { x: i32, y: i32 },
</span><span class="boring">        Ecrire(String),
</span><span class="boring">        ChangerCouleur(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn appeler(&amp;self) {
            // le corps de la m√©thode sera d√©fini ici
        }
    }
    
    let m = Message::Ecrire(String::from(&quot;hello&quot;));
    m.appeler();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, we‚Äôve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>Le corps de la m√©thode va utiliser <code>self</code> pour obtenir la valeur sur laquelle
nous avons utilis√© la m√©thode. Dans cet exemple, nous avons cr√©√© une variable
<code>m</code> qui a la valeur <code>Message::Ecrire(String::from(&quot;hello&quot;))</code>, et cela sera ce
que <code>self</code> aura comme valeur dans le corps de la m√©thode <code>appeler</code> quand nous
lancerons <code>m.appeler()</code>.</p>
<!--
Let‚Äôs look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>Regardons maintenant une autre √©num√©ration de la biblioth√®que standard qui est
tr√®s utilis√©e et utile¬†: <code>Option</code>.</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3 id="l√©num√©ration-option-et-ses-avantages-par-rapport-√†-la-valeur-null"><a class="header" href="#l√©num√©ration-option-et-ses-avantages-par-rapport-√†-la-valeur-null">L'√©num√©ration <code>Option</code> et ses avantages par rapport √† la valeur null</a></h3>
<!--
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type encodes the very common scenario in
which a value could be something or it could be nothing. For example, if you
request the first of a list containing items, you would get a value. If you
request the first item of an empty list, you would get nothing. Expressing this
concept in terms of the type system means the compiler can check whether you‚Äôve
handled all the cases you should be handling; this functionality can prevent
bugs that are extremely common in other programming languages.
-->
<p>Cette section √©tudie le cas de <code>Option</code>, qui est une autre √©num√©ration d√©finie
dans la biblioth√®que standard. Le type <code>Option</code> d√©crit un sc√©nario tr√®s courant
o√π une valeur peut √™tre soit quelque chose, soit rien du tout. Par exemple, si
vous demandez le premier √©l√©ment dans une liste non vide, vous devriez obtenir
une valeur. Si vous demandez le premier √©l√©ment d'une liste vide, vous ne
devriez rien obtenir. Exprimer ce concept avec le syst√®me de types implique que
le compilateur peut v√©rifier si vous avez g√©r√© tous les cas que vous pourriez
rencontrer¬†; cette fonctionnalit√© peut √©viter des bogues qui sont tr√®s courants
dans d'autres langages de programmation.</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn‚Äôt have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>La conception d'un langage de programmation est souvent pens√©e en fonction des
fonctionnalit√©s qu'on inclut, mais les fonctionnalit√©s qu'on refuse sont elles
aussi importantes. Rust n'a pas de fonctionnalit√© <em>null</em> qu'ont de nombreux
langages. <em>Null</em> est une valeur qui signifie qu'il n'y a pas de valeur √† cet
endroit. Avec les langages qui utilisent null, les variables peuvent toujours
√™tre dans deux √©tats¬†: null ou non null.</p>
<!--
In his 2009 presentation ‚ÄúNull References: The Billion Dollar Mistake,‚Äù Tony
Hoare, the inventor of null, has this to say:
-->
<p>Dans sa th√®se de 2009 ‚ÄúNull References: The Billion Dollar Mistake‚Äù (les
r√©f√©rences nulles¬†: l'erreur √† un milliard de dollars), Tony Hoare, l'inventeur
de null, a √©crit ceci¬†:</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldn‚Äôt resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>Je l'appelle mon erreur √† un milliard de dollars. √Ä cette √©poque, je concevais
le premier syst√®me de type complet pour des r√©f√©rences dans un langage orient√©
objet. Mon objectif √©tait de garantir que toutes les utilisations des
r√©f√©rences soient totalement s√ªres, et soient v√©rifi√©es automatiquement par le
compilateur. Mais je n'ai pas pu r√©sister √† la tentation d'inclure la
r√©f√©rence nulle, simplement parce que c'√©tait si simple √† impl√©menter. Cela a
conduit √† d'innombrables erreurs, vuln√©rabilit√©s, et pannes syst√®mes, qui ont
probablement caus√© un milliard de dollars de dommages au cours des quarante
derni√®res ann√©es.</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, you‚Äôll get an error of some kind. Because this null or not-null
property is pervasive, it‚Äôs extremely easy to make this kind of error.
-->
<p>Le probl√®me avec les valeurs nulles, c'est que si vous essayez d'utiliser une
valeur nulle comme si elle n'√©tait pas nulle, vous obtiendrez une erreur d'une
fa√ßon ou d'une autre. Comme cette propri√©t√© nulle ou non nulle est omnipr√©sente,
il est tr√®s facile de faire cette erreur.</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>Cependant, le concept que null essaye d'exprimer reste utile¬†: une valeur nulle
est une valeur qui est actuellement invalide ou absente pour une raison ou une
autre.</p>
<!--
The problem isn‚Äôt really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]<!-- ignore -- >
as follows:
-->
<p>Le probl√®me ne vient pas vraiment du concept, mais de son impl√©mentation. C'est
pourquoi Rust n'a pas de valeurs nulles, mais il a une √©num√©ration qui d√©crit le
concept d'une valeur qui peut √™tre soit pr√©sente, soit absente. Cette
√©num√©ration est <code>Option&lt;T&gt;</code>, et elle est <a href="https://doc.rust-lang.org/std/option/enum.Option.html">d√©finie dans la biblioth√®que
standard</a><!-- ignore --> comme ci-dessous¬†:</p>
<!--
```rust
enum Option<T> {
    None,
    Some(T),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that it‚Äôs even included in the prelude; you
don‚Äôt need to bring it into scope explicitly. Its variants are also included in
the prelude: you can use `Some` and `None` directly without the `Option::`
prefix. The `Option<T>` enum is still just a regular enum, and `Some(T)` and
`None` are still variants of type `Option<T>`.
-->
<p>L'√©num√©ration <code>Option&lt;T&gt;</code> est tellement utile qu'elle est int√©gr√©e dans l'√©tape
pr√©liminaire¬†; vous n'avez pas besoin de l'importer explicitement dans la
port√©e. Ses variantes sont aussi int√©gr√©es dans l'√©tape pr√©liminaire¬†: vous
pouvez utiliser directement <code>Some</code> (<em>quelque chose</em>) et <code>None</code> (<em>rien</em>) sans
les pr√©fixer par <code>Option::</code>. L'√©num√©ration <code>Option&lt;T&gt;</code> reste une √©num√©ration
normale, et <code>Some(T)</code> ainsi que <code>None</code> sont toujours des variantes de type
<code>Option&lt;T&gt;</code>.</p>
<!--
The `<T>` syntax is a feature of Rust we haven‚Äôt talked about yet. It‚Äôs a
generic type parameter, and we‚Äôll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type, and that each concrete
type that gets used in place of `T` makes the overall `Option<T>` type a
different type. Here are some examples of using `Option` values to hold number
types and string types:
-->
<p>La syntaxe <code>&lt;T&gt;</code> est une fonctionnalit√© de Rust que nous n'avons pas encore
abord√©e. Il s'agit d'un param√®tre de type g√©n√©rique, et nous verrons la
g√©n√©ricit√© plus en d√©tail au chapitre 10. Pour le moment, dites-vous que ce
<code>&lt;T&gt;</code> signifie que la variante <code>Some</code> de l'√©num√©ration <code>Option</code> peut stocker un
√©l√©ment de donn√©e de n'importe quel type, et que chaque type concret qui est
utilis√© √† la place du <code>T</code> transforme tout le type <code>Option&lt;T&gt;</code> en un type
diff√©rent. Voici quelques exemples d'utilisation de valeurs de <code>Option</code> pour
stocker des types de nombres et des types de cha√Ænes de caract√®res¬†:</p>
<!--
```rust
# fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let un_nombre = Some(5);
    let une_chaine = Some(&quot;une cha√Æne&quot;);

    let nombre_absent: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `some_number` is `Option<i32>`. The type of `some_string` is
`Option<&str>`, which is a different type. Rust can infer these types because
we‚Äôve specified a value inside the `Some` variant. For `absent_number`, Rust
requires us to annotate the overall `Option` type: the compiler can‚Äôt infer the
type that the corresponding `Some` variant will hold by looking only at a
`None` value. Here, we tell Rust that we mean for `absent_number` to be of type
`Option<i32>`.
-->
<p>La variable <code>un_nombre</code> est du type <code>Option&lt;i32&gt;</code>. Mais la variable <code>une_chaine</code>
est du type <code>Option&lt;&amp;str&gt;</code>, qui est un tout autre type. Rust peut d√©duire ces
types car nous avons renseign√© une valeur dans la variante <code>Some</code>. Pour
<code>nombre_absent</code>, Rust n√©cessite que nous annotions le type de tout le <code>Option</code>¬†:
le compilateur ne peut pas d√©duire le type qui devrait √™tre stock√© dans la
variante <code>Some</code> √† partir de la valeur <code>None</code>. Ici, nous avons renseign√© √† Rust
que nous voulions que <code>nombre_absent</code> soit du type <code>Option&lt;i32&gt;</code>.</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we don‚Äôt have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p>Lorsque nous avons une valeur <code>Some</code>, nous savons que la valeur est pr√©sente et
que la valeur est stock√©e dans le <code>Some</code>. Lorsque nous avons une valeur <code>None</code>,
en quelque sorte, cela veut dire la m√™me chose que null¬†: nous n'avons pas une
valeur valide. Donc pourquoi obtenir <code>Option&lt;T&gt;</code> est meilleur que d'avoir null¬†?</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler won‚Äôt let us use an `Option<T>` value as if it were
definitely a valid value. For example, this code won‚Äôt compile because it‚Äôs
trying to add an `i8` to an `Option<i8>`:
-->
<p>En bref, comme <code>Option&lt;T&gt;</code> et <code>T</code> (o√π <code>T</code> repr√©sente n'importe quel type) sont
de types diff√©rents, le compilateur ne va pas nous autoriser √† utiliser une
valeur <code>Option&lt;T&gt;</code> comme si cela √©tait bien une valeur valide. Par exemple, le
code suivant ne se compile pas car il essaye d'additionner un <code>i8</code> et une
<code>Option&lt;i8&gt;</code>¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let somme = x + y;
<span class="boring">}
</span></code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>Si nous lan√ßons ce code, nous aurons un message d'erreur comme celui-ci¬†:</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 -- > src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let somme = x + y;
  |                   ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesn‚Äôt understand how
to add an `i8` and an `Option<i8>`, because they‚Äôre different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value we‚Äôre working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>Intense¬†! Effectivement, ce message d'erreur signifie que Rust ne comprend pas
comment additionner un <code>i8</code> et une <code>Option&lt;i8&gt;</code>, car ils sont de types
diff√©rents. Quand nous avons une valeur d'un type comme <code>i8</code> avec Rust, le
compilateur va s'assurer que nous avons toujours une valeur valide. Nous pouvons
continuer en toute confiance sans avoir √† v√©rifier que cette valeur n'est pas
nulle avant de l'utiliser. Ce n'est que lorsque nous avons une <code>Option&lt;i8&gt;</code> (ou
tout autre type de valeur avec lequel nous travaillons) que nous devons nous
inqui√©ter de ne pas avoir de valeur, et le compilateur va s'assurer que nous
g√©rons ce cas avant d'utiliser la valeur.</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn‚Äôt null when it actually
is.
-->
<p>Autrement dit, vous devez convertir une <code>Option&lt;T&gt;</code> en <code>T</code> pour pouvoir faire
avec elle des op√©rations du type <code>T</code>. G√©n√©ralement, cela permet de r√©soudre l'un
des probl√®mes les plus courants avec null¬†: supposer qu'une valeur n'est pas
nulle alors qu'en r√©alit√©, elle l'est.</p>
<!--
Eliminating the risk of incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn‚Äôt an
`Option<T>`, you *can* safely assume that the value isn‚Äôt null. This was a
deliberate design decision for Rust to limit null‚Äôs pervasiveness and increase
the safety of Rust code.
-->
<p>Eliminer le risque que des valeurs nulles puissent √™tre mal g√©r√©es vous aide √†
√™tre plus confiant en votre code. Pour avoir une valeur qui peut
potentiellement √™tre nulle, vous devez l'indiquer explicitement en d√©clarant
que le type de cette valeur est <code>Option&lt;T&gt;</code>. Ensuite, quand vous utiliserez
cette valeur, il vous faudra g√©rer explicitement le cas o√π cette valeur est
nulle. Si vous utilisez une valeur qui n'est pas une <code>Option&lt;T&gt;</code>, alors vous
<em>pouvez</em> consid√©rer que cette valeur ne sera jamais nulle sans prendre de
risques. Il s'agit d'un choix de conception d√©lib√©r√© de Rust pour limiter
l'omnipr√©sence de null et augmenter la s√©curit√© du code en Rust.</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]<!-- ignore -- >. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>Donc, comment r√©cup√©rer la valeur de type <code>T</code> d'une variante <code>Some</code> quand vous
avez une valeur de type <code>Option&lt;T&gt;</code> afin de l'utiliser¬†? L'√©num√©ration
<code>Option&lt;T&gt;</code> a un large choix de m√©thodes qui sont plus ou moins utiles selon les
cas¬†; vous pouvez les d√©couvrir dans <a href="https://doc.rust-lang.org/std/option/enum.Option.html">sa documentation</a><!-- ignore -->. Se
familiariser avec les m√©thodes de <code>Option&lt;T&gt;</code> peut √™tre tr√®s utile dans votre
aventure avec Rust.</p>
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. You want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. You want some
other code to run if you have a `None` value, and that code doesn‚Äôt have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>De mani√®re g√©n√©rale, pour pouvoir utiliser une valeur de <code>Option&lt;T&gt;</code>, votre code
doit g√©rer chaque variante. On veut que du code soit ex√©cut√© uniquement quand on
a une valeur <code>Some(T)</code>, et que ce code soit autoris√© √† utiliser la valeur de
type <code>T</code> √† l'int√©rieur. On veut aussi qu'un autre code soit ex√©cut√© si on a une
valeur <code>None</code>, et ce code n'aura pas de valeur de type <code>T</code> de disponible.
L'expression <code>match</code> est une structure de contr√¥le qui fait bien ceci
lorsqu'elle est utilis√©e avec les √©num√©rations¬†: elle va ex√©cuter du code
diff√©rent en fonction de quelle variante de l'√©num√©ration elle obtient, et ce
code pourra utiliser la donn√©e pr√©sente dans la valeur correspondante.</p>
<!--
[IpAddr]: ../std/net/enum.IpAddr.html
[option]: ../std/option/enum.Option.html
[docs]: ../std/option/enum.Option.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
