<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stocker du texte encod√© en UTF-8 avec les Strings - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html" class="active"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Storing UTF-8 Encoded Text with Strings
-->
<h2 id="stocker-du-texte-encod√©-en-utf-8-avec-les-strings"><a class="header" href="#stocker-du-texte-encod√©-en-utf-8-avec-les-strings">Stocker du texte encod√© en UTF-8 avec les Strings</a></h2>
<!--
We talked about strings in Chapter 4, but we‚Äôll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rust‚Äôs propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when you‚Äôre
coming from other programming languages.
-->
<p>Nous avons d√©j√† parl√© des cha√Ænes de caract√®res dans le chapitre 4, mais nous
allons √† pr√©sent les analyser plus en d√©tail. Les nouveaux Rustac√©s bloquent
souvent avec les cha√Ænes de caract√®res pour trois raisons¬†: la tendance de Rust
√† pr√©venir les erreurs, le fait que les cha√Ænes de caract√®res sont des
structures de donn√©es plus compliqu√©es que ne le pensent la plupart des
d√©veloppeurs, et l'UTF-8. Ces raisons cumul√©es rendent les choses compliqu√©es
lorsque vous venez d'un autre langage de programmation.</p>
<!--
We discuss strings in the context of collections because strings are
implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we‚Äôll
talk about the operations on `String` that every collection type has, such as
creating, updating, and reading. We‚Äôll also discuss the ways in which `String`
is different from the other collections, namely how indexing into a `String` is
complicated by the differences between how people and computers interpret
`String` data.
-->
<p>Nous avons pr√©sent√© les cha√Ænes de caract√®res comme des collections car les
cha√Ænes de caract√®res sont en r√©alit√© des suites d'octets, avec quelques
m√©thodes suppl√©mentaires qui sont utiles lorsque ces octets sont consid√©r√©s
comme du texte. Dans cette section, nous allons voir les points communs entre
le fonctionnement des <code>String</code> et celui des autres collections, comme la
cr√©ation, la modification et la lecture. Nous verrons les raisons pour
lesquelles les <code>String</code> sont diff√©rentes des autres collections, en particulier
pourquoi l'indexation d'une <code>String</code> est compliqu√©e √† cause des diff√©rences
entre la fa√ßon dont les gens et les ordinateurs interpr√®tent les donn√©es d'une
<code>String</code>.</p>
<!--
### What Is a String?
-->
<h3 id="quest-ce-quune-cha√Æne-de-caract√®res-"><a class="header" href="#quest-ce-quune-cha√Æne-de-caract√®res-">Qu'est-ce qu'une cha√Æne de caract√®res¬†?</a></h3>
<!--
We‚Äôll first define what we mean by the term *string*. Rust has only one string
type in the core language, which is the string slice `str` that is usually seen
in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the program‚Äôs binary and are therefore
string slices.
-->
<p>Nous allons d'abord d√©finir ce que nous entendons par le terme <em>cha√Æne de
caract√®res</em>. Rust a un seul type de cha√Ænes de caract√®res dans le noyau du
langage, qui est la slice de cha√Æne de caract√®res <code>str</code> qui est habituellement
utilis√©e sous sa forme emprunt√©e, <code>&amp;str</code>. Dans le chapitre 4, nous avons abord√©
les <em>slices de cha√Ænes de caract√®res</em>, qui sont des r√©f√©rences √† des donn√©es
d'une cha√Æne de caract√®res encod√©e en UTF-8 qui sont stock√©es autre part. Les
litt√©raux de cha√Ænes de caract√®res, par exemple, sont stock√©s dans le binaire du
programme et sont des slices de cha√Ænes de caract√®res.</p>
<!--
The `String` type, which is provided by Rust‚Äôs standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to ‚Äústrings‚Äù in Rust, they might be
referring to either the `String` or the string slice `&str` types, not just one
of those types. Although this section is largely about `String`, both types are
used heavily in Rust‚Äôs standard library, and both `String` and string slices
are UTF-8 encoded.
-->
<p>Le type <code>String</code>, qui est fourni par la biblioth√®que standard de Rust plut√¥t que
d'√™tre int√©gr√© au noyau du langage, est un type de cha√Æne de caract√®res encod√©
en UTF-8 qui peut s'agrandir, √™tre mutable, et √™tre poss√©d√©. Lorsque les
Rustac√©s parlent de ‚Äúcha√Ænes de caract√®res‚Äù en Rust, ils entendent soit le type
<code>String</code>, soit le type de slice de cha√Ænes de caract√®res <code>&amp;str</code>, et non pas un
seul de ces types. Bien que cette section traite essentiellement de <code>String</code>,
ces deux types sont utilis√©s massivement dans la biblioth√®que standard de Rust,
et tous les deux sont encod√©s en UTF-8.</p>
<!--
Rust‚Äôs standard library also includes a number of other string types, such as
`OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even
more options for storing string data. See how those names all end in `String`
or `Str`? They refer to owned and borrowed variants, just like the `String` and
`str` types you‚Äôve seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We won‚Äôt discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.
-->
<p>La biblioth√®que standard de Rust apporte aussi un certain nombre d'autres types
de cha√Ænes de caract√®res, comme <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, et <code>CStr</code>. Les
crates de biblioth√®que peuvent fournir encore plus de solutions pour stocker des
cha√Ænes de caract√®res. Avez-vous remarqu√© que ces noms finissent tous par
<code>String</code> ou <code>Str</code>¬†? Cela fait r√©f√©rence aux variantes poss√©d√©es et emprunt√©es,
comme les types <code>String</code> et <code>str</code> que nous avons vus pr√©c√©demment. Ces types de
cha√Ænes de caract√®res peuvent stocker leur texte dans de diff√©rents encodages,
ou le stocker en m√©moire de mani√®re diff√©rente, par exemple. Nous n'allons pas
traiter de ces autres types de cha√Ænes de caract√®res dans ce chapitre¬†;
r√©f√©rez-vous √† la documentation de leur API pour en savoir plus sur leur
utilisation et leur utilit√©.</p>
<!--
### Creating a New String
-->
<h3 id="cr√©er-une-nouvelle-string"><a class="header" href="#cr√©er-une-nouvelle-string">Cr√©er une nouvelle String</a></h3>
<!--
Many of the same operations available with `Vec<T>` are available with `String`
as well, starting with the `new` function to create a string, shown in Listing
8-11.
-->
<p>De nombreuses op√©rations disponibles avec <code>Vec&lt;T&gt;</code> sont aussi disponibles avec
<code>String</code>, en commen√ßant par la fonction <code>new</code> pour cr√©er une <code>String</code>, utilis√©e
dans l'encart 8-11.</p>
<!--
```rust
# fn main() {
    let mut s = String::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-11: Creating a new, empty `String`</span>
-->
<p><span class="caption">Encart 8-11¬†: Cr√©ation d'une nouvelle <code>String</code> vide</span></p>
<!--
This line creates a new empty string called `s`, which we can then load data
into. Often, we‚Äôll have some initial data that we want to start the string
with. For that, we use the `to_string` method, which is available on any type
that implements the `Display` trait, as string literals do. Listing 8-12 shows
two examples.
-->
<p>Cette ligne cr√©e une nouvelle <code>String</code> vide qui s'appelle <code>s</code>, dans laquelle
nous pouvons ensuite charger des donn√©es. Souvent, nous aurons quelques donn√©es
initiales que nous voudrions ajouter dans la <code>String</code>. Pour cela, nous utilisons
la m√©thode <code>to_string</code>, qui est disponible sur tous les types qui impl√©mentent
le trait <code>Display</code>, comme le font les litt√©raux de cha√Ænes de caract√®res.
L'encart 8-12 nous montre deux exemples.</p>
<!--
```rust
# fn main() {
    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let donnee = &quot;contenu initial&quot;;

    let s = donnee.to_string();

    // cette m√©thode fonctionne aussi directement sur un
    // litt√©ral de cha√Æne de caract√®res¬†:
    let s = &quot;contenu initial&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-12: Using the `to_string` method to create a
`String` from a string literal</span>
-->
<p><span class="caption">Encart 8-12¬†: Utilisation de la m√©thode <code>to_string</code> pour
cr√©er une <code>String</code> √† partir d'un litt√©ral de cha√Æne</span></p>
<!--
This code creates a string containing `initial contents`.
-->
<p>Ce code cr√©e une <code>String</code> qui contient <code>contenu initial</code>.</p>
<!--
We can also use the function `String::from` to create a `String` from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses `to_string`.
-->
<p>Nous pouvons aussi utiliser la fonction <code>String::from</code> pour cr√©er une <code>String</code>
√† partir d'un litt√©ral de cha√Æne. Le code dans l'encart 8-13 est √©quivalent au
code dans l'encart 8-12 qui utilisait <code>to_string</code>.</p>
<!--
```rust
# fn main() {
    let s = String::from("initial contents");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;contenu initial&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-13: Using the `String::from` function to create
a `String` from a string literal</span>
-->
<p><span class="caption">Encart 8-13¬†: Utilisation de la fonction <code>String::from</code>
afin de cr√©er une <code>String</code> √† partir d'un litt√©ral de cha√Æne</span></p>
<!--
Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, `String::from` and
`to_string` do the same thing, so which you choose is a matter of style and
readability.
-->
<p>Comme les cha√Ænes de caract√®res sont utilis√©es pour de nombreuses choses, nous
pouvons utiliser beaucoup d'API g√©n√©riques pour les cha√Ænes de caract√®res.
Certaines d'entre elles peuvent para√Ætre redondantes, mais elles ont toutes
leur place¬†! Dans notre cas, <code>String::from</code> et <code>to_string</code> font la m√™me chose,
donc votre choix est une question de go√ªt et de lisibilit√©.</p>
<!--
Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.
-->
<p>Souvenez-vous que les cha√Ænes de caract√®res sont encod√©es en UTF-8, donc nous
pouvons y int√©grer n'importe quelle donn√©e valide, comme nous le voyons dans
l'encart 8-14.</p>
<!--
```rust
# fn main() {
    let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
    let hello = String::from("Dobr√Ω den");
    let hello = String::from("Hello");
    let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
    let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
    let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
    let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
    let hello = String::from("‰Ω†Â•Ω");
    let hello = String::from("Ol√°");
    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let bonjour = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
    let bonjour = String::from(&quot;Dobr√Ω den&quot;);
    let bonjour = String::from(&quot;Hello&quot;);
    let bonjour = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
    let bonjour = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
    let bonjour = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
    let bonjour = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
    let bonjour = String::from(&quot;‰Ω†Â•Ω&quot;);
    let bonjour = String::from(&quot;Ol√°&quot;);
    let bonjour = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
    let bonjour = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span>
-->
<p><span class="caption">Encart 8-14¬†: Stockage de salutations dans diff√©rentes
langues dans des cha√Ænes de caract√®res</span></p>
<!--
All of these are valid `String` values.
-->
<p>Toutes ces cha√Ænes sont des valeurs <code>String</code> valides.</p>
<!--
### Updating a String
-->
<h3 id="modifier-une-string"><a class="header" href="#modifier-une-string">Modifier une <code>String</code></a></h3>
<!--
A `String` can grow in size and its contents can change, just like the contents
of a `Vec<T>`, if you push more data into it. In addition, you can conveniently
use the `+` operator or the `format!` macro to concatenate `String` values.
-->
<p>Une <code>String</code> peut s'agrandir et son contenu peut changer, exactement comme le
contenu d'un <code>Vec&lt;T&gt;</code>, si on y ajoute des donn√©es. De plus, vous pouvez ais√©ment
utiliser l'op√©rateur <code>+</code> ou la macro <code>format!</code> pour concat√©ner des valeurs
<code>String</code>.</p>
<!--
#### Appending to a String with `push_str` and `push`
-->
<h4 id="ajouter-du-texte-√†-une-cha√Æne-avec-push_str-et-push"><a class="header" href="#ajouter-du-texte-√†-une-cha√Æne-avec-push_str-et-push">Ajouter du texte √† une cha√Æne avec <code>push_str</code> et <code>push</code></a></h4>
<!--
We can grow a `String` by using the `push_str` method to append a string slice,
as shown in Listing 8-15.
-->
<p>Nous pouvons agrandir une <code>String</code> en utilisant la m√©thode <code>push_str</code> pour
ajouter une slice de cha√Æne de caract√®res, comme dans l'encart 8-15.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-15: Appending a string slice to a `String`
using the `push_str` method</span>
-->
<p><span class="caption">Encart 8-15¬†: Ajout d'une slice de cha√Æne de caract√®res
dans une <code>String</code> en utilisant la m√©thode <code>push_str</code></span></p>
<!--
After these two lines, `s` will contain `foobar`. The `push_str` method takes a
string slice because we don‚Äôt necessarily want to take ownership of the
parameter. For example, in the code in Listing 8-16, we want to able to use
`s2` after appending its contents to `s1`.
-->
<p>√Ä l'issue de ces deux lignes, <code>s</code> va contenir <code>foobar</code>. La m√©thode <code>push_str</code>
prend une slice de cha√Æne de caract√®res car nous ne souhaitons pas forc√©ment
prendre possession du param√®tre. Par exemple, dans le code de l'encart 8-16,
nous voulons pouvoir utiliser <code>s2</code> apr√®s avoir ajout√© son contenu dans <code>s1</code>.</p>
<!--
```rust
# fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 est {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-16: Using a string slice after appending its
contents to a `String`</span>
-->
<p><span class="caption">Encart 8-16¬†: Utilisation d'une slice de cha√Æne de
caract√®res apr√®s avoir ajout√© son contenu dans une <code>String</code></span></p>
<!--
If the `push_str` method took ownership of `s2`, we wouldn‚Äôt be able to print
its value on the last line. However, this code works as we‚Äôd expect!
-->
<p>Si la m√©thode <code>push_str</code> prenait possession de <code>s2</code>, √† la derni√®re ligne, nous
ne pourrions pas afficher sa valeur. Cependant, ce code fonctionne comme nous
l'esp√©rions¬†!</p>
<!--
The `push` method takes a single character as a parameter and adds it to the
`String`. Listing 8-17 adds the letter ‚Äúl‚Äù to a `String` using the `push`
method.
-->
<p>La m√©thode <code>push</code> prend un seul caract√®re en param√®tre et l'ajoute √† la
<code>String</code>. L'encart 8-17 ajoute la lettre ‚Äúl‚Äù √† une <code>String</code> en utilisant la
m√©thode <code>push</code>.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("lo");
    s.push('l');
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-17: Adding one character to a `String` value
using `push`</span>
-->
<p><span class="caption">Encart 8-17¬†: Ajout d'un unique caract√®re √† la valeur
d'une <code>String</code> en utilisant <code>push</code></span></p>
<!--
As a result, `s` will contain `lol`.
-->
<p>Apr√®s l'ex√©cution, <code>s</code> contiendra <code>lol</code>.</p>
<!--
#### Concatenation with the `+` Operator or the `format!` Macro
-->
<h4 id="concat√©nation-avec-lop√©rateur--ou-la-macro-format"><a class="header" href="#concat√©nation-avec-lop√©rateur--ou-la-macro-format">Concat√©nation avec l'op√©rateur <code>+</code> ou la macro <code>format!</code></a></h4>
<!--
Often, you‚Äôll want to combine two existing strings. One way to do so is to use
the `+` operator, as shown in Listing 8-18.
-->
<p>Souvent, vous aurez besoin de combiner deux cha√Ænes de caract√®res existantes.
Une fa√ßon de faire cela est d'utiliser l'op√©rateur <code>+</code>, comme dans l'encart
8-18.</p>
<!--
```rust
# fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // notez que s1 a √©t√© d√©plac√© ici
                       // et ne pourra plus √™tre utilis√©
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-18: Using the `+` operator to combine two
`String` values into a new `String` value</span>
-->
<p><span class="caption">Encart 8-18¬†: Utilisation de l'op√©rateur <code>+</code> pour combiner
deux valeurs de <code>String</code></span></p>
<!--
The string `s3` will contain `Hello, world!`. The reason `s1` is no longer
valid after the addition, and the reason we used a reference to `s2`, has to do
with the signature of the method that‚Äôs called when we use the `+` operator.
The `+` operator uses the `add` method, whose signature looks something like
this:
-->
<p>La cha√Æne de caract√®res <code>s3</code> va contenir <code>Hello, world!</code>. La raison pour
laquelle <code>s1</code> n'est plus utilisable apr√®s avoir √©t√© ajout√©, et pour laquelle
nous utilisons une r√©f√©rence vers <code>s2</code>, est la signature de la m√©thode qui est
appel√©e lorsque nous utilisons l'op√©rateur <code>+</code>. L'op√©rateur <code>+</code> utilise la
m√©thode <code>add</code>, dont la signature ressemble √† ceci¬†:</p>
<!--
```rust,ignore
fn add(self, s: &str) -> String {
```
-->
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!--
In the standard library, you‚Äôll see `add` defined using generics. Here, we‚Äôve
substituted in concrete types for the generic ones, which is what happens when
we call this method with `String` values. We‚Äôll discuss generics in Chapter 10.
This signature gives us the clues we need to understand the tricky bits of the
`+` operator.
-->
<p>Dans la biblioth√®que standard, vous pouvez constater que <code>add</code> est d√©fini en
utilisant des g√©n√©riques. Ici, nous avons remplac√© par des types concrets √† la
place des g√©n√©riques, ce qui se passe lorsque nous utilisons cette m√©thode avec
des valeurs de type <code>String</code>. Nous verrons la g√©n√©ricit√© au chapitre 10. Cette
signature nous donne les √©l√©ments dont nous avons besoin pour comprendre les
subtilit√©s de l'op√©rateur <code>+</code>.</p>
<!--
First, `s2` has an `&`, meaning that we‚Äôre adding a *reference* of the second
string to the first string. This is because of the `s` parameter in the `add`
function: we can only add a `&str` to a `String`; we can‚Äôt add two `String`
values together. But wait‚Äîthe type of `&s2` is `&String`, not `&str`, as
specified in the second parameter to `add`. So why does Listing 8-18 compile?
-->
<p>Premi√®rement, <code>s2</code> a un <code>&amp;</code>, ce qui veut dire que nous ajoutons une <em>r√©f√©rence</em>
vers la seconde cha√Æne de caract√®res √† la premi√®re cha√Æne. C'est √† cause du
param√®tre <code>s</code> de la fonction <code>add</code>¬†: nous pouvons seulement ajouter un <code>&amp;str</code> √†
une <code>String</code>¬†; nous ne pouvons pas ajouter deux valeurs de type <code>String</code>
ensemble. Mais attendez ‚Äî le type de <code>&amp;s2</code> est <code>&amp;String</code>, et non pas <code>&amp;str</code>,
comme c'est √©crit dans le second param√®tre de <code>add</code>. Alors pourquoi est-ce que
le code de l'encart 8-18 se compile¬†?</p>
<!--
The reason we‚Äôre able to use `&s2` in the call to `add` is that the compiler
can *coerce* the `&String` argument into a `&str`. When we call the `add`
method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`.
We‚Äôll discuss deref coercion in more depth in Chapter 15. Because `add` does
not take ownership of the `s` parameter, `s2` will still be a valid `String`
after this operation.
-->
<p>La raison pour laquelle nous pouvons utiliser <code>&amp;s2</code> dans l'appel √† <code>add</code> est que
le compilateur peut <em>extrapoler</em> l'argument <code>&amp;String</code> en un <code>&amp;str</code>. Lorsque nous
appelons la m√©thode <code>add</code>, Rust va utiliser une <em>extrapolation de
d√©r√©f√©rencement</em>, qui transforme ici <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Nous verrons plus en
d√©tail l'extrapolation de d√©r√©f√©rencement au chapitre 15. Comme <code>add</code> ne prend
pas possession du param√®tre <code>s</code>, <code>s2</code> sera toujours une <code>String</code> valide apr√®s
cette op√©ration.</p>
<!--
Second, we can see in the signature that `add` takes ownership of `self`,
because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be
moved into the `add` call and will no longer be valid after that. So although
`let s3 = s1 + &s2;` looks like it will copy both strings and create a new one,
this statement actually takes ownership of `s1`, appends a copy of the contents
of `s2`, and then returns ownership of the result. In other words, it looks
like it‚Äôs making a lot of copies but isn‚Äôt; the implementation is more
efficient than copying.
-->
<p>Ensuite, nous pouvons constater que la signature de <code>add</code> prend possession de
<code>self</code>, car <code>self</code> n'a <em>pas</em> de <code>&amp;</code>. Cela signifie que <code>s1</code> dans l'encart 8-18
va √™tre d√©plac√© dans l'appel √† <code>add</code> et ne sera plus en vigueur apr√®s cela. Donc
bien que <code>let s3 = s1 + &amp;s2</code> semble copier les deux cha√Ænes de caract√®res pour
en cr√©er une nouvelle, cette instruction va en r√©alit√© prendre possession de
<code>s1</code>, y ajouter une copie du contenu de <code>s2</code> et nous redonner la possession du
r√©sultat. Autrement dit, cela semble faire beaucoup de copies mais en r√©alit√©
non¬†; son impl√©mentation est plus efficace que la copie.</p>
<!--
If we need to concatenate multiple strings, the behavior of the `+` operator
gets unwieldy:
-->
<p>Si nous avons besoin de concat√©ner plusieurs cha√Ænes de caract√®res, le
comportement de l'op√©rateur <code>+</code> devient difficile √† utiliser¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<!--
At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"`
characters, it‚Äôs difficult to see what‚Äôs going on. For more complicated string
combining, we can instead use the `format!` macro:
-->
<p>Au final, <code>s</code> vaudra <code>tic-tac-toe</code>. Avec tous les caract√®res <code>+</code> et <code>&quot;</code>, il est
difficile de visualiser ce qui se passe. Pour une combinaison de cha√Ænes de
caract√®res plus complexe, nous pouvons utiliser √† la place la macro <code>format!</code>¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<!--
This code also sets `s` to `tic-tac-toe`. The `format!` macro works like
`println!`, but instead of printing the output to the screen, it returns a
`String` with the contents. The version of the code using `format!` is much
easier to read, and the code generated by the `format!` macro uses references
so that this call doesn‚Äôt take ownership of any of its parameters.
-->
<p>Ce code assigne lui aussi √† <code>s</code> la valeur <code>tic-tac-toe</code>. La macro <code>format!</code>
fonctionne comme <code>println!</code>, mais au lieu d'afficher son r√©sultat √† l'√©cran,
elle retourne une <code>String</code> avec son contenu. La version du code qui utilise
<code>format!</code> est plus facile √† lire, et le code g√©n√©r√© par la macro <code>format!</code>
utilise des r√©f√©rences afin qu'il ne prenne pas possession de ses param√®tres.</p>
<!--
### Indexing into Strings
-->
<h3 id="lindexation-des-strings"><a class="header" href="#lindexation-des-strings">L'indexation des Strings</a></h3>
<!--
In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a `String` using indexing syntax in Rust, you‚Äôll
get an error. Consider the invalid code in Listing 8-19.
-->
<p>Dans de nombreux autres langages de programmation, l'acc√®s individuel aux
caract√®res d'une cha√Æne de caract√®res en utilisant leur indice est une op√©ration
valide et courante. Cependant, si vous essayez d'acc√©der √† des √©l√©ments d'une
<code>String</code> en utilisant la syntaxe d'indexation avec Rust, vous allez avoir une
erreur. Nous tentons cela dans le code invalide de l'encart 8-19.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span>
-->
<p><span class="caption">Encart 8-19¬†: Tentative d'utilisation de la syntaxe
d'indexation avec une <code>String</code></span></p>
<!--
This code will result in the following error:
-->
<p>Ce code va produire l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 -- > src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<!--
The error and the note tell the story: Rust strings don‚Äôt support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.
-->
<p>L'erreur et la remarque nous expliquent le probl√®me¬†: les <code>String</code> de Rust
n'acceptent pas l'utilisation des indices. Mais pourquoi¬†? Pour r√©pondre √† cette
question, nous avons besoin de savoir comment Rust enregistre les cha√Ænes de
caract√®res dans la m√©moire.</p>
<!--
#### Internal Representation
-->
<h4 id="repr√©sentation-interne"><a class="header" href="#repr√©sentation-interne">Repr√©sentation interne</a></h4>
<!--
A `String` is a wrapper over a `Vec<u8>`. Let‚Äôs look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:
-->
<p>Une <code>String</code> est une surcouche de <code>Vec&lt;u8&gt;</code>. Revenons sur certains exemples de
cha√Ænes de caract√®res correctement encod√©es en UTF-8 que nous avions dans
l'encart 8-14. Premi√®rement, celle-ci¬†:</p>
<!--
```rust
# fn main() {
#     let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
#     let hello = String::from("Dobr√Ω den");
#     let hello = String::from("Hello");
#     let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
#     let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
#     let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
#     let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
#     let hello = String::from("‰Ω†Â•Ω");
#     let hello = String::from("Ol√°");
#     let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let bonjour = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Hello&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Ol√°&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
</span>    let bonjour = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
In this case, `len` will be 4, which means the vector storing the string ‚ÄúHola‚Äù
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. The
following line, however, may surprise you. (Note that this string begins with
the capital Cyrillic letter Ze, not the Arabic number 3.)
-->
<p>Dans ce cas-ci, <code>len</code> vaudra 4, ce qui veut dire que le vecteur qui stocke la
cha√Æne ‚ÄúHola‚Äù a une taille de 4 octets. Chacune des lettres prend 1 octet
lorsqu'elles sont encod√©es en UTF-8. Cependant, la ligne suivante peut
surprendre. (Notez que cette cha√Æne de caract√®res commence avec la lettre
majuscule cyrillique Z√©, et non pas le chiffre arabe 3.)</p>
<!--
```rust
# fn main() {
#     let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
#     let hello = String::from("Dobr√Ω den");
#     let hello = String::from("Hello");
#     let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
#     let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
#     let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
#     let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
#     let hello = String::from("‰Ω†Â•Ω");
#     let hello = String::from("Ol√°");
    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
#     let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let bonjour = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Hello&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Ol√°&quot;);
</span>    let bonjour = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
<span class="boring">    let bonjour = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Asked how long the string is, you might say 12. In fact, Rust‚Äôs answer is 24:
that‚Äôs the number of bytes it takes to encode ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù in UTF-8, because
each Unicode scalar value in that string takes 2 bytes of storage. Therefore,
an index into the string‚Äôs bytes will not always correlate to a valid Unicode
scalar value. To demonstrate, consider this invalid Rust code:
-->
<p>Si on vous demandait la longueur de la cha√Æne de caract√®res, vous r√©pondriez
probablement 12. En r√©alit√©, la r√©ponse de Rust sera 24¬†: c'est le nombre
d'octets n√©cessaires pour encoder ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù en UTF-8, car chaque valeur
scalaire Unicode dans cette cha√Æne de caract√®res prend 2 octets en m√©moire.
Par cons√©quent, un indice dans les octets de la cha√Æne de caract√®res ne
correspondra pas forc√©ment √† une valeur scalaire Unicode valide. Pour d√©montrer
cela, utilisons ce code Rust invalide¬†:</p>
<!--
```rust,ignore,does_not_compile
let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";
let answer = &hello[0];
```
-->
<pre><code class="language-rust ignore does_not_compile">let bonjour = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let reponse = &amp;bonjour[0];
</code></pre>
<!--
You already know that `answer` will not be `–ó`, the first letter. When encoded
in UTF-8, the first byte of `–ó` is `208` and the second is `151`, so it would
seem that `answer` should in fact be `208`, but `208` is not a valid character
on its own. Returning `208` is likely not what a user would want if they asked
for the first letter of this string; however, that‚Äôs the only data that Rust
has at byte index 0. Users generally don‚Äôt want the byte value returned, even
if the string contains only Latin letters: if `&"hello"[0]` were valid code
that returned the byte value, it would return `104`, not `h`.
-->
<p>Vous savez d√©j√† que <code>reponse</code> ne vaudra pas <code>–ó</code>, la premi√®re lettre. Lorsqu'il
est encod√© en UTF-8, le premier octet de <code>–ó</code> est <code>208</code> et le second est <code>151</code>,
donc on dirait que <code>reponse</code> vaudrait <code>208</code>, mais <code>208</code> n'est pas un caract√®re
valide √† lui seul. Retourner <code>208</code> n'est pas ce qu'un utilisateur attend s'il
demande la premi√®re lettre de cette cha√Æne de caract√®res¬†; cependant, c'est la
seule valeur que Rust a √† l'indice 0 des octets. Les utilisateurs ne souhaitent
g√©n√©ralement pas obtenir la valeur d'un octet, m√™me si la cha√Æne de caract√®res
contient uniquement des lettres latines¬†: si <code>&amp;&quot;hello&quot;[0]</code> √©tait un code valide
qui retournait la valeur de l'octet, il retournerait <code>104</code> et non pas <code>h</code>.</p>
<!--
The answer, then, is that to avoid returning an unexpected value and causing
bugs that might not be discovered immediately, Rust doesn‚Äôt compile this code
at all and prevents misunderstandings early in the development process.
-->
<p>La solution est donc, pour √©viter de retourner une valeur inattendue et g√©n√©rer
des bogues qui ne seraient pas d√©couverts imm√©diatement, que Rust ne va pas
compiler ce code et va ainsi √©viter des erreurs d√®s le d√©but du processus de
d√©veloppement.</p>
<!--
#### Bytes and Scalar Values and Grapheme Clusters! Oh My!
-->
<h4 id="des-octets-des-valeurs-scalaires-et-des-groupes-de-graph√®mes--oh-mon-dieu-"><a class="header" href="#des-octets-des-valeurs-scalaires-et-des-groupes-de-graph√®mes--oh-mon-dieu-">Des octets, des valeurs scalaires et des groupes de graph√®mes¬†!? Oh mon Dieu¬†!</a></h4>
<!--
Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust‚Äôs perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call *letters*).
-->
<p>Un autre probl√®me avec l'UTF-8 est qu'il a en fait trois mani√®res pertinentes
de consid√©rer les cha√Ænes de caract√®res avec Rust¬†: comme des octets, comme
des valeurs scalaires ou comme des groupes de graph√®mes (ce qui se rapproche le
plus de ce que nous pourrions appeler des <em>lettres</em>).</p>
<!--
If we look at the Hindi word ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:
-->
<p>Si l'on consid√®re le mot hindi ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù √©crit en √©criture devanagari, il est
stock√© comme un vecteur de valeurs <code>u8</code> qui sont les suivantes¬†:</p>
<!--
```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```
-->
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!--
That‚Äôs 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust‚Äôs `char` type is, those
bytes look like this:
-->
<p>Cela fait 18 octets et c'est ainsi que les ordinateurs stockeront cette donn√©e.
Si nous les voyons comme des valeurs scalaires Unicode, ce qu'est le type <code>char</code>
de Rust, ces octets seront les suivants¬†:</p>
<!--
```text
['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
```
-->
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<!--
There are six `char` values here, but the fourth and sixth are not letters:
they‚Äôre diacritics that don‚Äôt make sense on their own. Finally, if we look at
them as grapheme clusters, we‚Äôd get what a person would call the four letters
that make up the Hindi word:
-->
<p>Nous avons six valeurs <code>char</code> ici, mais les quatri√®me et sixi√®me valeurs ne sont
pas des lettres¬†: ce sont des signes diacritiques qui n'ont pas de sens employ√©s
seuls. Enfin, si nous les voyons comme des groupes de graph√®mes, on obtient ce
qu'on pourrait appeler les quatre lettres qui constituent le mot hindi¬†:</p>
<!--
```text
["‡§®", "‡§Æ", "‡§∏‡•ç", "‡§§‡•á"]
```
-->
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<!--
Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.
-->
<p>Rust fournit diff√©rentes mani√®res d'interpr√©ter les donn√©es brutes des cha√Ænes
de caract√®res que les ordinateurs stockent afin que chaque programme puisse
choisir l'interpr√©tation dont il a besoin, peu importe la langue dans laquelle
sont les donn√©es.</p>
<!--
A final reason Rust doesn‚Äôt allow us to index into a `String` to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn‚Äôt possible to guarantee that performance with a `String`,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.
-->
<p>Une derni√®re raison pour laquelle Rust ne nous autorise pas √† indexer une
<code>String</code> pour r√©cup√©rer un caract√®re est que les op√©rations d'indexation sont
cens√©es prendre un temps constant (O(1)). Mais il n'est pas possible de garantir
cette performance avec une <code>String</code>, car Rust devrait parcourir le contenu
depuis le d√©but jusqu'√† l'indice pour d√©terminer combien il y a de caract√®res
valides.</p>
<!--
### Slicing Strings
-->
<h3 id="les-slices-de-cha√Ænes-de-caract√®res"><a class="header" href="#les-slices-de-cha√Ænes-de-caract√®res">Les slices de cha√Ænes de caract√®res</a></h3>
<!--
Indexing into a string is often a bad idea because it‚Äôs not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. If you really need to use
indices to create string slices, therefore, Rust asks you to be more specific.
-->
<p>L'indexation sur une cha√Æne de caract√®res est souvent une mauvaise id√©e car le
type de retour de l'op√©ration n'est pas toujours √©vident¬†: un octet, un
caract√®re, un groupe de graph√®mes ou une slice de cha√Æne de caract√®res¬†? Si
vous avez vraiment besoin d'utiliser des indices pour cr√©er des slices de
cha√Ænes, Rust vous demande plus de pr√©cisions.</p>
<!--
Rather than indexing using `[]` with a single number, you can use `[]` with a
range to create a string slice containing particular bytes:
-->
<p>Plut√¥t que d'utiliser <code>[]</code> avec un nombre seul, vous pouvez utiliser <code>[]</code> avec
un intervalle d'indices pour cr√©er une slice de cha√Æne contenant des octets
bien pr√©cis, plut√¥t que d'utiliser <code>[]</code> avec un seul nombre¬†:</p>
<!--
```rust
let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";

let s = &hello[0..4];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bonjour = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;bonjour[0..4];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `s` will be a `&str` that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
`s` will be `–ó–¥`.
-->
<p>Ici, <code>s</code> sera un <code>&amp;str</code> qui contiendra les 4 premiers octets de la cha√Æne de
caract√®res. Pr√©c√©demment, nous avions mentionn√© que chacun de ces caract√®res
√©tait encod√© sur 2 octets, ce qui veut dire que <code>s</code> vaudra <code>–ó–¥</code>.</p>
<!--
If we were to try to slice only part of a character‚Äôs bytes with something like
`&hello[0..1]`, Rust would panic at runtime in the same way as if an invalid
index were accessed in a vector:
-->
<p>Si vous essayons de produire une slice d'une partie des octets d'un caract√®re
avec quelquechose comme <code>&amp;bonjour[0..1]</code>, Rust va paniquer au moment de
l'ex√©cution de la m√™me fa√ßon que si nous utilisions un indice invalide pour
acc√©der √† un √©l√©ment d'un vecteur¬†:</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
You should use ranges to create string slices with caution, because doing so
can crash your program.
-->
<p>Vous devriez utiliser les intervalles pour cr√©er des slices avec prudence, car
cela peut provoquer un plantage de votre programme.</p>
<!--
### Methods for Iterating Over Strings
-->
<h3 id="les-m√©thodes-pour-parcourir-les-cha√Ænes-de-caract√®res"><a class="header" href="#les-m√©thodes-pour-parcourir-les-cha√Ænes-de-caract√®res">Les m√©thodes pour parcourir les cha√Ænes de caract√®res</a></h3>
<!--
The best way to operate on pieces of strings is to be explicit about whether
you want characters or bytes. For individual Unicode scalar values, use the
`chars` method. Calling `chars` on ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù separates out and returns six values
of type `char`, and you can iterate over the result to access each element:
-->
<p>La meilleure mani√®re de travailler sur des parties de cha√Ænes de caract√®res est
d'exprimer clairement si vous voulez travailler avec des caract√®res ou des
octets. Pour les valeurs scalaires Unicode une par une, utilisez la m√©thode
<code>chars</code>. Appeler <code>chars</code> sur ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù s√©pare et retourne six valeurs de type
<code>char</code>, et vous pouvez it√©rer sur le r√©sultat pour acc√©der √† chaque √©l√©ment¬†:</p>
<!--
```rust
for c in "‡§®‡§Æ‡§∏‡•ç‡§§‡•á".chars() {
    println!("{}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the following:
-->
<p>Ce code va afficher ceci¬†:</p>
<!--
```text
‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
```
-->
<pre><code class="language-text">‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
</code></pre>
<!--
Alternatively, the `bytes` method returns each raw byte, which might be
appropriate for your domain:
-->
<p>Aussi, la m√©thode <code>bytes</code> va retourner chaque octet brut, ce qui sera peut-√™tre
plus utile selon ce que vous voulez faire¬†:</p>
<!--
```rust
for b in "‡§®‡§Æ‡§∏‡•ç‡§§‡•á".bytes() {
    println!("{}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the 18 bytes that make up this `String`:
-->
<p>Ce code va afficher les 18 octets qui constituent cette <code>String</code>¬†:</p>
<!--
```text
224
164
// --snip--
165
135
```
-->
<pre><code class="language-text">224
164
// -- √©l√©ments masqu√©s ici --
165
135
</code></pre>
<!--
But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.
-->
<p>Rappelez-vous bien que des valeurs scalaires Unicode peuvent √™tre constitu√©es de
plus d'un octet.</p>
<!--
Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
[crates.io](https://crates.io/)<!-- ignore -- > if this is the functionality you
need.
-->
<p>L'obtention des groupes de graph√®mes √† partir de cha√Ænes de caract√®res est
complexe, donc cette fonctionnalit√© n'est pas fournie par la biblioth√®que
standard. Des crates sont disponibles sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> si c'est la fonctionnalit√© dont
vous avez besoin.</p>
<!--
### Strings Are Not So Simple
-->
<h3 id="les-cha√Ænes-de-caract√®res-ne-sont-pas-si-simples"><a class="header" href="#les-cha√Ænes-de-caract√®res-ne-sont-pas-si-simples">Les cha√Ænes de caract√®res ne sont pas si simples</a></h3>
<!--
To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of `String` data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.
-->
<p>Pour r√©sumer, les cha√Ænes de caract√®res sont complexes. Les diff√©rents langages
de programmation ont fait diff√©rents choix sur la fa√ßon de pr√©senter cette
complexit√© aux d√©veloppeurs. Rust a choisi d'appliquer par d√©faut la gestion
rigoureuse des donn√©es de <code>String</code> pour tous les programmes Rust, ce qui veut
dire que les d√©veloppeurs doivent r√©fl√©chir davantage √† la gestion des donn√©es
UTF-8. Ce compromis r√©v√®le davantage la complexit√© des cha√Ænes de caract√®res par
rapport √† ce que les autres langages de programmation laissent para√Ætre, mais
vous √©vite d'avoir √† g√©rer plus tard dans votre cycle de d√©veloppement des
erreurs √† cause de caract√®res non ASCII.</p>
<!--
Let‚Äôs switch to something a bit less complex: hash maps!
-->
<p>Passons maintenant √† quelque chose de moins complexe¬†: les tables de hachage¬†!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
