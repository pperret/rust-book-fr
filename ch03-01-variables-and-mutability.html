<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les variables et la mutabilit√© - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html" class="active"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Variables and Mutability
-->
<h2 id="les-variables-et-la-mutabilit√©"><a class="header" href="#les-variables-et-la-mutabilit√©">Les variables et la mutabilit√©</a></h2>
<!--
As mentioned in the [‚ÄúStoring Values with
Variables‚Äù][storing-values-with-variables]<!-- ignore -- > section, by default
variables are immutable. This is one of many nudges Rust gives you to write
your code in a way that takes advantage of the safety and easy concurrency that
Rust offers. However, you still have the option to make your variables mutable.
Let‚Äôs explore how and why Rust encourages you to favor immutability and why
sometimes you might want to opt out.
-->
<p>Tel qu'abord√© au <a href="ch02-00-guessing-game-tutorial.html">chapitre 2</a><!-- ignore -->,
par d√©faut, les variables sont <em>immuables</em>. C'est un des nombreux coups de pouce
de Rust pour √©crire votre code de fa√ßon √† garantir la s√©curit√© et la concurrence
sans probl√®me. Cependant, vous avez quand m√™me la possibilit√© de rendre vos
variables mutables <em>(modifiables)</em>. Explorons comment et pourquoi Rust vous
encourage √† favoriser l'immuabilit√©, et pourquoi parfois vous pourriez choisir
d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you can‚Äôt change
that value. To illustrate this, let‚Äôs generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
li√©e √† un nom, vous ne pouvez pas changer cette valeur. √Ä titre d'illustration,
g√©n√©rons un nouveau projet appel√© <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code. This code won‚Äôt compile just yet, we‚Äôll first
examine the immutability error.
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant. Ce code ne se compile pas pour le
moment, nous allons commencer par √©tudier l'erreur d'immutabilit√©.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ci¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;La valeur de x est¬†: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but really they only mean your program
isn‚Äôt safely doing what you want it to do yet; they do *not* mean that you‚Äôre
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide √† trouver les erreurs dans
vos programmes. Les erreurs de compilation peuvent s'av√©rer frustrantes, mais
elles signifient en r√©alit√© que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute s√©curit√©¬†; elles ne
signifient <em>pas</em> que vous √™tes un mauvais d√©veloppeur¬†! M√™me les Rustac√©s
exp√©riment√©s continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `` cannot
assign twice to immutable variable `x` ``, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du probl√®me est qu'il est
<code>impossible d'assigner √† deux reprises la variable immuable `x`</code>
(<code>cannot assign twice to immutable variable `x`</code>).</p>
<!--
It‚Äôs important that we get compile-time errors when we attempt to change a
value that‚Äôs designated as immutable because this very situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, it‚Äôs possible
that the first part of the code won‚Äôt do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only *sometimes*. The Rust
compiler guarantees that when you state a value won‚Äôt change, it really won‚Äôt
change, so you don‚Äôt have to keep track of it yourself. Your code is thus
easier to reason through.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a √©t√© d√©clar√©e comme immuable,
car cette situation particuli√®re peut donner lieu √† des bogues. Si une partie
de notre code part du principe qu'une valeur ne changera jamais et qu'une autre
partie de notre code modifie cette valeur, il est possible que la premi√®re
partie du code ne fasse pas ce pour quoi elle a √©t√© con√ßue. La cause de ce
genre de bogue peut √™tre difficile √† localiser apr√®s coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur. Le
compilateur Rust garantit que lorsque vous d√©clarez qu'une valeur ne change
pas, elle ne va jamais changer, donc vous n'avez pas √† vous en soucier. Votre
code est ainsi plus facile √† ma√Ætriser.</p>
<!--
But mutability can be very useful, and can make code more convenient to write.
Variables are immutable only by default; as you did in Chapter 2, you can make
them mutable by adding `mut` in front of the variable name. Adding `mut` also
conveys intent to future readers of the code by indicating that other parts of
the code will be changing this variable‚Äôs value.
-->
<p>Mais la mutabilit√© peut s'av√©rer tr√®s utile, et peut faciliter la r√©daction du
code. Les variables sont immuables par d√©faut¬†; mais comme vous l'avez fait au
chapitre 2, vous pouvez les rendre mutables en ajoutant <code>mut</code> devant le nom de
la variable. L'ajout de <code>mut</code> va aussi signaler l'intention aux futurs lecteurs
de ce code que d'autres parties du code vont modifier la valeur de cette
variable.</p>
<!--
For example, let‚Äôs change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsi¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous ex√©cutons le programme, nous obtenons¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
La valeur de x est¬†: 5
La valeur de x est¬†: 6
</code></pre>
<!--
We‚Äôre allowed to change the value bound to `x` from `5` to `6` when `mut`
is used. There are multiple trade-offs to consider in addition to the
prevention of bugs. For example, in cases where you‚Äôre using large data
structures, mutating an instance in place may be faster than copying and
returning newly allocated instances. With smaller data structures, creating new
instances and writing in a more functional programming style may be easier to
think through, so lower performance might be a worthwhile penalty for gaining
that clarity.
-->
<p>En utilisant <code>mut</code>, nous avons permis √† la valeur li√©e √† <code>x</code> de passer de <code>5</code> √†
<code>6</code>. Il y a d'autres compromis √† envisager, en plus de la pr√©vention des
bogues. Par exemple, dans le cas o√π vous utiliseriez des grosses structures de
donn√©es, muter une instance d√©j√† existante peut √™tre plus rapide que copier et
retourner une instance nouvellement allou√©e. Avec des structures de donn√©es
plus petites, cr√©er de nouvelles instances avec un style de programmation
fonctionnelle peut rendre le code plus facile √† comprendre, donc il peut valoir
le coup de sacrifier un peu de performance pour que le code gagne en clart√©.</p>
<!--
### Constants
-->
<h3 id="les-constantes"><a class="header" href="#les-constantes">Les constantes</a></h3>
<!--
Like immutable variables, *constants* are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.
-->
<p>Comme les variables immuables, les <em>constantes</em> sont des valeurs qui sont li√©es
√† un nom et qui ne peuvent √™tre modifi√©es, mais il y a quelques diff√©rences
entre les constantes et les variables.</p>
<!--
First, you aren‚Äôt allowed to use `mut` with constants. Constants aren‚Äôt just
immutable by default‚Äîthey‚Äôre always immutable. You declare constants using the
`const` keyword instead of the `let` keyword, and the type of the value *must*
be annotated. We‚Äôre about to cover types and type annotations in the next
section, [‚ÄúData Types,‚Äù][data-types]<!-- ignore -- > so don‚Äôt worry about the
details right now. Just know that you must always annotate the type.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par d√©faut ‚àí elles sont toujours immuables. On
d√©clare les constantes en utilisant le mot-cl√© <code>const</code> √† la place du mot-cl√©
<code>let</code>, et le type de la valeur <em>doit</em> √™tre indiqu√©. Nous allons aborder les
types et les annotations de types dans la prochaine section, <a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">‚ÄúLes types de
donn√©es‚Äù</a><!-- ignore -->, donc ne vous souciez pas des d√©tails pour
le moment. Sachez seulement que vous devez toujours indiquer le type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent √™tre d√©clar√©es √† n'importe quel endroit du code, y
compris la port√©e globale, ce qui les rend tr√®s utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de conna√Ætre.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a value that could only be computed at runtime.
-->
<p>La derni√®re diff√©rence est que les constantes ne peuvent √™tre d√©finies que par
une expression constante, et non pas le r√©sultat d'une valeur qui ne pourrait
√™tre calcul√©e qu'√† l'ex√©cution.</p>
<!--
Here‚Äôs an example of a constant declaration:
-->
<p>Voici un exemple d'une d√©claration de constante¬†:</p>
<!--
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TROIS_HEURES_EN_SECONDES: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<!--
The constant‚Äôs name is `THREE_HOURS_IN_SECONDS` and its value is set to the
result of multiplying 60 (the number of seconds in a minute) by 60 (the number
of minutes in an hour) by 3 (the number of hours we want to count in this
program). Rust‚Äôs naming convention for constants is to use all uppercase with
underscores between words. The compiler is able to evaluate a limited set of
operations at compile time, which lets us choose to write out this value in a
way that‚Äôs easier to understand and verify, rather than setting this constant
to the value 10,800. See the [Rust Reference‚Äôs section on constant
evaluation][const-eval] for more information on what operations can be used
when declaring constants.
-->
<p>Le nom de la constante est <code>TROIS_HEURES_EN_SECONDES</code> et sa valeur est d√©finie
comme √©tant le r√©sultat de la multiplication de 60 (le nombre de secondes dans
une minute) par 60 (le nombre de minutes dans une heure) par 3 (le nombre
d'heures que nous voulons calculer dans ce programme).
En Rust, la convention de nommage des constantes est de les √©crire tout en
majuscule avec des tirets bas entre les mots. Le compilateur peut calculer un
certain nombre d'op√©rations √† la compilation, ce qui nous permet d'√©crire
cette valeur de fa√ßon √† la comprendre plus facilement et √† la v√©rifier, plut√¥t
que de d√©finir cette valeur √† 10 800. Vous pouvez consulter la <a href="https://doc.rust-lang.org/reference/const_eval.html">section de la
r√©f√©rence Rust √† propos des √©valuations des constantes</a> pour en
savoir plus sur les op√©rations qui peuvent √™tre utilis√©es pour d√©clarer des
constantes.</p>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in. This property makes constants useful for values in your
application domain that multiple parts of the program might need to know about,
such as the maximum number of points any player of a game is allowed to earn or
the speed of light.
-->
<p>Les constantes sont valables pendant toute la dur√©e d'ex√©cution du programme
au sein de la port√©e dans laquelle elles sont d√©clar√©es. Cette caract√©ristique
rends les constantes tr√®s utiles lorsque plusieurs parties du programme doivent
conna√Ætre certaines valeurs, comme par exemple le nombre maximum de points
qu'un joueur est autoris√© √† gagner ou encore la vitesse de la lumi√®re.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>D√©clarer des valeurs cod√©es en dur et utilis√©es tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs d√©veloppeurs. Cela permet √©galement de
n'avoir qu'un seul endroit de votre code √† modifier si cette valeur cod√©e en dur
doit √™tre mise √† jour √† l'avenir.</p>
<!--
### Shadowing
-->
<h3 id="le-masquage"><a class="header" href="#le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in [Chapter
2][comparing-the-guess-to-the-secret-number]<!-- ignore -- >, you can declare a
new variable with the same name as a previous variable. Rustaceans say that the
first variable is *shadowed* by the second, which means that the second
variable‚Äôs value is what the program sees when the variable is used. We can
shadow a variable by using the same variable‚Äôs name and repeating the use of
the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans le <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">Chapitre
2</a><!-- ignore -->, on peut d√©clarer
une nouvelle variable avec le m√™me nom qu'une variable pr√©c√©dente. Les Rustac√©s
disent que la premi√®re variable est <em>masqu√©e</em> par la seconde, ce qui signifie
que la valeur de la seconde variable sera ce que le programme verra lorsque
nous utiliserons cette variable. Nous pouvons cr√©er un masque d'une variable en
utilisant le m√™me nom de variable et en r√©utilisant le mot-cl√© <code>let</code> comme
ci-dessous¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;La valeur de x dans la port√©e interne est : {}&quot;, x);
    }

    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. Then, within an inner scope, the third `let` statement also
shadows `x`, multiplying the previous value by `2` to give `x` a value of `12`.
When that scope is over, the inner shadowing ends and `x` returns to being `6`.
When we run this program, it will output the following:
-->
<p>Au d√©but, ce programme lie <code>x</code> √† la valeur <code>5</code>. Puis il cr√©e un masque de <code>x</code>
en r√©p√©tant <code>let x =</code>, en r√©cup√©rant la valeur d'origine et lui ajoutant <code>1</code>¬†:
la valeur de <code>x</code> est d√©sormais <code>6</code>. Ensuite, √† l'int√©rieur de la port√©e interne,
la troisi√®me instruction <code>let</code> cr√©e un autre masque de <code>x</code>, en r√©cup√©rant la
pr√©c√©dente valeur et en la multipliant par <code>2</code> pour donner √† <code>x</code> la valeur
finale de <code>12</code>. D√®s que nous sortons de cette port√©e, le masque prends fin, et
<code>x</code> revient √† la valeur <code>6</code>. Lorsque nous ex√©cutons ce programme, nous obtenons
ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
La valeur de x dans la port√©e interne est : 12
La valeur de x est¬†: 6
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because we‚Äôll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>Cr√©er un masque est diff√©rent que de marquer une variable comme √©tant <code>mut</code>,
car √† moins d'utiliser une nouvelle fois le mot-cl√© <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de r√©assigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable apr√®s que ces
transformations ont √©t√© appliqu√©es.</p>
<!--
The other difference between `mut` and shadowing is that because we‚Äôre
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, and then we want to store that input as a number:
-->
<p>Comme nous cr√©ons une nouvelle variable lorsque nous utilisons le mot-cl√© <code>let</code>
une nouvelle fois, l'autre diff√©rence entre le <code>mut</code> et la cr√©ation d'un masque
est que cela nous permet de changer le type de la valeur, mais en r√©utilisant
le m√™me nom. Par exemple, imaginons un programme qui demande √† l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, et ensuite nous voulons stocker cette saisie sous forme de
nombre¬†:</p>
<!--
```rust
# fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let espaces = &quot;   &quot;;
    let espaces = espaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
The first `spaces` variable is a string type and the second `spaces` variable
is a number type. Shadowing thus spares us from having to come up with
different names, such as `spaces_str` and `spaces_num`; instead, we can reuse
the simpler `spaces` name. However, if we try to use `mut` for this, as shown
here, we‚Äôll get a compile-time error:
-->
<p>La premi√®re variable <code>espaces</code> est du type cha√Æne de caract√®res <em>(string)</em> et
la seconde variable <code>espaces</code> est du type nombre. L'utilisation du masquage
nous √©vite ainsi d'avoir √† trouver des noms diff√©rents, comme <code>espaces_str</code> et
<code>espaces_num</code>¬†; nous pouvons plut√¥t simplement r√©utiliser le nom <code>espaces</code>.
Cependant, si nous essayons d'utiliser <code>mut</code> pour faire ceci, comme ci-dessous,
nous avons une erreur de compilation¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut espaces = &quot;   &quot;;
    espaces = espaces.len();
<span class="boring">}
</span></code></pre>
<!--
The error says we‚Äôre not allowed to mutate a variable‚Äôs type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variable¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut espaces = &quot;   &quot;;
  |                       ----- expected due to this value
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
Now that we‚Äôve explored how variables work, let‚Äôs look at more data types they
can have.
-->
<p>Maintenant que nous avons d√©couvert comment fonctionnent les variables, √©tudions
les types de donn√©es qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch03-02-data-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-00-common-programming-concepts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch03-02-data-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
