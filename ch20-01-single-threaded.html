<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DÃ©velopper un serveur web monotÃ¢che - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilitÃ©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donnÃ©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrÃ´le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les rÃ©fÃ©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donnÃ©es apparentÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> DÃ©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des mÃ©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les Ã©numÃ©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> DÃ©finir une Ã©numÃ©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrÃ´le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrÃ´le conciseÂ : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> GÃ©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> DÃ©finir des modules pour gÃ©rer la portÃ©e et la visibilitÃ©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> DÃ©signer un Ã©lÃ©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portÃ©e via le mot-clÃ© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> SÃ©parer les modules dans diffÃ©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodÃ© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clÃ©s associÃ©es Ã  des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrÃ©cupÃ©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs rÃ©cupÃ©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types gÃ©nÃ©riques, les traits et les durÃ©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donnÃ©es gÃ©nÃ©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> DÃ©finir des comportements partagÃ©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformitÃ© des rÃ©fÃ©rences avec les durÃ©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisÃ©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment Ã©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> GÃ©rer l'exÃ©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrÃ©e/sortieÂ : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> RÃ©cupÃ©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour amÃ©liorer sa modularitÃ© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> DÃ©velopper les fonctionnalitÃ©s de la bibliothÃ¨que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalitÃ©s des langages fonctionnelsÂ : les itÃ©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermeturesÂ : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une sÃ©rie d'Ã©lÃ©ments avec un itÃ©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> AmÃ©lioration de notre projet d'entrÃ©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performancesÂ : les boucles et les itÃ©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires Ã  partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalitÃ©s de cargo avec des commandes personnalisÃ©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donnÃ©es prÃ©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ConsidÃ©rer les pointeurs intelligents comme des rÃ©fÃ©rences grÃ¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ExÃ©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les rÃ©fÃ©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilitÃ© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de rÃ©fÃ©rences qui peuvent provoquer des fuites de mÃ©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les tÃ¢ches pour exÃ©cuter simultanÃ©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transfÃ©rer des donnÃ©es entre les tÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'Ã©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalitÃ©s orientÃ©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caractÃ©ristiques des langages orientÃ©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diffÃ©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ImplÃ©menter un patron de conception orientÃ©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits oÃ¹ les motifs peuvent Ãªtre utilisÃ©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La rÃ©futabilitÃ©Â : lorsqu'un motif peut Ã©chouer Ã  correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalitÃ©s avancÃ©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non sÃ©curisÃ© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avancÃ©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avancÃ©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multitÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html" class="active"><strong aria-hidden="true">20.1.</strong> DÃ©velopper un serveur web monotÃ¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monotÃ¢che en serveur multitÃ¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> ArrÃªt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-clÃ©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> ğŸš§ B - les opÃ©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> ğŸš§ C - les traits dÃ©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> ğŸš§ D - Des outils de dÃ©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> ğŸš§ E - Les Ã©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> ğŸš§ F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> ğŸš§ G - Comment Rust est construit, et â€œNightly Rustâ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Building a Single-Threaded Web Server
-->
<h2 id="dÃ©velopper-un-serveur-web-monotÃ¢che"><a class="header" href="#dÃ©velopper-un-serveur-web-monotÃ¢che">DÃ©velopper un serveur web monotÃ¢che</a></h2>
<!--
Weâ€™ll start by getting a single-threaded web server working. Before we begin,
letâ€™s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.
-->
<p>Nous allons commencer par faire fonctionner un serveur web monotÃ¢che.
Avant de commencer, faisons un survol rapide des protocoles utilisÃ©s dans les
serveurs web. Les dÃ©tails de ces protocoles ne sont pas le sujet de ce livre,
mais un rapide aperÃ§u vous donnera les informations dont vous avez besoin.</p>
<!--
The two main protocols involved in web servers are the *Hypertext Transfer
Protocol* *(HTTP)* and the *Transmission Control Protocol* *(TCP)*. Both
protocols are *request-response* protocols, meaning a *client* initiates
requests and a *server* listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.
-->
<p>Les deux principaux protocoles utilisÃ©s dans les serveurs web sont le
<em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> et le <em>Transmission Control Protocol</em>
<em>(TCP)</em>. Ces deux protocoles sont des protocoles de type <em>requÃªte-rÃ©ponse</em>, ce
qui signifie qu'un <em>client</em> initie des requÃªtes tandis que le <em>serveur</em> Ã©coute les
requÃªtes et fournit une rÃ©ponse au client. Le contenu de ces requÃªtes et de ces
rÃ©ponses est dÃ©fini par les protocoles.</p>
<!--
TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesnâ€™t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. Itâ€™s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. Weâ€™ll work with the
raw bytes of TCP and HTTP requests and responses.
-->
<p>TCP est le protocole le plus bas-niveau qui dÃ©crit les dÃ©tails de comment une
information passe d'un serveur Ã  un autre mais ne prÃ©cise pas ce qu'est cette
information. HTTP est construit sur TCP en dÃ©finissant le contenu des requÃªtes et
des rÃ©ponses. Il est techniquement possible d'utiliser HTTP avec d'autres
protocoles, mais dans la grande majoritÃ© des cas, HTTP envoie ses donnÃ©es via
TCP. Nous allons travailler avec les octets bruts des requÃªtes et des rÃ©ponses
de TCP et HTTP.</p>
<!--
### Listening to the TCP Connection
-->
<h3 id="ecouter-les-connexions-tcp"><a class="header" href="#ecouter-les-connexions-tcp">Ecouter les connexions TCP</a></h3>
<!--
Our web server needs to listen to a TCP connection, so thatâ€™s the first part
weâ€™ll work on. The standard library offers a `std::net` module that lets us do
this. Letâ€™s make a new project in the usual fashion:
-->
<p>Notre serveur web a besoin d'Ã©couter les connexions TCP, donc cela sera la
premiÃ¨re partie sur laquelle nous travaillerons. La bibliothÃ¨que standard offre
un module <code>std::net</code> qui nous permet de faire ceci. CrÃ©ons un nouveau projet de
maniÃ¨re habituelleÂ :</p>
<!--
```console
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```
-->
<pre><code class="language-console">$ cargo new salutations
     Created binary (application) `salutations` project
$ cd salutations
</code></pre>
<!--
Now enter the code in Listing 20-1 in *src/main.rs* to start. This code will
listen at the address `127.0.0.1:7878` for incoming TCP streams. When it gets
an incoming stream, it will print `Connection established!`.
-->
<p>Maintenant, saisissez le code de l'encart 20-1 dans <em>src/main.rs</em> pour
commencer. Ce code va Ã©couter les flux TCP entrants Ã  l'adresse
<code>127.0.0.1:7878</code>. Lorsqu'il obtiendra un flux entrant, il va afficher
<code>Connexion Ã©tablieÂ !</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        println!(&quot;Connexion Ã©tablieÂ !&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span>
-->
<p><span class="caption">Encart 20-1Â : Ã©coute des flux entrants et affichage d'un
message lorsque nous recevons un flux</span></p>
<!--
Using `TcpListener`, we can listen for TCP connections at the address
`127.0.0.1:7878`. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesnâ€™t
represent the authorsâ€™ computer specifically), and `7878` is the port. Weâ€™ve
chosen this port for two reasons: HTTP isnâ€™t normally accepted on this port, and
7878 is *rust* typed on a telephone.
-->
<p>En utilisant <code>TcpListener</code>, nous pouvons Ã©couter les connexions TCP Ã  l'adresse
<code>127.0.0.1:7878</code>. Dans cette adresse, la partie avant les double-points est une
adresse IP qui reprÃ©sente votre ordinateur (c'est la mÃªme sur chaque ordinateur
et ne reprÃ©sente pas spÃ©cifiquement l'ordinateur de l'auteur), et <code>7878</code> est le
port. Nous avons choisi ce port pour deux raisonsÂ : HTTP n'est pas
habituellement acceptÃ© sur ce port et 7878 correspond aux touches utilisÃ©es
sur un clavier de tÃ©lÃ©phone pour Ã©crire <em>Rust</em>.</p>
<!--
The `bind` function in this scenario works like the `new` function in that it
will return a new `TcpListener` instance. The reason the function is called
`bind` is that in networking, connecting to a port to listen to is known as
â€œbinding to a port.â€
-->
<p>La fonction <code>bind</code> dans ce scÃ©nario fonctionne comme la fonction <code>new</code> dans le
sens oÃ¹ elle retourne une nouvelle instance de <code>TcpListener</code>. La raison pour
laquelle cette fonction s'appelle <code>bind</code> <em>(NdT : signifie &quot;lier&quot;)</em> est que dans
le domaine des rÃ©seaux, se connecter Ã  un port se dit se â€œlier Ã  un portâ€.</p>
<!--
The `bind` function returns a `Result<T, E>`, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1023), so if
we tried to connect to port 80 without being an administrator, binding wouldnâ€™t
work. As another example, binding wouldnâ€™t work if we ran two instances of our
program and so had two programs listening to the same port. Because weâ€™re
writing a basic server just for learning purposes, we wonâ€™t worry about
handling these kinds of errors; instead, we use `unwrap` to stop the program if
errors happen.
-->
<p>La fonction <code>bind</code> retourne un <code>Result&lt;T, E&gt;</code>, ce qui signifie que la crÃ©ation
de lien peut Ã©chouer. Par exemple, la connexion au port 80 nÃ©cessite d'Ãªtre
administrateur (les utilisateurs non-administrateur ne peuvent Ã©couter que sur
les ports supÃ©rieurs Ã  1023), donc si nous essayons de connecter un port 80
sans Ãªtre administrateur, le lien ne va pas fonctionner. Pour donner un autre
exemple, le lien ne va pas fonctionner si nous exÃ©cutons deux instances de
notre programme et que nous avons deux programmes qui Ã©coutent sur le mÃªme
port. Comme nous Ã©crivons un serveur basique uniquement Ã  but pÃ©dagogique, nous
n'avons pas Ã  nous soucier de la gestion de ce genre d'erreurÂ ; c'est pourquoi
nous utilisons <code>unwrap</code> pour arrÃªter l'exÃ©cution du programme si des erreurs
surviennent.</p>
<!--
The `incoming` method on `TcpListener` returns an iterator that gives us a
sequence of streams (more specifically, streams of type `TcpStream`). A single
*stream* represents an open connection between the client and the server. A
*connection* is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, `TcpStream` will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this `for` loop will process each connection in turn and produce a series of
streams for us to handle.
-->
<p>La mÃ©thode <code>incoming</code> d'un <code>TcpListener</code> retourne l'itÃ©rateur qui nous donne une
sÃ©quence de flux (plus prÃ©cisÃ©ment, des flux de type <code>TcpStream</code>). Un seul
<em>flux</em> reprÃ©sente une connexion entre le client et le serveur. Une <em>connexion</em>
est le nom qui dÃ©signe le processus complet de requÃªte et de rÃ©ponse, durant
lequel le client se connecte au serveur, le serveur gÃ©nÃ¨re une rÃ©ponse puis le
serveur ferme la connexion. Ainsi, <code>TcpStream</code> va se lire lui-mÃªme pour voir ce
que le client a envoyÃ© et nous permettre ensuite d'Ã©crire notre rÃ©ponse dans le
flux. De maniÃ¨re gÃ©nÃ©rale, cette boucle <code>for</code> traitera l'une aprÃ¨s l'autre
chaque connexion dans l'ordre et produira une sÃ©rie de flux que nous devrons
gÃ©rer.</p>
<!--
For now, our handling of the stream consists of calling `unwrap` to terminate
our program if the stream has any errors; if there arenâ€™t any errors, the
program prints a message. Weâ€™ll add more functionality for the success case in
the next listing. The reason we might receive errors from the `incoming` method
when a client connects to the server is that weâ€™re not actually iterating over
connections. Instead, weâ€™re iterating over *connection attempts*. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.
-->
<p>Pour l'instant, notre gestion des flux consiste Ã  appeler <code>unwrap</code> pour arrÃªter
notre programme si le flux rencontre une erreurÂ ; s'il n'y a pas d'erreurs, le
programme affiche un message. Nous ajouterons davantage de fonctionnalitÃ©s en
cas de succÃ¨s dans le prochain encart. La raison pour laquelle nous pourrions
recevoir des erreurs de la mÃ©thode <code>incoming</code> lorsqu'un client se connecte au
serveur est qu'en rÃ©alitÃ© nous n'itÃ©rons pas sur les connexions. En effet, nous
itÃ©rons sur des <em>tentatives de connexion</em>. La connexion peut Ã©chouer pour de
nombreuses raisons, beaucoup d'entre elles sont spÃ©cifiques au systÃ¨me
d'exploitation. Par exemple, de nombreux systÃ¨mes d'exploitation ont une limite
sur le nombre de connexions ouvertes simultanÃ©ment qu'ils peuvent supporterÂ ;
les tentatives de nouvelles connexions une fois ce nombre dÃ©passÃ© produiront une
erreur jusqu'Ã  ce que certaines des connexions soient fermÃ©es.</p>
<!--
Letâ€™s try running this code! Invoke `cargo run` in the terminal and then load
*127.0.0.1:7878* in a web browser. The browser should show an error message
like â€œConnection reset,â€ because the server isnâ€™t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!
-->
<p>Essayons d'exÃ©cuter ce codeÂ ! Saisissez <code>cargo run</code> dans le terminal et ensuite
ouvrez <em>127.0.0.1:7878</em> dans un navigateur web. Le navigateur devrait afficher
un message d'erreur tel que â€œLa connexion a Ã©tÃ© rÃ©initialisÃ©eâ€, car le serveur ne
renvoie pas de donnÃ©es pour le moment. Mais si vous regardez le terminal, vous
devriez voir quelques messages qui se sont affichÃ©s lorsque le navigateur s'est
connectÃ© au serveurÂ !</p>
<!--
```text
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```
-->
<pre><code class="language-text">     Running `target/debug/salutations`
Connexion Ã©tablieÂ !
Connexion Ã©tablieÂ !
Connexion Ã©tablieÂ !
</code></pre>
<!--
Sometimes, youâ€™ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the *favicon.ico* icon that appears in the
browser tab.
-->
<p>Des fois, vous pourriez voir plusieurs messages s'afficher pour une seule
requÃªte du navigateurÂ ; la raison Ã  cela est peut-Ãªtre que le navigateur fait
une requÃªte pour la page ainsi que des requÃªtes pour d'autres ressources, comme
l'icone <em>favicon.ico</em> qui s'affiche dans l'onglet du navigateur.</p>
<!--
It could also be that the browser is trying to connect to the server multiple
times because the server isnâ€™t responding with any data. When `stream` goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the `drop` implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that weâ€™ve successfully gotten a handle to a TCP connection!
-->
<p>Peut-Ãªtre que le navigateur essaie aussi de se connecter plusieurs fois au
serveur car le serveur ne renvoie aucune donnÃ©e dans sa rÃ©ponse. Lorsque <code>flux</code>
sort de la portÃ©e et est nettoyÃ© Ã  la fin de la boucle, la connexion est fermÃ©e
car cela est implÃ©mentÃ© dans le <code>drop</code>. Les navigateurs rÃ©agissent Ã  ces
connexions fermÃ©es en rÃ©-essayant, car le problÃ¨me peut Ãªtre temporaire. La
partie importante est que nous avons obtenu avec succÃ¨s un manipulateur de
connexion TCPÂ !</p>
<!--
Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when youâ€™re done running a particular version of the code. Then restart `cargo
run` after youâ€™ve made each set of code changes to make sure youâ€™re running the
newest code.
-->
<p>Pensez Ã  arrÃªter le programme en appuyant sur
<span class="keystroke">ctrl-c</span> lorsque vous avez fini d'exÃ©cuter une
version donnÃ©e du code. Relancez ensuite <code>cargo run</code> aprÃ¨s avoir appliquÃ© une
sÃ©rie de modifications afin d'Ãªtre sÃ»r que vous exÃ©cutez bien la toute derniÃ¨re
version du code.</p>
<!--
### Reading the Request
-->
<h3 id="lire-la-requÃªte"><a class="header" href="#lire-la-requÃªte">Lire la requÃªte</a></h3>
<!--
Letâ€™s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, weâ€™ll start a new function for processing connections. In
this new `handle_connection` function, weâ€™ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.
-->
<p>CommenÃ§ons Ã  implÃ©menter la fonctionnalitÃ© permettant de lire la requÃªte du
navigateur ! Pour sÃ©parer les parties oÃ¹ nous obtenons une connexion de celle
oÃ¹ nous agissons avec la connexion, nous allons crÃ©er une nouvelle fonction
pour traiter les connexions. Dans cette nouvelle fonction <code>gestion_connexion</code>,
nous allons lire des donnÃ©es provenant du flux TCP et les afficher afin que
nous puissions voir les donnÃ©es envoyÃ©es par le navigateur. Changez le code
pour qu'il ressemble Ã  l'encart 20-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        gestion_connexion(flux);
    }
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    println!(&quot;RequÃªteÂ : {}&quot;, String::from_utf8_lossy(&amp;tampon[..]));
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-2: Reading from the `TcpStream` and printing
the data</span>
-->
<p><span class="caption">Encart 20-2Â : lecture du <code>TcpStream</code> et affichage des
donnÃ©es</span></p>
<!--
We bring `std::io::prelude` into scope to get access to certain traits that let
us read from and write to the stream. In the `for` loop in the `main` function,
instead of printing a message that says we made a connection, we now call the
new `handle_connection` function and pass the `stream` to it.
-->
<p>Nous avons importÃ© <code>std::io::prelude</code> dans la portÃ©e pour accÃ©der Ã  certains
traits qui nous permettent de lire et d'Ã©crire dans le flux. Dans la boucle
<code>for</code> de la fonction <code>main</code>, au lieu d'afficher un message qui dit que nous
avons Ã©tabli une connexion, nous faisons maintenant appel Ã  <code>gestion_connexion</code>
et nous lui passons le <code>flux</code>.</p>
<!--
In the `handle_connection` function, weâ€™ve made the `stream` parameter mutable.
The reason is that the `TcpStream` instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be `mut` because its
internal state might change; usually, we think of â€œreadingâ€ as not needing
mutation, but in this case we need the `mut` keyword.
-->
<p>Dans la fonction <code>gestion_connexion</code>, nous avons fait en sorte que le paramÃ¨tre
<code>flux</code> soit mutable. La raison Ã  cela est que l'instance de <code>TcpStream</code> garde
en mÃ©moire interne le suivi des donnÃ©es qu'il nous a retournÃ©es. Il peut lire
plus de donnÃ©es que nous en avons demandÃ©es et les conserver pour la prochaine
fois que nous en redemanderons. Il doit donc Ãªtre <code>mut</code> car son Ã©tat interne
doit pouvoir changerÂ ; d'habitude, nous n'avons pas besoin que la â€œlectureâ€
nÃ©cessite d'Ãªtre mutable, mais dans ce cas nous avons besoin du mot-clÃ© <code>mut</code>.</p>
<!--
Next, we need to actually read from the stream. We do this in two steps:
first, we declare a `buffer` on the stack to hold the data that is read in.
Weâ€™ve made the buffer 1024 bytes in size, which is big enough to hold the
data of a basic request and sufficient for our purposes in this chapter. If
we wanted to handle requests of an arbitrary size, buffer management would
need to be more complicated; weâ€™ll keep it simple for now. We pass the buffer
to `stream.read`, which will read bytes from the `TcpStream` and put them in
the buffer.
-->
<p>Ensuite, nous devons lire les donnÃ©es du flux. Nous faisons cela en deux
tempsÂ : d'abord, nous dÃ©clarons un <code>tampon</code> sur la pile pour y stocker les
donnÃ©es qui seront lues. Nous avons fait en sorte que le tampon fasse 1024
octets, ce qui est suffisamment grand pour stocker les donnÃ©es d'une requÃªte
basique, ce qui est suffisant pour nos besoins dans ce chapitre. Si nous
avions voulu gÃ©rer des requÃªtes de taille arbitraire, cette gestion du tampon
aurait Ã©tÃ© plus complexe ; nous allons la garder simpliste pour l'instant.
Nous envoyons le tampon dans <code>flux.read</code> qui va lire les octets provenant du
<code>TcpStream</code> et les ajouter dans le tampon.</p>
<!--
Second, we convert the bytes in the buffer to a string and print that string.
The `String::from_utf8_lossy` function takes a `&[u8]` and produces a `String`
from it. The â€œlossyâ€ part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with `ï¿½`, the `U+FFFD REPLACEMENT CHARACTER`. You might see replacement
characters for characters in the buffer that arenâ€™t filled by request data.
-->
<p>Ensuite, nous convertissons les octets prÃ©sents dans le tampon en chaÃ®nes de
caractÃ¨res et nous affichons cette chaÃ®ne de caractÃ¨res. La fonction
<code>String::from_utf8_lossy</code> prend en paramÃ¨tre un <code>&amp;[u8]</code> et le transforme en une
<code>String</code>. La partie â€œlossyâ€ du nom indique le comportement de cette fonction
lorsqu'elle rencontre une sÃ©quence UTF-8 invalideÂ : elle va remplacer la
sÃ©quence invalide par <code>ï¿½</code>, le caractÃ¨re <code>U+FFFD REPLACEMENT CHARACTER</code>. Vous
devriez voir ces caractÃ¨res de remplacement Ã  la place des caractÃ¨res du
tampon qui n'ont pas Ã©tÃ© renseignÃ©s par des donnÃ©es de requÃªte.</p>
<!--
Letâ€™s try this code! Start the program and make a request in a web browser
again. Note that weâ€™ll still get an error page in the browser, but our
programâ€™s output in the terminal will now look similar to this:
-->
<p>Essayons ce codeÂ ! DÃ©marrez le programme et faites Ã  nouveau une requÃªte dans
un navigateur web. Notez que nous obtenons toujours une page d'erreur dans le
navigateur web, mais que la sortie de notre programme dans le terminal devrait
ressembler Ã  ceciÂ :</p>
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/salutations`
RequÃªteÂ : GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
</code></pre>
<!--
Depending on your browser, you might get slightly different output. Now that
weâ€™re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after `Request: GET`. If the
repeated connections are all requesting */*, we know the browser is trying to
fetch */* repeatedly because itâ€™s not getting a response from our program.
-->
<p>En fonction de votre navigateur, vous pourriez voir une sortie lÃ©gÃ¨rement
diffÃ©rente. Maintenant que nous affichons les donnÃ©es des requÃªtes, nous
pouvons constater pourquoi nous obtenons plusieurs
connexions pour un seul chargement de page dans le navigateur web en analysant
le chemin aprÃ¨s le <code>RequÃªteÂ : GET</code>. Si les connexions rÃ©pÃ©tÃ©es sont toutes vers
<em>/</em>, nous pouvons constater que le navigateur essaye d'obtenir <em>/</em> Ã  rÃ©pÃ©tition
car il n'obtient pas de rÃ©ponse de la part de notre programme.</p>
<!--
Letâ€™s break down this request data to understand what the browser is asking of
our program.
-->
<p>DÃ©composons les donnÃ©es de cette requÃªte pour comprendre ce que le navigateur
demande Ã  notre programme.</p>
<!--
### A Closer Look at an HTTP Request
-->
<h3 id="une-analyse-plus-poussÃ©e-dune-requÃªte-http"><a class="header" href="#une-analyse-plus-poussÃ©e-dune-requÃªte-http">Une analyse plus poussÃ©e d'une requÃªte HTTP</a></h3>
<!--
HTTP is a text-based protocol, and a request takes this format:
-->
<p>HTTP est un protocole basÃ© sur du texte, et une requÃªte doit suivre cette
formeÂ :</p>
<!--
```text
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">MÃ©thode URI-DemandÃ©e Version-HTTP CRLF
entÃªtes CRLF
corps-du-message
</code></pre>
<!--
The first line is the *request line* that holds information about what the
client is requesting. The first part of the request line indicates the *method*
being used, such as `GET` or `POST`, which describes how the client is making
this request. Our client used a `GET` request.
-->
<p>La premiÃ¨re ligne est la <em>ligne de requÃªte</em> qui contient les informations sur
ce que demande le client. La premiÃ¨re partie de la ligne de requÃªte indique la
<em>mÃ©thode</em> utilisÃ©e, comme <code>GET</code> ou <code>POST</code>, qui dÃ©crit comment le client fait sa
requÃªte. Notre client a utilisÃ© une requÃªte <code>GET</code>.</p>
<!--
The next part of the request line is */*, which indicates the *Uniform Resource
Identifier* *(URI)* the client is requesting: a URI is almost, but not quite,
the same as a *Uniform Resource Locator* *(URL)*. The difference between URIs
and URLs isnâ€™t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.
-->
<p>La partie suivante de la ligne de requÃªte est <em>/</em>, qui indique <em>l'URI</em>
<em>(Uniform Resource Identifier)</em> que demande le clientÂ : une URI est presque,
mais pas complÃ¨tement, la mÃªme chose qu'une <em>URL</em> <em>(Uniform Resource Locator)</em>.
La diffÃ©rence entre les URI et les URL n'est pas trÃ¨s importante pour nous
dans ce chapitre, mais la spÃ©cification de HTTP utilise le terme URI,
donc, ici, nous pouvons simplement lire URL lÃ  oÃ¹ URI est Ã©crit.</p>
<!--
The last part is the HTTP version the client uses, and then the request line
ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,
which are terms from the typewriter days!) The CRLF sequence can also be
written as `\r\n`, where `\r` is a carriage return and `\n` is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than `\r\n`.
-->
<p>La derniÃ¨re partie est la version HTTP que le client utilise, puis la
ligne de requÃªte termine avec une <em>sÃ©quence CRLF</em> (CRLF signifie
<em>Carriage Return, retour chariot</em>, et <em>Line Feed, saut de ligne</em> qui sont des
termes qui remontent Ã  l'Ã©poque des machines Ã  Ã©crireÂ !). La sÃ©quence CRLF peut
aussi Ãªtre Ã©crite <code>\r\n</code>, dans laquelle <code>\r</code> est un retour chariot et <code>\n</code> est
un saut de ligne. La sÃ©quence CRLF sÃ©pare la ligne de requÃªte du reste des
donnÃ©es de la requÃªte. Notez toutefois que lorsqu'un CRLF est affichÃ©, nous
voyons une nouvelle ligne plutÃ´t qu'un <code>\r\n</code>.</p>
<!--
Looking at the request line data we received from running our program so far,
we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the
version.
-->
<p>D'aprÃ¨s la ligne de requÃªte que nous avons reÃ§ue aprÃ¨s avoir exÃ©cutÃ© notre
programme prÃ©cÃ©demment, nous constatons que la mÃ©thode est <code>GET</code>, <em>/</em> est l'URI
demandÃ©e et <code>HTTP/1.1</code> est la version.</p>
<!--
After the request line, the remaining lines starting from `Host:` onward are
headers. `GET` requests have no body.
-->
<p>AprÃ¨s la ligne de requÃªte, les lignes suivant celle oÃ¹ nous avons <code>Host:</code> sont
des entÃªtes. Les requÃªtes <code>GET</code> n'ont pas de corps.</p>
<!--
Try making a request from a different browser or asking for a different
address, such as *127.0.0.1:7878/test*, to see how the request data changes.
-->
<p>Essayez de faire une requÃªte dans un navigateur diffÃ©rent ou de demander une
adresse diffÃ©rente, telle que <em>127.0.0.1:7878/test</em>, afin d'observer comment les
donnÃ©es de requÃªte changent.</p>
<!--
Now that we know what the browser is asking for, letâ€™s send back some data!
-->
<p>Maintenant que nous savons ce que demande le navigateur, envoyons-lui quelques
donnÃ©esÂ !</p>
<!--
### Writing a Response
-->
<h3 id="ecrire-une-rÃ©ponse"><a class="header" href="#ecrire-une-rÃ©ponse">Ecrire une rÃ©ponse</a></h3>
<!--
Now weâ€™ll implement sending data in response to a client request. Responses
have the following format:
-->
<p>Maintenant, nous allons implÃ©menter l'envoi d'une rÃ©ponse Ã  une requÃªte client. Les
rÃ©ponses suivent le format suivantÂ :</p>
<!--
```text
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">Version-HTTP Code-Statut Phrase-De-Raison CRLF
entÃªtes CRLF
corps-message
</code></pre>
<!--
The first line is a *status line* that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.
-->
<p>La premiÃ¨re ligne est une <em>ligne de statut</em> qui contient la version HTTP
utilisÃ©e dans la rÃ©ponse, un code numÃ©rique de statut qui rÃ©sume le rÃ©sultat
de la requÃªte et une phrase de raison qui fournit une description textuelle du
code de statut. AprÃ¨s la sÃ©quence CRLF viennent tous les entÃªtes, une autre
sÃ©quence CRLF et enfin le corps de la rÃ©ponse.</p>
<!--
Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:
-->
<p>Voici un exemple de rÃ©ponse qui utilise HTTP version 1.1, a un code de
statut de 200, une phrase de raison Ã  OK, pas d'entÃªtes, et pas de corpsÂ :</p>
<!--
```text
HTTP/1.1 200 OK\r\n\r\n
```
-->
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<!--
The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Letâ€™s write this to the stream as our response to a
successful request! From the `handle_connection` function, remove the
`println!` that was printing the request data and replace it with the code in
Listing 20-3.
-->
<p>Le code de statut 200 est la rÃ©ponse standard de succÃ¨s. Le texte est une toute
petite rÃ©ponse HTTP de succÃ¨s. Ecrivons ceci dans le flux de notre rÃ©ponse Ã 
une requÃªte avec succÃ¨sÂ ! Dans la fonction <code>gestion_connexion</code>, enlevez le
<code>println!</code> qui affiche les donnÃ©es de requÃªte et remplacez-le par le code de
l'encart 20-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    let reponse = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span>
-->
<p><span class="caption">Encart 20-3Â : Ã©criture d'une toute petite rÃ©ponse HTTP de
rÃ©ussite dans le flux</span></p>
<!--
The first new line defines the `response` variable that holds the success
messageâ€™s data. Then we call `as_bytes` on our `response` to convert the string
data to bytes. The `write` method on `stream` takes a `&[u8]` and sends those
bytes directly down the connection.
-->
<p>La premiÃ¨re ligne dÃ©finit la variable <code>reponse</code> qui contient les donnÃ©es du
message de rÃ©ussite. Ensuite, nous faisons appel Ã  <code>as_bytes</code> sur notre
<code>reponse</code> pour convertir la chaÃ®ne de caractÃ¨res en octets. La mÃ©thode <code>write</code>
sur le <code>flux</code> prend en argument un <code>&amp;[u8]</code> et envoie ces octets directement
dans la connexion.</p>
<!--
Because the `write` operation could fail, we use `unwrap` on any error result
as before. Again, in a real application you would add error handling here.
Finally, `flush` will wait and prevent the program from continuing until all
the bytes are written to the connection; `TcpStream` contains an internal
buffer to minimize calls to the underlying operating system.
-->
<p>Comme l'opÃ©ration <code>write</code> peut Ã©chouer, nous utilisons <code>unwrap</code> sur toutes les
erreurs, comme prÃ©cÃ©demment. Encore une fois, dans un vÃ©ritable application,
vous devriez gÃ©rer les cas d'erreur ici. Enfin, <code>flush</code> va attendre et empÃªcher
le programme de continuer Ã  s'exÃ©cuter jusqu'Ã  ce que tous les octets soient
Ã©crits dans la connexionÂ ; <code>TcpStream</code> contient un tampon interne pour rÃ©duire
les appels au systÃ¨me d'exploitation concernÃ©.</p>
<!--
With these changes, letâ€™s run our code and make a request. Weâ€™re no longer
printing any data to the terminal, so we wonâ€™t see any output other than the
output from Cargo. When you load *127.0.0.1:7878* in a web browser, you should
get a blank page instead of an error. Youâ€™ve just hand-coded an HTTP request
and response!
-->
<p>Avec ces modifications, exÃ©cutons Ã  nouveau notre code et lanÃ§ons une requÃªte
dans le navigateur. Nous n'affichons plus les donnÃ©es dans le terminal, donc
nous ne voyons plus aucune sortie autre que celle de Cargo. Lorsque vous
chargez <em>127.0.0.1:7878</em> dans un navigateur web, vous devriez obtenir une page
blanche plutÃ´t qu'une erreur. Vous venez de coder en dur une rÃ©ponse Ã  une
requÃªte HTTPÂ !</p>
<!--
### Returning Real HTML
-->
<h3 id="retourner-du-vrai-html"><a class="header" href="#retourner-du-vrai-html">Retourner du vrai HTML</a></h3>
<!--
Letâ€™s implement the functionality for returning more than a blank page. Create
a new file, *hello.html*, in the root of your project directory, not in the
*src* directory. You can input any HTML you want; Listing 20-4 shows one
possibility.
-->
<p>ImplÃ©mentons la fonctionnalitÃ© permettant de retourner plus qu'une simple page
blanche. CrÃ©ez un nouveau fichier, <em>hello.html</em>, Ã  la racine de votre dossier
de projet, et pas dans le dossier <em>src</em>. Vous pouvez ajouter le HTML que vous
souhaitezÂ ; l'encart 20-4 vous montre une possibilitÃ©.</p>
<!--
<span class="filename">Filename: hello.html</span>
-->
<p><span class="filename">FichierÂ : hello.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1 id="hello"><a class="header" href="#hello">Hello!</a></h1>
    <p>Hi from Rust</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;SalutationsÂ !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;SalutÂ !&lt;/h1&gt;
    &lt;p&gt;Bonjour de la part de Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-4: A sample HTML file to return in a
response</span>
-->
<p><span class="caption">Encart 20-4Â : un exemple de fichier HTML Ã  retourner dans
une rÃ©ponse</span></p>
<!--
This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, weâ€™ll modify `handle_connection` as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.
-->
<p>Ceci est un document HTML5 minimal avec des entÃªtes et un peu de texte. Pour
retourner ceci Ã  partir d'un serveur lorsqu'une requÃªte est reÃ§ue, nous allons
modifier <code>gestion_connexion</code> comme proposÃ© dans l'encart 20-5 pour lire le
fichier HTML, l'ajouter dans la rÃ©ponse comme faisant partie de son corps, et
l'envoyer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
use std::fs;
// --snip--

# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let contents = fs::read_to_string("hello.html").unwrap();

    let response = format!(
        "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// -- partie masquÃ©e ici --

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let reponse = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-5: Sending the contents of *hello.html* as the
body of the response</span>
-->
<p><span class="caption">Encart 20-5Â : envoi du contenu de <em>hello.html</em> dans
le corps de la rÃ©ponse</span></p>
<!--
Weâ€™ve added a line at the top to bring the standard libraryâ€™s filesystem module
into scope. The code for reading the contents of a file to a string should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.
-->
<p>Nous avons ajoutÃ© une ligne en haut pour importer le module de systÃ¨me de
fichiers de la bibliothÃ¨que standard. Le code pour lire le contenu d'un fichier
dans une <code>String</code> devrait vous Ãªtre familierÂ ; nous l'avons utilisÃ© dans le
chapitre 12 lorsque nous lisions le contenu d'un fichier pour notre projet
d'entrÃ©e/sortie, dans l'encart 12-4.</p>
<!--
Next, we use `format!` to add the fileâ€™s contents as the body of the success
response. To ensure a valid HTTP response, we add the `Content-Length` header
which is set to the size of our response body, in this case the size of `hello.html`.
-->
<p>Ensuite, nous avons utilisÃ© <code>format!</code> pour ajouter le contenu du fichier comme
Ã©tant le corps de la rÃ©ponse avec succÃ¨s. Pour garantir que ce soit une rÃ©ponse
HTTP valide, nous avons ajoutÃ© l'entÃªte <code>Content-Length</code> qui dÃ©finit la taille
du corps de notre rÃ©ponse, qui dans ce cas est la taille de <code>hello.html</code>.</p>
<!--
Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; you
should see your HTML rendered!
-->
<p>ExÃ©cutez ce code avec <code>cargo run</code> et ouvrez <em>127.0.0.1:7878</em> dans votre
navigateur webÂ ; vous devriez voir le rÃ©sultat de votre HTMLÂ !</p>
<!--
Currently, weâ€™re ignoring the request data in `buffer` and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
*127.0.0.1:7878/something-else* in your browser, youâ€™ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to */*.
-->
<p>Pour le moment, nous ignorons les donnÃ©es de la requÃªte prÃ©sentes dans
<code>tampon</code> et nous renvoyons sans conditions le contenu du fichier HTML. Cela
signifie que si vous essayez de demander <em>127.0.0.1:7878/autre-chose</em> dans
votre navigateur web, vous obtiendrez la mÃªme rÃ©ponse HTML. Notre serveur est
trÃ¨s limitÃ©, et ne correspond pas Ã  ce que font la plupart des serveurs web.
Nous souhaitons dÃ©sormais personnaliser nos rÃ©ponses en fonction de la requÃªte
et ne renvoyer le fichier HTML que pour une requÃªte bien formatÃ©e faite Ã  <em>/</em>.</p>
<!--
### Validating the Request and Selectively Responding
-->
<h3 id="valider-la-requÃªte-et-rÃ©pondre-de-maniÃ¨re-sÃ©lective"><a class="header" href="#valider-la-requÃªte-et-rÃ©pondre-de-maniÃ¨re-sÃ©lective">Valider la requÃªte et rÃ©pondre de maniÃ¨re sÃ©lective</a></h3>
<!--
Right now, our web server will return the HTML in the file no matter what the
client requested. Letâ€™s add functionality to check that the browser is
requesting */* before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify `handle_connection`,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for */* looks like and adds `if` and
`else` blocks to treat requests differently.
-->
<p>Jusqu'Ã  prÃ©sent, notre serveur web retourne le HTML du fichier peu
importe ce que demande le client. Ajoutons une fonctionnalitÃ© pour vÃ©rifier que
le navigateur demande bien <em>/</em> avant de retourner le fichier HTML et retournons
une erreur si le navigateur demande autre chose. Pour cela, nous devons
modifier <code>gestion_connexion</code> comme dans l'encart 20-6. Ce nouveau code compare le
contenu de la requÃªte que nous recevons Ã  la requÃªte que nous attendrions pour
<em>/</em> et ajoute des blocs <code>if</code> et <code>else</code> pour traiter les requÃªtes de maniÃ¨re diffÃ©renciÃ©e.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";

    if buffer.starts_with(get) {
        let contents = fs::read_to_string("hello.html").unwrap();

        let response = format!(
            "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici --

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if tampon.starts_with(get) {
        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let reponse = format!(
            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
            contenu.len(),
            contenu
        );

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    } else {
        // autres requÃªtes
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-6: Matching the request and handling requests
to */* differently from other requests</span>
-->
<p><span class="caption">Encart 20-6Â : dÃ©tection et gestion des requÃªtes vers <em>/</em>
de maniÃ¨re diffÃ©renciÃ©e des autres requÃªtes</span></p>
<!--
First, we hardcode the data corresponding to the */* request into the `get`
variable. Because weâ€™re reading raw bytes into the buffer, we transform `get`
into a byte string by adding the `b""` byte string syntax at the start of the
content data. Then we check whether `buffer` starts with the bytes in `get`. If
it does, it means weâ€™ve received a well-formed request to */*, which is the
success case weâ€™ll handle in the `if` block that returns the contents of our
HTML file.
-->
<p>D'abord, nous codons en dur les donnÃ©es correspondant Ã  la requÃªte <em>/</em> dans la
variable <code>get</code>. Comme nous lisons des octets bruts provenant du tampon, nous
transformons <code>get</code> en une chaÃ®ne d'octets en ajoutant la syntaxe de chaÃ®ne
d'octets <code>b&quot;&quot;</code> au dÃ©but des donnÃ©es du contenu. Ensuite, nous vÃ©rifions que le
<code>tampon</code> commence par les mÃªmes octets que ceux prÃ©sents dans <code>get</code>. Si c'est
le cas, cela signifie que nous avons reÃ§u une requÃªte vers <em>/</em> correctement
formatÃ©e, qui est le cas de succÃ¨s que nous allons gÃ©rer dans le bloc <code>if</code> qui
retourne le contenu de notre fichier HTML.</p>
<!--
If `buffer` does *not* start with the bytes in `get`, it means weâ€™ve received
some other request. Weâ€™ll add code to the `else` block in a moment to respond
to all other requests.
-->
<p>Si <code>tampon</code> ne <em>commence pas</em> avec les octets prÃ©sents dans <code>get</code>, cela
signifie que nous avons reÃ§u une autre requÃªte. Nous allons bientÃ´t ajouter du
code au bloc <code>else</code> pour rÃ©pondre Ã  toutes ces autres requÃªtes.</p>
<!--
Run this code now and request *127.0.0.1:7878*; you should get the HTML in
*hello.html*. If you make any other request, such as
*127.0.0.1:7878/something-else*, youâ€™ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.
-->
<p>ExÃ©cutez ce code maintenant et demandez <em>127.0.0.1:7878</em>Â ; vous devriez obtenir
le HTML de <em>hello.html</em>. Si vous faites n'importe quelle autre requÃªte,
comme <em>127.0.0.1:7878/autre-chose</em>, vous allez obtenir une erreur de connexion
comme celle que vous avez vue lorsque vous exÃ©cutiez le code l'encart 20-1 et de
l'encart 20-2.</p>
<!--
Now letâ€™s add the code in Listing 20-7 to the `else` block to return a response
with the status code 404, which signals that the content for the request was
not found. Weâ€™ll also return some HTML for a page to render in the browser
indicating the response to the end user.
-->
<p>Maintenant ajoutons le code de l'encart 20-7 au bloc <code>else</code> pour retourner une
rÃ©ponse avec le code de statut 404, qui signale que le contenu demandÃ© par
cette requÃªte n'a pas Ã©tÃ© trouvÃ©. Nous allons aussi retourner du HTML pour qu'une
page s'affiche dans le navigateur, indiquant la rÃ©ponse Ã  l'utilisateur final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
#     if buffer.starts_with(get) {
#         let contents = fs::read_to_string("hello.html").unwrap();
# 
#         let response = format!(
#             "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
#             contents.len(),
#             contents
#         );
# 
#         stream.write(response.as_bytes()).unwrap();
#         stream.flush().unwrap();
    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();

        let response = format!(
            "{}\r\nContent-Length: {}\r\n\r\n{}",
            status_line,
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    if tampon.starts_with(get) {
</span><span class="boring">        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">        let reponse = format!(
</span><span class="boring">            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">            contenu.len(),
</span><span class="boring">            contenu
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">        flux.flush().unwrap();
</span>    // -- partie masquÃ©e ici --
    } else {
        let ligne_statut = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contenu = fs::read_to_string(&quot;404.html&quot;).unwrap();

        let reponse = format!(
            &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
            ligne_statut,
            contenu.len(),
            contenu
        );

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than */* was requested</span>
-->
<p><span class="caption">Encart 20-7Â : rÃ©pondre un code de statut 404 et une page
d'erreur lorsqu'autre chose que <em>/</em> a Ã©tÃ© demandÃ©</span></p>
<!--
Here, our response has a status line with status code 404 and the reason
phrase `NOT FOUND`. The body of the response will be the HTML in the file
*404.html*. Youâ€™ll need to create a *404.html* file next to *hello.html* for
the error page; again feel free to use any HTML you want or use the example
HTML in Listing 20-8.
-->
<p>Ici notre rÃ©ponse possÃ¨de une ligne de statut avec le code de statut 404 et la
phrase de raison <code>NOT FOUND</code>. Le corps de la rÃ©ponse sera le HTML prÃ©sent dans
le fichier <em>404.html</em>. Nous aurons besoin de crÃ©er un fichier <code>404.html</code> au
mÃªme endroit que <em>hello.html</em> pour la page d'erreur; de nouveau, n'hÃ©sitez pas
Ã  utiliser le HTML que vous souhaitez ou, Ã  dÃ©faut, utilisez le HTML d'exemple
prÃ©sent dans l'encart 20-8.</p>
<!--
<span class="filename">Filename: 404.html</span>
-->
<p><span class="filename">FichierÂ : 404.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1 id="oops"><a class="header" href="#oops">Oops!</a></h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;SalutationsÂ !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;OupsÂ !&lt;/h1&gt;
    &lt;p&gt;DÃ©solÃ©, je ne connaÃ®t pas ce que vous demandez.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span>
-->
<p><span class="caption">Encart 20-8Â : contenu d'exemple pour la page Ã  renvoyer
avec les rÃ©ponses 404</span></p>
<!--
With these changes, run your server again. Requesting *127.0.0.1:7878*
should return the contents of *hello.html*, and any other request, like
*127.0.0.1:7878/foo*, should return the error HTML from *404.html*.
-->
<p>Une fois ces modifications appliquÃ©es, exÃ©cutez Ã  nouveau votre serveur. Les
requÃªtes vers <em>127.0.0.1:7878</em> devraient retourner le contenu de
<em>hello.html</em> et toutes les autres requÃªtes, telle que
<em>127.0.0.1:7878/autre-chose</em>, devraient retourner le HTML d'erreur prÃ©sent dans
<em>404.html</em>.</p>
<!--
### A Touch of Refactoring
-->
<h3 id="un-peu-de-remaniement"><a class="header" href="#un-peu-de-remaniement">Un peu de remaniement</a></h3>
<!--
At the moment the `if` and `else` blocks have a lot of repetition: theyâ€™re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Letâ€™s make the code more
concise by pulling out those differences into separate `if` and `else` lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large `if` and `else` blocks.
-->
<p>Pour l'instant, les blocs <code>if</code> et <code>else</code> contiennent beaucoup de code rÃ©pÃ©tÃ©Â :
ils lisent tous les deux des fichiers et Ã©crivent le contenu de ces fichiers
dans le flux. La seule diffÃ©rence entre eux sont la ligne de statut et le nom
du fichier. Rendons le code plus concis en isolant ces diffÃ©rences dans des
lignes <code>if</code> et <code>else</code> qui vont assigner les valeurs de la ligne de statut et du
nom de fichier Ã  des variablesÂ ; nous pourrons ensuite utiliser ces variables
sans avoir Ã  nous prÃ©occuper du contexte dans le code qui va lire le fichier et
Ã©crire la rÃ©ponse. L'encart 20-9 montre le code rÃ©sultant aprÃ¨s remplacement des
gros blocs <code>if</code> et <code>else</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">FichierÂ : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquÃ©e ici--

fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masquÃ©e ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span>    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        ligne_statut,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-9: Refactoring the `if` and `else` blocks to
contain only the code that differs between the two cases</span>
-->
<p><span class="caption">Encart 20-9Â : remaniement des blocs <code>if</code> et <code>else</code> pour
qu'ils contiennent uniquement le code qui diffÃ©rencie les deux cas</span></p>
<!--
Now the `if` and `else` blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to `status_line` and `filename` using a pattern in the `let`
statement, as discussed in Chapter 18.
-->
<p>Maintenant que les blocs <code>if</code> et <code>else</code> retournent uniquement les valeurs
correctes pour la ligne de statut et le nom du fichier dans un tuple, nous
pouvons utiliser la dÃ©structuration pour assigner ces deux valeurs Ã 
<code>ligne_statut</code> et <code>nom_fichier</code> en utilisant un motif dans l'instruction <code>let</code>,
comme nous l'avons vu dans le chapitre 18.</p>
<!--
The previously duplicated code is now outside the `if` and `else` blocks and
uses the `status_line` and `filename` variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.
-->
<p>Le code prÃ©cÃ©dent qui Ã©tait en double se trouve maintenant Ã  l'extÃ©rieur des
blocs <code>if</code> et <code>else</code> et utilise les variables <code>ligne_statut</code> et <code>nom_fichier</code>.
Cela permet de mettre en Ã©vidence plus facilement les diffÃ©rences entre les
deux cas, et cela signifie que nous n'avons qu'un seul endroit du code Ã 
modifier si nous souhaitons changer le fonctionnement de lecture du fichier et
d'Ã©criture de la rÃ©ponse. Le comportement du code de l'encart 20-9 devrait Ãªtre
identique Ã  celui de l'encart 20-8.</p>
<!--
Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.
-->
<p>SuperÂ ! Nous avons maintenant un serveur web simple qui tient dans environ 40
lignes de code, qui rÃ©pond Ã  une requÃªte prÃ©cise par une page de contenu et
rÃ©pond Ã  toutes les autres avec une rÃ©ponse 404.</p>
<!--
Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Letâ€™s examine how that can be a problem by simulating some
slow requests. Then weâ€™ll fix it so our server can handle multiple requests at
once.
-->
<p>Actuellement, notre serveur fonctionne dans une seule tÃ¢che, ce qui signifie
qu'il ne peut rÃ©pondre qu'Ã  une seule requÃªte Ã  la fois. Examinons maintenant
Ã  quel point cela peut Ãªtre un problÃ¨me en simulant des rÃ©ponses lentes Ã  des
requÃªtes. Ensuite, nous corrigerons notre serveur pour qu'il puisse gÃ©rer
plusieurs requÃªtes Ã  la fois.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-final-project-a-web-server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch20-02-multithreaded.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-final-project-a-web-server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch20-02-multithreaded.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
