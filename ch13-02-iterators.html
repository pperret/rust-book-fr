<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traiter une s√©rie d&#x27;√©l√©ments avec un it√©rateur - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html" class="active"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Processing a Series of Items with Iterators
-->
<h2 id="traiter-une-s√©rie-d√©l√©ments-avec-un-it√©rateur"><a class="header" href="#traiter-une-s√©rie-d√©l√©ments-avec-un-it√©rateur">Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></h2>
<!--
The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don‚Äôt
have to reimplement that logic yourself.
-->
<p>Les it√©rateurs vous permettent d'effectuer une t√¢che sur une s√©quence d'√©l√©ments
√† tour de r√¥le. Un <em>it√©rateur</em> est responsable de la logique d'it√©ration sur
chaque √©l√©ment et de d√©terminer lorsque la s√©quence est termin√©e. Lorsque nous
utilisons des it√©rateurs, nous n'avons pas besoin de r√©-impl√©menter cette
logique nous-m√™mes.</p>
<!--
In Rust, iterators are *lazy*, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector `v1` by calling
the `iter` method defined on `Vec<T>`. This code by itself doesn‚Äôt do anything
useful.
-->
<p>En Rust, un it√©rateur est <em>une √©valuation paresseuse</em>, ce qui signifie qu'il n'a
aucun effet jusqu'√† ce que nous appelions des m√©thodes qui consomment
l'it√©rateur pour l'utiliser. Par exemple, le code dans l'encart 13-13 cr√©e un
it√©rateur sur les √©l√©ments du vecteur <code>v1</code> en appelant la m√©thode <code>iter</code> d√©finie
sur <code>Vec&lt;T&gt;</code>. Ce code en lui-m√™me ne fait rien d'utile.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-13: Creating an iterator</span>
-->
<p><span class="caption">Encart 13-13¬†: cr√©ation d'un it√©rateur</span></p>
<!--
Once we‚Äôve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with `for` loops to execute some code on
each item, although we glossed over what the call to `iter` did until now.
-->
<p>Une fois que nous avons cr√©√© un it√©rateur, nous pouvons l'utiliser de diverses
mani√®res. Dans l'encart 3-4 du chapitre 3, nous avions utilis√© des it√©rateurs
avec des boucles <code>for</code> pour ex√©cuter du code sur chaque √©l√©ment, bien que nous
ayons laiss√© de c√¥t√© ce que l'appel √† <code>iter</code> faisait jusqu'√† pr√©sent.</p>
<!--
The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the `for` loop. The iterator is stored in the `v1_iter`
variable, and no iteration takes place at that time. When the `for` loop is
called using the iterator in `v1_iter`, each element in the iterator is used in
one iteration of the loop, which prints out each value.
-->
<p>L'exemple dans l'encart 13-14 s√©pare la cr√©ation de l'it√©rateur de son
utilisation dans la boucle <code>for</code>. L'it√©rateur est stock√© dans la variable
<code>v1_iter</code>, et aucune it√©ration n'a lieu √† ce moment-l√†. Lorsque la boucle <code>for</code>
est appel√©e en utilisant l'it√©rateur <code>v1_iter</code>, chaque √©l√©ment de l'it√©rateur
est utilis√© √† chaque it√©ration de la boucle, qui affiche chaque valeur.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;On a¬†: {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-14: Using an iterator in a `for` loop</span>
-->
<p><span class="caption">Encart 13-14¬†: utilisation d'un it√©rateur dans une boucle
<code>for</code></span></p>
<!--
In languages that don‚Äôt have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.
-->
<p>Dans les langages qui n'ont pas d'it√©rateurs fournis par leur biblioth√®que
standard, nous √©cririons probablement cette m√™me fonctionnalit√© en d√©marrant une
variable √† l'indice 0, en utilisant cette variable comme indice sur le vecteur afin
d'obtenir une valeur puis en incr√©mentant la valeur de cette variable dans une boucle
jusqu'√† ce qu'elle atteigne le nombre total d'√©l√©ments dans le vecteur.</p>
<!--
Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let‚Äôs examine how iterators do that.
-->
<p>Les it√©rateurs s'occupent de toute cette logique pour nous, r√©duisant le code
redondant dans lequel nous pourrions potentiellement faire des erreurs. Les
it√©rateurs nous donnent plus de flexibilit√© pour utiliser la m√™me logique avec
de nombreux types de s√©quences diff√©rentes, et pas seulement avec des
structures de donn√©es avec lesquelles nous pouvons utiliser des indices, telles que
les vecteurs. Voyons comment les it√©rateurs font cela.</p>
<!--
### The `Iterator` Trait and the `next` Method
-->
<h3 id="le-trait-iterator-et-la-m√©thode-next"><a class="header" href="#le-trait-iterator-et-la-m√©thode-next">Le trait <code>Iterator</code> et la m√©thode <code>next</code></a></h3>
<!--
All iterators implement a trait named `Iterator` that is defined in the
standard library. The definition of the trait looks like this:
-->
<p>Tous les it√©rateurs impl√©mentent un trait appel√© <code>Iterator</code> qui est d√©fini dans
la biblioth√®que standard. La d√©finition du trait ressemble √† ceci¬†:</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // les m√©thodes avec des impl√©mentations par d√©faut ont √©t√© exclues
}
<span class="boring">}
</span></code></pre></pre>
<!--
Notice this definition uses some new syntax: `type Item` and `Self::Item`,
which are defining an *associated type* with this trait. We‚Äôll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the `Iterator` trait requires that you also define
an `Item` type, and this `Item` type is used in the return type of the `next`
method. In other words, the `Item` type will be the type returned from the
iterator.
-->
<p>Remarquez que cette d√©finition utilise une nouvelle syntaxe¬†: <code>type Item</code> et
<code>Self::Item</code>, qui d√©finissent un <em>type associ√©</em> √† ce trait. Nous verrons ce que
sont les types associ√©s au chapitre 19. Pour l'instant, tout ce que vous devez
savoir est que ce code dit que l'impl√©mentation du trait <code>Iterator</code> n√©cessite
que vous d√©finissiez aussi un type <code>Item</code>, et ce type <code>Item</code> est utilis√© dans le
type de retour de la m√©thode <code>next</code>. En d'autres termes, le type <code>Item</code> sera le
type retourn√© par l'it√©rateur.</p>
<!--
The `Iterator` trait only requires implementors to define one method: the
`next` method, which returns one item of the iterator at a time wrapped in
`Some` and, when iteration is over, returns `None`.
-->
<p>Le trait <code>Iterator</code> exige la d√©finition d'une seule m√©thode par les
d√©veloppeurs¬†: la m√©thode <code>next</code>, qui retourne un √©l√©ment de l'it√©rateur √† la
fois int√©gr√© dans un <code>Some</code>, et lorsque l'it√©ration est termin√©e, il retourne
<code>None</code>.</p>
<!--
We can call the `next` method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to `next` on the iterator created
from the vector.
-->
<p>On peut appeler la m√©thode <code>next</code> directement sur les it√©rateurs¬†; l'encart
13-15 montre quelles valeurs sont retourn√©es par des appels r√©p√©t√©s √† <code>next</code> sur
l'it√©rateur cr√©√© √† partir du vecteur.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn demo_iterateur() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-15: Calling the `next` method on an
iterator</span>
-->
<p><span class="caption">Encart 13-15¬†: appel de la m√©thode <code>next</code> sur un it√©rateur
</span></p>
<!--
Note that we needed to make `v1_iter` mutable: calling the `next` method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code *consumes*, or uses up, the
iterator. Each call to `next` eats up an item from the iterator. We didn‚Äôt need
to make `v1_iter` mutable when we used a `for` loop because the loop took
ownership of `v1_iter` and made it mutable behind the scenes.
-->
<p>Remarquez que nous avons eu besoin de rendre mutable <code>v1_iter</code>¬†: appeler la
m√©thode <code>next</code> sur un iterator change son √©tat interne qui garde en m√©moire l'endroit
o√π il en est dans la s√©quence. En d'autres termes, ce code <em>consomme</em>, ou utilise,
l'it√©rateur. Chaque appel √† <code>next</code> consomme un √©l√©ment de l'it√©rateur. Nous
n'avions pas eu besoin de rendre mutable <code>v1_iter</code> lorsque nous avions utilis√©
une boucle <code>for</code> parce que la boucle avait pris possession de <code>v1_iter</code> et l'avait
rendu mutable en coulisses.</p>
<!--
Also note that the values we get from the calls to `next` are immutable
references to the values in the vector. The `iter` method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of `v1` and returns owned values, we can call `into_iter` instead of
`iter`. Similarly, if we want to iterate over mutable references, we can call
`iter_mut` instead of `iter`.
-->
<p>Notez √©galement que les valeurs que nous obtenons des appels √† <code>next</code> sont des
r√©f√©rences immuables aux valeurs dans le vecteur. La m√©thode <code>iter</code> produit un
it√©rateur pour des r√©f√©rences immuables. Si nous voulons cr√©er un it√©rateur qui
prend possession de <code>v1</code> et retourne les valeurs poss√©d√©es, nous pouvons appeler
<code>into_iter</code> au lieu de <code>iter</code>. De m√™me, si nous voulons it√©rer sur des
r√©f√©rences mutables, nous pouvons appeler <code>iter_mut</code> au lieu de <code>iter</code>.</p>
<!--
### Methods that Consume the Iterator
-->
<h3 id="les-m√©thodes-qui-consomment-un-it√©rateur"><a class="header" href="#les-m√©thodes-qui-consomment-un-it√©rateur">Les m√©thodes qui consomment un it√©rateur</a></h3>
<!--
The `Iterator` trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the `Iterator`
trait. Some of these methods call the `next` method in their definition, which
is why you‚Äôre required to implement the `next` method when implementing the
`Iterator` trait.
-->
<p>Le trait <code>Iterator</code> a un certain nombre de m√©thodes diff√©rentes avec des
impl√©mentations par d√©faut que nous fournit la biblioth√®que standard¬†; vous
pouvez d√©couvrir ces m√©thodes en regardant dans la documentation de l'API de la
biblioth√®que standard pour le trait <code>Iterator</code>. Certaines de ces m√©thodes
appellent la m√©thode <code>next</code> dans leur d√©finition, c'est pourquoi nous devons
toujours impl√©menter la m√©thode <code>next</code> lors de l'impl√©mentation du trait
<code>Iterator</code>.</p>
<!--
Methods that call `next` are called *consuming adaptors*, because calling them
uses up the iterator. One example is the `sum` method, which takes ownership of
the iterator and iterates through the items by repeatedly calling `next`, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the `sum` method:
-->
<p>Les m√©thodes qui appellent <code>next</code> sont appel√©es des
<em>adaptateurs de consommation</em>, parce que les appeler consomme l'it√©rateur. Un
exemple est la m√©thode <code>sum</code>, qui prend possession de l'it√©rateur et it√©re sur
ses √©l√©ments en appelant plusieurs fois <code>next</code>, consommant ainsi l'it√©rateur. A
chaque √©tape de l'it√©ration, il ajoute chaque √©l√©ment √† un total en cours et
retourne le total une fois l'it√©ration termin√©e. L'encart 13-16 a un test
illustrant une utilisation de la m√©thode <code>sum</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-16: Calling the `sum` method to get the total
of all items in the iterator</span>
-->
<p><span class="caption">Encart 13-16¬†: appel de la m√©thode <code>sum</code> pour obtenir la
somme de tous les √©l√©ments pr√©sents dans l'it√©rateur</span></p>
<!--
We aren‚Äôt allowed to use `v1_iter` after the call to `sum` because `sum` takes
ownership of the iterator we call it on.
-->
<p>Nous ne sommes pas autoris√©s √† utiliser <code>v1_iter</code> apr√®s l'appel √† <code>sum</code> car
<code>sum</code> a pris possession de l'it√©rateur avec lequel nous l'appelons.</p>
<!--
### Methods that Produce Other Iterators
-->
<h3 id="m√©thodes-qui-produisent-dautres-it√©rateurs"><a class="header" href="#m√©thodes-qui-produisent-dautres-it√©rateurs">M√©thodes qui produisent d'autres it√©rateurs</a></h3>
<!--
Other methods defined on the `Iterator` trait, known as *iterator adaptors*,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.
-->
<p>D'autres m√©thodes d√©finies sur le trait <code>Iterator</code>, connues sous le nom
<em>d'adaptateurs d'it√©ration</em>, nous permettent de transformer un it√©rateur en un
type d'it√©rateur diff√©rent. Nous pouvons encha√Æner plusieurs appels √† des
adaptateurs d'it√©ration pour effectuer des actions complexes de mani√®re
compr√©hensible. Mais comme les it√©rateurs sont <em>des √©valuations paresseuses</em>,
nous devons faire appel √† l'une des m√©thodes d'adaptation de consommation pour
obtenir les r√©sultats des appels aux adaptateurs d'it√©ration.</p>
<!--
Listing 13-17 shows an example of calling the iterator adaptor method `map`,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:
-->
<p>L'encart 13-17 montre un exemple d'appel √† la m√©thode d'adaptation d'it√©ration
<code>map</code>, qui prend en param√®tre une fermeture qui va s'ex√©cuter sur chaque √©l√©ment
pour produire un nouvel it√©rateur. La fermeture cr√©e ici un nouvel it√©rateur
dans lequel chaque √©l√©ment du vecteur a √©t√© incr√©ment√© de 1. Cependant, ce code
d√©clenche un avertissement¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,not_desired_behavior
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
# }
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-17: Calling the iterator adaptor `map` to
create a new iterator</span>
-->
<p><span class="caption">Encart 13-17¬†: appel de l'adaptateur d'it√©ration <code>map</code>
pour cr√©er un nouvel it√©rateur</span></p>
<!--
The warning we get is this:
-->
<p>Voici l'avertissement que nous obtenons¬†:</p>
<!--
```console
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 -- > src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin "iterators") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```
-->
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<!--
The code in Listing 13-17 doesn‚Äôt do anything; the closure we‚Äôve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.
-->
<p>Le code dans l'encart 13-17 ne fait rien¬†; la fermeture que nous avons renseign√©e
n'est jamais ex√©cut√©e. L'avertissement nous rappelle pourquoi¬†: les adaptateurs
d'it√©ration sont des <em>√©valuations paresseuses</em>, c'est pourquoi nous devons
consommer l'it√©rateur ici.</p>
<!--
To fix this and consume the iterator, we‚Äôll use the `collect` method, which we
used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.
-->
<p>Pour corriger ceci et consommer l'it√©rateur, nous utiliserons la m√©thode
<code>collect</code>, que vous avez utilis√© avec <code>env::args</code> dans l'encart 12-1 du
chapitre 12. Cette m√©thode consomme l'it√©rateur et collecte les valeurs
r√©sultantes dans un type de collection de donn√©es.</p>
<!--
In Listing 13-18, we collect the results of iterating over the iterator that‚Äôs
returned from the call to `map` into a vector. This vector will end up
containing each item from the original vector incremented by 1.
-->
<p>Dans l'encart 13-18, nous recueillons les r√©sultats de l'it√©ration sur
l'it√©rateur qui sont retourn√©s par l'appel √† <code>map</code> sur un vecteur. Ce vecteur
finira par contenir chaque √©l√©ment du vecteur original incr√©ment√© de 1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-18: Calling the `map` method to create a new
iterator and then calling the `collect` method to consume the new iterator and
create a vector</span>
-->
<p><span class="caption">Encart 13-18¬†: appel de la m√©thode <code>map</code> pour cr√©er un
nouvel it√©rateur, puis appel de la m√©thode <code>collect</code> pour consommer le nouvel
it√©rateur afin de cr√©er un vecteur</span></p>
<!--
Because `map` takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the `Iterator` trait
provides.
-->
<p>Comme <code>map</code> prend en param√®tre une fermeture, nous pouvons renseigner n'importe
quelle op√©ration que nous souhaitons ex√©cuter sur chaque √©l√©ment. C'est un bon
exemple de la fa√ßon dont les fermetures nous permettent de personnaliser
certains comportements tout en r√©utilisant le comportement d'it√©ration fourni
par le trait <code>Iterator</code>.</p>
<!--
### Using Closures that Capture Their Environment
-->
<h3 id="utilisation-de-fermetures-capturant-leur-environnement"><a class="header" href="#utilisation-de-fermetures-capturant-leur-environnement">Utilisation de fermetures capturant leur environnement</a></h3>
<!--
Now that we‚Äôve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the `filter` iterator adaptor.
The `filter` method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns `true`, the value
will be included in the iterator produced by `filter`. If the closure returns
`false`, the value won‚Äôt be included in the resulting iterator.
-->
<p>Maintenant que nous avons pr√©sent√© les it√©rateurs, nous pouvons illustrer une
utilisation commune des fermetures qui capturent leur environnement en utilisant
l'adaptateur d'it√©ration <code>filter</code>. La m√©thode <code>filter</code> appel√©e sur un it√©rateur
prend en param√®tre une fermeture qui s'ex√©cute sur chaque √©l√©ment de l'it√©rateur
et retourne un bool√©en pour chacun. Si la fermeture retourne <code>true</code>, la valeur
sera incluse dans l'it√©rateur produit par <code>filter</code>. Si la fermeture retourne
<code>false</code>, la valeur ne sera pas incluse dans l'it√©rateur r√©sultant.</p>
<!--
In Listing 13-19, we use `filter` with a closure that captures the `shoe_size`
variable from its environment to iterate over a collection of `Shoe` struct
instances. It will return only shoes that are the specified size.
-->
<p>Dans l'encart 13-19, nous utilisons <code>filter</code> avec une fermeture qui capture la
variable <code>pointure_chaussure</code> de son environnement pour it√©rer sur une
collection d'instances de la structure <code>Chaussure</code>. Il ne retournera que les
chaussures avec la pointure demand√©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```
-->
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Chaussure {
    pointure: u32,
    style: String,
}

fn chaussures_a_la_pointure(chaussures: Vec&lt;Chaussure&gt;, pointure_chaussure: u32) -&gt; Vec&lt;Chaussure&gt; {
    chaussures.into_iter()
              .filter(|s| s.pointure == pointure_chaussure)
              .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filtres_par_pointure() {
        let chaussures = vec![
            Chaussure {
                pointure: 10,
                style: String::from(&quot;baskets&quot;),
            },
            Chaussure {
                pointure: 13,
                style: String::from(&quot;sandale&quot;),
            },
            Chaussure {
                pointure: 10,
                style: String::from(&quot;bottes&quot;),
            },
        ];

        let a_ma_pointure = chaussures_a_la_pointure(chaussures, 10);

        assert_eq!(
            a_ma_pointure,
            vec![
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;baskets&quot;)
                },
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;bottes&quot;)
                },
            ]
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-19: Using the `filter` method with a closure
that captures `shoe_size`</span>
-->
<p><span class="caption">Encart 13-19¬†: utilisation de la m√©thode <code>filter</code> avec une
fermeture capturant <code>pointure_chaussure</code></span></p>
<!--
The `shoes_in_size` function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.
-->
<p>La fonction <code>chaussures_a_la_pointure</code> prend possession d'un vecteur de
chaussures et d'une pointure comme param√®tres. Il retourne un vecteur contenant
uniquement des chaussures de la pointure demand√©e.</p>
<!--
In the body of `shoes_in_size`, we call `into_iter` to create an iterator
that takes ownership of the vector. Then we call `filter` to adapt that
iterator into a new iterator that only contains elements for which the closure
returns `true`.
-->
<p>Dans le corps de <code>chaussures_a_la_pointure</code>, nous appelons <code>into_iter</code> pour
cr√©er un it√©rateur qui prend possession du vecteur. Ensuite, nous appelons
<code>filter</code> pour adapter cet it√©rateur dans un nouvel it√©rateur qui ne contient que
les √©l√©ments pour lesquels la fermeture retourne <code>true</code>.</p>
<!--
The closure captures the `shoe_size` parameter from the environment and
compares the value with each shoe‚Äôs size, keeping only shoes of the size
specified. Finally, calling `collect` gathers the values returned by the
adapted iterator into a vector that‚Äôs returned by the function.
-->
<p>La fermeture capture le param√®tre <code>pointure_chaussure</code> de l'environnement et
compare la valeur avec la pointure de chaque chaussure, en ne gardant que les
chaussures de la pointure sp√©cifi√©e. Enfin, l'appel √† <code>collect</code> retourne un
vecteur qui regroupe les valeurs renvoy√©es par l'it√©rateur.</p>
<!--
The test shows that when we call `shoes_in_size`, we get back only shoes
that have the same size as the value we specified.
-->
<p>Le test confirme que lorsque nous appelons <code>chaussures_a_la_pointure</code>, nous
n'obtenons que des chaussures qui ont la m√™me pointure que la valeur que nous
avons demand√©e.</p>
<!--
### Creating Our Own Iterators with the `Iterator` Trait
-->
<h3 id="cr√©er-nos-propres-it√©rateurs-avec-le-trait-iterator"><a class="header" href="#cr√©er-nos-propres-it√©rateurs-avec-le-trait-iterator">Cr√©er nos propres it√©rateurs avec le trait <code>Iterator</code></a></h3>
<!--
We‚Äôve shown that you can create an iterator by calling `iter`, `into_iter`, or
`iter_mut` on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the `Iterator` trait on your own
types. As previously mentioned, the only method you‚Äôre required to provide a
definition for is the `next` method. Once you‚Äôve done that, you can use all
other methods that have default implementations provided by the `Iterator`
trait!
-->
<p>Nous avons vu que nous pouvons cr√©er un it√©rateur en appelant <code>iter</code>,
<code>into_iter</code> ou <code>iter_mut</code> sur un vecteur. Nous pouvons cr√©er des it√©rateurs √†
partir d'autres types de collections de la biblioth√®que standard, comme les
tables de hachage. Nous pouvons aussi cr√©er des it√©rateurs qui font tout ce que
nous voulons en impl√©mentant le trait <code>Iterator</code> sur nos propres types. Comme
nous l'avons mentionn√© pr√©c√©demment, la seule m√©thode pour laquelle nous devons
fournir une d√©finition est la m√©thode <code>next</code>. Une fois que nous avons fait cela,
nous pouvons utiliser toutes les autres m√©thodes qui ont des impl√©mentations par
d√©faut fournies par le trait <code>Iterator</code>¬†!</p>
<!--
To demonstrate, let‚Äôs create an iterator that will only ever count from 1 to 5.
First, we‚Äôll create a struct to hold some values. Then we‚Äôll make this struct
into an iterator by implementing the `Iterator` trait and using the values in
that implementation.
-->
<p>Pour preuve, cr√©ons un it√©rateur qui ne comptera que de 1 √† 5. D'abord, nous
allons cr√©er une structure contenant quelques valeurs. Ensuite nous
transformerons cette structure en it√©rateur en impl√©mentant le trait <code>Iterator</code>
et nous utiliserons les valeurs de cette impl√©mentation.</p>
<!--
Listing 13-20 has the definition of the `Counter` struct and an associated
`new` function to create instances of `Counter`:
-->
<p>L'encart 13-20 montre la d√©finition de la structure <code>Compteur</code> et une fonction
associ√©e <code>new</code> pour cr√©er des instances de <code>Compteur</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```
-->
<pre><code class="language-rust noplayground">struct Compteur {
    compteur: u32,
}

impl Compteur {
    fn new() -&gt; Compteur {
        Compteur { compteur: 0 }
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-20: Defining the `Counter` struct and a `new`
function that creates instances of `Counter` with an initial value of 0 for
`count`</span>
-->
<p><span class="caption">Encart 13-20¬†: d√©finition de la structure <code>Compteur</code> et
d'une fonction <code>new</code> qui cr√©e des instances de <code>Compteur</code> avec une valeur
initiale de 0 pour le champ <code>compteur</code>.</span></p>
<!--
The `Counter` struct has one field named `count`. This field holds a `u32`
value that will keep track of where we are in the process of iterating from 1
to 5. The `count` field is private because we want the implementation of
`Counter` to manage its value. The `new` function enforces the behavior of
always starting new instances with a value of 0 in the `count` field.
-->
<p>La structure <code>Compteur</code> a un champ <code>compteur</code>. Ce champ contient une valeur
<code>u32</code> qui gardera la trace de l'endroit o√π nous sommes dans le processus
d'it√©ration de 1 √† 5. Le champ <code>compteur</code> est priv√© car nous voulons que ce soit
l'impl√©mentation de <code>Compteur</code> qui g√®re sa valeur. La fonction <code>new</code> impose de
toujours d√©marrer de nouvelles instances avec une valeur de 0 pour le champ
<code>compteur</code>.</p>
<!--
Next, we‚Äôll implement the `Iterator` trait for our `Counter` type by defining
the body of the `next` method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:
-->
<p>Ensuite, nous allons impl√©menter le trait <code>Iterator</code> sur notre type <code>Compteur</code>
en d√©finissant le corps de la m√©thode <code>next</code> pour pr√©ciser ce que nous voulons
qu'il se passe quand cet it√©rateur est utilis√©, comme dans l'encart 13-21¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.compteur &lt; 5 {
            self.compteur += 1;
            Some(self.compteur)
        } else {
            None
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-21: Implementing the `Iterator` trait on our
`Counter` struct</span>
-->
<p><span class="caption">Encart 13-21¬†: impl√©mentation du trait <code>Iterator</code> sur
notre structure <code>Compteur</code></span></p>
<!--
We set the associated `Item` type for our iterator to `u32`, meaning the
iterator will return `u32` values. Again, don‚Äôt worry about associated types
yet, we‚Äôll cover them in Chapter 19.
-->
<p>Nous avons d√©fini le type associ√© <code>Item</code> pour notre it√©rateur √† <code>u32</code>, ce qui
signifie que l'it√©rateur renverra des valeurs <code>u32</code>. Encore une fois, ne vous
pr√©occupez pas des types associ√©s, nous les aborderons au chapitre 19.</p>
<!--
We want our iterator to add 1 to the current state, so we initialized `count`
to 0 so it would return 1 first. If the value of `count` is less than 5, `next`
will increment `count` and return the current value wrapped in `Some`. Once
`count` is 5, our iterator will stop incrementing `count` and always return
`None`.
-->
<p>Nous voulons que notre it√©rateur ajoute 1 √† l'√©tat courant, donc nous avons
initialis√© <code>compteur</code> √† 0 pour qu'il retourne 1 lors du premier appel √† <code>next</code>.
Si la valeur de <code>compteur</code> est strictement inf√©rieure √† 5, <code>next</code> va incr√©menter
<code>compteur</code> puis va retourner la valeur courante int√©gr√©e dans un <code>Some</code>. Une fois
que <code>compteur</code> vaudra 5, notre it√©rateur va arr√™ter d'incr√©menter <code>compteur</code> et
retournera toujours <code>None</code>.</p>
<!--
#### Using Our `Counter` Iterator‚Äôs `next` Method
-->
<h3 id="utiliser-la-m√©thode-next-de-notre-it√©rateur-compteur"><a class="header" href="#utiliser-la-m√©thode-next-de-notre-it√©rateur-compteur">Utiliser la m√©thode <code>next</code> de notre It√©rateur <code>Compteur</code></a></h3>
<!--
Once we‚Äôve implemented the `Iterator` trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
`Counter` struct by calling the `next` method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.
-->
<p>Une fois que nous avons impl√©ment√© le trait <code>Iterator</code>, nous avons un
it√©rateur¬†! L'encart 13-22 montre un test d√©montrant que nous pouvons utiliser
la fonctionnalit√© d'it√©ration de notre structure <code>Compteur</code> en appelant
directement la m√©thode <code>next</code>, comme nous l'avons fait avec l'it√©rateur cr√©√© √†
partir d'un vecteur dans l'encart 13-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_direct_a_next() {
        let mut compteur = Compteur::new();

        assert_eq!(compteur.next(), Some(1));
        assert_eq!(compteur.next(), Some(2));
        assert_eq!(compteur.next(), Some(3));
        assert_eq!(compteur.next(), Some(4));
        assert_eq!(compteur.next(), Some(5));
        assert_eq!(compteur.next(), None);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-22: Testing the functionality of the `next`
method implementation</span>
-->
<p><span class="caption">Encart 13-22¬†: test de l'impl√©mentation de la m√©thode
<code>next</code></span></p>
<!--
This test creates a new `Counter` instance in the `counter` variable and then
calls `next` repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.
-->
<p>Ce test cr√©e une nouvelle instance de <code>Compteur</code> dans la variable <code>compteur</code> et
appelle ensuite <code>next</code> √† plusieurs reprises, en v√©rifiant que nous avons
impl√©ment√© le comportement que nous voulions que cet it√©rateur suive¬†: renvoyer
les valeurs de 1 √† 5.</p>
<!--
#### Using Other `Iterator` Trait Methods
-->
<h4 id="utiliser-dautres-m√©thodes-du-trait-iterator"><a class="header" href="#utiliser-dautres-m√©thodes-du-trait-iterator">Utiliser d'autres m√©thodes du trait <code>Iterator</code></a></h4>
<!--
We implemented the `Iterator` trait by defining the `next` method, so we
can now use any `Iterator` trait method‚Äôs default implementations as defined in
the standard library, because they all use the `next` method‚Äôs functionality.
-->
<p>Maintenant que nous avons impl√©ment√© le trait <code>Iterator</code> en d√©finissant la
m√©thode <code>next</code>, nous pouvons maintenant utiliser les impl√©mentations par d√©faut
de n'importe quelle m√©thode du trait <code>Iterator</code> telles que d√©finies dans la
biblioth√®que standard, car elles utilisent toutes la m√©thode <code>next</code>.</p>
<!--
For example, if for some reason we wanted to take the values produced by an
instance of `Counter`, pair them with values produced by another `Counter`
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:
-->
<p>Par exemple, si pour une raison quelconque nous voulions prendre les valeurs
produites par une instance de <code>Compteur</code>, les coupler avec des valeurs produites
par une autre instance de <code>Compteur</code> apr√®s avoir saut√© la premi√®re valeur,
multiplier chaque paire ensemble, ne garder que les r√©sultats qui sont
divisibles par 3 et additionner toutes les valeurs r√©sultantes ensemble, nous
pourrions le faire, comme le montre le test dans l'encart 13-23¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn calling_next_directly() {
#         let mut counter = Counter::new();
# 
#         assert_eq!(counter.next(), Some(1));
#         assert_eq!(counter.next(), Some(2));
#         assert_eq!(counter.next(), Some(3));
#         assert_eq!(counter.next(), Some(4));
#         assert_eq!(counter.next(), Some(5));
#         assert_eq!(counter.next(), None);
#     }
# 
    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn appel_direct_a_next() {
</span><span class="boring">        let mut compteur = Compteur::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(compteur.next(), Some(1));
</span><span class="boring">        assert_eq!(compteur.next(), Some(2));
</span><span class="boring">        assert_eq!(compteur.next(), Some(3));
</span><span class="boring">        assert_eq!(compteur.next(), Some(4));
</span><span class="boring">        assert_eq!(compteur.next(), Some(5));
</span><span class="boring">        assert_eq!(compteur.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn utilisation_des_autres_methodes_du_trait_iterator() {
        let somme: u32 = Compteur::new()
            .zip(Compteur::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, somme);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-23: Using a variety of `Iterator` trait
methods on our `Counter` iterator</span>
-->
<p><span class="caption">Encart 13-23¬†: utilisation d'une gamme de m√©thodes du
trait <code>Iterator</code> sur notre it√©rateur <code>Compteur</code> </span></p>
<!--
Note that `zip` produces only four pairs; the theoretical fifth pair `(5,
None)` is never produced because `zip` returns `None` when either of its input
iterators return `None`.
-->
<p>Notez que <code>zip</code> ne produit que quatre paires¬†; la cinqui√®me paire th√©orique
<code>(5, None)</code> n'est jamais produite car <code>zip</code> retourne <code>None</code> lorsque l'un de
ses it√©rateurs d'entr√©e retourne <code>None</code>.</p>
<!--
All of these method calls are possible because we specified how the `next`
method works, and the standard library provides default implementations for
other methods that call `next`.
-->
<p>Tous ces appels de m√©thode sont possibles car nous avons renseign√© comment
la m√©thode <code>next</code> fonctionne et la biblioth√®que standard fournit des
impl√©mentations par d√©faut pour les autres m√©thodes qui appellent <code>next</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
