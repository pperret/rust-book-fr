<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html" class="active"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Refactoring to Improve Modularity and Error Handling
-->
<h2 id="remanier-le-code-pour-am√©liorer-sa-modularit√©-et-la-gestion-des-erreurs"><a class="header" href="#remanier-le-code-pour-am√©liorer-sa-modularit√©-et-la-gestion-des-erreurs">Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></h2>
<!--
To improve our program, we‚Äôll fix four problems that have to do with the
program‚Äôs structure and how it‚Äôs handling potential errors.
-->
<p>Pour am√©liorer notre programme, nous allons r√©soudre quatre probl√®mes li√©s
√† la structure du programme et √† la fa√ßon dont il g√®re de potentielles erreurs.</p>
<!--
First, our `main` function now performs two tasks: it parses arguments and
reads files. For such a small function, this isn‚Äôt a major problem. However, if
we continue to grow our program inside `main`, the number of separate tasks the
`main` function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It‚Äôs best to separate functionality so each
function is responsible for one task.
-->
<p>Premi√®rement, notre fonction <code>main</code> assure deux t√¢ches¬†: elle interpr√®te les
arguments et elle lit des fichiers. Pour une fonction aussi petite, ce n'est
pas un probl√®me majeur. Cependant, si nous continuons √† faire grossir notre
programme dans le <code>main</code>, le nombre des diff√©rentes t√¢ches qu'assure la
fonction <code>main</code> va continuer √† s'agrandir. Plus une fonction assure des
t√¢ches diff√©rentes, plus cela devient difficile de la comprendre, de la tester,
et d'y faire des changements sans casser ses autres constituants. Cela est
mieux de s√©parer les fonctionnalit√©s afin que chaque fonction n'assure qu'une
seule t√¢che.</p>
<!--
This issue also ties into the second problem: although `query` and `filename`
are configuration variables to our program, variables like `contents` are used
to perform the program‚Äôs logic. The longer `main` becomes, the more variables
we‚Äôll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It‚Äôs best to group the
configuration variables into one structure to make their purpose clear.
-->
<p>Cette probl√©matique est aussi li√©e au deuxi√®me probl√®me¬†: bien que <code>recherche</code> et
<code>nom_fichier</code> soient des variables de configuration de notre programme, les
variables telles que <code>contenu</code> sont utilis√©es pour appuyer la logique du
programme. Plus <code>main</code> est grand, plus nous aurons des variables √† importer
dans la port√©e¬†; plus nous avons des variables dans notre port√©e, plus il sera
difficile de se souvenir √† quoi elles servent. Il est pr√©f√©rable de regrouper
les variables de configuration dans une structure pour clarifier leur usage.</p>
<!--
The third problem is that we‚Äôve used `expect` to print an error message when
reading the file fails, but the error message just prints `Something went wrong
reading the file`. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, we‚Äôd print the `Something went wrong reading
the file` error message, which wouldn‚Äôt give the user any information!
-->
<p>Le troisi√®me probl√®me est que nous avons utilis√© <code>expect</code> pour afficher un
message d'erreur lorsque la lecture du fichier √©choue, mais le message affiche
uniquement <code>Quelque chose s'est mal pass√© lors de la lecture du fichier</code>. Lire
un fichier peut √©chouer pour de nombreuses raisons¬†: par exemple, le fichier
peut ne pas exister, ou parce que nous n'avons pas le droit de l'ouvrir. Pour
le moment, quelle que soit la raison, nous affichons le message d'erreur
<code>Quelque chose s'est mal pass√© lors de la lecture du fichier</code>, ce qui ne donne
aucune information √† l'utilisateur¬†!</p>
<!--
Fourth, we use `expect` repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they‚Äôll get an `index out
of bounds` error from Rust that doesn‚Äôt clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we‚Äôre printing messages that will be meaningful to our end users.
-->
<p>Quatri√®mement, nous utilisons <code>expect</code> √† r√©p√©tition pour g√©rer les diff√©rentes
erreurs, et si l'utilisateur lance notre programme sans renseigner d'arguments,
il va avoir une erreur <code>index out of bounds</code> provenant de Rust, qui n'explique
pas clairement le probl√®me. Il serait plus judicieux que tout le code de gestion
des erreurs se trouve au m√™me endroit afin que les futurs mainteneurs n'aient
qu'un seul endroit √† consulter dans le code si la logique de gestion des
erreurs doit √™tre modifi√©e. Avoir tout le code de gestion des erreurs dans un
seul endroit va aussi garantir que nous affichons des messages qui ont du sens
pour les utilisateurs.</p>
<!--
Let‚Äôs address these four problems by refactoring our project.
-->
<p>Corrigeons ces quatre probl√®mes en remaniant notre projet.</p>
<!--
### Separation of Concerns for Binary Projects
-->
<h3 id="s√©paration-des-t√¢ches-des-projets-de-binaires"><a class="header" href="#s√©paration-des-t√¢ches-des-projets-de-binaires">S√©paration des t√¢ches des projets de binaires</a></h3>
<!--
The organizational problem of allocating responsibility for multiple tasks to
the `main` function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when `main` starts getting large. The
process has the following steps:
-->
<p>Le probl√®me de l'organisation de la r√©partition des t√¢ches multiples dans la
fonction <code>main</code> est commun √† de nombreux projets binaires. En cons√©quence, la
communaut√© Rust a d√©velopp√© une proc√©dure √† utiliser comme ligne conductrice
pour partager les t√¢ches d'un programme binaire lorsque <code>main</code> commence √†
grossir. Le processus se d√©compose selon les √©tapes suivantes¬†:</p>
<!--
* Split your program into a *main.rs* and a *lib.rs* and move your program‚Äôs
  logic to *lib.rs*.
* As long as your command line parsing logic is small, it can remain in
  *main.rs*.
* When the command line parsing logic starts getting complicated, extract it
  from *main.rs* and move it to *lib.rs*.
-->
<ul>
<li>Diviser votre programme dans un <em>main.rs</em> et un <em>lib.rs</em> et d√©placer la
logique de votre programme dans <em>lib.rs</em>.</li>
<li>Tant que votre logique d'interpr√©tation de la ligne de commande est peu
volumineuse, elle peut rester dans le <em>main.rs</em></li>
<li>Lorsque la logique d'interpr√©tation de la ligne de commande commence √† devenir
compliqu√©e, il faut la d√©placer du <em>main.rs</em> vers le <em>lib.rs</em>.</li>
</ul>
<!--
The responsibilities that remain in the `main` function after this process
should be limited to the following:
-->
<p>Les fonctionnalit√©s qui restent dans la fonction <code>main</code> apr√®s cette proc√©dure
seront les suivantes¬†:</p>
<!--
* Calling the command line parsing logic with the argument values
* Setting up any other configuration
* Calling a `run` function in *lib.rs*
* Handling the error if `run` returns an error
-->
<ul>
<li>Appeler la logique d'interpr√©tation de ligne de commande avec les valeurs des
arguments</li>
<li>R√©gler toutes les autres configurations</li>
<li>Appeler une fonction <code>run</code> de <em>lib.rs</em></li>
<li>G√©rer l'erreur si <code>run</code> retourne une erreur</li>
</ul>
<!--
This pattern is about separating concerns: *main.rs* handles running the
program, and *lib.rs* handles all the logic of the task at hand. Because you
can‚Äôt test the `main` function directly, this structure lets you test all of
your program‚Äôs logic by moving it into functions in *lib.rs*. The only code
that remains in *main.rs* will be small enough to verify its correctness by
reading it. Let‚Äôs rework our program by following this process.
-->
<p>Cette structure permet de s√©parer les responsabilit√©s¬†: <em>main.rs</em> se charge de
lancer le programme, et <em>lib.rs</em> renferme toute la logique des t√¢ches √†
accomplir. Comme vous ne pouvez pas directement tester la fonction <code>main</code>, cette
structure vous permet de tester toute la logique de votre programme en les
d√©pla√ßant dans des fonctions dans <em>lib.rs</em>. Le seul code qui restera dans le
<em>main.rs</em> sera suffisamment petit pour s'assurer qu'il soit correct en le
lisant. Lan√ßons-nous dans le remaniement de notre programme en suivant cette
proc√©dure.</p>
<!--
#### Extracting the Argument Parser
-->
<h4 id="extraction-de-linterpr√©teur-des-arguments"><a class="header" href="#extraction-de-linterpr√©teur-des-arguments">Extraction de l'interpr√©teur des arguments</a></h4>
<!--
We‚Äôll extract the functionality for parsing arguments into a function that
`main` will call to prepare for moving the command line parsing logic to
*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new
function `parse_config`, which we‚Äôll define in *src/main.rs* for the moment.
-->
<p>Nous allons d√©placer la fonctionnalit√© de l'interpr√©tation des arguments dans
une fonction que <code>main</code> va appeler afin de pr√©parer le d√©placement de la logique
de l'interpr√©teur dans <em>src/lib.rs</em>. L'encart 12-5 montre le nouveau d√©but du
<code>main</code> qui appelle une nouvelle fonction <code>interpreter_config</code>, que nous allons
d√©finir dans <em>src/main.rs</em> pour le moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
# 
#     println!("Searching for {}", query);
#     println!("In file {}", filename);
# 
#     let contents = fs::read_to_string(filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (recherche, nom_fichier) = interpreter_config(&amp;args);

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

fn interpreter_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    (recherche, nom_fichier)
}
</code></pre>
<!--
<span class="caption">Listing 12-5: Extracting a `parse_config` function from
`main`</span>
-->
<p><span class="caption">Encart 12-5¬†: Extraction d'une fonction
<code>interpreter_config</code> √† partir de <code>main</code></span></p>
<!--
We‚Äôre still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable `query` and the
argument value at index 2 to the variable `filename` within the `main`
function, we pass the whole vector to the `parse_config` function. The
`parse_config` function then holds the logic that determines which argument
goes in which variable and passes the values back to `main`. We still create
the `query` and `filename` variables in `main`, but `main` no longer has the
responsibility of determining how the command line arguments and variables
correspond.
-->
<p>Nous continuons √† r√©cup√©rer les arguments de la ligne de commande dans un
vecteur, mais au lieu d'assigner la valeur de l'argument d'indice 1 √† la
variable <code>recherche</code> et la valeur de l'argument d'indice 2 √† la variable
<code>nom_fichier</code> dans la fonction <code>main</code>, nous passons le vecteur entier √† la
fonction <code>interpreter_config</code>. La fonction <code>interpreter_config</code> renferme la
logique qui d√©termine quel argument va dans quelle variable et renvoie les
valeurs au <code>main</code>. Nous continuons √† cr√©er les variables <code>recherche</code> et
<code>nom_fichier</code> dans le <code>main</code>, mais <code>main</code> n'a plus la responsabilit√© de
d√©terminer quelles sont les variables qui correspondent aux arguments de la
ligne de commande.</p>
<!--
This rework may seem like overkill for our small program, but we‚Äôre refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It‚Äôs good to check your progress
often, to help identify the cause of problems when they occur.
-->
<p>Ce remaniement peut sembler excessif pour notre petit programme, mais nous
remanions de mani√®re incr√©mentale par de petites √©tapes. Apr√®s avoir fait
ces changements, lancez √† nouveau le programme pour v√©rifier que l'envoi des
arguments fonctionne toujours. C'est une bonne chose de v√©rifier souvent lorsque
vous avancez, pour vous aider √† mieux identifier les causes de probl√®mes
lorsqu'ils apparaissent.</p>
<!--
#### Grouping Configuration Values
-->
<h4 id="grouper-les-valeurs-de-configuration"><a class="header" href="#grouper-les-valeurs-de-configuration">Grouper les valeurs de configuration</a></h4>
<!--
We can take another small step to improve the `parse_config` function further.
At the moment, we‚Äôre returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don‚Äôt have
the right abstraction yet.
-->
<p>Nous pouvons appliquer une nouvelle petite √©tape pour am√©liorer la fonction
<code>interpreter_config</code>. Pour le moment, nous retournons un tuple, mais ensuite
nous divisons imm√©diatement ce tuple √† nouveau en plusieurs √©l√©ments. C'est un
signe que nous n'avons peut-√™tre pas la bonne approche.</p>
<!--
Another indicator that shows there‚Äôs room for improvement is the `config` part
of `parse_config`, which implies that the two values we return are related and
are both part of one configuration value. We‚Äôre not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.
-->
<p>Un autre signe qui indique qu'il y a encore de la place pour de l'am√©lioration
est la partie <code>config</code> de <code>interpreter_config</code> qui sous-entend que les
deux valeurs que nous retournons sont li√©es et font partie d'une m√™me valeur de
configuration. Or, √† ce stade, nous ne tenons pas compte de cela dans la
structure des donn√©es que nous utilisons si ce n'est en regroupant les deux
valeurs dans un tuple¬†; nous pourrions mettre les deux valeurs dans une seule
structure et donner un nom significatif √† chacun des champs de la structure.
Faire ainsi permet de faciliter la compr√©hension du code par les futurs
d√©veloppeurs de ce code pour mettre en √©vidence le lien entre les deux valeurs
et leurs r√¥les respectifs.</p>
<!--
Listing 12-6 shows the improvements to the `parse_config` function.
-->
<p>L'encart 12-6 montre les am√©liorations apport√©es √† la fonction
<code>interpreter_config</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
# 
#     println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
```
-->
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = interpreter_config(&amp;args);

    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);

    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

struct Config {
    recherche: String,
    nom_fichier: String,
}

fn interpreter_config(args: &amp;[String]) -&gt; Config {
    let recherche = args[1].clone();
    let nom_fichier = args[2].clone();

    Config { recherche, nom_fichier }
}
</code></pre>
<!--
<span class="caption">Listing 12-6: Refactoring `parse_config` to return an
instance of a `Config` struct</span>
-->
<p><span class="caption">Encart 12-6¬†: Remaniement de <code>interpreter_config</code> pour
retourner une instance de la structure <code>Config</code></span></p>
<!--
We‚Äôve added a struct named `Config` defined to have fields named `query` and
`filename`. The signature of `parse_config` now indicates that it returns a
`Config` value. In the body of `parse_config`, where we used to return string
slices that reference `String` values in `args`, we now define `Config` to
contain owned `String` values. The `args` variable in `main` is the owner of
the argument values and is only letting the `parse_config` function borrow
them, which means we‚Äôd violate Rust‚Äôs borrowing rules if `Config` tried to take
ownership of the values in `args`.
-->
<p>Nous avons ajout√© une structure <code>Config</code> qui a deux champs <code>recherche</code> et
<code>nom_fichier</code>. La signature de <code>interpreter_config</code> indique maintenant qu'elle
retourne une valeur <code>Config</code>. Dans le corps de <code>interpreter_config</code>, o√π nous
retournions une slice de cha√Ænes de caract√®res qui pointaient sur des valeurs
<code>String</code> pr√©sentes dans <code>args</code>, nous d√©finissons maintenant la structure
<code>Config</code> pour contenir des valeurs <code>String</code> qu'elle poss√®de. La variable <code>args</code>
du <code>main</code> est la propri√©taire des valeurs des arguments et permet uniquement √†
la fonction <code>interpreter_config</code> de les emprunter, ce qui signifie que nous
violons les r√®gles d'emprunt de Rust si <code>Config</code> essaye de prendre possession
des valeurs provenant de <code>args</code>.</p>
<!--
We could manage the `String` data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the `clone` method on
the values. This will make a full copy of the data for the `Config` instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don‚Äôt have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.
-->
<p>Nous pourrions g√©rer les donn√©es <code>String</code> de plusieurs mani√®res, mais la fa√ßon
la plus facile, bien que non optimis√©e, est d'appeler la m√©thode <code>clone</code> sur
les valeurs. Cela va produire une copie compl√®te des donn√©es pour que
l'instance de <code>Config</code> puisse se les approprier, ce qui va prendre plus de
temps et de m√©moire que de stocker une r√©f√©rence vers les donn√©es de la cha√Æne
de caract√®res. Cependant le clonage des donn√©es rend votre code tr√®s simple
car nous n'avons pas √† g√©rer les dur√©es de vie des r√©f√©rences¬†; dans ces
circonstances, sacrifier un peu de performances pour gagner en simplicit√© est
un compromis qui en vaut la peine.</p>
<!--
> ### The Trade-Offs of Using `clone`
>
> There‚Äôs a tendency among many Rustaceans to avoid using `clone` to fix
> ownership problems because of its runtime cost. In
> [Chapter 13][ch13]<!-- ignore -- >, you‚Äôll learn how to use more efficient
> methods in this type of situation. But for now, it‚Äôs okay to copy a few
> strings to continue making progress because you‚Äôll make these copies only
> once and your filename and query string are very small. It‚Äôs better to have
> a working program that‚Äôs a bit inefficient than to try to hyperoptimize code
> on your first pass. As you become more experienced with Rust, it‚Äôll be
> easier to start with the most efficient solution, but for now, it‚Äôs
> perfectly acceptable to call `clone`.
-->
<blockquote>
<h3 id="les-contre-parties-de-lutilisation-de-clone"><a class="header" href="#les-contre-parties-de-lutilisation-de-clone">Les contre-parties de l'utilisation de <code>clone</code></a></h3>
<p>Il y a une tendance chez les Rustac√©s de s'interdire l'utilisation de <code>clone</code>
pour r√©gler les probl√®mes d'appartenance √† cause du co√ªt √† l'ex√©cution. Dans
le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->, vous allez apprendre √† utiliser des
m√©thodes plus efficaces dans ce genre de situation. Mais pour le moment, ce
n'est pas un probl√®me de copier quelques cha√Ænes de caract√®res pour continuer
√† progresser car vous allez le faire une seule fois et les cha√Ænes de
caract√®res <code>nom_fichier</code> et <code>recherche</code> sont tr√®s courtes. Il est plus
important d'avoir un programme fonctionnel qui n'est pas tr√®s optimis√© plut√¥t
que d'essayer d'optimiser √† outrance le code d√®s sa premi√®re √©criture. Plus
vous deviendrez exp√©riment√© en Rust, plus il sera facile de commencer par la
solution la plus performante, mais pour le moment, il est parfaitement
acceptable de faire appel √† <code>clone</code>.</p>
</blockquote>
<!--
We‚Äôve updated `main` so it places the instance of `Config` returned by
`parse_config` into a variable named `config`, and we updated the code that
previously used the separate `query` and `filename` variables so it now uses
the fields on the `Config` struct instead.
-->
<p>Nous avons actualis√© <code>main</code> pour qu'il utilise l'instance de <code>Config</code> retourn√©e
par <code>interpreter_config</code> dans une variable <code>config</code>, et nous avons rafra√Æchi le
code qui utilisait les variables s√©par√©es <code>recherche</code> et <code>nom_fichier</code> pour
qu'il utilise maintenant les champs de la structure <code>Config</code> √† la place.</p>
<!--
Now our code more clearly conveys that `query` and `filename` are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the `config` instance in the fields
named for their purpose.
-->
<p>Maintenant, notre code indique clairement que <code>recherche</code> et <code>nom_fichier</code> sont
reli√©s et que leur but est de configurer le fonctionnement du programme.
N'importe quel code qui utilise ces valeurs sait comment les retrouver dans les
champs de l'instance <code>config</code> gr√¢ce √† leurs noms donn√©s √† cet effet.</p>
<!--
#### Creating a Constructor for `Config`
-->
<h4 id="cr√©er-un-constructeur-pour-config"><a class="header" href="#cr√©er-un-constructeur-pour-config">Cr√©er un constructeur pour <code>Config</code></a></h4>
<!--
So far, we‚Äôve extracted the logic responsible for parsing the command line
arguments from `main` and placed it in the `parse_config` function. Doing so
helped us to see that the `query` and `filename` values were related and that
relationship should be conveyed in our code. We then added a `Config` struct to
name the related purpose of `query` and `filename` and to be able to return the
values‚Äô names as struct field names from the `parse_config` function.
-->
<p>Pour l'instant, nous avons extrait la logique en charge d'interpr√©ter les
arguments de la ligne de commande √† partir du <code>main</code> et nous l'avons plac√© dans
la fonction <code>interpreter_config</code>. Cela nous a aid√© √† d√©couvrir que les valeurs
<code>recherche</code> et <code>nom_fichier</code> √©taient li√©es et que ce lien devait √™tre
retranscrit dans notre code. Nous avons ensuite cr√©√© une structure <code>Config</code>
afin de donner un nom au r√¥le apparent√© √† <code>recherche</code> et √† <code>nom_fichier</code>, et
pour pouvoir retourner les noms des valeurs sous la forme de noms de champs √†
partir de la fonction <code>interpreter_config</code>.</p>
<!--
So now that the purpose of the `parse_config` function is to create a `Config`
instance, we can change `parse_config` from a plain function to a function
named `new` that is associated with the `Config` struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as `String`, by calling `String::new`. Similarly, by
changing `parse_config` into a `new` function associated with `Config`, we‚Äôll
be able to create instances of `Config` by calling `Config::new`. Listing 12-7
shows the changes we need to make.
-->
<p>Maintenant que le but de la fonction <code>interpreter_config</code> est de cr√©er une
instance de <code>Config</code>, nous pouvons transformer <code>interpreter_config</code> d'une
simple fonction √† une fonction <code>new</code> qui est associ√©e √† la structure <code>Config</code>.
Ce changement rendra le code plus familier. Habituellement, nous cr√©ons des
instances de types de la biblioth√®que standard, comme <code>String</code>, en appelant
<code>String::new</code>. Si on change le <code>interpreter_config</code> en une fonction <code>new</code>
associ√©e √† <code>Config</code>, nous pourrons cr√©er de la m√™me fa√ßon des instances de
<code>Config</code> en appelant <code>Config::new</code>. L'encart 12-7 nous montre les changements
que nous devons faire pour cela.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);

    // --snip--
}

// --snip--

# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
```
-->
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>
    // -- partie masqu√©e ici --
}

// -- partie masqu√©e ici --

<span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Config { recherche, nom_fichier }
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-7: Changing `parse_config` into
`Config::new`</span>
-->
<p><span class="caption">Encart 12-7¬†: Transformer <code>interpreter_config</code> en
<code>Config::new</code></span></p>
<!--
We‚Äôve updated `main` where we were calling `parse_config` to instead call
`Config::new`. We‚Äôve changed the name of `parse_config` to `new` and moved it
within an `impl` block, which associates the `new` function with `Config`. Try
compiling this code again to make sure it works.
-->
<p>Nous avons actualis√© le <code>main</code> o√π nous appelions <code>interpreter_config</code> pour
appeler √† la place le <code>Config::new</code>. Nous avons chang√© le nom de
<code>interpreter_config</code> par <code>new</code> et nous l'avons d√©plac√© dans un bloc <code>impl</code>,
ce qui relie la fonction <code>new</code> √† <code>Config</code>. Essayez √† nouveau de compiler ce
code pour vous assurer qu'il fonctionne.</p>
<!--
### Fixing the Error Handling
-->
<h3 id="corriger-la-gestion-des-erreurs"><a class="header" href="#corriger-la-gestion-des-erreurs">Corriger la gestion des erreurs</a></h3>
<!--
Now we‚Äôll work on fixing our error handling. Recall that attempting to access
the values in the `args` vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:
-->
<p>Maintenant, nous allons nous pencher sur la correction de la gestion des
erreurs. Rappellez-vous que la tentative d'acc√©der aux valeurs dans le vecteur
<code>args</code> aux indices 1 ou 2 va faire paniquer le programme si le vecteur contient
moins de trois √©l√©ments. Essayez de lancer le programme sans aucun argument¬†;
cela donnera quelque chose comme ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The line `index out of bounds: the len is 1 but the index is 1` is an error
message intended for programmers. It won‚Äôt help our end users understand what
happened and what they should do instead. Let‚Äôs fix that now.
-->
<p>La ligne <code>index out of bounds: the len is 1 but the index is 1</code> est un
message d'erreur destin√© aux d√©veloppeurs. Il n'aidera pas nos utilisateurs
finaux √† comprendre ce qu'il s'est pass√© et ce qu'ils devraient faire √† la
place. Corrigeons cela d√®s maintenant.</p>
<!--
#### Improving the Error Message
-->
<h4 id="am√©liorer-le-message-derreur"><a class="header" href="#am√©liorer-le-message-derreur">Am√©liorer le message d'erreur</a></h4>
<!--
In Listing 12-8, we add a check in the `new` function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isn‚Äôt long
enough, the program panics and displays a better error message than the `index
out of bounds` message.
-->
<p>Dans l'encart 12-8, nous ajoutons une v√©rification dans la fonction <code>new</code>, qui
va v√©rifier que le slice est suffisamment grand avant d'acc√©der aux indices 1
et 2. Si le slice n'est pas suffisamment grand, le programme va paniquer et
afficher un meilleur message d'erreur que le message <code>index out of bounds</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
    // --snip--
    fn new(args: &[String]) -> Config {
        if args.len() < 3 {
            panic!("not enough arguments");
        }
        // --snip--
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Config { query, filename }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // -- partie masqu√©e ici --
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;il n'y a pas assez d'arguments&quot;);
        }
        // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { recherche, nom_fichier }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-8: Adding a check for the number of
arguments</span>
-->
<p><span class="caption">Encart 12-8¬†: Ajout d'une v√©rification du nombre
d'arguments</span></p>
<!--
This code is similar to [the `Guess::new` function we wrote in Listing
9-13][ch9-custom-types]<!-- ignore -- >, where we called `panic!` when the
`value` argument was out of the range of valid values. Instead of checking for
a range of values here, we‚Äôre checking that the length of `args` is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If `args` has fewer than three items, this condition
will be true, and we call the `panic!` macro to end the program immediately.
-->
<p>Ce code est similaire √† <a href="ch09-03-to-panic-or-not-to-panic.html">la fonction Supposition::new que nous avons √©crit
dans l'encart 9-13</a><!-- ignore -->, dans laquelle nous
appelions <code>panic!</code> lorsque l'argument <code>valeur</code> √©tait hors de l'intervalle des
valeurs valides. Plut√¥t que de v√©rifier un intervalle de valeurs dans le cas
pr√©sent, nous v√©rifions que la taille de <code>args</code> est au moins de 3 et que le
reste de la fonction puisse fonctionner en s'appuyant sur l'affirmation que
cette condition a bien √©t√© remplie. Si <code>args</code> avait moins de trois √©l√©ments,
cette fonction serait vraie, et nous appellerions alors la macro <code>panic!</code>
pour mettre fin au programme imm√©diatement.</p>
<!--
With these extra few lines of code in `new`, let‚Äôs run the program without any
arguments again to see what the error looks like now:
-->
<p>Avec ces quelques lignes de code en plus dans <code>new</code>, lan√ßons le programme sans
aucun argument √† nouveau pour voir √† quoi ressemble d√©sormais l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'il n'y a pas assez d'arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
This output is better: we now have a reasonable error message. However, we also
have extraneous information we don‚Äôt want to give to our users. Perhaps using
the technique we used in Listing 9-13 isn‚Äôt the best to use here: a call to
`panic!` is more appropriate for a programming problem than a usage problem,
[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -- >. Instead, we
can use the other technique you learned about in Chapter 9‚Äî[returning a
`Result`][ch9-result]<!-- ignore -- > that indicates either success or an error.
-->
<p>Cette sortie est meilleure¬†: nous avons maintenant un message d'erreur
compr√©hensible. Cependant, nous avons aussi des informations superflues que
nous ne souhaitons pas afficher √† nos utilisateurs. Peut-√™tre que la technique
que nous avons utilis√©e dans l'encart 9-13 n'est pas la plus appropri√©e dans ce
cas¬†: un appel √† <code>panic!</code> est plus appropri√© pour un probl√®me de d√©veloppement
qu'un probl√®me d'utilisation, <a href="ch09-03-to-panic-or-not-to-panic.html">comme nous l'avons appris au chapitre
9</a><!-- ignore -->. A la place, nous pourrions utiliser
une autre technique que vous avez apprise au chapitre 9 ‚Äî <a href="ch09-02-recoverable-errors-with-result.html">retourner un
<code>Result</code></a><!-- ignore --> qui indique si c'est un succ√®s ou une
erreur.</p>
<!--
#### Returning a `Result` from `new` Instead of Calling `panic!`
-->
<h4 id="retourner-un-result-√†-partir-de-new-plut√¥t-que-dappeler-panic"><a class="header" href="#retourner-un-result-√†-partir-de-new-plut√¥t-que-dappeler-panic">Retourner un <code>Result</code> √† partir de <code>new</code> plut√¥t que d'appeler <code>panic!</code></a></h4>
<!--
We can instead return a `Result` value that will contain a `Config` instance in
the successful case and will describe the problem in the error case. When
`Config::new` is communicating to `main`, we can use the `Result` type to
signal there was a problem. Then we can change `main` to convert an `Err`
variant into a more practical error for our users without the surrounding text
about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.
-->
<p>Nous pouvons √† la place retourner une valeur <code>Result</code> qui contiendra une
instance de <code>Config</code> dans le cas d'un succ√®s et va d√©crire le probl√®me dans le
cas d'une erreur. Lorsque <code>Config::new</code> communiquera avec le <code>main</code>, nous
pourrons utiliser le type de <code>Result</code> pour signaler o√π il y a un probl√®me.
Ensuite, nous pourrons changer le <code>main</code> pour convertir une variante de <code>Err</code>
dans une erreur plus pratique pour nos utilisateurs sans avoir le texte √†
propos de <code>thread 'main'</code> et de <code>RUST_BACKTRACE</code> qui sont provoqu√©s par l'appel
√† <code>panic!</code>.</p>
<!--
Listing 12-9 shows the changes we need to make to the return value of
`Config::new` and the body of the function needed to return a `Result`. Note
that this won‚Äôt compile until we update `main` as well, which we‚Äôll do in the
next listing.
-->
<p>L'encart 12-9 nous montre les changements que nous devons apporter √† la
valeur de retour de <code>Config::new</code> et le corps de la fonction pour pouvoir retourner
un <code>Result</code>. Notez que cela ne va pas se compiler tant que nous ne corrigeons
pas aussi le <code>main</code>, ce que nous allons faire dans le prochain encart.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Ok(Config { recherche, nom_fichier })
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-9: Returning a `Result` from
`Config::new`</span>
-->
<p><span class="caption">Encart 12-9¬†: Retourner un <code>Result</code> √† partir de
<code>Config::new</code></span></p>
<!--
Our `new` function now returns a `Result` with a `Config` instance in the
success case and a `&'static str` in the error case. Our error values will
always be string literals that have the `'static` lifetime.
-->
<p>Notre fonction <code>new</code> retourne d√©sormais un <code>Result</code> contenant une instance de
<code>Config</code> dans le cas d'un succ√®s et une <code>&amp;'static str</code> dans le cas d'une
erreur. Nos valeurs d'erreur seront toujours des lit√©raux de cha√Æne de
caract√®res qui ont la dur√©e de vie <code>'static</code>.</p>
<!--
We‚Äôve made two changes in the body of the `new` function: instead of calling
`panic!` when the user doesn‚Äôt pass enough arguments, we now return an `Err`
value, and we‚Äôve wrapped the `Config` return value in an `Ok`. These changes
make the function conform to its new type signature.
-->
<p>Nous avons fait deux changements dans le corps de notre fonction <code>new</code>¬†:
plut√¥t que d'avoir √† appeler <code>panic!</code> lorsque l'utilisateur n'envoie pas assez
d'arguments, nous retournons maintenant une valeur <code>Err</code>, et nous avons int√©gr√©
la valeur de retour <code>Config</code> dans un <code>Ok</code>. Ces modifications rendent la
fonction conforme √† son nouveau type de signature.</p>
<!--
Returning an `Err` value from `Config::new` allows the `main` function to
handle the `Result` value returned from the `new` function and exit the process
more cleanly in the error case.
-->
<p>Retourner une valeur <code>Err</code> √† partir de <code>Config::new</code> permet √† la fonction
<code>main</code> de g√©rer la valeur <code>Result</code> retourn√©e par la fonction <code>new</code> et de
terminer plus proprement le processus dans le cas d'une erreur.</p>
<!--
#### Calling `Config::new` and Handling Errors
-->
<h4 id="appeler-confignew-et-g√©rer-les-erreurs"><a class="header" href="#appeler-confignew-et-g√©rer-les-erreurs">Appeler <code>Config::new</code> et g√©rer les erreurs</a></h4>
<!--
To handle the error case and print a user-friendly message, we need to update
`main` to handle the `Result` being returned by `Config::new`, as shown in
Listing 12-10. We‚Äôll also take the responsibility of exiting the command line
tool with a nonzero error code from `panic!` and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.
-->
<p>Pour g√©rer les cas d'erreurs et afficher un message correct pour
l'utilisateur, nous devons mettre √† jour <code>main</code> pour g√©rer le <code>Result</code>
retourn√© par <code>Config::new</code>, comme dans l'encart 12-10. Nous allons aussi
prendre la d√©cision de quitter l'outil en ligne de commande avec un code
d'erreur diff√©rent de z√©ro avec <code>panic!</code> et nous allons l'impl√©menter
manuellement. Un statut de sortie diff√©rent de z√©ro est une convention pour
signaler au processus qui a appel√© notre programme que le programme s'est
termin√© dans un √©tat d'erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
        process::exit(1);
    });

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-10: Exiting with an error code if creating a
new `Config` fails</span>
-->
<p><span class="caption">Encart 12-10¬†: Quitter avec un code d'erreur si la
cr√©ation d'une nouvelle <code>Config</code> √©choue.
</span></p>
<!--
In this listing, we‚Äôve used a method we haven‚Äôt covered in detail yet:
`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.
Using `unwrap_or_else` allows us to define some custom, non-`panic!` error
handling. If the `Result` is an `Ok` value, this method‚Äôs behavior is similar
to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value
is an `Err` value, this method calls the code in the *closure*, which is an
anonymous function we define and pass as an argument to `unwrap_or_else`. We‚Äôll
cover closures in more detail in [Chapter 13][ch13]<!-- ignore -- >. For now,
you just need to know that `unwrap_or_else` will pass the inner value of the
`Err`, which in this case is the static string `"not enough arguments"` that we
added in Listing 12-9, to our closure in the argument `err` that appears
between the vertical pipes. The code in the closure can then use the `err`
value when it runs.
-->
<p>Dans cet encart, nous avons utilis√© une m√©thode que nous n'avons pas encore
d√©taill√©e pour l'instant¬†: <code>unwrap_or_else</code>, qui est d√©finie sur <code>Result&lt;T, E&gt;</code>
par la biblioth√®que standard. L'utilisation de <code>unwrap_or_else</code> nous permet de
d√©finir une gestion des erreurs personnalis√©e, exempt de <code>panic!</code>. Si le
<code>Result</code> est une valeur <code>Ok</code>, le comportement de cette m√©thode est similaire √†
<code>unwrap</code>¬†: elle retourne la valeur √† l'int√©rieur du <code>Ok</code>. Cependant, si la
valeur est une valeur <code>Err</code>, cette m√©thode appelle le code dans la <em>fermeture</em>,
qui est une fonction anonyme que nous d√©finissons et passons en argument de
<code>unwrap_or_else</code>. Nous verrons les fermetures plus en d√©tail dans le <a href="ch13-00-functional-features.html">chapitre
13</a><!-- ignore -->. Pour l'instant, vous avez juste √† savoir que le
<code>unwrap_or_else</code> va passer la valeur interne du <code>Err</code> (qui dans ce cas est la
cha√Æne de caract√®res statique <code>&quot;pas assez d'arguments&quot;</code> que nous avons ajout√©e
dans l'encart 12-9) √† notre fermeture dans l'argument <code>err</code> qui est pr√©sent
entre deux barres verticales. Le code dans la fermeture peut ensuite utiliser
la valeur <code>err</code> lorsqu'il est ex√©cut√©.</p>
<!--
We‚Äôve added a new `use` line to bring `process` from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the `err` value and then call `process::exit`. The
`process::exit` function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
`panic!`-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let‚Äôs try it:
-->
<p>Nous avons ajout√© une nouvelle ligne <code>use</code> pour importer <code>process</code> dans la port√©e
√† partir de la biblioth√®que standard. Le code dans la fermeture qui sera ex√©cut√©
dans le cas d'une erreur fait uniquement deux lignes¬†: nous affichons la valeur
de <code>err</code> et nous appelons ensuite <code>process::exit</code>. La fonction <code>process::exit</code>
va stopper le programme imm√©diatement et retourner le nombre qui lui a √©t√© donn√©
en param√®tre comme code de statut de sortie. C'est semblable √† la gestion bas√©e
sur <code>panic!</code> que nous avons utilis√©e √† l'encart 12-8, mais nous n'avons plus tout
le texte en plus. Essayons cela¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: il n'y a pas assez d'arguments
</code></pre>
<!--
Great! This output is much friendlier for our users.
-->
<p>Tr√®s bien ! Cette sortie est bien plus compr√©hensible pour nos utilisateurs.</p>
<!--
### Extracting Logic from `main`
-->
<h3 id="extraction-de-la-logique-du-main"><a class="header" href="#extraction-de-la-logique-du-main">Extraction de la logique du <code>main</code></a></h3>
<!--
Now that we‚Äôve finished refactoring the configuration parsing, let‚Äôs turn to
the program‚Äôs logic. As we stated in [‚ÄúSeparation of Concerns for Binary
Projects‚Äù](#separation-of-concerns-for-binary-projects)<!-- ignore -- >, we‚Äôll
extract a function named `run` that will hold all the logic currently in the
`main` function that isn‚Äôt involved with setting up configuration or handling
errors. When we‚Äôre done, `main` will be concise and easy to verify by
inspection, and we‚Äôll be able to write tests for all the other logic.
-->
<p>Maintenant que nous avons fini le remaniement de l'interpr√©tation de la
configuration, occupons-nous de la logique du programme. Comme nous l'avons dit
dans <a href="#separation-of-concerns-for-binary-projects">‚ÄúS√©paration des t√¢ches des projets de
binaires‚Äù</a><!-- ignore -->, nous
allons extraire une fonction <code>run</code> qui va contenir toute la logique qui est
actuellement dans la fonction <code>main</code> qui n'est pas li√©e au r√©glage de la
configuration ou la gestion des erreurs. Lorsque nous aurons termin√©, <code>main</code>
sera plus concise et facile √† v√©rifier en l'inspectant, et nous pourrons √©crire
des tests pour toutes les autres logiques.</p>
<!--
Listing 12-11 shows the extracted `run` function. For now, we‚Äôre just making
the small, incremental improvement of extracting the function. We‚Äôre still
defining the function in *src/main.rs*.
-->
<p>L'encart 12-11 montre la fonction <code>run</code> extraite. Pour le moment, nous faisons
des petites am√©liorations progressives pour extraire les fonctions. Nous
continuons √† d√©finir la fonction dans <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masqu√©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);

    run(config);
}

fn run(config: Config) {
    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte :\n{}&quot;, contenu);
}

// -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-11: Extracting a `run` function containing the
rest of the program logic</span>
-->
<p><span class="caption">Encart 12-11¬†: Extraction d'une fonction <code>run</code> qui
contient le reste de la logique du programme</span></p>
<!--
The `run` function now contains all the remaining logic from `main`, starting
from reading the file. The `run` function takes the `Config` instance as an
argument.
-->
<p>La fonction <code>run</code> contient maintenant toute la logique qui restait dans le
<code>main</code>, en commen√ßant par la lecture du fichier. La fonction <code>run</code> prend
l'instance de <code>Config</code> en argument.</p>
<!--
#### Returning Errors from the `run` Function
-->
<h4 id="retourner-des-erreurs-avec-la-fonction-run"><a class="header" href="#retourner-des-erreurs-avec-la-fonction-run">Retourner des erreurs avec la fonction <code>run</code></a></h4>
<!--
With the remaining program logic separated into the `run` function, we can
improve the error handling, as we did with `Config::new` in Listing 12-9.
Instead of allowing the program to panic by calling `expect`, the `run`
function will return a `Result<T, E>` when something goes wrong. This will let
us further consolidate into `main` the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of `run`.
-->
<p>Avec le restant de la logique du programme maintenant s√©par√©e dans la fonction
<code>run</code>, nous pouvons am√©liorer la gestion des erreurs, comme nous l'avons fait
avec <code>Config::new</code> dans l'encart 12-9. Plut√¥t que de permettre au programme de
paniquer en appelant <code>expect</code>, la fonction <code>run</code> va retourner un <code>Result&lt;T, E&gt;</code>
lorsque quelque chose se passe mal. Cela va nous permettre de consolider
davantage la logique de gestion des erreurs dans le <code>main</code> pour qu'elle soit
plus conviviale pour l'utilisateur. L'encart 12-12 montre les changements que
nous devons appliquer √† la signature et au corps du <code>run</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
use std::error::Error;

// --snip--

# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     run(config);
# }
# 
fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// -- partie masqu√©e ici --

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    println!(&quot;Dans le texte :\n{}&quot;, contenu);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-12: Changing the `run` function to return
`Result`</span>
-->
<p><span class="caption">Encart 12-12¬†: Changer la fonction <code>run</code> pour retourner
un <code>Result</code></span></p>
<!--
We‚Äôve made three significant changes here. First, we changed the return type of
the `run` function to `Result<(), Box<dyn Error>>`. This function previously
returned the unit type, `()`, and we keep that as the value returned in the
`Ok` case.
-->
<p>Nous avons fait trois changements significatifs ici. Premi√®rement, nous avons
chang√© le type de retour de la fonction <code>run</code> en <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>.
Cette fonction renvoyait pr√©c√©demment le type unit√©, <code>()</code>, que nous gardons
comme valeur de retour dans le cas de <code>Ok</code>.</p>
<!--
For the error type, we used the *trait object* `Box<dyn Error>` (and we‚Äôve
brought `std::error::Error` into scope with a `use` statement at the top).
We‚Äôll cover trait objects in [Chapter 17][ch17]<!-- ignore -- >. For now, just
know that `Box<dyn Error>` means the function will return a type that
implements the `Error` trait, but we don‚Äôt have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The `dyn` keyword is short
for ‚Äúdynamic.‚Äù
-->
<p>En ce qui concerne le type d'erreur, nous avons utilis√© <em>l'objet trait</em>
<code>Box&lt;dyn Error&gt;</code> (et nous avons import√© <code>std::error::Error</code> dans la port√©e avec
une instruction <code>use</code> en haut). Nous allons voir les objets trait dans le
<a href="ch17-00-oop.html">chapitre 17</a><!-- ignore -->. Pour l'instant, retenez juste que
<code>Box&lt;dyn Error&gt;</code> signifie que la fonction va retourner un type qui impl√©mente
le trait <code>Error</code>, mais que nous n'avons pas √† sp√©cifier quel sera pr√©cis√©ment le
type de la valeur de retour. Cela nous donne la flexibilit√© de retourner des valeurs
d'erreurs qui peuvent √™tre de diff√©rents types dans diff√©rents cas d'erreurs.
Le mot-cl√© <code>dyn</code> est un raccourci pour ‚Äúdynamique‚Äù.</p>
<!--
Second, we‚Äôve removed the call to `expect` in favor of the `?` operator, as we
talked about in [Chapter 9][ch9-question-mark]<!-- ignore -- >. Rather than
`panic!` on an error, `?` will return the error value from the current function
for the caller to handle.
-->
<p>Deuxi√®mement, nous avons enlev√© l'appel √† <code>expect</code> pour privil√©gier l'op√©rateur
<code>?</code>, que nous avons vu dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore -->.
Au lieu de faire un <code>panic!</code> sur une erreur, <code>?</code> va retourner la valeur d'erreur
de la fonction courante vers le code qui l'a appel√© pour qu'il la g√®re.</p>
<!--
Third, the `run` function now returns an `Ok` value in the success case. We‚Äôve
declared the `run` function‚Äôs success type as `()` in the signature, which
means we need to wrap the unit type value in the `Ok` value. This `Ok(())`
syntax might look a bit strange at first, but using `()` like this is the
idiomatic way to indicate that we‚Äôre calling `run` for its side effects only;
it doesn‚Äôt return a value we need.
-->
<p>Troisi√®mement, la fonction <code>run</code> retourne maintenant une valeur <code>Ok</code> dans les
cas de succ√®s. Nous avons d√©clar√© dans la signature que le type de succ√®s de la
fonction <code>run</code> √©tait <code>()</code>, ce qui signifie que nous avons envelopp√© la valeur
de type unit√© dans la valeur <code>Ok</code>. Cette syntaxe <code>Ok(())</code> peut sembler un peu
√©trange au d√©part, mais utiliser <code>()</code> de cette mani√®re est la fa√ßon id√©ale
d'indiquer que nous appelons <code>run</code> uniquement pour ses effets de bord¬†; elle
ne retourne pas de valeur dont nous pourrions avoir besoin.</p>
<!--
When you run this code, it will compile but will display a warning:
-->
<p>Lorsque vous ex√©cutez ce code, il va se compiler mais il va afficher un
avertissement¬†:</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  -- > src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
On recherche¬†: the
Dans le fichier¬†: poem.txt
Dans le texte :
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Rust tells us that our code ignored the `Result` value and the `Result` value
might indicate that an error occurred. But we‚Äôre not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let‚Äôs rectify that problem now.
-->
<p>Rust nous informe que notre code ignore la valeur <code>Result</code> et que cette valeur
<code>Result</code> pourrait indiquer qu'une erreur s'est pass√©e. Mais nous ne v√©rifions
pas pour savoir si oui ou non il y a eu une erreur, et le compilateur nous
rappelle que nous devrions avoir du code de gestion des erreurs ici !
Corrigeons d√®s √† pr√©sent ce probl√®me.</p>
<!--
#### Handling Errors Returned from `run` in `main`
-->
<h4 id="g√©rer-les-erreurs-retourn√©es-par-run-dans-main"><a class="header" href="#g√©rer-les-erreurs-retourn√©es-par-run-dans-main">G√©rer les erreurs retourn√©es par <code>run</code> dans <code>main</code></a></h4>
<!--
We‚Äôll check for errors and handle them using a technique similar to one we used
with `Config::new` in Listing 12-10, but with a slight difference:
-->
<p>Nous allons v√©rifier les erreurs et les g√©rer en utilisant une technique
similaire √† celle que nous avons utilis√©e avec <code>Config::new</code> dans l'encart
12-10, mais avec une l√©g√®re diff√©rence¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}
# 
# fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masqu√©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);

    if let Err(e) = run(config) {
        println!(&quot;Erreur applicative¬†: {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We use `if let` rather than `unwrap_or_else` to check whether `run` returns an
`Err` value and call `process::exit(1)` if it does. The `run` function doesn‚Äôt
return a value that we want to `unwrap` in the same way that `Config::new`
returns the `Config` instance. Because `run` returns `()` in the success case,
we only care about detecting an error, so we don‚Äôt need `unwrap_or_else` to
return the unwrapped value because it would only be `()`.
-->
<p>Nous utilisons <code>if let</code> plut√¥t que <code>unwrap_or_else</code> pour v√©rifier si <code>run</code>
retourne un valeur <code>Err</code> et appeler <code>process::exit(1)</code> le cas √©ch√©ant. La
fonction <code>run</code> ne retourne pas de valeur sur laquelle nous aurions besoin
d'utiliser <code>unwrap</code> comme avec le <code>Config::new</code> qui retournait une instance de
<code>Config</code>. Comme <code>run</code> retourne <code>()</code> dans le cas d'un succ√®s, nous nous
pr√©occupons uniquement de d√©tecter les erreurs, donc nous n'avons pas besoin de
<code>unwrap_or_else</code> pour retourner la valeur extraite car elle sera toujours
<code>()</code>.</p>
<!--
The bodies of the `if let` and the `unwrap_or_else` functions are the same in
both cases: we print the error and exit.
-->
<p>Les corps du <code>if let</code> et de la fonction <code>unwrap_or_else</code> sont identiques dans
les deux cas¬†: nous affichons l'erreur et nous quittons.</p>
<!--
### Splitting Code into a Library Crate
-->
<h3 id="d√©placer-le-code-dans-une-crate-de-biblioth√®que"><a class="header" href="#d√©placer-le-code-dans-une-crate-de-biblioth√®que">D√©placer le code dans une crate de biblioth√®que</a></h3>
<!--
Our `minigrep` project is looking good so far! Now we‚Äôll split the
*src/main.rs* file and put some code into the *src/lib.rs* file so we can test
it and have a *src/main.rs* file with fewer responsibilities.
-->
<p>Notre projet <code>minigrep</code> se pr√©sente plut√¥t bien pour le moment¬†! Maintenant,
nous allons diviser notre fichier <em>src/main.rs</em> et d√©placer du code dans le
fichier <em>src/lib.rs</em> pour que nous puissions le tester et avoir un fichier
<em>src/main.rs</em> qui h√©berge moins de fonctionnalit√©s.</p>
<!--
Let‚Äôs move all the code that isn‚Äôt the `main` function from *src/main.rs* to
*src/lib.rs*:
-->
<p>D√©pla√ßons tout le code qui ne fait pas partie de la fonction <code>main</code> dans le
<em>src/main.rs</em> vers le <em>src/lib.rs</em>¬†:</p>
<!--
* The `run` function definition
* The relevant `use` statements
* The definition of `Config`
* The `Config::new` function definition
-->
<ul>
<li>La d√©finition de la fonction <code>run</code></li>
<li>Les instructions <code>use</code> correspondantes</li>
<li>La d√©finition de <code>Config</code></li>
<li>La d√©finition de la fonction <code>Config::new</code></li>
</ul>
<!--
The contents of *src/lib.rs* should have the signatures shown in Listing 12-13
(we‚Äôve omitted the bodies of the functions for brevity). Note that this won‚Äôt
compile until we modify *src/main.rs* in Listing 12-14.
-->
<p>Le contenu du <em>src/lib.rs</em> devrait contenir les signatures de l'encart 12-13
(nous avons enlev√© les corps des fonctions pour des raisons de bri√®vet√©). Notez
que cela ne va pas se compiler jusqu'√† ce que nous modifions le <em>src/main.rs</em>
dans l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        // --snip--
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masqu√©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // -- partie masqu√©e ici --
<span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 12-13: Moving `Config` and `run` into
*src/lib.rs*</span>
-->
<p><span class="caption">Encart 12-13¬†: D√©placement de <code>Config</code> et de <code>run</code> dans
<em>src/lib.rs</em></span></p>
<!--
We‚Äôve made liberal use of the `pub` keyword: on `Config`, on its fields and its
`new` method, and on the `run` function. We now have a library crate that has a
public API that we can test!
-->
<p>Nous avons fait un usage g√©n√©reux du mot-cl√© <code>pub</code>¬†: sur <code>Config</code>, sur ses
champs et sur la m√©thode <code>new</code> et enfin sur la fonction <code>run</code>. Nous avons maintenant
une crate de biblioth√®que qui a une API publique que nous pouvons tester¬†!</p>
<!--
Now we need to bring the code we moved to *src/lib.rs* into the scope of the
binary crate in *src/main.rs*, as shown in Listing 12-14.
-->
<p>Maintenant nous devons importer le code que nous avons d√©plac√© dans
<em>src/lib.rs</em> dans la port√©e de la crate binaire dans <em>src/main.rs</em>, comme dans
l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
    if let Err(e) = minigrep::run(config) {
        // --snip--
#         println!("Application error: {}", e);
# 
#         process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // -- partie masqu√©e ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // -- partie masqu√©e ici --
<span class="boring">        println!(&quot;Erreur applicative¬†: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 12-14: Using the `minigrep` library crate in
*src/main.rs*</span>
-->
<p><span class="caption">Encart 12-14¬†: Utilisation de la crate de biblioth√®que
<code>minigrep</code> dans <em>src/main.rs</em></span></p>
<!--
We add a `use minigrep::Config` line to bring the `Config` type from the
library crate into the binary crate‚Äôs scope, and we prefix the `run` function
with our crate name. Now all the functionality should be connected and should
work. Run the program with `cargo run` and make sure everything works
correctly.
-->
<p>Nous avons ajout√© une ligne <code>use minigrep::Config</code> pour importer le type
<code>Config</code> de la crate de biblioth√®que dans la port√©e de la crate binaire, et
nous avons avons pr√©fix√© la fonction <code>run</code> avec le nom de notre crate.
Maintenant, toutes les fonctionnalit√©s devraient √™tre connect√©es et devraient
fonctionner. Lancez le programme avec <code>cargo run</code> pour vous assurer que tout
fonctionne correctement.</p>
<!--
Whew! That was a lot of work, but we‚Äôve set ourselves up for success in the
future. Now it‚Äôs much easier to handle errors, and we‚Äôve made the code more
modular. Almost all of our work will be done in *src/lib.rs* from here on out.
-->
<p>Ouah¬†! C'√©tait pas mal de travail, mais nous nous sommes organis√©s pour nous assurer
le succ√®s √† venir. Maintenant il est bien plus facile de g√©rer les erreurs, et
nous avons rendu le code plus modulaire. A partir de maintenant, l'essentiel de
notre travail sera effectu√© dans <em>src/lib.rs</em>.</p>
<!--
Let‚Äôs take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we‚Äôll
write some tests!
-->
<p>Profitons de cette nouvelle modularit√© en accomplissant quelque chose qui
aurait √©t√© difficile √† faire avec l'ancien code, mais qui est facile avec ce
nouveau code¬†: nous allons √©crire des tests¬†!</p>
<!--
[ch13]: ch13-00-functional-features.html
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[ch9-result]: ch09-02-recoverable-errors-with-result.html
[ch17]: ch17-00-oop.html
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
