<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Des erreurs r√©cup√©rables avec Result - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Recoverable Errors with `Result`
-->
<h2 id="des-erreurs-r√©cup√©rables-avec-result"><a class="header" href="#des-erreurs-r√©cup√©rables-avec-result">Des erreurs r√©cup√©rables avec <code>Result</code></a></h2>
<!--
Most errors aren‚Äôt serious enough to require the program to stop entirely.
Sometimes, when a function fails, it‚Äôs for a reason that you can easily
interpret and respond to. For example, if you try to open a file and that
operation fails because the file doesn‚Äôt exist, you might want to create the
file instead of terminating the process.
-->
<p>La plupart des erreurs ne sont pas assez graves au point d'arr√™ter compl√®tement
le programme. Parfois, lorsqu'une fonction √©choue, c'est pour une raison que
vous pouvez facilement comprendre et pour laquelle vous pouvez agir en
cons√©quence. Par exemple, si vous essayez d'ouvrir un fichier et que l'op√©ration
√©choue parce que le fichier n'existe pas, vous pourriez vouloir cr√©er le fichier
plut√¥t que d'arr√™ter le processus.</p>
<!--
Recall from [‚ÄúHandling Potential Failure with the `Result`
Type‚Äù][handle_failure]<!-- ignore -- > in Chapter 2 that the `Result` enum is
defined as having two variants, `Ok` and `Err`, as follows:
-->
<p>Souvenez-vous de la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">‚ÄúG√©rer les erreurs potentielles avec le type
<code>Result</code>‚Äù</a><!-- ignore --> du chapitre 2 que l'√©num√©ration
<code>Result</code> poss√®de deux variantes, <code>Ok</code> et <code>Err</code>, comme ci-dessous¬†:</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `T` and `E` are generic type parameters: we‚Äôll discuss generics in more
detail in Chapter 10. What you need to know right now is that `T` represents
the type of the value that will be returned in a success case within the `Ok`
variant, and `E` represents the type of the error that will be returned in a
failure case within the `Err` variant. Because `Result` has these generic type
parameters, we can use the `Result` type and the functions defined on it in
many different situations where the successful value and error value we want to
return may differ.
-->
<p>Le <code>T</code> et le <code>E</code> sont des param√®tres de type g√©n√©riques¬†: nous parlerons plus en
d√©tail de la g√©n√©ricit√© au chapitre 10. Tout ce que vous avez besoin de savoir
pour le moment, c'est que <code>T</code> repr√©sente le type de valeur imbriqu√©e dans la
variante <code>Ok</code> qui sera retourn√©e dans le cas d'un succ√®s, et <code>E</code> repr√©sente le
type d'erreur imbriqu√©e dans la variante <code>Err</code> qui sera retourn√©e dans le cas
d'un √©chec. Comme <code>Result</code> a ces param√®tres de type g√©n√©riques, nous pouvons
utiliser le type <code>Result</code> et les fonctions associ√©es dans diff√©rentes
situations o√π la valeur de succ√®s et la valeur d'erreur peuvent varier.</p>
<!--
Let‚Äôs call a function that returns a `Result` value because the function could
fail. In Listing 9-3 we try to open a file.
-->
<p>Utilisons une fonction qui retourne une valeur de type <code>Result</code> car la fonction
peut √©chouer. Dans l'encart 9-3, nous essayons d'ouvrir un fichier¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-3: Opening a file</span>
-->
<p><span class="caption">Encart 9-3¬†: ouverture d'un fichier</span></p>
<!--
How do we know `File::open` returns a `Result`? We could look at the [standard
library API documentation](../std/index.html)<!-- ignore -- >, or we could ask
the compiler! If we give `f` a type annotation that we know is *not* the return
type of the function and then try to compile the code, the compiler will tell
us that the types don‚Äôt match. The error message will then tell us what the
type of `f` *is*. Let‚Äôs try it! We know that the return type of `File::open`
isn‚Äôt of type `u32`, so let‚Äôs change the `let f` statement to this:
-->
<p>Comment savons-nous que <code>File::open</code> retourne un <code>Result</code>¬†? Nous pouvons
consulter la <a href="https://doc.rust-lang.org/std/index.html">documentation de l'API de la biblioth√®que
standard</a><!-- ignore -->, ou nous
pouvons demander au compilateur¬†! Si nous appliquons √† <code>f</code> une annotation de
type dont nous savons qu'elle n'est <em>pas</em> le type de retour de la fonction et
que nous essayons ensuite de compiler le code, le compilateur va nous dire que
les types ne correspondent pas. Le message d'erreur va ensuite nous dire <em>quel
est le type</em> de <code>f</code>. Essayons cela¬†! Nous savons que le type de retour de
<code>File::open</code> n'est pas <code>u32</code>, alors essayons de changer l'instruction <code>let f</code>
par ceci¬†:</p>
<!--
```rust,ignore,does_not_compile
# use std::fs::File;
# 
# fn main() {
    let f: u32 = File::open("hello.txt");
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre>
<!--
Attempting to compile now gives us the following output:
-->
<p>Tenter de compiler ce code nous donne maintenant le r√©sultat suivant¬†:</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 -- > src/main.rs:4:18
  |
4 |     let f: u32 = File::open("hello.txt");
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `Result<File, std::io::Error>`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `Result&lt;File, std::io::Error&gt;`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling` due to previous error
</code></pre>
<!--
This tells us the return type of the `File::open` function is a `Result<T, E>`.
The generic parameter `T` has been filled in here with the type of the success
value, `std::fs::File`, which is a file handle. The type of `E` used in the
error value is `std::io::Error`.
-->
<p>Cela nous dit que le type de retour de la fonction <code>File::open</code> est de la forme
<code>Result&lt;T, E&gt;</code>. Le param√®tre g√©n√©rique <code>T</code> a √©t√© remplac√© dans ce cas par le
type en cas de succ√®s, <code>std::fs::File</code>, qui permet d'interagir avec le fichier.
Le <code>E</code> utilis√© pour la valeur d'erreur est du type <code>std::io::Error</code>.</p>
<!--
This return type means the call to `File::open` might succeed and return a file
handle that we can read from or write to. The function call also might fail:
for example, the file might not exist, or we might not have permission to
access the file. The `File::open` function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the `Result` enum
conveys.
-->
<p>Ce type de retour veut dire que l'appel √† <code>File::open</code> peut r√©ussir et nous
retourner un manipulateur de fichier qui peut nous permettre de le lire ou d'y
√©crire. L'utilisation de cette fonction peut aussi √©chouer¬†: par exemple, si le
fichier n'existe pas, ou si nous n'avons pas le droit d'acc√©der au fichier. La
fonction <code>File::open</code> doit avoir un moyen de nous dire si son utilisation a
r√©ussi ou √©chou√© et en m√™me temps nous fournir soit le manipulateur de fichier,
soit des informations sur l'erreur. C'est exactement ces informations que
l'√©num√©ration <code>Result</code> se charge de nous transmettre.</p>
<!--
In the case where `File::open` succeeds, the value in the variable `f` will be
an instance of `Ok` that contains a file handle. In the case where it fails,
the value in `f` will be an instance of `Err` that contains more information
about the kind of error that happened.
-->
<p>Dans le cas o√π <code>File::open</code> r√©ussit, la valeur que nous obtiendrons dans la
variable <code>f</code> sera une instance de <code>Ok</code> qui contiendra un manipulateur de
fichier. Dans le cas o√π cela √©choue, la valeur dans <code>f</code> sera une instance de
<code>Err</code> qui contiendra plus d'information sur le type d'erreur qui a eu lieu.</p>
<!--
We need to add to the code in Listing 9-3 to take different actions depending
on the value `File::open` returns. Listing 9-4 shows one way to handle the
`Result` using a basic tool, the `match` expression that we discussed in
Chapter 6.
-->
<p>Nous avons besoin d'ajouter diff√©rentes actions dans le code de l'encart 9-3 en
fonction de la valeur que <code>File::open</code> retourne. L'encart 9-4 montre une fa√ßon
de g√©rer le <code>Result</code> en utilisant un outil basique, l'expression <code>match</code> que
nous avons vue au chapitre 6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; panic!(&quot;Erreur d'ouverture du fichier¬†: {:?}&quot;, erreur),
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-4: Using a `match` expression to handle the
`Result` variants that might be returned</span>
-->
<p><span class="caption">Encart 9-4¬†: utilisation de l'expression <code>match</code> pour
g√©rer les variantes de <code>Result</code> qui peuvent √™tre retourn√©es</span></p>
<!--
Note that, like the `Option` enum, the `Result` enum and its variants have been
brought into scope by the prelude, so we don‚Äôt need to specify `Result::`
before the `Ok` and `Err` variants in the `match` arms.
-->
<p>Remarquez que, tout comme l'√©num√©ration <code>Option</code>, l'√©num√©ration <code>Result</code> et ses
variantes ont √©t√© import√©es par l'√©tape pr√©liminaire, donc vous n'avez pas
besoin de pr√©ciser <code>Result::</code> devant les variantes <code>Ok</code> et <code>Err</code> dans les
branches du <code>match</code>.</p>
<!--
When the result is `Ok`, this code will return the inner `file` value out of
the `Ok` variant, and we then assign that file handle value to the variable
`f`. After the `match`, we can use the file handle for reading or writing.
-->
<p>Lorsque le r√©sultat est <code>Ok</code>, ce code va retourner la valeur <code>fichier</code> contenue
dans la variante <code>Ok</code>, et nous assignons ensuite cette valeur √† la variable
<code>f</code>. Apr√®s le <code>match</code>, nous pourrons ensuite utiliser le manipulateur de
fichier pour lire ou √©crire.</p>
<!--
The other arm of the `match` handles the case where we get an `Err` value from
`File::open`. In this example, we‚Äôve chosen to call the `panic!` macro. If
there‚Äôs no file named *hello.txt* in our current directory and we run this
code, we‚Äôll see the following output from the `panic!` macro:
-->
<p>L'autre branche du bloc <code>match</code> g√®re le cas o√π nous obtenons un <code>Err</code> √† l'appel
de <code>File::open</code>. Dans cet exemple, nous avons choisi de faire appel √† la macro
<code>panic!</code>. S'il n'y a pas de fichier qui s'appelle <em>hello.txt</em> dans notre
r√©pertoire actuel et que nous ex√©cutons ce code, nous allons voir la sortie
suivante suite √† l'appel de la macro <code>panic!</code>¬†:</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Erreur d'ouverture du fichier : Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:24
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
As usual, this output tells us exactly what has gone wrong.
-->
<p>Comme d'habitude, cette sortie nous explique avec pr√©cision ce qui s'est mal
pass√©.</p>
<!--
### Matching on Different Errors
-->
<h3 id="g√©rer-les-diff√©rentes-erreurs"><a class="header" href="#g√©rer-les-diff√©rentes-erreurs">G√©rer les diff√©rentes erreurs</a></h3>
<!--
The code in Listing 9-4 will `panic!` no matter why `File::open` failed.
However, we want to take different actions for different failure reasons: if
`File::open` failed because the file doesn‚Äôt exist, we want to create the file
and return the handle to the new file. If `File::open` failed for any other
reason‚Äîfor example, because we didn‚Äôt have permission to open the file‚Äîwe still
want the code to `panic!` in the same way as it did in Listing 9-4. For this we
add an inner `match` expression, shown in Listing 9-5.
-->
<p>Le code dans l'encart 9-4 va faire un <code>panic!</code> peu importe la raison de l'√©chec
de <code>File::open</code>. Cependant, nous voulons r√©agir diff√©remment en fonction de
diff√©rents cas d'erreurs¬†: si <code>File::open</code> a √©chou√© parce que le
fichier n'existe pas, nous voulons cr√©er le fichier et retourner le manipulateur
de fichier pour ce nouveau fichier. Si <code>File::open</code> √©choue pour toute autre
raison, par exemple si nous n'avons pas l'autorisation d'ouvrir le fichier,
nous voulons quand m√™me que le code lance un <code>panic!</code> de la m√™me mani√®re qu'il
l'a fait dans l'encart 9-4. C'est pourquoi nous avons ajout√© dans l'encart 9-5
une expression <code>match</code> imbriqu√©e¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -- >
-->
<!--
```rust,ignore
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}
```
-->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; match erreur.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Erreur de cr√©ation du fichier¬†: {:?}&quot;, e),
            },
            autre_erreur =&gt; {
                panic!(&quot;Erreur d'ouverture du fichier¬†: {:?}&quot;, autre_erreur)
            }
        },
    };
}
</code></pre>
<!--
<span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span>
-->
<p><span class="caption">Encart 9-5¬†: gestion des diff√©rents cas d'erreurs avec des
actions diff√©rentes</span></p>
<!--
The type of the value that `File::open` returns inside the `Err` variant is
`io::Error`, which is a struct provided by the standard library. This struct
has a method `kind` that we can call to get an `io::ErrorKind` value. The enum
`io::ErrorKind` is provided by the standard library and has variants
representing the different kinds of errors that might result from an `io`
operation. The variant we want to use is `ErrorKind::NotFound`, which indicates
the file we‚Äôre trying to open doesn‚Äôt exist yet. So we match on `f`, but we
also have an inner match on `error.kind()`.
-->
<p>La valeur de retour de <code>File::open</code> log√©e dans la variante <code>Err</code> est de type
<code>io::Error</code>, qui est une structure fournie par la biblioth√®que standard. Cette
structure a une m√©thode <code>kind</code> que nous pouvons appeler pour obtenir une valeur
de type <code>io::ErrorKind</code>. L'√©num√©ration <code>io::ErrorKind</code> est fournie elle aussi
par la biblioth√®que standard et a des variantes qui repr√©sentent les diff√©rents
types d'erreurs qui pourraient r√©sulter d'une op√©ration provenant du module
<code>io</code>. La variante que nous voulons utiliser est <code>ErrorKind::NotFound</code>, qui
indique que le fichier que nous essayons d'ouvrir n'existe pas encore. Donc nous
utilisons <code>match</code> sur <code>f</code>, mais nous avons dans celle-ci un autre <code>match</code> sur
<code>erreur.kind()</code>.</p>
<!--
The condition we want to check in the inner match is whether the value returned
by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is,
we try to create the file with `File::create`. However, because `File::create`
could also fail, we need a second arm in the inner `match` expression. When the
file can‚Äôt be created, a different error message is printed. The second arm of
the outer `match` stays the same, so the program panics on any error besides
the missing file error.
-->
<p>Nous souhaitons v√©rifier dans le <code>match</code> interne si la valeur de retour de
<code>error.kind()</code> est la variante <code>NotFound</code> de l'√©num√©ration <code>ErrorKind</code>. Si c'est
le cas, nous essayons de cr√©er le fichier avec <code>File::create</code>. Cependant, comme
<code>File::create</code> peut aussi √©chouer, nous avons besoin d'une seconde branche dans
le <code>match</code> interne. Lorsque le fichier ne peut pas √™tre cr√©√©, un message
d'erreur diff√©rent est affich√©. La seconde branche du <code>match</code> principal reste
inchang√©e, donc le programme panique lorsqu'on rencontre une autre erreur que
l'absence de fichier.</p>
<!--
> ### Alternatives to Using `match` with `Result<T, E>`
>
> That‚Äôs a lot of `match`! The `match` expression is very useful but also very
> much a primitive. In Chapter 13, you‚Äôll learn about closures, which are used
> with many of the methods defined on `Result<T, E>`. These methods can be more
> concise than using `match` when handling `Result<T, E>` values in your code.
>
> For example, here‚Äôs another way to write the same logic as shown in Listing
> 9-5 but using closures and the `unwrap_or_else` method:
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -- >
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let f = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {:?}", error);
>             })
>         } else {
>             panic!("Problem opening the file: {:?}", error);
>         }
>     });
> }
> ```
>
> Although this code has the same behavior as Listing 9-5, it doesn‚Äôt contain
> any `match` expressions and is cleaner to read. Come back to this example
> after you‚Äôve read Chapter 13, and look up the `unwrap_or_else` method in the
> standard library documentation. Many more of these methods can clean up huge
> nested `match` expressions when you‚Äôre dealing with errors.
-->
<blockquote>
<h3 id="dautres-solutions-pour-utiliser-match-avec-resultt-e"><a class="header" href="#dautres-solutions-pour-utiliser-match-avec-resultt-e">D'autres solutions pour utiliser <code>match</code> avec <code>Result&lt;T, E&gt;</code></a></h3>
<p>Cela commence √† faire beaucoup de <code>match</code>¬†! L'expression <code>match</code> est tr√®s
utile mais elle est aussi assez rudimentaire. Dans le chapitre 13, vous en
apprendrez plus sur les fermetures, qui sont utilis√©es avec de nombreuses
m√©thodes d√©finies sur <code>Result&lt;T, E&gt;</code>. Ces m√©thodes peuvent s'av√©rer √™tre plus
concises que l'utilisation de <code>match</code> lorsque vous travaillez avec des
valeurs <code>Result&lt;T, E&gt;</code> dans votre code.</p>
<p>Par exemple, voici une autre mani√®re d'√©crire la m√™me logique que celle dans
l'encart 9-5 mais en utilisant les fermetures et la m√©thode
<code>unwrap_or_else</code>¬†:</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
        if erreur.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
                panic!(&quot;Erreur de cr√©ation du fichier¬†: {:?}&quot;, erreur);
            })
        } else {
            panic!(&quot;Erreur d'ouverture du fichier¬†: {:?}&quot;, erreur);
        }
    });
}
</code></pre>
<p>Bien que ce code ait le m√™me comportement que celui de l'encart 9-5, il ne
contient aucune expression <code>match</code> et est plus facile √† lire. Revenez sur cet
exemple apr√®s avoir lu le chapitre 13, et renseignez-vous sur la m√©thode
<code>unwrap_or_else</code> dans la documentation de la biblioth√®que standard. De
nombreuses m√©thodes de ce type peuvent clarifier de grosses expressions
<code>match</code> imbriqu√©es lorsque vous traitez les erreurs.</p>
</blockquote>
<!--
### Shortcuts for Panic on Error: `unwrap` and `expect`
-->
<h3 id="raccourcis-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect"><a class="header" href="#raccourcis-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect">Raccourcis pour faire un panic lors d'une erreur¬†: <code>unwrap</code> et <code>expect</code></a></h3>
<!--
Using `match` works well enough, but it can be a bit verbose and doesn‚Äôt always
communicate intent well. The `Result<T, E>` type has many helper methods
defined on it to do various, more specific tasks. The `unwrap` method is a
shortcut method implemented just like the `match` expression we wrote in
Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return
the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will
call the `panic!` macro for us. Here is an example of `unwrap` in action:
-->
<p>L'utilisation de <code>match</code> fonctionne assez bien, mais elle peut √™tre un peu
verbeuse et ne communique pas forc√©ment bien son intention. Le type
<code>Result&lt;T, E&gt;</code> a de nombreuses m√©thodes qui lui ont √©t√© d√©finies pour
diff√©rents cas. La m√©thode <code>unwrap</code> est une m√©thode de raccourci impl√©ment√©e
comme l'expression <code>match</code> que nous avons √©crite dans l'encart 9-4. Si la
valeur de <code>Result</code> est la variante <code>Ok</code>, <code>unwrap</code> va retourner la valeur
contenue dans le <code>Ok</code>. Si le <code>Result</code> est la variante <code>Err</code>, <code>unwrap</code> va
appeler la macro <code>panic!</code> pour nous. Voici un exemple de <code>unwrap</code> en action¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<!--
If we run this code without a *hello.txt* file, we‚Äôll see an error message from
the `panic!` call that the `unwrap` method makes:
-->
<p>Si nous ex√©cutons ce code alors qu'il n'y a pas de fichier <em>hello.txt</em>, nous
allons voir un message d'erreur suite √† l'appel √† <code>panic!</code> que la m√©thode
<code>unwrap</code> a fait¬†:</p>
<!--
```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: "No such file or directory" } }',
src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<!--
Similarly, the `expect` method lets us also choose the `panic!` error message.
Using `expect` instead of `unwrap` and providing good error messages can convey
your intent and make tracking down the source of a panic easier. The syntax of
`expect` looks like this:
-->
<p>De la m√™me mani√®re, la m√©thode <code>expect</code> nous donne la possibilit√© de d√©finir le
message d'erreur du <code>panic!</code>. Utiliser <code>expect</code> plut√¥t que <code>unwrap</code> et lui
fournir un bon message d'erreur permet de mieux exprimer le probl√®me et
faciliter la recherche de la source d'un panic. La syntaxe de <code>expect</code> est la
suivante¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;√âchec √† l'ouverture de hello.txt&quot;);
}
</code></pre></pre>
<!--
We use `expect` in the same way as `unwrap`: to return the file handle or call
the `panic!` macro. The error message used by `expect` in its call to `panic!`
will be the parameter that we pass to `expect`, rather than the default
`panic!` message that `unwrap` uses. Here‚Äôs what it looks like:
-->
<p>Nous utilisons <code>expect</code> de la m√™me mani√®re que <code>unwrap</code>¬†: pour retourner le
manipulateur de fichier ou appeler la macro <code>panic!</code>. Le message d'erreur
utilis√© par <code>expect</code> lors de son appel √† <code>panic!</code> sera le param√®tre que nous
avons pass√© √† <code>expect</code>, plut√¥t que le message par d√©faut de <code>panic!</code> qu'utilise
<code>unwrap</code>. Voici ce que cela donne¬†:</p>
<!--
```text
thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: "No such file or directory" } }', src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at '√âchec √† l'ouverture de hello.txt: Error { repr: Os {
code: 2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<!--
Because this error message starts with the text we specified, `Failed to open
hello.txt`, it will be easier to find where in the code this error message is
coming from. If we use `unwrap` in multiple places, it can take more time to
figure out exactly which `unwrap` is causing the panic because all `unwrap`
calls that panic print the same message.
-->
<p>Comme ce message d'erreur commence par le texte que nous avons pr√©cis√©, <code>√âchec √† l'ouverture de hello.txt</code>, ce sera plus facile de trouver l√† d'o√π provient ce
message d'erreur dans le code. Si nous utilisons <code>unwrap</code> √† plusieurs endroits,
cela peut prendre plus de temps de comprendre exactement quel <code>unwrap</code> a caus√©
le panic, car tous les appels √† <code>unwrap</code> vont afficher le m√™me message.</p>
<!--
### Propagating Errors
-->
<h3 id="propager-les-erreurs"><a class="header" href="#propager-les-erreurs">Propager les erreurs</a></h3>
<!--
When a function‚Äôs implementation calls something that might fail, instead of
handling the error within the function itself, you can return the error to the
calling code so that it can decide what to do. This is known as *propagating*
the error and gives more control to the calling code, where there might be more
information or logic that dictates how the error should be handled than what
you have available in the context of your code.
-->
<p>Lorsqu'une fonction dont l'impl√©mentation utilise quelque chose qui peut
√©chouer, au lieu de g√©rer l'erreur directement dans cette fonction, vous pouvez
retourner cette erreur au code qui l'appelle pour qu'il d√©cide quoi faire.
C'est ce que l'on appelle <em>propager</em> l'erreur et donne ainsi plus de contr√¥le
au code qui appelle la fonction, dans lequel il peut y avoir plus
d'informations ou d'instructions pour traiter l'erreur que dans le contexte de
votre code.</p>
<!--
For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn‚Äôt exist or can‚Äôt be read, this function will return those errors
to the code that called the function.
-->
<p>Par exemple, l'encart 9-6 montre une fonction qui lit un pseudo √† partir d'un
fichier. Si ce fichier n'existe pas ou ne peut pas √™tre lu, cette fonction va
retourner ces erreurs au code qui a appel√© la fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(fichier) =&gt; fichier,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-6: A function that returns errors to the
calling code using `match`</span>
-->
<p><span class="caption">Encart 9-6¬†: une fonction qui retourne les erreurs au code
qui l'appelle en utilisant <code>match</code></span></p>
<!--
This function can be written in a much shorter way, but we‚Äôre going to start by
doing a lot of it manually in order to explore error handling; at the end,
we‚Äôll show the shorter way. Let‚Äôs look at the return type of the function
first: `Result<String, io::Error>`. This means the function is returning a
value of the type `Result<T, E>` where the generic parameter `T` has been
filled in with the concrete type `String`, and the generic type `E` has been
filled in with the concrete type `io::Error`. If this function succeeds without
any problems, the code that calls this function will receive an `Ok` value that
holds a `String`‚Äîthe username that this function read from the file. If this
function encounters any problems, the calling code will receive an `Err` value
that holds an instance of `io::Error` that contains more information about what
the problems were. We chose `io::Error` as the return type of this function
because that happens to be the type of the error value returned from both of
the operations we‚Äôre calling in this function‚Äôs body that might fail: the
`File::open` function and the `read_to_string` method.
-->
<p>Cette fonction peut √™tre √©crite de fa√ßon plus concise, mais nous avons d√©cid√© de
commencer par faire un maximum de choses manuellement pour d√©couvrir la gestion
d'erreurs¬†; mais √† la fin, nous verrons comment raccourcir le code. Commen√ßons
par regarder le type de retour de la fonction¬†: <code>Result&lt;String, io::Error&gt;</code>.
Cela signifie que la fonction retourne une valeur de type <code>Result&lt;T, E&gt;</code> o√π le
param√®tre g√©n√©rique <code>T</code> a √©t√© remplac√© par le type <code>String</code> et le param√®tre
g√©n√©rique <code>E</code> a √©t√© remplac√© par le type <code>io::Error</code>. Si cette fonction r√©ussit
sans probl√®me, le code qui appellant va obtenir une valeur <code>Ok</code> qui contient
une <code>String</code>, le pseudo que cette fonction lit dans le fichier. Si cette
fonction rencontre un probl√®me, le code qui appelle cette fonction va obtenir
une valeur <code>Err</code> qui contient une instance de <code>io::Error</code> qui donne plus
d'informations sur la raison du probl√®me. Nous avons choisi <code>io::Error</code> comme
type de retour de cette fonction parce qu'il se trouve que c'est le type
d'erreur de retour pour les deux op√©rations qui peuvent √©chouer que l'on utilise
dans le corps de cette fonction¬†: la fonction <code>File::open</code> et la m√©thode
<code>read_to_string</code>.</p>
<!--
The body of the function starts by calling the `File::open` function. Then we
handle the `Result` value with a `match` similar to the `match` in Listing 9-4.
If `File::open` succeeds, the file handle in the pattern variable `file`
becomes the value in the mutable variable `f` and the function continues. In
the `Err` case, instead of calling `panic!`, we use the `return` keyword to
return early out of the function entirely and pass the error value from
`File::open`, now in the pattern variable `e`, back to the calling code as this
function‚Äôs error value.
-->
<p>Le corps de la fonction commence par appeler la fonction <code>File::open</code>. Ensuite,
nous g√©rons la valeur du <code>Result</code> avec un <code>match</code> similaire au <code>match</code> de
l'encart 9-4. Si le <code>File::open</code> est un succ√®s, le manipulateur de fichier dans
la variable <code>fichier</code> du motif devient la valeur dans la variable mutable <code>f</code>
et la fonction continue son d√©roulement. Dans le cas d'un <code>Err</code>, au lieu
d'appeler <code>panic!</code>, nous utilisons <code>return</code> pour sortir pr√©matur√©ment de toute
la fonction et en passant la valeur du <code>File::open</code>, d√©sormais dans la variable
<code>e</code>, au code appelant comme valeur de retour de cette fonction.</p>
<!--
So if we have a file handle in `f`, the function then creates a new `String` in
variable `s` and calls the `read_to_string` method on the file handle in `f` to
read the contents of the file into `s`. The `read_to_string` method also
returns a `Result` because it might fail, even though `File::open` succeeded.
So we need another `match` to handle that `Result`: if `read_to_string`
succeeds, then our function has succeeded, and we return the username from the
file that‚Äôs now in `s` wrapped in an `Ok`. If `read_to_string` fails, we return
the error value in the same way that we returned the error value in the `match`
that handled the return value of `File::open`. However, we don‚Äôt need to
explicitly say `return`, because this is the last expression in the function.
-->
<p>Donc si nous avons un manipulateur de fichier dans <code>f</code>, la fonction cr√©e
ensuite une nouvelle <code>String</code> dans la variable <code>s</code> et nous appelons la m√©thode
<code>read_to_string</code> sur le manipulateur de fichier <code>f</code> pour extraire le contenu du
fichier dans <code>s</code>. La m√©thode <code>read_to_string</code> retourne aussi un <code>Result</code> car
elle peut √©chouer, m√™me si <code>File::open</code> a r√©ussi. Nous avons donc besoin d'un
nouveau <code>match</code> pour g√©rer ce <code>Result</code>¬†: si <code>read_to_string</code> r√©ussit, alors
notre fonction a r√©ussi, et nous retournons le pseudo que nous avons extrait du
fichier qui est maintenant int√©gr√© dans un <code>Ok</code>, lui-m√™me stock√© dans <code>s</code>. Si
<code>read_to_string</code> √©choue, nous retournons la valeur d'erreur de la m√™me fa√ßon
que nous avons retourn√© la valeur d'erreur dans le <code>match</code> qui g√©rait la valeur
de retour de <code>File::open</code>. Cependant, nous n'avons pas besoin d'√©crire
explicitement <code>return</code>, car c'est la derni√®re expression de la fonction.</p>
<!--
The code that calls this code will then handle getting either an `Ok` value
that contains a username or an `Err` value that contains an `io::Error`. It‚Äôs
up to the calling code to decide what to do with those values. If the calling
code gets an `Err` value, it could call `panic!` and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don‚Äôt have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.
-->
<p>Le code qui appelle ce code va devoir ensuite g√©rer les cas o√π il r√©cup√®re une
valeur <code>Ok</code> qui contient un pseudo, ou une valeur <code>Err</code> qui contient une
<code>io::Error</code>. Il revient au code appelant de d√©cider quoi faire avec ces
valeurs. Si le code appelant obtient une valeur <code>Err</code>, il peut appeler <code>panic!</code>
et faire planter le programme, utiliser un pseudo par d√©faut, ou chercher le
pseudo autre part que dans ce fichier, par exemple. Nous n'avons pas assez
d'informations sur ce que le code appelant a l'intention de faire, donc nous
remontons toutes les informations de succ√®s ou d'erreur pour qu'elles soient
g√©r√©es correctement.</p>
<!--
This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator `?` to make this easier.
-->
<p>Cette fa√ßon de propager les erreurs est si courante en Rust que Rust fournit
l'op√©rateur point d'interrogation <code>?</code> pour faciliter ceci.</p>
<!--
#### A Shortcut for Propagating Errors: the `?` Operator
-->
<h4 id="un-raccourci-pour-propager-les-erreurs--lop√©rateur-"><a class="header" href="#un-raccourci-pour-propager-les-erreurs--lop√©rateur-">Un raccourci pour propager les erreurs¬†: l'op√©rateur <code>?</code></a></h4>
<!--
Listing 9-7 shows an implementation of `read_username_from_file` that has the
same functionality as in Listing 9-6, but this implementation uses the
`?` operator.
-->
<p>L'encart 9-7 montre une impl√©mentation de <code>lire_pseudo_depuis_fichier</code> qui a
les m√™mes fonctionnalit√©s que dans l'encart 9-6, mais cette impl√©mentation
utilise l'op√©rateur point d'interrogation <code>?</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-7: A function that returns errors to the
calling code using the `?` operator</span>
-->
<p><span class="caption">Encart 9-7¬†: une fonction qui retourne les erreurs au code
appelant en utilisant l'op√©rateur <code>?</code></span></p>
<!--
The `?` placed after a `Result` value is defined to work in almost the same way
as the `match` expressions we defined to handle the `Result` values in Listing
9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will
get returned from this expression, and the program will continue. If the value
is an `Err`, the `Err` will be returned from the whole function as if we had
used the `return` keyword so the error value gets propagated to the calling
code.
-->
<p>Le <code>?</code> plac√© apr√®s une valeur <code>Result</code> est con√ßu pour fonctionner presque de la
m√™me mani√®re que les expressions <code>match</code> que nous avons d√©finies pour g√©rer les
valeurs <code>Result</code> dans l'encart 9-6. Si la valeur du <code>Result</code> est un <code>Ok</code>, la
valeur dans le <code>Ok</code> sera retourn√©e par cette expression et le programme
continuera. Si la valeur est un <code>Err</code>, le <code>Err</code> sera retourn√© par la fonction
comme si nous avions utilis√© le mot-cl√© <code>return</code> afin que la valeur d'erreur
soit propag√©e au code appelant.</p>
<!--
There is a difference between what the `match` expression from Listing 9-6 does
and what the `?` operator does: error values that have the `?` operator called
on them go through the `from` function, defined in the `From` trait in the
standard library, which is used to convert errors from one type into another.
When the `?` operator calls the `from` function, the error type received is
converted into the error type defined in the return type of the current
function. This is useful when a function returns one error type to represent
all the ways a function might fail, even if parts might fail for many different
reasons. As long as there‚Äôs an `impl From<OtherError> for ReturnedError` to
define the conversion in the trait‚Äôs `from` function, the `?` operator takes
care of calling the `from` function automatically.
-->
<p>Il y a une diff√©rence entre ce que fait l'expression <code>match</code> de l'encart 9-6 et
ce que fait l'op√©rateur <code>?</code>¬†: les valeurs d'erreurs sur lesquelles est utilis√©
l'op√©rateur <code>?</code> passent par la fonction <code>from</code>, d√©finie dans le trait <code>From</code> de
la biblioth√®que standard, qui est utilis√©e pour convertir les erreurs d'un type
√† un autre. Lorsque l'op√©rateur <code>?</code> appelle la fonction <code>from</code>, le type d'erreur
re√ßu est converti dans le type d'erreur d√©clar√© dans le type de retour de la
fonction concern√©e. C'est utile lorsqu'une fonction retourne un type d'erreur
qui peut couvrir tous les cas d'√©chec de la fonction, m√™me si certaines de ses
parties peuvent √©chouer pour diff√©rentes raisons. √Ä partir du moment qu'il y a
un <code>impl From&lt;AutreErreur&gt;</code> sur <code>ErreurRetournee</code> pour expliquer la conversion
dans la fonction <code>from</code> du trait, l'op√©rateur <code>?</code> se charge d'appeler la
fonction <code>from</code> automatiquement.</p>
<!--
In the context of Listing 9-7, the `?` at the end of the `File::open` call will
return the value inside an `Ok` to the variable `f`. If an error occurs, the
`?` operator will return early out of the whole function and give any `Err`
value to the calling code. The same thing applies to the `?` at the end of the
`read_to_string` call.
-->
<p>Dans le cas de l'encart 9-7, le <code>?</code> √† la fin de l'appel √† <code>File::open</code> va
retourner la valeur √† l'int√©rieur d'un <code>Ok</code> √† la variable <code>f</code>. Si une erreur se
produit, l'op√©rateur <code>?</code> va quitter pr√©matur√©ment la fonction et retourner une
valeur <code>Err</code> au code appelant. La m√™me chose se produira au <code>?</code> √† la fin de
l'appel √† <code>read_to_string</code>.</p>
<!--
The `?` operator eliminates a lot of boilerplate and makes this function‚Äôs
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the `?`, as shown in Listing 9-8.
-->
<p>L'op√©rateur <code>?</code> all√®ge l'√©criture de code et facilite l'impl√©mentation de la
fonction. Nous pouvons m√™me encore plus r√©duire ce code en encha√Ænant
imm√©diatement les appels aux m√©thodes apr√®s le <code>?</code> comme dans l'encart 9-8¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-8: Chaining method calls after the `?`
operator</span>
-->
<p><span class="caption">Encart 9-8¬†: encha√Ænement des appels aux m√©thodes apr√®s
l'op√©rateur <code>?</code></span></p>
<!--
We‚Äôve moved the creation of the new `String` in `s` to the beginning of the
function; that part hasn‚Äôt changed. Instead of creating a variable `f`, we‚Äôve
chained the call to `read_to_string` directly onto the result of
`File::open("hello.txt")?`. We still have a `?` at the end of the
`read_to_string` call, and we still return an `Ok` value containing the
username in `s` when both `File::open` and `read_to_string` succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.
-->
<p>Nous avons d√©plac√© la cr√©ation de la nouvelle <code>String</code> dans <code>s</code> au d√©but de la
fonction¬†; cette partie n'a pas chang√©. Au lieu de cr√©er la variable <code>f</code>, nous
encha√Ænons directement l'appel √† <code>read_to_string</code> sur le r√©sultat de
<code>File::open(&quot;hello.txt&quot;)?</code>. Nous avons toujours le <code>?</code> √† la fin de l'appel √†
<code>read_to_string</code>, et nous retournons toujours une valeur <code>Ok</code> contenant le
pseudo dans <code>s</code> lorsque <code>File::open</code> et <code>read_to_string</code> r√©ussissent toutes les
deux plut√¥t que de retourner des erreurs. Cette fonctionnalit√© est toujours la
m√™me que dans l'encart 9-6 et l'encart 9-7¬†; c'est juste une fa√ßon diff√©rente et
plus ergonomique de l'√©crire.</p>
<!--
Listing 9-9 shows a way to make this even shorter using `fs::read_to_string`.
-->
<p>L'encart 9-9 nous montre comment encore plus raccourcir tout ceci en utilisant
<code>fs::read_to_string</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-9: Using `fs::read_to_string` instead of
opening and then reading the file</span>
-->
<p><span class="caption">Encart 9-9¬†: utilisation de <code>fs::read_to_string</code> plut√¥t
que d'ouvrir puis lire le fichier</span></p>
<!--
Reading a file into a string is a fairly common operation, so the standard
library provides the convenient `fs::read_to_string` function that opens the
file, creates a new `String`, reads the contents of the file, puts the contents
into that `String`, and returns it. Of course, using `fs::read_to_string`
doesn‚Äôt give us the opportunity to explain all the error handling, so we did it
the longer way first.
-->
<p>R√©cup√©rer le contenu d'un fichier dans une <code>String</code> est une op√©ration assez
courante, donc la biblioth√®que standard fournit la fonction assez pratique
<code>fs::read_to_string</code>, qui ouvre le fichier, cr√©e une nouvelle <code>String</code>, lit le
contenu du fichier, ins√®re ce contenu dans cette <code>String</code>, et la retourne.
√âvidemment, l'utilisation de <code>fs:read_to_string</code> ne nous offre pas l'occasion
d'expliquer toute la gestion des erreurs, donc nous avons d'abord utilis√© la
mani√®re la plus longue.</p>
<!--
#### Where The `?` Operator Can Be Used
-->
<h4 id="o√π-lop√©rateur--peut-√™tre-utilis√©"><a class="header" href="#o√π-lop√©rateur--peut-√™tre-utilis√©">O√π l'op√©rateur <code>?</code> peut √™tre utilis√©</a></h4>
<!--
The `?` operator can only be used in functions whose return type is compatible
with the value the `?` is used on. This is because the `?` operator is defined
to perform an early return of a value out of the function, in the same manner
as the `match` expression we defined in Listing 9-6. In Listing 9-6, the
`match` was using a `Result` value, and the early return arm returned an
`Err(e)` value. The return type of the function has to be a `Result` so that
it‚Äôs compatible with this `return`.
-->
<p>L'op√©rateur <code>?</code> ne peut √™tre utilis√© uniquement que dans des fonctions dont le
type de retour compatible avec ce sur quoi le <code>?</code> est utilis√©. C'est parce que
l'op√©rateur <code>?</code> est con√ßu pour retourner pr√©matur√©mment une valeur de la
fonction, de la m√™me mani√®re que le faisait l'expression <code>match</code> que nous avons
d√©finie dans l'encart 9-6. Dans l'encart 9-6, le <code>match</code> utilisait une valeur
de type <code>Result</code>, et la branche de retour pr√©matur√© retournait une valeur de
type <code>Err(e)</code>. Le type de retour de cette fonction doit √™tre un <code>Result</code> afin
d'√™tre compatible avec ce <code>return</code>.</p>
<!--
In Listing 9-10, let‚Äôs look at the error we‚Äôll get if we use the `?` operator
in a `main` function with a return type incompatible with the type of the value
we use `?` on:
-->
<p>Dans l'encart 9-10, d√©couvrons l'erreur que nous allons obtenir si nous
utilisons l'op√©rateur <code>?</code> dans une fonction <code>main</code> qui a un type de retour
incompatible avec le type de valeur sur laquelle nous utilisons <code>?</code>¬†:</p>
<!--
```rust,ignore,does_not_compile
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!--
<span class="caption">Listing 9-10: Attempting to use the `?` in the `main`
function that returns `()` won‚Äôt compile</span>
-->
<p><span class="caption">Encart 9-10¬†: tentative d'utilisation du <code>?</code> dans la
fonction <code>main</code> qui retourne un <code>()</code>, qui ne devrait pas pouvoir se
compiler</span></p>
<!--
This code opens a file, which might fail. The `?` operator follows the `Result`
value returned by `File::open`, but this `main` function has the return type of
`()`, not `Result`. When we compile this code, we get the following error
message:
-->
<p>Ce code ouvre un fichier, ce qui devrait √©chouer. L'op√©rateur <code>?</code> est plac√©e
derri√®re la valeur de type <code>Result</code> retourn√©e par <code>File::open</code>, mais cette
fonction <code>main</code> a un type de retour <code>()</code> et non pas <code>Result</code>. Lorsque nous
compilons ce code, nous obtenons le message d'erreur suivant¬†:</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 -- > src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open("hello.txt")?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<!--
This error points out that we‚Äôre only allowed to use the `?` operator in a
function that returns `Result`, `Option`, or another type that implements
`FromResidual`. To fix the error, you have two choices. One choice is to change
the return type of your function to be compatible with the value you‚Äôre using
the `?` operator on as long as you have no restrictions preventing that. The
other technique is to use a `match` or one of the `Result<T, E>` methods to
handle the `Result<T, E>` in whatever way is appropriate.
-->
<p>Cette erreur explique que nous sommes autoris√©s √† utiliser l'op√©rateur <code>?</code>
uniquement dans une fonction qui retourne <code>Result</code>, <code>Option</code>, ou un autre type
qui impl√©mente <code>FromResidual</code>. Pour corriger l'erreur, vous avez deux choix. Le
premier est de changer le type de retour de votre fonction pour √™tre compatible
avec la valeur avec lequel vous utilisez l'op√©rateur <code>?</code>, si vous pouvez le
faire. L'autre solution est d'utiliser un <code>match</code> ou une des m√©thodes de
<code>Result&lt;T, E&gt;</code> pour g√©rer le <code>Result&lt;T, E&gt;</code> de la mani√®re la plus appropri√©e.</p>
<!--
The error message also mentioned that `?` can be used with `Option<T>` values
as well. As with using `?` on `Result`, you can only use `?` on `Option` in a
function that returns an `Option`. The behavior of the `?` operator when called
on an `Option<T>` is similar to its behavior when called on a `Result<T, E>`:
if the value is `None`, the `None` will be returned early from the function at
that point. If the value is `Some`, the value inside the `Some` is the
resulting value of the expression and the function continues. Listing 9-11 has
an example of a function that finds the last character of the first line in the
given text:
-->
<p>Le message d'erreur indique √©galement que <code>?</code> peut aussi √™tre utilis√© avec des
valeurs de type <code>Option&lt;T&gt;</code>. Comme pour pouvoir utiliser <code>?</code> sur un <code>Result</code>,
vous devez utiliser <code>?</code> sur <code>Option</code> uniquement dans une fonction qui retourne
une <code>Option</code>. Le comportement de l'op√©rateur <code>?</code> sur une <code>Option&lt;T&gt;</code> est
identique au comportement sur un <code>Result&lt;T, E&gt;</code>¬†: si la valeur est <code>None</code>, le
<code>None</code> sera retourn√© pr√©matur√©mment √† la fonction dans laquelle il est utilis√©.
Si la valeur est <code>Some</code>, la valeur dans le <code>Some</code> sera la valeur r√©sultante de
l'expression et la fonction continuera son d√©roulement. L'encart 9-11 est un
exemple de fonction qui trouve le dernier caract√®re de la premi√®re ligne dans
le texte qu'on lui fournit¬†:</p>
<!--
```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
# 
# fn main() {
#     assert_eq!(
#         last_char_of_first_line("Hello, world\nHow are you today?"),
#         Some('d')
#     );
# 
#     assert_eq!(last_char_of_first_line(""), None);
#     assert_eq!(last_char_of_first_line("\nhi"), None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn dernier_caractere_de_la_premiere_ligne(texte: &amp;str) -&gt; Option&lt;char&gt; {
    texte.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dernier_caractere_de_la_premiere_ligne(&quot;Et bonjour\nComment ca va, aujourd'hui ?&quot;),
</span><span class="boring">        Some('r')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(dernier_caractere_de_la_premiere_ligne(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(dernier_caractere_de_la_premiere_ligne(&quot;\nsalut&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-11: Using the `?` operator on an `Option<T>`
value</span>
-->
<p><span class="caption">Encart 9-11¬†: utilisation de l'op√©rateur <code>?</code> sur une
valeur du type <code>Option&lt;T&gt;</code></span></p>
<!--
This function returns `Option<char>` because it‚Äôs possible that there is a
character there, but it‚Äôs also possible that there isn‚Äôt. This code takes the
`text` string slice argument and calls the `lines` method on it, which returns
an iterator over the lines in the string. Because this function wants to
examine the first line, it calls `next` on the iterator to get the first value
from the iterator. If `text` is the empty string, this call to `next` will
return `None`, in which case we use `?` to stop and return `None` from
`last_char_of_first_line`. If `text` is not the empty string, `next` will
return a `Some` value containing a string slice of the first line in `text`.
-->
<p>Cette fonction retourne un type <code>Option&lt;char&gt;</code> car il est possible qu'il y ait
un caract√®re √† cet endroit, mais il est aussi possible qu'il n'y soit pas. Ce
code prends l'argument <code>texte</code> slice de cha√Æne de caract√®re et appelle sur elle
la m√©thode <code>lines</code>, qui retourne un it√©rateur des lignes dans la cha√Æne. Comme
cette fonction veut traiter la premi√®re ligne, elle appelle <code>next</code> sur
l'it√©rateur afin d'obtenir la premi√®re valeur de cet it√©rateur. Si <code>texte</code> est
une cha√Æne vide, cet appel √† <code>next</code> va retourner <code>None</code>, et dans ce cas nous
utilisons <code>?</code> pour arr√™ter le d√©roulement de la fonction et retourner <code>None</code>.
Si <code>texte</code> n'est pas une cha√Æne vide, <code>next</code> va retourner une valeur de type
<code>Some</code> contenant une slice de cha√Æne de caract√®res de la premi√®re ligne de
<code>texte</code>.</p>
<!--
The `?` extracts the string slice, and we can call `chars` on that string slice
to get an iterator of its characters. We‚Äôre interested in the last character in
this first line, so we call `last` to return the last item in the iterator.
This is an `Option` because it‚Äôs possible that the first line is the empty
string, for example if `text` starts with a blank line but has characters on
other lines, as in `"\nhi"`. However, if there is a last character on the first
line, it will be returned in the `Some` variant. The `?` operator in the middle
gives us a concise way to express this logic, allowing us to implement the
function in one line. If we couldn‚Äôt use the `?` operator on `Option`, we‚Äôd
have to implement this logic using more method calls or a `match` expression.
-->
<p>Le <code>?</code> extrait la slice de la cha√Æne de caract√®res, et nous pouvons ainsi
appeller <code>chars</code> sur cette slice de cha√Æne de caract√®res afin d'obtenir un
it√©rateur de ses caract√®res. Nous nous int√©ressons au dernier caract√®re de
cette premi√®re ligne, donc nous appelons <code>last</code> pour retourner le dernier
√©l√©ment dans l'it√©rateur. C'est une <code>Option</code> car il est possible que la
premi√®re ligne soit une cha√Æne de caract√®res vide, par exemple si <code>texte</code>
commence par une ligne vide mais a des caract√®res sur les autres lignes, comme
par exemple <code>&quot;\nhi&quot;</code>. Cependant, si il y a un caract√®re √† la fin de la premi√®re
ligne, il sera retourn√© dans la variante <code>Some</code>. L'op√©rateur <code>?</code> au millieu
nous donne un moyen concret d'exprimer cette logique, nous permettant
d'impl√©menter la fonction en une ligne. Si nous n'avions pas pu utiliser
l'op√©rateur <code>?</code> sur <code>Option</code>, nous aurions d√ª impl√©menter cette logique en
utilisant plus d'appels √† des m√©thodes ou des expressions <code>match</code>.</p>
<!--
Note that you can use the `?` operator on a `Result` in a function that returns
`Result`, and you can use the `?` operator on an `Option` in a function that
returns `Option`, but you can‚Äôt mix and match. The `?` operator won‚Äôt
automatically convert a `Result` to an `Option` or vice versa; in those cases,
you can use methods like the `ok` method on `Result` or the `ok_or` method on
`Option` to do the conversion explicitly.
-->
<p>Notez bien que vous pouvez utiliser l'op√©rateur <code>?</code> sur un <code>Result</code> dans une
fonction qui retourne <code>Result</code>, et vous pouvez utiliser l'op√©rateur <code>?</code> sur une
<code>Option</code> dans une fonction qui retourne une <code>Option</code>, mais vous ne pouvez pas
m√©langer les deux. L'op√©rateur <code>?</code> ne va pas convertir un <code>Result</code> en <code>Option</code>
et vice-versa¬†; dans ce cas, vous pouvez utiliser des m√©thodes comme la m√©thode
<code>ok</code> sur <code>Result</code> ou la m√©thode <code>ok_or</code> sur <code>Option</code> pour faire explicitement
la conversion.</p>
<!--
So far, all the `main` functions we‚Äôve used return `()`. The `main` function is
special because it‚Äôs the entry and exit point of executable programs, and there
are restrictions on what its return type can be for the programs to behave as
expected.
-->
<p>Jusqu'ici, toutes les fonctions <code>main</code> que nous avons utilis√© retournent <code>()</code>.
La fonction <code>main</code> est sp√©ciale car c'est le point d'entr√©e et de sortie des
programmes ex√©cutables, et il y a quelques limitations sur ce que peut √™tre
le type de retour pour que les programmes se comportent correctement.</p>
<!--
Luckily, `main` can also return a `Result<(), E>`. Listing 9-12 has the
code from Listing 9-10 but we‚Äôve changed the return type of `main` to be
`Result<(), Box<dyn Error>>` and added a return value `Ok(())` to the end. This
code will now compile:
-->
<p>Heureusement, <code>main</code> peut aussi retourner un <code>Result&lt;(), E&gt;</code>. L'encart 9-12
reprend le code de l'encart 9-10 mais nous avons chang√© le type de retour du
<code>main</code> pour √™tre <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> et nous avons ajout√© la valeur de
retour <code>Ok(())</code> √† la fin. Ce code devrait maintenant pouvoir se compiler¬†:</p>
<!--
```rust,ignore
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<!--
<span class="caption">Listing 9-12: Changing `main` to return `Result<(), E>`
allows the use of the `?` operator on `Result` values</span>
-->
<p><span class="caption">Encart 9-12¬†: changement du <code>main</code> pour qu'elle retourne
un <code>Result&lt;(), E&gt;</code> permettant d'utiliser l'op√©rateur <code>?</code> sur des valeurs de type
<code>Result</code></span></p>
<!--
The `Box<dyn Error>` type is a *trait object*, which we‚Äôll talk about in the
[‚ÄúUsing Trait Objects that Allow for Values of Different
Types‚Äù][trait-objects]<!-- ignore -- > section in Chapter 17. For now, you can
read `Box<dyn Error>` to mean ‚Äúany kind of error.‚Äù Using `?` on a `Result`
value in a `main` function with the error type `Box<dyn Error>` is allowed,
because it allows any `Err` value to be returned early.
-->
<p>Le type <code>Box&lt;dyn Error&gt;</code> est un <em>objet trait</em>, que nous verrons dans une
section du <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore -->. Pour l'instant, vous
pouvez interpr√©ter <code>Box&lt;dyn Error&gt;</code> en ‚Äútout type d'erreur‚Äù. L'utilisation de
<code>?</code> sur une valeur type <code>Result</code> dans la fonction <code>main</code> avec le type
<code>Box&lt;dyn Error&gt;</code> est donc permise, car cela permet √† n'importe quelle une
valeur de type <code>Err</code> d'√™tre retourn√©e pr√©matur√©ment.</p>
<!--
When a `main` function returns a `Result<(), E>`, the executable will
exit with a value of `0` if `main` returns `Ok(())` and will exit with a
nonzero value if `main` returns an `Err` value. Executables written in C return
integers when they exit: programs that exit successfully return the integer
`0`, and programs that error return some integer other than `0`. Rust also
returns integers from executables to be compatible with this convention.
-->
<p>Lorsqu'une fonction <code>main</code> retourne un <code>Result&lt;(), E&gt;</code>, l'ex√©cutable va
terminer son ex√©cution avec une valeur de <code>0</code> si le <code>main</code> retourne <code>Ok(())</code> et
va se terminer avec une valeur diff√©rente de z√©ro si <code>main</code> retourne une valeur
<code>Err</code>. Les ex√©cutables √©crits en C retournent des entiers lorsqu'ils se
terminent¬†: les programmes qui se terminent avec succ√®s retournent l'entier
<code>0</code>, et les programmes qui sont en erreur retournent un entier autre que <code>0</code>.
Rust retourne √©galement des entiers avec des ex√©cutables pour √™tre compatible
avec cette convention.</p>
<!--
The `main` function may return any types that implement [the
`std::process::Termination` trait][termination]<!-- ignore -- >. As of this
writing, the `Termination` trait is an unstable feature only available in
Nightly Rust, so you can‚Äôt yet implement it for your own types in Stable Rust,
but you might be able to someday!
-->
<p>La fonction <code>main</code> peut retourner n'importe quel type qui impl√©mente <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">le trait
<code>std::process::Termination</code></a><!-- ignore -->. Au moment de
l'√©criture de ces mots, le trait <code>Termination</code> est une fonctionnalit√© instable
seulement disponible avec la version exp√©rimentale de Rust, donc vous ne pouvez
pas l'impl√©menter sur vos propres types avec la version stable de Rust, mais
vous pourrez peut-√™tre le faire un jour¬†!</p>
<!--
Now that we‚Äôve discussed the details of calling `panic!` or returning `Result`,
let‚Äôs return to the topic of how to decide which is appropriate to use in which
cases.
-->
<p>Maintenant que nous avons vu les d√©tails pour utiliser <code>panic!</code> ou retourner
<code>Result</code>, voyons maintenant comment choisir ce qu'il faut faire en fonction des
cas.</p>
<!--
[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[termination]: ../std/process/trait.Termination.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
