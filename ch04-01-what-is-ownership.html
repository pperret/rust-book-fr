<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Qu&#x27;est-ce que la possession ? - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## What Is Ownership?
-->
<h2 id="quest-ce-que-la-possession-"><a class="header" href="#quest-ce-que-la-possession-">Qu'est-ce que la possession¬†?</a></h2>
<!--
*Ownership* is a set of rules that governs how a Rust program manages memory.
All programs have to manage the way they use a computer‚Äôs memory while running.
Some languages have garbage collection that constantly looks for no-longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks. If
any of the rules are violated, the program won‚Äôt compile. None of the features
of ownership will slow down your program while it‚Äôs running.
-->
<p><em>La possession</em> est un jeu de r√®gles qui gouvernent la gestion de la m√©moire
par un programme Rust. Tous les programmes doivent g√©rer la fa√ßon dont ils
utilisent la m√©moire lorsqu'ils s'ex√©cutent. Certains langages ont un
ramasse-miettes qui scrute constamment la m√©moire qui n'est plus utilis√©e
pendant qu'il s'ex√©cute¬†; dans d'autres langages, le d√©veloppeur doit
explicitement allouer et lib√©rer la m√©moire. Rust adopte une troisi√®me
approche¬†: la m√©moire est g√©r√©e avec un syst√®me de possession qui repose sur un
jeu de r√®gles que le compilateur v√©rifie au moment de la compilation. Si une de
ces r√®gles a √©t√© enfreinte, le programme ne sera pas compil√©. Aucune des
fonctionnalit√©s de la possession ne ralentit votre programme √† l'ex√©cution.</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the easier you‚Äôll find it to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>Comme la possession est un nouveau principe pour de nombreux d√©veloppeurs,
cela prend un certain temps pour s'y familiariser. La bonne nouvelle est que
plus vous devenez exp√©riment√© avec Rust et ses r√®gles de possession, plus vous
d√©velopperez naturellement et facilement du code s√ªr et efficace. Gardez bien
cela √† l'esprit¬†!</p>
<!--
When you understand ownership, you‚Äôll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you‚Äôll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>Lorsque vous comprendrez la possession, vous aurez des bases solides pour
comprendre les fonctionnalit√©s qui font la particularit√© de Rust. Dans ce
chapitre, vous allez apprendre la possession en pratiquant avec plusieurs
exemples qui se concentrent sur une structure de donn√©es tr√®s courante¬†: les
cha√Ænes de caract√®res.</p>
<!--
> ### The Stack and the Heap
>
> Many programming languages don‚Äôt require you to think about the stack and the
> heap very often. But in a systems programming language like Rust, whether a
> value is on the stack or the heap affects how the language behaves and why
> you have to make certain decisions. Parts of ownership will be described in
> relation to the stack and the heap later in this chapter, so here is a brief
> explanation in preparation.
>
> Both the stack and the heap are parts of memory available to your code to use
> at runtime, but they are structured in different ways. The stack stores
> values in the order it gets them and removes the values in the opposite
> order. This is referred to as *last in, first out*. Think of a stack of
> plates: when you add more plates, you put them on top of the pile, and when
> you need a plate, you take one off the top. Adding or removing plates from
> the middle or bottom wouldn‚Äôt work as well! Adding data is called *pushing
> onto the stack*, and removing data is called *popping off the stack*. All
> data stored on the stack must have a known, fixed size. Data with an unknown
> size at compile time or a size that might change must be stored on the heap
> instead.
>
> The heap is less organized: when you put data on the heap, you request a
> certain amount of space. The memory allocator finds an empty spot in the heap
> that is big enough, marks it as being in use, and returns a *pointer*, which
> is the address of that location. This process is called *allocating on the
> heap* and is sometimes abbreviated as just *allocating*. Pushing values onto
> the stack is not considered allocating. Because the pointer to the heap is a
> known, fixed size, you can store the pointer on the stack, but when you want
> the actual data, you must follow the pointer. Think of being seated at a
> restaurant. When you enter, you state the number of people in your group, and
> the staff finds an empty table that fits everyone and leads you there. If
> someone in your group comes late, they can ask where you‚Äôve been seated to
> find you.
>
> Pushing to the stack is faster than allocating on the heap because the
> allocator never has to search for a place to store new data; that location is
> always at the top of the stack. Comparatively, allocating space on the heap
> requires more work, because the allocator must first find a big enough space
> to hold the data and then perform bookkeeping to prepare for the next
> allocation.
>
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. It‚Äôs most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data that‚Äôs close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
>
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the function‚Äôs
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
>
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so you don‚Äôt run out of space are all problems that ownership
> addresses. Once you understand ownership, you won‚Äôt need to think about the
> stack and the heap very often, but knowing that the main purpose of ownership
> is to manage heap data can help explain why it works the way it does.
-->
<blockquote>
<h3 id="la-pile-et-le-tas"><a class="header" href="#la-pile-et-le-tas">La pile et le tas</a></h3>
<p>De nombreux langages ne n√©cessitent pas de se pr√©occuper de la
pile (<em>stack</em>) et du tas (<em>heap</em>). Mais dans un langage de programmation
syst√®me comme Rust, le fait qu'une donn√©e soit sur la pile ou sur le tas a une influence
sur le comportement du langage et explique pourquoi nous devons faire certains
choix. Nous d√©crirons plus loin dans ce chapitre comment la possession
fonctionne vis-√†-vis de la pile et du tas, voici donc une br√®ve explication au
pr√©alable.</p>
<p>La pile et le tas sont tous les deux des emplacements de la m√©moire √†
disposition de votre code lors de son ex√©cution, mais sont organis√©s de fa√ßon
diff√©rente. La pile enregistre les valeurs dans l'ordre qu'elle les re√ßoit et
enl√®ve les valeurs dans l'autre sens. C'est ce que l'on appelle le principe
de <em>dernier entr√©, premier sorti</em>. C'est comme une pile d'assiettes¬†: quand
vous ajoutez des nouvelles assiettes, vous les d√©posez sur le dessus de la
pile, et quand vous avez besoin d'une assiette, vous en prenez une sur le
dessus. Ajouter ou enlever des assiettes au milieu ou en bas ne serait pas
aussi efficace¬†! Ajouter une donn√©e sur la pile se dit <em>empiler</em> et en retirer
une se dit <em>d√©piler</em>. Toutes donn√©e stock√©e dans la pile doit avoir une
taille connue et fixe. Les donn√©es avec une taille inconnue au moment de la
compilation ou une taille qui peut changer doivent plut√¥t √™tre stock√©es sur
le tas.</p>
<p>Le tas est moins bien organis√©¬†: lorsque vous ajoutez des donn√©es sur le tas,
vous demandez une certaine quantit√© d'espace m√©moire. Le gestionnaire de
m√©moire va trouver un emplacement dans le tas qui est suffisamment grand, va
le marquer comme √©tant en cours d'utilisation, et va retourner un <em>pointeur</em>,
qui est l'adresse de cet emplacement. Cette proc√©dure est appel√©e <em>allocation
sur le tas</em>, ce qu'on abr√®ge parfois en <em>allocation</em> tout court. L'ajout de
valeurs sur la pile n'est pas consid√©r√© comme une allocation. Comme le
pointeur vers le tas a une taille connue et fixe, on peut stocker ce pointeur
sur la pile, mais quand on veut la vraie donn√©e, il faut suivre le pointeur.</p>
<p>C'est comme si vous vouliez manger au restaurant. Quand vous entrez, vous
indiquez le nombre de personnes dans votre groupe, et le personnel trouve une
table vide qui peut recevoir tout le monde, et vous y conduit. Si quelqu'un
dans votre groupe arrive en retard, il peut leur demander o√π vous √™tes assis
pour vous rejoindre.</p>
<p>Empiler sur la pile est plus rapide qu'allouer sur le tas car le gestionnaire
ne va jamais avoir besoin de chercher un emplacement pour y stocker les
nouvelles donn√©es¬†; il le fait toujours au sommet de la pile. En comparaison,
allouer de la place sur le tas demande plus de travail, car le gestionnaire
doit d'abord trouver un espace assez grand pour stocker les donn√©es et mettre
√† jour son suivi pour pr√©parer la prochaine allocation.</p>
<p>Acc√©der √† des donn√©es dans le tas est plus lent que d'acc√©der aux donn√©es sur
la pile car nous devons suivre un pointeur pour les obtenir. Les processeurs
modernes sont plus rapides s'ils se d√©placent moins dans la m√©moire. Pour
continuer avec notre analogie, imaginez un serveur dans un restaurant qui
prend les commandes de nombreuses tables. C'est plus efficace de r√©cup√©rer
toutes les commandes √† une seule table avant de passer √† la table suivante.
Prendre une commande √† la table A, puis prendre une commande √† la table B,
puis ensuite une autre √† la table A, puis une autre √† la table B serait un
processus bien plus lent. De la m√™me mani√®re, un processeur sera plus efficace
dans sa t√¢che s'il travaille sur des donn√©es qui sont proches les unes des
autres (comme c'est le cas sur la pile) plut√¥t que si elles sont plus
√©loign√©es (comme cela peut √™tre le cas sur le tas). Allouer une grande
quantit√© de m√©moire sur le tas peut aussi prendre beaucoup de temps.</p>
<p>Quand notre code utilise une fonction, les valeurs pass√©es √† la fonction
(incluant, potentiellement, des pointeurs de donn√©es sur le tas) et les
variables locales √† la fonction sont d√©pos√©es sur la pile. Quand l'utilisation
de la fonction est termin√©e, ces donn√©es sont retir√©es de la pile.</p>
<p>La possession nous aide √† ne pas nous pr√©occuper de faire attention √† quelles
parties du code utilisent quelles donn√©es sur le tas, de minimiser la
quantit√© de donn√©es en double sur le tas, ou encore de veiller √† lib√©rer les
donn√©es inutilis√©es sur le tas pour que nous ne soyons pas √† court d'espace.
Quand vous aurez compris la possession, vous n'aurez plus besoin de vous
pr√©occuper de la pile et du tas tr√®s souvent, mais savoir que le but
principal de la possession est de g√©rer les donn√©es du tas peut vous aider √†
comprendre pourquoi elle fonctionne de cette mani√®re.</p>
</blockquote>
<!--
### Ownership Rules
-->
<h3 id="les-r√®gles-de-la-possession"><a class="header" href="#les-r√®gles-de-la-possession">Les r√®gles de la possession</a></h3>
<!--
First, let‚Äôs take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>Tout d'abord, d√©finissons les r√®gles de la possession. Gardez √† l'esprit ces
r√®gles pendant que nous travaillons sur des exemples qui les illustrent¬†:</p>
<!--
* Each value in Rust has a variable that‚Äôs called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Chaque valeur en Rust a une variable qui s'appelle son <em>propri√©taire</em>.</li>
<li>Il ne peut y avoir qu'un seul propri√©taire √† la fois.</li>
<li>Quand le propri√©taire sortira de la port√©e, la valeur sera supprim√©e.</li>
</ul>
<!--
### Variable Scope
-->
<h3 id="port√©e-de-la-variable"><a class="header" href="#port√©e-de-la-variable">Port√©e de la variable</a></h3>
<!--
Now that we‚Äôre past basic Rust syntax, we won‚Äôt include all the `fn main() {`
code in examples, so if you‚Äôre following along, make sure to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>Maintenant
que nous avons vu la syntaxe Rust de base, nous n'allons plus ajouter tout le
code du style <code>fn main() {</code> dans les exemples, donc si vous voulez reproduire
les exemples, assurez-vous de les placer manuellement dans une fonction <code>main</code>. Par
cons√©quent, nos exemples seront plus concis, nous permettant de nous concentrer
sur les d√©tails de la situation plut√¥t que sur du code normalis√©.</p>
<!--
As a first example of ownership, we‚Äôll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:
-->
<p>Pour le premier exemple de possession, nous allons analyser la <em>port√©e</em> de
certaines variables. Une port√©e est une zone dans un programme dans laquelle un
√©l√©ment est en vigueur. Admettons la variable suivante¬†:</p>
<!--
```rust
let s = "hello";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it‚Äôs declared until the end of the current *scope*. Listing 4-1 shows a
program with comments annotating where the variable `s` would be valid.
-->
<p>La variable <code>s</code> fait r√©f√©rence √† un litt√©ral de cha√Æne de caract√®res, o√π la
valeur de la cha√Æne est cod√©e en dur dans notre programme. La variable est en
vigueur √† partir du moment o√π elle est d√©clar√©e jusqu'√† la fin de la <em>port√©e</em>
actuelle. L'encart 4-1 nous pr√©sente un programme avec des commentaires pour
indiquer quand la variable <code>s</code> est en vigueur¬†:</p>
<!--
```rust
# fn main() {
    {                      // s is not valid here, it‚Äôs not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                    // s n'est pas en vigueur ici, elle n'est pas encore d√©clar√©e
        let s = &quot;hello&quot;; // s est en vigueur √† partir de ce point

        // on fait des choses avec s ici
    }                    // cette port√©e est maintenant termin√©e, et s n'est plus en vigueur
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span>
-->
<p><span class="caption">Encart 4-1¬†: Une variable et la port√©e dans laquelle elle
est en vigueur.</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>Autrement dit, il y a ici deux √©tapes importantes¬†:</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li>Quand <code>s</code> rentre <em>dans la port√©e</em>, elle est en vigueur.</li>
<li>Cela reste ainsi jusqu'√† ce qu'elle <em>sorte de la port√©e</em>.</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we‚Äôll build on top of this
understanding by introducing the `String` type.
-->
<p>Pour le moment, la relation entre les port√©es et les conditions pour lesquelles
les variables sont en vigueur sont similaires √† d'autres langages de
programmation. Maintenant, nous allons aller plus loin en y ajoutant le type
<code>String</code>.</p>
<!--
### The `String` Type
-->
<h3 id="le-type-string"><a class="header" href="#le-type-string">Le type <code>String</code></a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the [‚ÄúData Types‚Äù][data-types]<!-- ignore -- > section
of Chapter 3. The types covered previously are all a known size, can be stored
on the stack and popped off the stack when their scope is over, and can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope. But we want to
look at data that is stored on the heap and explore how Rust knows when to
clean up that data, and the `String` type is a great example.
-->
<p>Pour illustrer les r√®gles de la possession, nous avons besoin d'un type de
donn√©e qui est plus complexe que ceux que nous avons rencontr√©s dans la section
<a href="ch03-02-data-types.html">‚ÄúTypes de donn√©es‚Äù</a><!-- ignore --> du chapitre 3. Les types que
nous avons vus pr√©c√©demment ont tous une taille connue et peuvent √™tre stock√©s
sur la pile ainsi que retir√©s de la pile lorsque la port√©e n'en a plus besoin,
et peuvent aussi √™tre rapidement et facilement copi√©s afin de constituer une nouvelle
instance ind√©pendante si une autre partie du code a besoin d'utiliser la m√™me
valeur dans une port√©e diff√©rente. Mais nous voulons exp√©rimenter le stockage
de donn√©es sur le tas et d√©couvrir comment Rust sait quand il doit nettoyer ces
donn√©es, et le type <code>String</code> est un bon exemple.</p>
<!--
We‚Äôll concentrate on the parts of `String` that relate to ownership. These
aspects also apply to other complex data types, whether they are provided by
the standard library or created by you. We‚Äôll discuss `String` in more depth in
[Chapter 8][ch8]<!-- ignore -- >.
-->
<p>Nous allons nous concentrer sur les caract√©ristiques de <code>String</code> qui sont li√©es
√† la possession. Ces aspects s'appliquent √©galement √† d'autres types de donn√©es
complexes, qu'ils soient fournis par la biblioth√®que standard ou qu'ils soient
cr√©√©s par vous. Nous verrons <code>String</code> plus en d√©tail dans le <a href="ch08-02-strings.html">chapitre
8</a><!-- ignore -->.</p>
<!--
We‚Äôve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren‚Äôt suitable for every
situation in which we may want to use text. One reason is that they‚Äôre
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type manages
data allocated on the heap and as such is able to store an amount of text that
is unknown to us at compile time. You can create a `String` from a string
literal using the `from` function, like so:
-->
<p>Nous avons d√©j√† vu les litt√©raux de cha√Ænes de caract√®res, quand une valeur de
cha√Æne est cod√©e en dur dans notre programme. Les litt√©raux de cha√Ænes sont
pratiques, mais ils ne conviennent pas toujours √† tous les cas o√π on veut
utiliser du texte. Une des raisons est qu'ils sont immuables. Une autre raison
est qu'on ne conna√Æt pas forc√©ment le contenu des cha√Ænes de caract√®res quand
nous √©crivons notre code¬†: par exemple, comment faire si nous voulons r√©cup√©rer
du texte saisi par l'utilisateur et l'enregistrer¬†? Pour ces cas-ci, Rust a un
second type de cha√Æne de caract√®res, <code>String</code>. Ce type g√®re ses donn√©es sur le
tas et est ainsi capable de stocker une quantit√© de texte qui nous est inconnue
au moment de la compilation. Vous pouvez cr√©er une <code>String</code> √† partir d'un
litt√©ral de cha√Æne de caract√®res en utilisant la fonction <code>from</code>, comme ceci¬†:</p>
<!--
```rust
let s = String::from("hello");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon `::` operator allows us to namespace this particular `from`
function under the `String` type rather than using some sort of name like
`string_from`. We‚Äôll discuss this syntax more in the [‚ÄúMethod
Syntax‚Äù][method-syntax]<!-- ignore -- > section of Chapter 5 and when we talk
about namespacing with modules in [‚ÄúPaths for Referring to an Item in the
Module Tree‚Äù][paths-module-tree]<!-- ignore -- > in Chapter 7.
-->
<p>L'op√©rateur double deux-points <code>::</code> nous permet d'appeler cette fonction
sp√©cifique dans l'espace de nom du type <code>String</code> plut√¥t que d'utiliser un nom
comme <code>string_from</code>. Nous verrons cette syntaxe plus en d√©tail dans la section
<a href="ch05-03-method-syntax.html">‚ÄúSyntaxe de m√©thode‚Äù</a><!-- ignore --> du chapitre 5 et lorsque
nous aborderons les espaces de noms dans la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúLes chemins pour d√©signer
un √©l√©ment dans l'arborescence de module‚Äù</a><!-- ignore --> du
chapitre 7.</p>
<!--
This kind of string *can* be mutated:
-->
<p>Ce type de cha√Æne de caract√®res <em>peut</em> √™tre mutable¬†:</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() ajoute un litt√©ral de cha√Æne dans une String
    
    println!(&quot;{}&quot;, s); // Cela va afficher `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<!--
So, what‚Äôs the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>Donc, quelle est la diff√©rence ici¬†? Pourquoi <code>String</code> peut √™tre mutable, mais
pourquoi les litt√©raux de cha√Ænes ne peuvent pas l'√™tre¬†? La diff√©rence
se trouve dans la fa√ßon dont ces deux types travaillent avec la m√©moire.</p>
<!--
### Memory and Allocation
-->
<h3 id="m√©moire-et-allocation"><a class="header" href="#m√©moire-et-allocation">M√©moire et allocation</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal‚Äôs immutability. Unfortunately, we can‚Äôt put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>Dans le cas d'un litt√©ral de cha√Æne de caract√®res, nous connaissons le contenu
au moment de la compilation donc le texte est cod√© en dur directement dans
l'ex√©cutable final. Voil√† pourquoi ces litt√©raux de cha√Ænes de caract√®res sont
performants et rapides. Mais ces caract√©ristiques viennent de leur immuabilit√©.
Malheureusement, on ne peut pas accorder une grosse r√©gion de m√©moire dans le
binaire pour chaque morceau de texte qui n'a pas de taille connue au moment de
la compilation et dont la taille pourrait changer pendant l'ex√©cution de ce
programme.</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p>Avec le type <code>String</code>, pour nous permettre d'avoir un texte mutable et qui peut
s'agrandir, nous devons allouer une quantit√© de m√©moire sur le tas, inconnue
au moment de la compilation, pour stocker le contenu. Cela signifie que¬†:</p>
<!--
* The memory must be requested from the memory allocator at runtime.
* We need a way of returning this memory to the allocator when we‚Äôre
  done with our `String`.
-->
<ul>
<li>La m√©moire doit √™tre demand√©e aupr√®s du gestionnaire de m√©moire lors de
l'ex√©cution.</li>
<li>Nous avons besoin d'un moyen de rendre cette m√©moire au gestionnaire lorsque
nous aurons fini d'utiliser notre <code>String</code>.</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>Nous nous occupons de ce premier point¬†: quand nous appelons <code>String::from</code>, son
impl√©mentation demande la m√©moire dont elle a besoin. C'est pratiquement
toujours ainsi dans la majorit√© des langages de programmation.</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track of and cleans up memory that isn‚Äôt being used
anymore, and we don‚Äôt need to think about it. In most languages without a GC,
it‚Äôs our responsibility to identify when memory is no longer being used and
call code to explicitly return it, just as we did to request it. Doing this
correctly has historically been a difficult programming problem. If we forget,
we‚Äôll waste memory. If we do it too early, we‚Äôll have an invalid variable. If
we do it twice, that‚Äôs a bug too. We need to pair exactly one `allocate` with
exactly one `free`.
-->
<p>Cependant, le deuxi√®me point est diff√©rent. Dans des langages avec un
<em>ramasse-miettes</em>, le ramasse-miettes surveille et nettoie la m√©moire qui n'est
plus utilis√©e, sans que nous n'ayons √† nous en pr√©occuper. Dans la pluspart des
langages sans ramasse-miettes, c'est de notre responsabilit√© d'identifier quand
cette m√©moire n'est plus utilis√©e et d'appeler du code pour explicitement la
lib√©rer, comme nous l'avons fait pour la demander auparavant. Historiquement,
faire ceci correctement a toujours √©t√© une difficult√© pour les d√©veloppeurs. Si
nous oublions de le faire, nous allons gaspiller de la m√©moire. Si nous le
faisons trop t√¥t, nous allons avoir une variable invalide. Si nous le faisons
deux fois, cela produit aussi un bogue. Nous devons associer exactement un
<code>allocate</code> avec exactement un <code>free</code>.</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here‚Äôs a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rust prend un chemin diff√©rent¬†: la m√©moire est automatiquement lib√©r√©e d√®s
que la variable qui la poss√®de sort de la port√©e. Voici une version de notre
exemple de port√©e de l'encart 4-1 qui utilise une <code>String</code> plut√¥t qu'un litt√©ral
de cha√Æne de caract√®res¬†:</p>
<!--
```rust
# fn main() {
    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s est en vigueur √† partir de ce point
    
        // on fait des choses avec s ici
    }                                  // cette port√©e est d√©sormais termin√©e, et s
                                       // n'est plus en vigueur maintenant
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the allocator: when `s` goes out of scope. When a variable goes out of
scope, Rust calls a special function for us. This function is called
[`drop`][drop]<!-- ignore -- >, and it‚Äôs where the author of `String` can put
the code to return the memory. Rust calls `drop` automatically at the closing
curly bracket.
-->
<p>Il y a un moment naturel o√π nous devons rendre la m√©moire de notre
<code>String</code> au gestionnaire¬†: quand <code>s</code> sort de la port√©e. Quand une variable sort
de la port√©e, Rust appelle une fonction sp√©ciale pour nous. Cette fonction
s'appelle <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, et c'est dans celle-ci que l'auteur de
<code>String</code> a pu mettre le code pour lib√©rer la m√©moire. Rust appelle
automatiquement <code>drop</code> √† l'accolade fermante <code>}</code>.</p>
<!--
> Note: In C++, this pattern of deallocating resources at the end of an item‚Äôs
> lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
> The `drop` function in Rust will be familiar to you if you‚Äôve used RAII
> patterns.
-->
<blockquote>
<p>Remarque¬†: en C++, cette fa√ßon de lib√©rer des ressources √† la fin de la
dur√©e de vie d'un √©l√©ment est parfois appel√©e <em>l'acquisition d'une ressource
est une initialisation (RAII)</em>. La fonction <code>drop</code> de Rust vous sera famili√®re
si vous avez d√©j√† utilis√© des techniques de RAII.</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we‚Äôve allocated on the heap. Let‚Äôs explore some of those situations now.
-->
<p>Cette fa√ßon de faire a un impact profond sur la fa√ßon dont le code Rust est
√©crit. Cela peut sembler simple dans notre cas, mais le comportement du code
peut √™tre surprenant dans des situations plus compliqu√©es o√π nous voulons
avoir plusieurs variables utilisant des donn√©es que nous avons affect√©es sur le
tas. Examinons une de ces situations d√®s √† pr√©sent.</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4 id="les-interactions-entre-les-variables-et-les-donn√©es--le-d√©placement"><a class="header" href="#les-interactions-entre-les-variables-et-les-donn√©es--le-d√©placement">Les interactions entre les variables et les donn√©es¬†: le d√©placement</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Let‚Äôs look at an example using an integer in Listing 4-2.
-->
<p>Plusieurs variables peuvent interagir avec les m√™mes donn√©es de diff√©rentes
mani√®res en Rust. Regardons un exemple avec un entier dans l'encart 4-2¬†:</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span>
-->
<p><span class="caption">Encart 4-2¬†: Assigner l'entier de la variable <code>x</code> √† <code>y</code>
</span></p>
<!--
We can probably guess what this is doing: ‚Äúbind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.‚Äù We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>Nous pouvons probablement deviner ce que ce code fait¬†: ‚ÄúAssigner la valeur <code>5</code>
√† <code>x</code>¬†; ensuite faire une copie de cette valeur de <code>x</code> et l'assigner √† <code>y</code>.‚Äù
Nous avons maintenant deux variables, <code>x</code> et <code>y</code>, et chacune vaut <code>5</code>. C'est
effectivement ce qui se passe, car les entiers sont des valeurs simples avec une
taille connue et fix√©e, et ces deux valeurs <code>5</code> sont stock√©es sur la pile.</p>
<!--
Now let‚Äôs look at the `String` version:
-->
<p>Maintenant, essayons une nouvelle version avec <code>String</code>¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar, so we might assume that the way it works would be the
same: that is, the second line would make a copy of the value in `s1` and bind
it to `s2`. But this isn‚Äôt quite what happens.
-->
<p>Cela ressemble beaucoup, donc nous allons supposer que cela fonctionne pareil
que pr√©c√©demment¬†: ainsi, la seconde ligne va faire une copie de la valeur de
<code>s1</code> et l'assigner √† <code>s2</code>. Mais ce n'est pas tout √† fait ce qu'il se passe.</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>Regardons l'illustration 4-1 pour d√©couvrir ce qui arrive √† <code>String</code> sous le
capot. Une <code>String</code> est constitu√©e de trois √©l√©ments, pr√©sents sur la gauche¬†:
un pointeur vers la m√©moire qui contient le contenu de la cha√Æne de caract√®res,
une taille, et une capacit√©. Ce groupe de donn√©es est stock√© sur la pile. √Ä
droite, nous avons la m√©moire sur le tas qui contient les donn√©es.</p>
<!-- markdownlint-disable -->
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une string en m√©moire" src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>
-->
<p><span class="caption">Illustration 4-1¬†: Repr√©sentation en m√©moire d'une
<code>String</code> qui contient la valeur <code>&quot;hello&quot;</code> assign√©e √† <code>s1</code>.</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the allocator. The difference between length
and capacity matters, but not in this context, so for now, it‚Äôs fine to ignore
the capacity.
-->
<p>La taille est la quantit√© de m√©moire, en octets, que le contenu de la <code>String</code>
utilise actuellement. La capacit√© est la quantit√© totale de m√©moire, en octets,
que la <code>String</code> a re√ßue du gestionnaire. La diff√©rence entre la taille et la
capacit√© est importante, mais pas pour notre exemple, donc pour l'instant, ce
n'est pas grave d'ignorer la capacit√©.</p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p>Quand nous assignons <code>s1</code> √† <code>s2</code>, les donn√©es de la <code>String</code> sont copi√©es, ce
qui veut dire que nous copions le pointeur, la taille et la capacit√© qui sont
stock√©s sur la pile. Nous ne copions pas les donn√©es stock√©es sur le tas
auxquelles le pointeur se r√©f√®re. Autrement dit, la repr√©sentation des donn√©es
dans la m√©moire ressemble √† l'illustration 4-2.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 qui pointent vers la m√™me valeur" src="img/trpl04-02.svg"
class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>
-->
<p><span class="caption">Illustration 4-2¬†: Repr√©sentation en m√©moire de la
variable <code>s2</code> qui a une copie du pointeur, de la taille et de la capacit√© de
<code>s1</code></span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>Cette repr√©sentation <em>n'est pas</em> comme l'illustration 4-3, qui repr√©senterait la
m√©moire si Rust avait aussi copi√© les donn√©es sur le tas. Si Rust faisait ceci,
l'op√©ration <code>s2 = s1</code> pourrait potentiellement √™tre tr√®s co√ªteuse en termes de
performances d'ex√©cution si les donn√©es sur le tas √©taient volumineuses.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 √† deux endroits" src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>
-->
<p><span class="caption">Illustration 4-3¬†: Une autre possibilit√© de ce que
pourrait faire <code>s2 = s1</code> si Rust copiait aussi les donn√©es du tas</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>Pr√©c√©demment, nous avons dit que quand une variable sortait de la port√©e, Rust
appelait automatiquement la fonction <code>drop</code> et nettoyait la m√©moire sur le tas
allou√©e pour cette variable. Mais l'illustration 4-2 montre que les deux
pointeurs de donn√©es pointeraient au m√™me endroit. C'est un probl√®me¬†: quand
<code>s2</code> et <code>s1</code> sortent de la port√©e, elles vont essayer toutes les deux de
lib√©rer la m√™me m√©moire. C'est ce qu'on appelle une erreur de <em>double
lib√©ration</em> et c'est un des bogues de s√©curit√© de m√©moire que nous avons
mentionn√©s pr√©c√©demment. Lib√©rer la m√©moire deux fois peut mener √† des
corruptions de m√©moire, ce qui peut potentiellement mener √† des vuln√©rabilit√©s
de s√©curit√©.</p>
<!--
To ensure memory safety, after the line `let s2 = s1`, Rust considers `s1` as
no longer valid. Therefore, Rust doesn‚Äôt need to free anything when `s1` goes
out of scope. Check out what happens when you try to use `s1` after `s2` is
created; it won‚Äôt work:
-->
<p>Pour garantir la s√©curit√© de la m√©moire, apr√®s la ligne <code>let s2 = s1</code>, Rust
consid√®re que <code>s1</code> n'est plus en vigueur. Par cons√©quent, Rust n'a pas besoin
de lib√©rer quoi que ce soit lorsque <code>s1</code> sort de la port√©e. Regardez ce qu'il
se passe quand vous essayez d'utiliser <code>s1</code> apr√®s que <code>s2</code> est cr√©√©, cela ne va
pas fonctionner¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<!--
You‚Äôll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>Vous allez avoir une erreur comme celle-ci, car Rust vous d√©fend d'utiliser la
r√©f√©rence qui n'est plus en vigueur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 -- > src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
If you‚Äôve heard the terms *shallow copy* and *deep copy* while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of calling it a
shallow copy, it‚Äôs known as a *move*. In this example, we would say that
`s1` was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>Si vous avez d√©j√† entendu parler de <em>copie superficielle</em> et de <em>copie
profonde</em> en utilisant d'autres langages, l'id√©e de copier le pointeur, la
taille et la capacit√© sans copier les donn√©es peut vous faire penser √† de la
copie superficielle. Mais comme Rust neutralise aussi la premi√®re variable, au
lieu d'appeler cela une copie superficielle, on appelle cela un <em>d√©placement</em>.
Ici, nous pourrions dire que <code>s1</code> a √©t√© <em>d√©plac√©</em> dans <code>s2</code>. Donc ce qui se
passe r√©ellement est d√©crit par l'illustration 4-4.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 d√©plac√© dans s2" src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>
-->
<p><span class="caption">Illustration 4-4¬†: Repr√©sentation de la m√©moire apr√®s que
<code>s1</code> a √©t√© neutralis√©e</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and we‚Äôre done.
-->
<p>Cela r√©sout notre probl√®me¬†! Avec seulement <code>s2</code> en vigueur, quand elle
sortira de la port√©e, elle seule va lib√©rer la m√©moire, et c'est tout.</p>
<!--
In addition, there‚Äôs a design choice that‚Äôs implied by this: Rust will never
automatically create ‚Äúdeep‚Äù copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>De plus, cela signifie qu'il y a eu un choix de conception¬†: Rust ne va jamais
cr√©er automatiquement de copie ‚Äúprofonde‚Äù de vos donn√©es. Par cons√©quent, toute
copie <em>automatique</em> peut √™tre consid√©r√©e comme peu co√ªteuse en termes de
performances d'ex√©cution.</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4 id="les-interactions-entre-les-variables-et-les-donn√©es--le-clonage"><a class="header" href="#les-interactions-entre-les-variables-et-les-donn√©es--le-clonage">Les interactions entre les variables et les donn√©es¬†: le clonage</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. We‚Äôll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you‚Äôve probably seen them before.
-->
<p>Si nous <em>voulons</em> faire une copie profonde des donn√©es sur le tas d'une
<code>String</code>, et pas seulement des donn√©es sur la pile, nous pouvons utiliser une
m√©thode commune qui s'appelle <code>clone</code>. Nous aborderons la syntaxe des m√©thodes
au chapitre 5, mais comme les m√©thodes sont des outils courants dans de
nombreux langages, vous les avez probablement utilis√©es auparavant.</p>
<!--
Here‚Äôs an example of the `clone` method in action:
-->
<p>Voici un exemple d'utilisation de la m√©thode <code>clone</code>¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>Cela fonctionne tr√®s bien et c'est ainsi que vous pouvez reproduire le
comportement d√©crit dans l'illustration 4-3, o√π les donn√©es du tas sont copi√©es.</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. It‚Äôs a visual indicator that something
different is going on.
-->
<p>Quand vous voyez un appel √† <code>clone</code>, vous savez que du code arbitraire est
ex√©cut√© et que ce code peut √™tre co√ªteux. C'est un indicateur visuel qu'il se
passe quelque chose de diff√©rent.</p>
<!--
#### Stack-Only Data: Copy
-->
<h4 id="donn√©es-uniquement-sur-la-pile--la-copie"><a class="header" href="#donn√©es-uniquement-sur-la-pile--la-copie">Donn√©es uniquement sur la pile¬†: la copie</a></h4>
<!--
There‚Äôs another wrinkle we haven‚Äôt talked about yet. This code using integers ‚Äì
part of which was shown in Listing 4-2 ‚Äì works and is valid:
-->
<p>Il y a un autre d√©tail dont on n'a pas encore parl√©. Le code suivant utilise
des entiers - on en a vu une partie dans l'encart 4-2¬†- il fonctionne et
est correct¬†:</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we don‚Äôt have a call to
`clone`, but `x` is still valid and wasn‚Äôt moved into `y`.
-->
<p>Mais ce code semble contredire ce que nous venons d'apprendre¬†: nous n'avons
pas appel√© <code>clone</code>, mais <code>x</code> est toujours en vigueur et n'a pas √©t√© d√©plac√©
dans <code>y</code>.</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there‚Äôs no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, there‚Äôs no difference
between deep and shallow copying here, so calling `clone` wouldn‚Äôt do anything
different from the usual shallow copying and we can leave it out.
-->
<p>La raison est que les types comme les entiers ont une taille connue au moment de
la compilation et sont enti√®rement stock√©s sur la pile, donc la copie des
vraies valeurs est rapide √† faire. Cela signifie qu'il n'y a pas de raison que
nous voudrions neutraliser <code>x</code> apr√®s avoir cr√©√© la variable <code>y</code>. En d'autres
termes, il n'y a pas ici de diff√©rence entre la copie superficielle et profonde,
donc appeler <code>clone</code> ne ferait rien d'autre qu'une copie superficielle classique
et on peut s'en passer.</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types that are stored on the stack like integers are (we‚Äôll talk more about
traits in Chapter 10). If a type implements the `Copy` trait, a variable is
still valid after assignment to another variable. Rust won‚Äôt let us annotate a
type with `Copy` if the type, or any of its parts, has implemented the `Drop`
trait. If the type needs something special to happen when the value goes out of
scope and we add the `Copy` annotation to that type, we‚Äôll get a compile-time
error. To learn about how to add the `Copy` annotation to your type to
implement the trait, see [‚ÄúDerivable Traits‚Äù][derivable-traits]<!-- ignore -- >
in Appendix C.
-->
<p>Rust a une annotation sp√©ciale appel√©e le trait <code>Copy</code> que nous pouvons utiliser
sur des types comme les entiers qui sont stock√©s sur la pile (nous verrons les
traits dans le chapitre 10). Si un type impl√©mente le trait <code>Copy</code>, une
variable sera toujours en vigueur apr√®s avoir √©t√© affect√©e √† une autre
variable. Rust ne nous autorisera pas √† annoter un type avec le trait <code>Copy</code> si
ce type, ou un de ses √©l√©ments, a impl√©ment√© le trait <code>Drop</code>. Si ce type a
besoin que quelque chose de sp√©cial se produise quand la valeur sort de la
port√©e et que nous ajoutons l'annotation <code>Copy</code> sur ce type, nous aurons une
erreur au moment de la compilation. Pour savoir comment ajouter l'annotation
<code>Copy</code> sur votre type pour impl√©menter le trait, r√©f√©rez-vous √† <a href="appendix-03-derivable-traits.html">l'annexe
C</a><!-- ignore --> sur les traits d√©rivables.</p>
<!--
So what types implement the `Copy` trait? You can check the documentation for
the given type to be sure, but as a general rule, any group of simple scalar
values can implement `Copy`, and nothing that requires allocation or is some
form of resource can implement `Copy`. Here are some of the types that
implement `Copy`:
-->
<p>Donc, quels sont les types qui impl√©mentent le trait <code>Copy</code>¬†? Vous pouvez
regarder dans la documentation pour un type donn√© pour vous en assurer, mais de
mani√®re g√©n√©rale, tout groupe de valeur scalaire peut impl√©menter <code>Copy</code>, et
tout ce qui ne n√©cessite pas d'allocation de m√©moire ou tout autre forme de
ressource qui impl√©mente <code>Copy</code>. Voici quelques types qui impl√©mentent <code>Copy</code>¬†:</p>
<!--
* All the integer types, such as `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, such as `f64`.
* The character type, `char`.
* Tuples, if they only contain types that also implement `Copy`. For example,
  `(i32, i32)` implements `Copy`, but `(i32, String)` does not.
-->
<ul>
<li>Tous les types d'entiers, comme <code>u32</code>.</li>
<li>Le type bool√©en, <code>bool</code>, avec les valeurs <code>true</code> et <code>false</code>.</li>
<li>Tous les types de flottants, comme <code>f64</code>.</li>
<li>Le type de caract√®re, <code>char</code>.</li>
<li>Les tuples, mais uniquement s'ils contiennent des types qui impl√©mentent
aussi <code>Copy</code>. Par exemple, le <code>(i32, i32)</code> impl√©mente <code>Copy</code>, mais pas
<code>(i32, String)</code>.</li>
</ul>
<!--
### Ownership and Functions
-->
<h3 id="la-possession-et-les-fonctions"><a class="header" href="#la-possession-et-les-fonctions">La possession et les fonctions</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>La syntaxe pour passer une valeur √† une fonction est similaire √† celle pour
assigner une valeur √† une variable. Passer une variable √† une fonction va la
d√©placer ou la copier, comme l'assignation. L'encart 4-3 est un exemple avec
quelques commentaires qui montrent o√π les variables rentrent et sortent de la
port√©e¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello&quot;);  // s rentre dans la port√©e.

  prendre_possession(s);  // La valeur de s est d√©plac√©e dans la fonction‚Ä¶
                          // ‚Ä¶ et n'est plus en vigueur √† partir d'ici

  let x = 5;              // x rentre dans la port√©e.

  creer_copie(x);         // x va √™tre d√©plac√©e dans la fonction,
                          // mais i32 est Copy, donc on peut
                          // utiliser x ensuite.

} // Ici, x sort de la port√©e, puis ensuite s. Mais puisque la valeur de s a
// √©t√© d√©plac√©e, il ne se passe rien de sp√©cial.

fn prendre_possession(texte: String) { // texte rentre dans la port√©e.
  println!(&quot;{}&quot;, texte);
} // Ici, texte sort de la port√©e et `drop` est appel√©. La m√©moire est lib√©r√©e.

fn creer_copie(entier: i32) { // entier rentre dans la port√©e.
  println!(&quot;{}&quot;, entier);
} // Ici, entier sort de la port√©e. Il ne se passe rien de sp√©cial.
</code></pre></pre>
<!--
<span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span>
-->
<p><span class="caption">Encart 4-3¬†: Les fonctions avec les possessions et les
port√©es qui sont comment√©es</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p>Si on essayait d'utiliser <code>s</code> apr√®s l'appel √† <code>prendre_possession</code>, Rust
d√©clencherait une erreur √† la compilation. Ces v√©rifications statiques
nous prot√®gent des erreurs. Essayez d'ajouter du code au <code>main</code> qui utilise <code>s</code>
et <code>x</code> pour d√©couvrir lorsque vous pouvez les utiliser et lorsque les r√®gles de
la possession vous emp√™chent de le faire.</p>
<!--
### Return Values and Scope
-->
<h3 id="les-valeurs-de-retour-et-les-port√©es"><a class="header" href="#les-valeurs-de-retour-et-les-port√©es">Les valeurs de retour et les port√©es</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 shows an example
of a function that returns some value, with similar annotations as those in
Listing 4-3.
-->
<p>Retourner des valeurs peut aussi transf√©rer leur possession. L'encart 4-4
montre un exemple d'une fonction qui retourne une valeur, avec des annotations
similaires √† celles de l'encart 4-3¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s1 = donne_possession();     // donne_possession d√©place sa valeur de
                                   // retour dans s1

  let s2 = String::from(&quot;hello&quot;);  // s2 rentre dans la port√©e

  let s3 = prend_et_rend(s2);      // s2 est d√©plac√©e dans
                                   // prend_et_rend, qui elle aussi
                                   // d√©place sa valeur de retour dans s3.
} // Ici, s3 sort de la port√©e et est √©limin√©e. s2 a √©t√© d√©plac√©e donc il ne se
  // passe rien. s1 sort aussi de la port√©e et est √©limin√©e.

fn donne_possession() -&gt; String {      // donne_possession va d√©placer sa
                                       // valeur de retour dans la
                                       // fonction qui l'appelle.

  let texte = String::from(&quot;yours&quot;);   // texte rentre dans la port√©e.

  texte                                // texte est retourn√©e et
                                       // est d√©plac√©e vers le code qui
                                       // l'appelle.
}

// Cette fonction va prendre une String et en retourne aussi une.
fn prend_et_rend(texte: String) -&gt; String { // texte rentre dans la port√©e.

  texte  // texte est retourn√©e et d√©plac√©e vers le code qui l'appelle.
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">Encart 4-4¬†: Transferts de possession des valeurs de
retour</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless ownership
of the data has been moved to another variable.
-->
<p>La possession d'une variable suit toujours le m√™me sch√©ma √† chaque fois¬†:
assigner une valeur √† une autre variable la d√©place. Quand une variable qui
contient des donn√©es sur le tas sort de la port√©e, la valeur sera nettoy√©e avec
<code>drop</code> √† moins que la possession de cette donn√©e soit donn√©e √† une autre
variable.</p>
<!--
While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? It‚Äôs quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.
-->
<p>M√™me si cela fonctionne, il est un peu fastidieux de prendre la possession puis
ensuite de retourner la possession √† chaque fonction. Et qu'est-ce qu'il se
passe si nous voulons qu'une fonction utilise une valeur, mais n'en prenne pas
possession¬†? C'est assez p√©nible que tout ce que nous passons doit √™tre
retourn√© si nous voulons l'utiliser √† nouveau, en plus de toutes les donn√©es
qui d√©coulent du corps de la fonction que nous voulons aussi r√©cup√©rer.</p>
<!--
Rust does let us return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>Rust nous permet de retourner plusieurs valeurs √† l'aide d'un tuple, comme
ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, taille) = calculer_taille(s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s2, taille);
}

fn calculer_taille(s: String) -&gt; (String, usize) {
    let taille = s.len(); // len() retourne la taille d'une String.

    (s, taille)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">Encart 4-5¬†: Retourner la possession des param√®tres</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for using a value without
transferring ownership, called *references*.
-->
<p>Mais c'est trop laborieux et beaucoup de travail pour un principe qui devrait
√™tre banal. Heureusement pour nous, Rust a une fonctionnalit√© pour utiliser une
valeur sans avoir √† transf√©rer la possession, avec ce qu'on appelle les
<em>r√©f√©rences</em>.</p>
<!-- markdownlint-disable -->
<!--
[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
-->
<!-- markdownlint-restore -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
