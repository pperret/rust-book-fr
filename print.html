<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le langage de programmation Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1 id="le-langage-de-programmation-rust"><a class="header" href="#le-langage-de-programmation-rust">Le langage de programmation Rust</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>par Steve Klabnik et Carol Nichols, avec la participation de la Communaut√©
Rust</em></p>
<!--
This version of the text assumes you‚Äôre using Rust 1.58 (released 2022-01-13)
or later. See the [‚ÄúInstallation‚Äù section of Chapter 1][install]<!-- ignore -- >
to install or update Rust.
-->
<p>Cette version du document suppose que vous utilisez Rust 1.58 (publi√© le
13/01/2022) ou ult√©rieur. Voir la <a href="ch01-01-installation.html">section ‚ÄúInstallation‚Äù du
chapitre 1</a><!-- ignore --> pour installer ou mettre √† jour Rust.</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>Le format HTML de la version anglaise est disponible en ligne √† l'adresse
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
et en hors-ligne avec l'installation de Rust qui a √©t√© effectu√©e avec <code>rustup</code>¬†;
vous pouvez lancer <code>rustup docs --book</code> pour l'ouvrir.</p>
<!--
Several community [translations] are also available.
-->
<p>Vous avez aussi √† votre disposition quelques <a href="appendix-06-translation.html">traductions</a><!--
ignore --> entretenues par la communaut√©.</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>La version anglaise de ce livre est disponible
<a href="https://nostarch.com/rust">au format papier et e-book chez No Starch Press</a>.</p>
<!--
[install]: ch01-01-installation.html
[editions]: appendix-05-editions.html
[nsprust]: https://nostarch.com/rust
[translations]: appendix-06-translation.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Foreword
-->
<h1 id="avant-propos"><a class="header" href="#avant-propos">Avant-propos</a></h1>
<!--
It wasn‚Äôt always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>Cela n'a pas toujours √©t√© aussi √©vident, mais le langage de programmation Rust
apporte avant tout plus de <em>puissance</em>¬†: peu importe le type de code que vous
√©crivez en ce moment, Rust vous permet d'aller plus loin et de
programmer en toute confiance dans une plus grande diversit√© de domaines
qu'auparavant.</p>
<!--
Take, for example, ‚Äúsystems-level‚Äù work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>Prenez par exemple la gestion des √©l√©ments au ‚Äúniveau syst√®me‚Äù qui traite de
d√©tails bas niveau de gestion de m√©moire, de mod√®les de donn√©es et de
concurrence. Traditionnellement, ce domaine de la programmation est jug√©
√©sot√©rique, compr√©hensible uniquement par une poign√©e de personnes qui ont
consacr√© des ann√©es d'apprentissage √† en d√©jouer les pi√®ges inf√¢mes.
Et m√™me ceux qui travaillent dans ce domaine le font avec beaucoup de prudence,
de crainte que leur code ne puisse conduire √† des probl√®mes de s√©curit√©, des plantages
ou des corruptions de m√©moire.</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to ‚Äúdip down‚Äù into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>Rust fait tomber ces obstacles en √©liminant les vieux pi√®ges et en apportant un
ensemble d'outils soign√©s et conviviaux pour vous aider sur votre chemin.
Les d√©veloppeurs qui ont besoin de &quot;se plonger&quot; dans le contr√¥le de plus
bas niveau peuvent ainsi le faire avec Rust, sans prendre le risque habituel
de plantages ou de failles de s√©curit√©, et sans avoir √† apprendre les subtilit√©s
d'un enchev√™trement d'outils capricieux. Encore mieux, le langage est con√ßu pour
vous guider naturellement vers un code fiable et efficace en termes de rapidit√©
d'ex√©cution et d'utilisation de la m√©moire.</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won‚Äôt accidentally introduce crashes or vulnerabilities.
-->
<p>Les d√©veloppeurs qui travaillent d√©j√† avec du code bas niveau peuvent utiliser
Rust pour accro√Ætre leurs ambitions. Par exemple, introduire du parall√©lisme en
Rust est une op√©ration √† faible risque¬†: le compilateur va d√©tecter les erreurs
classiques pour vous. Et vous pourrez vous lancer dans des am√©liorations plus
agressives de votre code avec la certitude que vous n'introduirez pas
accidentellement des causes de plantage ou des vuln√©rabilit√©s.</p>
<!--
But Rust isn‚Äôt limited to low-level systems programming. It‚Äôs expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write ‚Äî you‚Äôll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>Mais Rust n'est pas cantonn√© √† la programmation de bas niveau. C'est un langage
suffisamment expressif et ergonomique pour rendre les applications en ligne
de commande, les serveurs web et bien d'autres types de code agr√©ables √† √©crire
‚Äî vous trouverez plus tard des exemples simples de ces types de programmes dans ce livre.
Travailler avec Rust vous permet d'acqu√©rir des comp√©tences qui sont
transposables d'un domaine √† un autre¬†; vous pouvez apprendre Rust en √©crivant
une application web, puis appliquer les m√™mes notions pour les utiliser avec
votre Raspberry Pi.</p>
<!--
This book fully embraces the potential of Rust to empower its users. It‚Äôs a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn‚Äîand welcome to the Rust community!
-->
<p>Ce livre exploite pleinement le potentiel de Rust pour permettre √† ses
utilisateurs de se perfectionner. C'est une documentation conviviale et accessible
destin√©e √† am√©liorer vos connaissances en Rust, mais aussi √† am√©liorer vos
capacit√©s et votre assurance en tant que d√©veloppeur en g√©n√©ral. Alors foncez,
pr√©parez-vous √† apprendre, et bienvenue dans la communaut√© Rust¬†!</p>
<!--
‚Äî Nicholas Matsakis and Aaron Turon
-->
<p>‚Äî Nicholas Matsakis et Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Introduction
-->
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>Note : la version anglaise de ce livre est disponible au format papier et
ebook chez <a href="https://nostarch.com/">No Starch Press</a> √† cette adresse :
<a href="https://nostarch.com/rust">The Rust Programming Language</a></p>
</blockquote>
<!--
[nsprust]: https://nostarch.com/rust
[nsp]: https://nostarch.com/
-->
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Bienvenue sur <em>Le langage de programmation Rust</em>, un livre d'initiation √† Rust.
Le langage de programmation Rust vous aide √† √©crire plus rapidement des
logiciels plus fiables. L'ergonomie de haut-niveau et la ma√Ætrise de bas-niveau
sont souvent en opposition dans la conception des langages de programmation¬†;
Rust remet en cause ce conflit. Gr√¢ce √† l'√©quilibre entre ses puissantes
capacit√©s techniques et une bonne ergonomie de d√©veloppement, Rust vous donne
la possibilit√© de contr√¥ler les d√©tails de bas-niveau (comme l'utilisation de
la m√©moire) sans tous les soucis traditionnellement associ√©s √† ce genre de
pratique.</p>
<!--
## Who Rust Is For
-->
<h2 id="√Ä-qui-sadresse-rust"><a class="header" href="#√Ä-qui-sadresse-rust">√Ä qui s'adresse Rust</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Let‚Äôs look at a few of
the most important groups.
-->
<p>Rust est id√©al pour de nombreuses personnes pour diverses raisons. Analysons
quelques-uns des groupes les plus importants.</p>
<!--
### Teams of Developers
-->
<h3 id="√âquipes-de-d√©veloppeurs"><a class="header" href="#√âquipes-de-d√©veloppeurs">√âquipes de d√©veloppeurs</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program‚Äôs
logic rather than chasing down bugs.
-->
<p>Rust se r√©v√®le √™tre un outil productif pour la collaboration entre de grandes
√©quipes de d√©veloppeurs ayant diff√©rents niveaux de connaissances en
programmation syst√®me. Le code de bas-niveau est sujet √† une multitude de bogues
subtils, qui, dans la plupart des autres langages, ne peuvent √™tre pr√©venus
qu'au moyen de campagnes de test √©tendues et de minutieuses revues de
code men√©es par des d√©veloppeurs chevronn√©s. Avec Rust, le compilateur joue le
r√¥le de gardien en refusant de compiler du code qui comprend ces bogues
discrets et vicieux, y compris les bogues de concurrence. En travaillant avec
le compilateur, l'√©quipe peut se concentrer sur la logique du programme plut√¥t
que de traquer les bogues.</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rust offre aussi des outils de d√©veloppement modernes au monde de la
programmation syst√®me :</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargo, l'outil int√©gr√© de gestion de d√©pendances et de compilation, qui
uniformise et facilite l'ajout, la compilation, et la gestion des d√©pendances
dans l'√©cosyst√®me Rust.</li>
<li>Rustfmt, qui assure une coh√©rence de style de codage pour tous les
d√©veloppeurs.</li>
<li>Le <em>Rust Langage Server</em> alimente les environnements de d√©veloppement
int√©gr√©s (IDE) pour la compl√©tion du code et l'affichage direct des messages
d'erreur.</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>En utilisant ces outils ainsi que d'autres dans l'√©cosyst√®me Rust, les
d√©veloppeurs peuvent √™tre plus productifs quand ils √©crivent du code syst√®me.</p>
<!--
### Students
-->
<h3 id="√âtudiants"><a class="header" href="#√âtudiants">√âtudiants</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rust est con√ßu pour les √©tudiants et ceux qui s'int√©ressent √† l'apprentissage
des concepts syst√®me. En utilisant Rust, de nombreuses personnes ont appris
des domaines comme le d√©veloppement de syst√®mes d'exploitation. La communaut√©
est tr√®s accueillante et r√©pond volontiers aux questions des √©tudiants. Gr√¢ce √†
des initiatives comme ce livre, les √©quipes de Rust veulent rendre les notions
syst√®me accessibles au plus grand nombre, particuli√®rement √† ceux qui d√©butent
dans la programmation.</p>
<!--
### Companies
-->
<h3 id="entreprises"><a class="header" href="#entreprises">Entreprises</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>Des centaines d'entreprises, petites et grosses, utilisent Rust en production
pour diff√©rentes missions. Ils l'utilisent pour des outils en ligne de commande,
des services web, des outils DevOps, des syst√®mes embarqu√©s, de l'analyse et de
la conversion audio et vid√©o, des cryptomonnaies, de la bio-informatique, des
moteurs de recherche, de l'internet des objets <em>(IoT)</em>, de l'apprentissage
automatique <em>(marchine learning)</em>, et m√™me des parties importantes du navigateur
internet Firefox.</p>
<!--
### Open Source Developers
-->
<h3 id="d√©veloppeurs-de-logiciel-libre"><a class="header" href="#d√©veloppeurs-de-logiciel-libre">D√©veloppeurs de logiciel libre</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We‚Äôd love to have you contribute to the Rust
language.
-->
<p>Rust est ouvert aux personnes qui veulent d√©velopper le langage de programmation
Rust, la communaut√©, les outils de d√©veloppement et les biblioth√®ques. Nous
serions ravis que vous contribuiez au langage Rust.</p>
<!--
### People Who Value Speed and Stability
-->
<h3 id="les-personnes-qui-recherchent-la-rapidit√©-et-la-stabilit√©"><a class="header" href="#les-personnes-qui-recherchent-la-rapidit√©-et-la-stabilit√©">Les personnes qui recherchent la rapidit√© et la stabilit√©</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler‚Äôs checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rust est une solution pour les personnes qui ch√©rissent la rapidit√© et la
stabilit√© dans un langage. Par rapidit√©, nous entendons la vitesse des
programmes que vous pouvez cr√©er avec Rust et la rapidit√© avec laquelle Rust
vous permet de les √©crire. Les v√©rifications du compilateur de Rust assurent la
stabilit√© durant l'ajout de fonctionnalit√©s ou le remaniement du code. Cela
le d√©marque des langages qui ne font pas ces contr√¥les sur du code instable que
le programme a h√©rit√© avec le temps, et que bien souvent les d√©veloppeurs ont
peur de modifier. En s'effor√ßant de mettre en place des abstractions sans co√ªt,
des fonctionnalit√©s de haut-niveau qui compilent vers du code bas-niveau aussi
rapide que s'il avait √©t√© √©crit √† la main, Rust fait en sorte que le
code s√ªr soit aussi du code rapide.</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust‚Äôs greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Le langage Rust esp√®re aider beaucoup d'autres utilisateurs¬†; ceux cit√©s ici ne
font partie que d'un univers bien plus grand. Globalement, la plus grande
ambition de Rust est d'√©radiquer les compromis auxquels les d√©veloppeurs
se soumettaient depuis des d√©cennies en leur apportant s√©curit√© <em>et</em>
productivit√©, rapidit√© <em>et</em> ergonomie. Essayez Rust et v√©rifiez si ses d√©cisions
vous conviennent.</p>
<!--
## Who This Book Is For
-->
<h2 id="√Ä-qui-est-destin√©-ce-livre"><a class="header" href="#√Ä-qui-est-destin√©-ce-livre">√Ä qui est destin√© ce livre</a></h2>
<!--
This book assumes that you‚Äôve written code in another programming language but
doesn‚Äôt make any assumptions about which one. We‚Äôve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don‚Äôt spend a lot of time talking about what programming *is* or how to think
about it. If you‚Äôre entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>Ce livre suppose que vous avez √©crit du code dans un autre langage de
programmation mais ne suppose pas lequel. Nous avons essay√© de rendre son
contenu le plus accessible au plus grand nombre d'exp√©riences de programmation
possible. Nous ne nous √©vertuons pas √† nous questionner sur <em>ce qu'est</em> la
programmation ou comment l'envisager. Si vous √™tes d√©butant en programmation,
vous seriez mieux avis√© en lisant un livre qui vous initie √† la programmation.</p>
<!--
## How to Use This Book
-->
<h2 id="comment-utiliser-ce-livre"><a class="header" href="#comment-utiliser-ce-livre">Comment utiliser ce livre</a></h2>
<!--
In general, this book assumes that you‚Äôre reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>Globalement, ce livre est pr√©vu pour √™tre lu dans l'ordre. Les chapitres
suivants s'appuient sur les notions abord√©es dans les chapitres pr√©c√©dents, et
lorsque les chapitres pr√©c√©dents ne peuvent pas approfondir un sujet, ce sera
g√©n√©ralement fait dans un chapitre suivant.</p>
<!--
You‚Äôll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you‚Äôll learn about an aspect of Rust. In project
chapters, we‚Äôll build small programs together, applying what you‚Äôve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>Vous allez rencontrer deux diff√©rents types de chapitres dans ce livre : les
chapitres th√©oriques et les chapitres de projet. Dans les chapitres th√©oriques,
vous allez apprendre un sujet √† propos de Rust. Dans un chapitre de projet, nous
allons construire ensemble des petits programmes, pour appliquer ce que vous
avez appris pr√©c√©demment. Les chapitres 2, 12 et 20 sont des chapitres de
projet¬†; les autres sont des chapitres th√©oriques.</p>
<!--
Chapter 1 explains how to install Rust, how to write a ‚ÄúHello, world!‚Äù program,
and how to use Cargo, Rust‚Äôs package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust‚Äôs ownership system. However, if you‚Äôre a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you‚Äôd like to work on a project applying the details you‚Äôve learned.
-->
<p>Le chapitre 1 explique comment installer Rust, comment √©crire un programme
&quot;Hello, world!&quot; et comment utiliser Cargo, le gestionnaire de paquets et outil
de compilation. Le chapitre 2 est une initiation pratique au langage Rust. Nous
y aborderons des concepts de haut-niveau, et les chapitres suivants apporteront
plus de d√©tails. Si vous voulez vous <em>salir les mains</em> tout de suite,
le chapitre 2 est l'endroit pour cela. Au d√©but, vous pouvez m√™me sauter le
chapitre 3, qui aborde les fonctionnalit√©s de Rust semblables aux autres
langages de programmation, et passer directement au chapitre 4 pour en savoir
plus sur le syst√®me de possession <em>(ownership)</em> de Rust. Toutefois, si vous √™tes
un apprenti particuli√®rement minutieux qui pr√©f√®re apprendre chaque
particularit√© avant de passer √† la suivante, vous pouvez sauter le chapitre 2 et
passer directement au chapitre 3, puis revenir au chapitre 2 lorsque vous
souhaitez travailler sur un projet en appliquant les notions que vous avez
apprises.</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. You‚Äôll use structs and
enums to make custom types in Rust.
-->
<p>Le chapitre 5 traite des structures et des m√©thodes, et le chapitre 6 couvre les
√©num√©rations, les expressions <code>match</code>, et la structure de contr√¥le <code>if let</code>.
Vous emploierez les structures et les √©num√©rations pour cr√©er des types
personnalis√©s avec Rust.</p>
<!--
In Chapter 7, you‚Äôll learn about Rust‚Äôs module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust‚Äôs error-handling philosophy and techniques.
-->
<p>Au chapitre 7, vous apprendrez le syst√®me de modules de Rust et les r√®gles de
visibilit√©, afin d'organiser votre code et son interface de programmation
applicative (API) publique. Le chapitre 8 traitera des structures de collections
de donn√©es usuelles fournies par la biblioth√®que standard, comme les vecteurs,
les cha√Ænes de caract√®res et les tables de hachage <em>(hash maps)</em>. Le chapitre 9
explorera la philosophie et les techniques de gestion d'erreurs de Rust.</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust‚Äôs safety guarantees is necessary to ensure your program‚Äôs
logic is correct. In Chapter 12, we‚Äôll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, we‚Äôll use many of the concepts we discussed in the
previous chapters.
-->
<p>Le chapitre 10 nous plongera dans la g√©n√©ricit√©, les <em>traits</em> et
les dur√©es de vie, qui vous donneront la capacit√© de cr√©er du code qui s'adapte
√† diff√©rents types. Le chapitre 11 traitera des techniques de test, qui restent
n√©cessaires malgr√© les garanties de s√©curit√© de Rust, pour s'assurer que
la logique de votre programme est valide. Au chapitre 12, nous √©crirons
notre propre impl√©mentation d'un sous-ensemble des fonctionnalit√©s du programme
en ligne de commande <code>grep</code>, qui recherche du texte dans des fichiers.
Pour ce faire, nous utiliserons de nombreuses notions abord√©es dans les
chapitres pr√©c√©dents.</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we‚Äôll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>Le chapitre 13 explorera les fermetures <em>(closures)</em> et it√©rateurs : ce sont les
fonctionnalit√©s de Rust inspir√©es des langages de programmation fonctionnels.
Au chapitre 14, nous explorerons plus en profondeur Cargo et les bonnes
pratiques pour partager vos propres biblioth√®ques avec les autres. Le chapitre
15 parlera de pointeurs intelligents qu'apporte la biblioth√®que standard et des
<em>traits</em> qui activent leurs fonctionnalit√©s.</p>
<!--
In Chapter 16, we‚Äôll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>Au chapitre 16, nous passerons en revue les diff√©rents modes de programmation
concurrente et comment Rust nous aide √† d√©velopper dans des t√¢ches parall√®les
sans crainte. Le chapitre 17 comparera les fonctionnalit√©s de Rust aux
principes de programmation orient√©e objet, que vous connaissez peut-√™tre.</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>Le chapitre 18 est une r√©f√©rence sur les motifs et le filtrage de motif
<em>(pattern matching)</em>, qui sont des moyens puissants permettant de communiquer
des id√©es dans les programmes Rust. Le chapitre 19 contient une foultitude de
sujets avanc√©s int√©ressants, comme le code Rust non s√©curis√© <em>(unsafe)</em>, les
macros et plus de d√©tails sur les dur√©es de vie, les <em>traits</em>, les types, les
fonctions et les fermetures <em>(closures)</em>.</p>
<!--
In Chapter 20, we‚Äôll complete a project in which we‚Äôll implement a low-level
multithreaded web server!
-->
<p>Au chapitre 20, nous terminerons un projet dans lequel nous allons
impl√©menter en bas-niveau un serveur web multit√¢ches¬†!</p>
<!--
Finally, some appendices contain useful information about the language in a
more reference-like format. Appendix A covers Rust‚Äôs keywords, Appendix B
covers Rust‚Äôs operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>Et finalement, quelques annexes qui contiennent des informations utiles sur le
langage sous forme de r√©f√©rentiels qui renvoient √† d'autres documents. L'annexe
A liste les mots-cl√©s de Rust, l'annexe B couvre les op√©rateurs et symboles de
Rust, l'annexe C parle des <em>traits</em> d√©rivables qu'apporte la biblioth√®que
standard, l'annexe D r√©f√©rence certains outils de d√©veloppement utiles, et
l'annexe E explique les diff√©rentes √©ditions de Rust.</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>Il n'y a pas de mauvaise mani√®re de lire ce livre : si vous voulez sauter des
√©tapes, allez-y !
Vous devrez alors peut-√™tre revenir sur les chapitres pr√©c√©dents si vous
√©prouvez des difficult√©s. Mais faites comme bon vous semble.</p>
<!--
<span id="ferris"></span>
-->
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we‚Äôll provide many examples that don‚Äôt compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you‚Äôre trying to run is meant to
error. Ferris will also help you distinguish code that isn‚Äôt meant to work:
-->
<p>Une composante importante du processus d'apprentissage de Rust est de comprendre
comment lire les messages d'erreur qu'affiche le compilateur : ils vous
guideront vers du code correct.
Ainsi, nous citerons de nombreux exemples qui ne compilent pas, avec le message
d'erreur que le compilateur devrait vous afficher dans chaque cas. C'est donc
normal que dans certains cas, si vous copiez et ex√©cutez un exemple au hasard,
il ne compile pas ! Assurez-vous d'avoir lu le texte autour pour savoir si
l'exemple que vous tentez de compiler doit √©chouer. Ferris va aussi vous aider
√† identifier du code qui ne devrait pas fonctionner :</p>
<!-- markdownlint-disable -->
<!--
| Ferris                                                                                                           | Meaning                                          |
|------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/>            | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/>                   | This code panics!                                |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/> | This code does not produce the desired behavior. |
-->
<!-- markdownlint-restore -->
<table><thead><tr><th>Ferris</th><th>Signification</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris avec un point d'interrogation"/></td><td>Ce code ne compile pas !</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris qui l√®ve ses bras"/></td><td>Ce code panique !</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris avec une pince en l'air, haussant les √©paules"/></td><td>Ce code ne se comporte pas comme voulu.</td></tr>
</tbody></table>
<!--
In most situations, we‚Äôll lead you to the correct version of any code that
doesn‚Äôt compile.
-->
<p>Dans la plupart des cas, nous vous guiderons vers la version du code qui devrait
fonctionner.</p>
<!--
## Source Code
-->
<h2 id="code-source"><a class="header" href="#code-source">Code source</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>Les fichiers du code source qui a g√©n√©r√© ce livre en anglais sont disponibles
sur <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.</p>
<p>La version fran√ßaise est aussi disponible sur <a href="https://github.com/Jimskapt/rust-book-fr">GitHub</a>.</p>
<!--
[book]: https://github.com/rust-lang/book/tree/main/src
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="traduction-des-termes"><a class="header" href="#traduction-des-termes">Traduction des termes</a></h1>
<p>Voici les principaux termes techniques qui ont √©t√© traduits de l'anglais vers le
fran√ßais.</p>
<table><thead><tr><th>Anglais</th><th>Fran√ßais</th><th>Remarques</th></tr></thead><tbody>
<tr><td>adaptor</td><td>adaptateur</td><td>-</td></tr>
<tr><td>ahead-of-time compilation</td><td>compilation anticip√©e</td><td>sigle¬†: AOT</td></tr>
<tr><td>alias</td><td>alias</td><td>-</td></tr>
<tr><td>allocated</td><td>allou√©</td><td>-</td></tr>
<tr><td>angle bracket</td><td>chevrons</td><td>-</td></tr>
<tr><td>annotate</td><td>indiquer</td><td>-</td></tr>
<tr><td>anti-pattern</td><td>anti-patron</td><td>-</td></tr>
<tr><td>Appendix</td><td>annexe</td><td>tout en minuscule (sauf en d√©but de phrase)</td></tr>
<tr><td>append</td><td>ajouter</td><td>-</td></tr>
<tr><td>Application Programming Interface (API)</td><td>interface de programmation applicative (API)</td><td>-</td></tr>
<tr><td>assertion</td><td>v√©rification</td><td>-</td></tr>
<tr><td>assign</td><td>assigner</td><td>-</td></tr>
<tr><td>argument</td><td>argument / param√®tre</td><td>-</td></tr>
<tr><td>arm</td><td>branche</td><td>dans une expression <code>match</code></td></tr>
<tr><td>array</td><td>tableau</td><td>-</td></tr>
<tr><td>artifact</td><td>art√©fact</td><td>-</td></tr>
<tr><td>associated function</td><td>fonction associ√©e</td><td>-</td></tr>
<tr><td>attribute</td><td>attribut</td><td>-</td></tr>
<tr><td>backend</td><td>application dorsale</td><td>-</td></tr>
<tr><td>backtrace</td><td>retra√ßage</td><td>-</td></tr>
<tr><td>benchmark</td><td>benchmark</td><td>-</td></tr>
<tr><td>binary crate</td><td>crate binaire</td><td>s'utilise au f√©minin</td></tr>
<tr><td>buffer overread</td><td>lecture hors limites</td><td>-</td></tr>
<tr><td><em>n</em>-bit number</td><td>nombre encod√© sur <em>n</em> bits</td><td>-</td></tr>
<tr><td>blanket implementation</td><td>impl√©mentation g√©n√©rale</td><td>-</td></tr>
<tr><td>blob</td><td>blob</td><td>-</td></tr>
<tr><td>boilerplate code</td><td>code standard</td><td>-</td></tr>
<tr><td>boolean</td><td>bool√©en</td><td>-</td></tr>
<tr><td>borrow</td><td>emprunt(er)</td><td>-</td></tr>
<tr><td>borrow checker</td><td>v√©rificateur d'emprunt</td><td>-</td></tr>
<tr><td>box</td><td>boite</td><td>-</td></tr>
<tr><td>buffer overread</td><td>sur-lecture de tampon</td><td>-</td></tr>
<tr><td>bug</td><td>bogue</td><td>-</td></tr>
<tr><td>build</td><td>compilation</td><td>-</td></tr>
<tr><td>build system</td><td>syst√®me de compilation</td><td>-</td></tr>
<tr><td>byte</td><td>octet</td><td>-</td></tr>
<tr><td>Cargo</td><td>Cargo</td><td>-</td></tr>
<tr><td>catchall value</td><td>valeur passe-partout</td><td>-</td></tr>
<tr><td>channel</td><td>canal</td><td>-</td></tr>
<tr><td>Chapter</td><td>chapitre</td><td>tout en minuscule (sauf en d√©but de phrase)</td></tr>
<tr><td>CI system</td><td>syst√®me d'Int√©gration Continue</td><td>-</td></tr>
<tr><td>clause</td><td>clause</td><td>-</td></tr>
<tr><td>cleanup</td><td>nettoyage</td><td>-</td></tr>
<tr><td>closure</td><td>fermeture</td><td>-</td></tr>
<tr><td>code review</td><td>revue de code</td><td>-</td></tr>
<tr><td>coercion</td><td>extrapolation</td><td>-</td></tr>
<tr><td>collection</td><td>collection</td><td>-</td></tr>
<tr><td>command</td><td>commande</td><td>dans un terminal</td></tr>
<tr><td>commit</td><td>commit</td><td>-</td></tr>
<tr><td>compound</td><td>compos√©</td><td>-</td></tr>
<tr><td>concept chapter</td><td>chapitre th√©orique</td><td>-</td></tr>
<tr><td>concurrency</td><td>concurrence</td><td>-</td></tr>
<tr><td>concurrent</td><td>concurrent</td><td>-</td></tr>
<tr><td>concurrent programming</td><td>programmation concurrente</td><td>-</td></tr>
<tr><td>conditional</td><td>structure conditionnelle</td><td>-</td></tr>
<tr><td>cons list</td><td>liste de construction</td><td>-</td></tr>
<tr><td>constant</td><td>constant / constante</td><td>-</td></tr>
<tr><td>construct</td><td>instruction</td><td>-</td></tr>
<tr><td>constructor</td><td>constructeur</td><td>-</td></tr>
<tr><td>consuming adaptor</td><td>adaptateur de consommation</td><td>-</td></tr>
<tr><td>control flow construct</td><td>structure de contr√¥le</td><td>-</td></tr>
<tr><td>core of the error</td><td>message d'erreur</td><td>-</td></tr>
<tr><td>corruption</td><td>corruption / √™tre corrompu</td><td>-</td></tr>
<tr><td>CPU</td><td>processeur</td><td>-</td></tr>
<tr><td>crash</td><td>plantage</td><td>-</td></tr>
<tr><td>crate</td><td>crate</td><td>nom f√©minin (une <em>crate</em>)</td></tr>
<tr><td>curly bracket</td><td>accolade</td><td>-</td></tr>
<tr><td>dangling</td><td>pendouillant</td><td>-</td></tr>
<tr><td>data race</td><td>acc√®s concurrent</td><td>-</td></tr>
<tr><td>data representation</td><td>mod√®le de donn√©es</td><td>-</td></tr>
<tr><td>deadlock</td><td>interblocage</td><td>-</td></tr>
<tr><td>deallocate</td><td>d√©sallou√©</td><td>-</td></tr>
<tr><td>debug</td><td>d√©boguer</td><td>-</td></tr>
<tr><td>debugging</td><td>d√©bogage</td><td>-</td></tr>
<tr><td>deep copy</td><td>copie en profondeur</td><td>-</td></tr>
<tr><td>dependency</td><td>d√©pendance</td><td>-</td></tr>
<tr><td>deref coercion</td><td>extrapolation de d√©r√©ferencement</td><td>-</td></tr>
<tr><td>dereference operator</td><td>op√©rateur de d√©r√©f√©rencement</td><td>-</td></tr>
<tr><td>dereferencing</td><td>d√©r√©f√©rencement</td><td>-</td></tr>
<tr><td>design pattern</td><td>patron de conception</td><td>-</td></tr>
<tr><td>destructor</td><td>destructeur</td><td>-</td></tr>
<tr><td>destructure</td><td>d√©structurer</td><td>-</td></tr>
<tr><td>DevOps</td><td>DevOps</td><td>-</td></tr>
<tr><td>directory</td><td>dossier</td><td>-</td></tr>
<tr><td>dot notation</td><td>la notation avec un point</td><td>-</td></tr>
<tr><td>double free</td><td>double lib√©ration</td><td>-</td></tr>
<tr><td>drop</td><td>lib√©r√©r</td><td>-</td></tr>
<tr><td>elision</td><td>√©lision</td><td>-</td></tr>
<tr><td>enum</td><td>√©num√©ration</td><td>-</td></tr>
<tr><td>enumeration</td><td>√©num√©ration</td><td>-</td></tr>
<tr><td>enum‚Äôs variant</td><td>variante d'√©num√©ration</td><td>-</td></tr>
<tr><td>exploit</td><td>faille</td><td>-</td></tr>
<tr><td>expression</td><td>expression</td><td>-</td></tr>
<tr><td>field</td><td>champ</td><td>d'une structure</td></tr>
<tr><td>Figure</td><td>Illustration</td><td>-</td></tr>
<tr><td>flag</td><td>drapeau</td><td>pour les programmes en ligne de commande</td></tr>
<tr><td>float</td><td>nombre √† virgule flottante</td><td>-</td></tr>
<tr><td>floating-point number</td><td>nombre √† virgule flottante</td><td>-</td></tr>
<tr><td>framework</td><td>environnement de d√©veloppement</td><td>-</td></tr>
<tr><td>frontend</td><td>interface frontale</td><td>-</td></tr>
<tr><td>fully qualified syntax</td><td>syntaxe totalement d√©finie</td><td>-</td></tr>
<tr><td>function</td><td>fonction</td><td>-</td></tr>
<tr><td>functional programming</td><td>programmation fonctionnelle</td><td>-</td></tr>
<tr><td>garbage collector</td><td>ramasse-miettes</td><td>-</td></tr>
<tr><td>generics</td><td>g√©n√©riques / g√©n√©ricit√©</td><td>-</td></tr>
<tr><td>generic type parameter</td><td>param√®tre de type g√©n√©rique</td><td>-</td></tr>
<tr><td>getter</td><td>accesseur</td><td>-</td></tr>
<tr><td>glob</td><td>global</td><td>op√©rateur</td></tr>
<tr><td>global scope</td><td>port√©e globale</td><td>-</td></tr>
<tr><td>grapheme cluster</td><td>groupe de graph√®mes</td><td>-</td></tr>
<tr><td>green thread</td><td>t√¢che virtuelle</td><td>-</td></tr>
<tr><td>guessing game</td><td>jeu de devinettes</td><td>-</td></tr>
<tr><td>handle</td><td>r√©f√©rence abstraite</td><td>-</td></tr>
<tr><td>hash</td><td>hash / relatif au hachage</td><td>-</td></tr>
<tr><td>hash map</td><td>table de hachage</td><td>-</td></tr>
<tr><td>heap</td><td>tas</td><td>-</td></tr>
<tr><td>Hello, world!</td><td>Hello, world!</td><td>-</td></tr>
<tr><td>high-level</td><td>haut niveau</td><td>-</td></tr>
<tr><td>identifier</td><td>identificateur</td><td>-</td></tr>
<tr><td>idiomatic</td><td>id√©al</td><td>-</td></tr>
<tr><td>immutability</td><td>immuabilit√©</td><td>-</td></tr>
<tr><td>immutable</td><td>immuable</td><td>-</td></tr>
<tr><td>index</td><td>indice</td><td>-</td></tr>
<tr><td>indexing</td><td>indexation</td><td>-</td></tr>
<tr><td>input/output</td><td>entr√©e/sortie</td><td>sigle¬†: IO</td></tr>
<tr><td>instance</td><td>instance</td><td>-</td></tr>
<tr><td>instantiate</td><td>instancier</td><td>cr√©er une instance</td></tr>
<tr><td>integer literal</td><td>litt√©ral d'entiers</td><td>-</td></tr>
<tr><td>integer overflow</td><td>d√©passement d'entier</td><td>-</td></tr>
<tr><td>Integrated Development Environment (IDE)</td><td>environnement de d√©veloppement int√©gr√© (IDE)</td><td>-</td></tr>
<tr><td>interior mutability</td><td>mutabilit√© interne</td><td>-</td></tr>
<tr><td>interrupt signal</td><td>signal d'arr√™t</td><td>-</td></tr>
<tr><td>invalidate</td><td>neutraliser</td><td>-</td></tr>
<tr><td>IOT</td><td>internet des objets (IOT)</td><td>-</td></tr>
<tr><td>iterator</td><td>it√©rateur</td><td>-</td></tr>
<tr><td>iterator adaptor</td><td>adaptateur d'it√©ration</td><td>-</td></tr>
<tr><td>job</td><td>mission</td><td>-</td></tr>
<tr><td>just-in-time compilation</td><td>compilation √† la vol√©e</td><td>sigle¬†: JIT</td></tr>
<tr><td>keyword</td><td>mot-cl√©</td><td>-</td></tr>
<tr><td>lazy</td><td>√©valuation paresseuse</td><td>comportement d'un it√©rateur</td></tr>
<tr><td>legacy code</td><td>code instable que le programme a h√©rit√© avec le temps</td><td>-</td></tr>
<tr><td>library</td><td>biblioth√®que</td><td>-</td></tr>
<tr><td>library crate</td><td>crate de biblioth√®que</td><td>s'utilise au f√©minin</td></tr>
<tr><td>lifetime</td><td>dur√©e de vie</td><td>-</td></tr>
<tr><td>linker</td><td>linker</td><td>-</td></tr>
<tr><td>linter</td><td>analyse statique</td><td>-</td></tr>
<tr><td>literal value</td><td>valeur litt√©rale</td><td>-</td></tr>
<tr><td>Listing</td><td>encart</td><td>tout en minuscule (sauf en d√©but de phrase)</td></tr>
<tr><td>loop</td><td>boucle</td><td>-</td></tr>
<tr><td>low-level</td><td>bas niveau</td><td>-</td></tr>
<tr><td>machine learning</td><td>apprentissage automatique</td><td>-</td></tr>
<tr><td>macro</td><td>macro</td><td>-</td></tr>
<tr><td>main</td><td>main</td><td>-</td></tr>
<tr><td>map</td><td>tableau associatif</td><td>-</td></tr>
<tr><td>match guard</td><td>contr√¥le de correspondance</td><td>-</td></tr>
<tr><td>memory leak</td><td>fuite de m√©moire</td><td>-</td></tr>
<tr><td>memory management</td><td>gestion de m√©moire</td><td>-</td></tr>
<tr><td>message-passing</td><td>passage de messages</td><td>-</td></tr>
<tr><td>method</td><td>m√©thode</td><td>-</td></tr>
<tr><td>mock object</td><td>mock object</td><td>-</td></tr>
<tr><td>modern</td><td>r√©cent</td><td>-</td></tr>
<tr><td>module</td><td>module</td><td>-</td></tr>
<tr><td>module system</td><td>syst√®me de modules</td><td>-</td></tr>
<tr><td>monomorphization</td><td>monomorphisation</td><td>-</td></tr>
<tr><td>move</td><td>d√©placement</td><td>-</td></tr>
<tr><td>mutability</td><td>mutabilit√©</td><td>-</td></tr>
<tr><td>mutable</td><td>mutable</td><td>modifiable</td></tr>
<tr><td>mutate</td><td>muter</td><td>-</td></tr>
<tr><td>namespace</td><td>espace de nom</td><td>-</td></tr>
<tr><td>namespacing</td><td>l'espace de nom</td><td>-</td></tr>
<tr><td>nested (path)</td><td>(chemin) imbriqu√©</td><td>-</td></tr>
<tr><td>newtype pattern</td><td>motif newtype</td><td>-</td></tr>
<tr><td>nightly Rust</td><td>version exp√©rimentale de Rust</td><td>-</td></tr>
<tr><td>Note</td><td>remarque</td><td>tout en minuscule (sauf en d√©but de phrase)</td></tr>
<tr><td>numerical characters</td><td>chiffres</td><td>-</td></tr>
<tr><td>object-oriented language</td><td>langage orient√© objet</td><td>-</td></tr>
<tr><td>operating system</td><td>syst√®me d'exploitation</td><td>-</td></tr>
<tr><td>output</td><td>sortie</td><td>-</td></tr>
<tr><td>overload</td><td>surcharge</td><td>-</td></tr>
<tr><td>owner</td><td>propri√©taire</td><td>-</td></tr>
<tr><td>ownership</td><td>possession</td><td>-</td></tr>
<tr><td>package manager</td><td>syst√®me de gestion de paquets</td><td>-</td></tr>
<tr><td>panic</td><td>panique(r)</td><td>-</td></tr>
<tr><td>parallel programming</td><td>parall√©lisme</td><td>-</td></tr>
<tr><td>parallelism</td><td>parall√©lisme</td><td>-</td></tr>
<tr><td>parameter</td><td>param√®tre</td><td>-</td></tr>
<tr><td>parse</td><td>interpr√©ter</td><td>-</td></tr>
<tr><td>PATH</td><td>PATH</td><td>-</td></tr>
<tr><td>pattern</td><td>motif</td><td>-</td></tr>
<tr><td>pattern-matching</td><td>filtrage par motif</td><td>-</td></tr>
<tr><td>placeholder</td><td>espace r√©serv√©</td><td><code>{}</code> pour <code>fmt</code></td></tr>
<tr><td>pointer</td><td>pointeur</td><td>-</td></tr>
<tr><td>popping off the stack</td><td>d√©piler</td><td>-</td></tr>
<tr><td>prelude</td><td>√©tape pr√©liminaire</td><td>-</td></tr>
<tr><td>primitive obsession</td><td>obsession primitive</td><td>-</td></tr>
<tr><td>privacy</td><td>visibilit√©</td><td>en parlant des √©l√©ments d'un module</td></tr>
<tr><td>procedural macro</td><td>macro proc√©durale</td><td>-</td></tr>
<tr><td>process</td><td>processus</td><td>-</td></tr>
<tr><td>project chapter</td><td>chapitre de projet</td><td>-</td></tr>
<tr><td>propagate</td><td>propager</td><td>-</td></tr>
<tr><td>pushing onto the stack</td><td>empiler</td><td>-</td></tr>
<tr><td>race condition</td><td>situation de concurrence</td><td>-</td></tr>
<tr><td>raw identifier</td><td>identificateur brut</td><td>-</td></tr>
<tr><td>README</td><td>README</td><td>-</td></tr>
<tr><td>recursive type</td><td>type r√©cursif</td><td>-</td></tr>
<tr><td>refactoring</td><td>remaniement</td><td>-</td></tr>
<tr><td>reference</td><td>r√©f√©rence</td><td>-</td></tr>
<tr><td>reference counting</td><td>compteur de r√©f√©rences</td><td>-</td></tr>
<tr><td>reference cycle</td><td>boucle de r√©f√©rences</td><td>-</td></tr>
<tr><td>release</td><td>publication</td><td>-</td></tr>
<tr><td>registry</td><td>registre</td><td>-</td></tr>
<tr><td>regression</td><td>r√©gression</td><td>-</td></tr>
<tr><td>release</td><td>publication</td><td>-</td></tr>
<tr><td>remainder</td><td>modulo</td><td>op√©ration <code>%</code></td></tr>
<tr><td>reproducible build</td><td>compilation reproductible</td><td>-</td></tr>
<tr><td>Resource Acquisition Is Initialization (RAII)</td><td>l'acquisition d'une ressource est une initialisation (RAII)</td><td>-</td></tr>
<tr><td>return</td><td>retourner</td><td>-</td></tr>
<tr><td>run</td><td>ex√©cuter</td><td>pour les programmes</td></tr>
<tr><td>Rustacean</td><td>Rustac√©</td><td>-</td></tr>
<tr><td>section header</td><td>ent√™te de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version s√©mantique</td><td>-</td></tr>
<tr><td>scalar</td><td>scalaire</td><td>-</td></tr>
<tr><td>scope</td><td>port√©e</td><td>-</td></tr>
<tr><td>script</td><td>script</td><td>-</td></tr>
<tr><td>secret</td><td>secret</td><td>-</td></tr>
<tr><td>section header</td><td>en-t√™te de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version s√©mantique</td><td>-</td></tr>
<tr><td>semantic versioning</td><td>versionnage s√©mantique</td><td>abr√©viation¬†: SemVer</td></tr>
<tr><td>shadow</td><td>masquer</td><td>remplacer une variable par une autre de m√™me nom</td></tr>
<tr><td>shadowing</td><td>masquage</td><td>-</td></tr>
<tr><td>shallow copy</td><td>copie superficielle</td><td>-</td></tr>
<tr><td>shell</td><td>terminal / invite de commande</td><td>-</td></tr>
<tr><td>shorthand</td><td>abr√©viation</td><td>-</td></tr>
<tr><td>sidebar</td><td>volet lat√©ral</td><td>-</td></tr>
<tr><td>signature</td><td>signature</td><td>d'une fonction</td></tr>
<tr><td>signed</td><td>sign√©</td><td>-</td></tr>
<tr><td>slash</td><td>barre oblique</td><td>-</td></tr>
<tr><td>slice</td><td>slice</td><td>-</td></tr>
<tr><td>smart pointer</td><td>pointeur intelligent</td><td>-</td></tr>
<tr><td>snake case</td><td>snake case</td><td>-</td></tr>
<tr><td>snip</td><td>partie masqu√©e ici</td><td>dans un encart</td></tr>
<tr><td>space</td><td>espace</td><td>ce mot est f√©minin quand on parle du caract√®re typographique</td></tr>
<tr><td>square brackets</td><td>crochets</td><td>-</td></tr>
<tr><td>stack</td><td>pile</td><td>-</td></tr>
<tr><td>stack overflow</td><td>d√©bordement de pile</td><td>-</td></tr>
<tr><td>standard</td><td>standard <em>(adj. inv.)</em> / norme <em>(n.f.)</em></td><td>-</td></tr>
<tr><td>standard error</td><td>erreur standard</td><td>-</td></tr>
<tr><td>standard input</td><td>entr√©e standard</td><td>-</td></tr>
<tr><td>standard library</td><td>biblioth√®que standard</td><td>-</td></tr>
<tr><td>standard output</td><td>sortie standard</td><td>-</td></tr>
<tr><td>statement</td><td>instruction</td><td>-</td></tr>
<tr><td>statically typed</td><td>statiquement typ√©</td><td>-</td></tr>
<tr><td>string</td><td>cha√Æne de caract√®res</td><td>-</td></tr>
<tr><td>string literal</td><td>un litt√©ral de cha√Æne de caract√®res</td><td>-</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>nom f√©minin (une <code>String</code>)</td></tr>
<tr><td>struct</td><td>structure</td><td>-</td></tr>
<tr><td>submodule</td><td>sous-module</td><td>-</td></tr>
<tr><td>supertrait</td><td>supertrait</td><td>-</td></tr>
<tr><td>syntax sugar</td><td>sucre syntaxique</td><td>-</td></tr>
<tr><td>systems concept</td><td>notion syst√®me</td><td>-</td></tr>
<tr><td>systems-level</td><td>niveau syst√®me</td><td>-</td></tr>
<tr><td>systems-level code</td><td>code syst√®me</td><td>-</td></tr>
<tr><td>terminal</td><td>terminal</td><td>-</td></tr>
<tr><td>test double</td><td>double de test</td><td>-</td></tr>
<tr><td>thread</td><td>t√¢che</td><td>-</td></tr>
<tr><td>thread pool</td><td>groupe de t√¢ches</td><td>-</td></tr>
<tr><td>token</td><td>jeton</td><td>-</td></tr>
<tr><td>trait</td><td>trait</td><td>-</td></tr>
<tr><td>trait bound</td><td>trait li√©</td><td>-</td></tr>
<tr><td>trait object</td><td>objet trait</td><td>-</td></tr>
<tr><td>tree</td><td>arborescence</td><td>-</td></tr>
<tr><td>troubleshooting</td><td>d√©pannage</td><td>-</td></tr>
<tr><td>tuple</td><td>tuple</td><td>-</td></tr>
<tr><td>tuple struct</td><td>structure tuple</td><td>-</td></tr>
<tr><td>tuple enum</td><td>√©num√©ration tuple</td><td>-</td></tr>
<tr><td>type</td><td>type</td><td>-</td></tr>
<tr><td>type annotation</td><td>annotation de type</td><td>-</td></tr>
<tr><td>type inference</td><td>inf√©rence de types</td><td>-</td></tr>
<tr><td>two‚Äôs complement</td><td>compl√©ment √† deux</td><td>-</td></tr>
<tr><td>two‚Äôs complement wrapping</td><td>rebouclage du compl√©ment √† deux</td><td>-</td></tr>
<tr><td>underlying operating system</td><td>syst√®me d'exploitation sous-jacent</td><td>-</td></tr>
<tr><td>underscore</td><td>tiret bas</td><td>le caract√®re <code>_</code></td></tr>
<tr><td>unit-like struct</td><td>structure unit√©</td><td>-</td></tr>
<tr><td>unit type</td><td>type unit√©</td><td>le <code>()</code></td></tr>
<tr><td>unit value</td><td>valeur unit√©</td><td>-</td></tr>
<tr><td>unrolling</td><td>d√©roulage</td><td>pour une boucle √† taille connue √† la compilation</td></tr>
<tr><td>unsafe</td><td>non s√©curis√©</td><td>-</td></tr>
<tr><td>unsigned</td><td>sans signe (toujours positif)</td><td>-</td></tr>
<tr><td>unsigned</td><td>non sign√©</td><td>-</td></tr>
<tr><td>unwind</td><td>d√©rouler</td><td>(la pile)</td></tr>
<tr><td>user input</td><td>saisie utilisateur</td><td>-</td></tr>
<tr><td>variable</td><td>variable</td><td>-</td></tr>
<tr><td>variant</td><td>variante</td><td>d'une √©num√©ration</td></tr>
<tr><td>vector</td><td>vecteur</td><td>-</td></tr>
<tr><td>version control system (VCS)</td><td>syst√®me de gestion de versions (VCS)</td><td>-</td></tr>
<tr><td>vertical pipe</td><td>barre verticale</td><td>la barre `</td></tr>
<tr><td>warning</td><td>avertissement</td><td>-</td></tr>
<tr><td>weak reference</td><td>r√©f√©rence faible</td><td>-</td></tr>
<tr><td>wildcard</td><td>joker</td><td>-</td></tr>
<tr><td>worker</td><td>op√©rateur</td><td>-</td></tr>
<tr><td>workspace</td><td>espace de travail</td><td>-</td></tr>
<tr><td>yank</td><td>d√©pr√©cier</td><td>-</td></tr>
<tr><td>zero-cost abstraction</td><td>abstraction sans co√ªt</td><td>-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><!--
# Getting Started
-->
<h1 id="prise-en-main"><a class="header" href="#prise-en-main">Prise en main</a></h1>
<!--
Let‚Äôs start your Rust journey! There‚Äôs a lot to learn, but every journey starts
somewhere. In this chapter, we‚Äôll discuss:
-->
<p>D√©marrons notre p√©riple avec Rust ! Il y a beaucoup √† apprendre, mais chaque
aventure doit commencer quelque part. Dans ce chapitre, nous allons aborder :</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rust‚Äôs package manager and build system
-->
<ul>
<li>L'installation de Rust sur Linux, macOS et Windows</li>
<li>L'√©criture d'un programme qui affiche <code>Hello, world!</code></li>
<li>L'utilisation de <code>cargo</code>, le gestionnaire de paquets et syst√®me de compilation
de Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
## Installation
-->
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<!--
The first step is to install Rust. We‚Äôll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. You‚Äôll need
an internet connection for the download.
-->
<p>La premi√®re √©tape consiste √† installer Rust. Nous allons t√©l√©charger Rust via
<code>rustup</code>, un outil en ligne de commande con√ßu pour g√©rer les versions de Rust et
les outils qui leur sont associ√©s. Vous allez avoir besoin d'une connexion
Internet pour le t√©l√©chargement.</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see the
> [Other Rust Installation Methods page][otherinstall] for more options.
-->
<blockquote>
<p>Note¬†: si vous pr√©f√©rez ne pas utiliser <code>rustup</code> pour une raison ou une autre,
vous pouvez vous r√©f√©rer √† <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">la page des autres moyens d'installation de
Rust</a> pour d'autres m√©thodes d'installation.</p>
</blockquote>
<!--
[otherinstall]: https://forge.rust-lang.org/infra/other-installation-methods.html
-->
<!--
The following steps install the latest stable version of the Rust compiler.
Rust‚Äôs stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>L'√©tape suivante est d'installer la derni√®re version stable du compilateur Rust.
La garantie de stabilit√© de Rust assurera que tous les exemples dans le livre
qui se compilent bien vont continuer √† se compiler avec les nouvelles versions
de Rust. La sortie peut varier l√©g√®rement d'une version √† une autre, car Rust
am√©liore souvent les messages d'erreur et les avertissements. En r√©sum√©, toute
nouvelle version stable de Rust que vous installez de cette mani√®re devrait
fonctionner en coh√©rence avec le contenu de ce livre.</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, we‚Äôll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> don‚Äôt need to type in the `$` character; it indicates the start of each
> command. Lines that don‚Äôt start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3 id="la-notation-en-ligne-de-commande"><a class="header" href="#la-notation-en-ligne-de-commande">La notation en ligne de commande</a></h3>
<p>Dans ce chapitre et les suivants dans le livre, nous allons montrer quelques
commandes tap√©es dans le terminal. Les lignes que vous devrez √©crire dans le
terminal commencent toutes par <code>$</code>. Vous n'avez pas besoin d'√©crire le
caract√®re <code>$</code>; il marque le d√©but de chaque commande. Les lignes qui ne
commencent pas par <code>$</code> montrent g√©n√©ralement le r√©sultat de la commande
pr√©c√©dente. De plus, les exemples propres √† PowerShell utiliseront
<code>&gt;</code> plut√¥t que <code>$</code>.</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3 id="installer-rustup-sur-linux-ou-macos"><a class="header" href="#installer-rustup-sur-linux-ou-macos">Installer <code>rustup</code> sur Linux ou macOS</a></h3>
<!--
If you‚Äôre using Linux or macOS, open a terminal and enter the following command:
-->
<p>Si vous utilisez Linux ou macOS, ouvrez un terminal et √©crivez la commande
suivante¬†:</p>
<!--
```console
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```
-->
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>Cette commande t√©l√©charge un script et lance l'installation de l'outil <code>rustup</code>,
qui va installer la derni√®re version stable de Rust. Il est possible que l'on
vous demande votre mot de passe. Si l'installation se d√©roule bien, vous
devriez voir la ligne suivante s'afficher¬†:</p>
<!--
```text
Rust is installed now. Great!
```
-->
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
You will also need a linker, which is a program that Rust uses to join its
compiled outputs into one file. It is likely you already have one. If you get
linker errors, you should install a C compiler, which will typically include a
linker. A C compiler is also useful because some common Rust packages depend on
C code and will need a C compiler.
-->
<p>Vous aurez aussi besoin d'un <em>linker</em>, qui est un programme que Rust utilise
pour regrouper ses multiples r√©sultats de compilation dans un unique fichier.
Il est probable que vous en ayez d√©j√† un d'install√©, mais si vous avez des
erreurs √† propos du <em>linker</em>, cela veut dire vous devrez installer un
compilateur de langage C, qui inclura g√©n√©ralement un <em>linker</em>. Un compilateur
est parfois utile car certains paquets Rust communs n√©cessitent du code C et
auront besoin d'un compilateur C.</p>
<!--
On macOS, you can get a C compiler by running:
-->
<p>Sur macOS, vous pouvez obtenir un compilateur C en lan√ßant la commande :</p>
<!--
```console
$ xcode-select --install
```
-->
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<!--
Linux users should generally install GCC or Clang, according to their
distribution‚Äôs documentation. For example, if you use Ubuntu, you can install
the `build-essential` package.
-->
<p>Les utilisateurs de Linux doivent g√©n√©ralement installer GCC ou Clang, en fonction
de la documentation de leur distribution. Par exemple, si vous utilisez Ubuntu,
vous pouvez installer le paquet <code>build-essential</code>.</p>
<!--
### Installing `rustup` on Windows
-->
<h3 id="installer-rustup-sous-windows"><a class="header" href="#installer-rustup-sous-windows">Installer <code>rustup</code> sous Windows</a></h3>
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, you‚Äôll
receive a message explaining that you‚Äôll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. When asked which
workloads to install make sure ‚ÄúC++ build tools‚Äù is selected and that the
Windows 10 SDK and the English language pack components are included.
-->
<p>Sous Windows, il faut aller sur
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> et suivre les instructions
pour installer Rust. √Ä un moment donn√© durant l'installation, vous aurez un
message vous expliquant qu'il va vous falloir l'outil de compilation C++
pour Visual Studio 2013 ou plus r√©cent. La m√©thode la plus facile pour obtenir
les outils de compilation est d'installer
<a href="https://visualstudio.microsoft.com/fr/visual-cpp-build-tools/">Build Tools pour Visual Studio 2019</a>. Lorsque vous aurez √†
s√©lectionner les composants √† installer, assurez-vous que les ‚ÄúOutils de
compilation C++‚Äù sont bien s√©lectionn√©s, et que le SDK Windows 10 et les paquets
de langage Anglais sont bien inclus.</p>
<!--
[install]: https://www.rust-lang.org/tools/install
[visualstudio]: https://visualstudio.microsoft.com/visual-cpp-build-tools/

FR translation: the website redirects to French version, we lose the "id" link.
Fix is directly below:
-->
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, we‚Äôll explain which to use.
-->
<p>La suite de ce livre utilisera des commandes qui fonctionnent √† la fois dans
<em>cmd.exe</em> et PowerShell. S'il y a des diff√©rences particuli√®res, nous vous
expliquerons lesquelles utiliser.</p>
<!--
### Updating and Uninstalling
-->
<h3 id="mettre-√†-jour-et-d√©sinstaller"><a class="header" href="#mettre-√†-jour-et-d√©sinstaller">Mettre √† jour et d√©sinstaller</a></h3>
<!--
After you‚Äôve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p>Apr√®s avoir install√© Rust avec <code>rustup</code>, la mise √† jour vers la derni√®re version
est facile. Dans votre terminal, lancez le script de mise √† jour suivant¬†:</p>
<!--
```console
$ rustup update
```
-->
<pre><code class="language-console">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Pour d√©sinstaller Rust et <code>rustup</code>, ex√©cutez le script de d√©sinstallation
suivant dans votre terminal¬†:</p>
<!--
```console
$ rustup self uninstall
```
-->
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3 id="d√©pannage"><a class="header" href="#d√©pannage">D√©pannage</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Pour v√©rifier si Rust est correctement install√©, ouvrez un terminal et entrez
cette ligne¬†:</p>
<!--
```console
$ rustc --version
```
-->
<pre><code class="language-console">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>Vous devriez voir le num√©ro de version, le <em>hash</em> de <em>commit</em>,
et la date de <em>commit</em> de la derni√®re version stable qui a √©t√© publi√©e,
au format suivant¬†:</p>
<!--
```text
rustc x.y.z (abcabcabc yyyy-mm-dd)
```
-->
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you don‚Äôt
see this information and you‚Äôre on Windows, check that Rust is in your `%PATH%`
system variable. If that‚Äôs all correct and Rust still isn‚Äôt working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>Si vous voyez cette information, c'est que vous avez install√© Rust avec succ√®s¬†!
Si vous ne voyez pas cette information et que vous √™tes sous Windows, v√©rifiez
que Rust est pr√©sent dans votre variable d'environnement syst√®me <code>%PATH%</code>. Si
tout est correct et que Rust ne fonctionne toujours pas, il y a quelques
endroits o√π vous pourrez trouver de l'aide. Le plus accessible est le
canal #beginners sur le <a href="https://discord.gg/rust-lang">Discord officiel de Rust</a>. L√†-bas, vous pouvez
dialoguer en ligne avec d'autres <em>Rustac√©s</em> (un surnom ridicule que nous nous
donnons entre nous) qui pourront vous aider. D'autres bonnes sources de donn√©es
sont <a href="https://users.rust-lang.org/">le forum d'utilisateurs</a> et <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<!--
[discord]: https://discord.gg/rust-lang
[users]: https://users.rust-lang.org/
[stackoverflow]: https://stackoverflow.com/questions/tagged/rust
-->
<!--
### Local Documentation
-->
<h3 id="documentation-en-local"><a class="header" href="#documentation-en-local">Documentation en local</a></h3>
<!--
The installation of Rust also includes a copy of the documentation locally, so
you can read it offline. Run `rustup doc` to open the local documentation in
your browser.
-->
<p>L'installation de Rust embarque aussi une copie de la documentation en local
pour que vous puissiez la lire hors ligne. Lancez <code>rustup doc</code> afin d'ouvrir la
documentation locale dans votre navigateur.</p>
<!--
Any time a type or function is provided by the standard library and you‚Äôre not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>√Ä chaque fois que vous n'√™tes pas s√ªr de ce que fait un type ou une fonction
fournie par la biblioth√®que standard ou que vous ne savez pas comment
l'utiliser, utilisez cette documentation de l'interface de programmation
applicative <em>(API)</em> pour le savoir¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Hello, World!
-->
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<!--
Now that you‚Äôve installed Rust, let‚Äôs write your first Rust program. It‚Äôs
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so we‚Äôll do the same here!
-->
<p>Maintenant que vous avez install√© Rust, √©crivons notre premier programme Rust.
Lorsqu'on apprend un nouveau langage, il est de tradition d'√©crire un petit
programme qui √©crit le texte &quot;Hello, world!&quot; √† l'√©cran, donc c'est ce que nous
allons faire !</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDE‚Äôs documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>Note¬†: ce livre part du principe que vous √™tes familier avec la ligne de
commande. Rust n'impose pas d'exigences sur votre √©diteur, vos outils ou
l'endroit o√π vous mettez votre code, donc si vous pr√©f√©rez utiliser un
environnement de d√©veloppement int√©gr√© (IDE) au lieu de la ligne de commande,
vous √™tes libre d'utiliser votre IDE favori. De nombreux IDE prennent en
charge Rust √† des degr√©s divers¬†; consultez la documentation de
l'IDE pour plus d'informations. R√©cemment, l'√©quipe Rust s'est attel√©e √†
am√©liorer l'int√©gration dans les IDE et des progr√®s ont rapidement √©t√© faits
dans ce domaine !</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3 id="cr√©er-un-dossier-projet"><a class="header" href="#cr√©er-un-dossier-projet">Cr√©er un dossier projet</a></h3>
<!--
You‚Äôll start by making a directory to store your Rust code. It doesn‚Äôt matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Nous allons commencer par cr√©er un dossier pour y ranger le code Rust. L√† o√π
vous mettez votre code n'est pas important pour Rust, mais pour les exercices et
projets de ce livre, nous vous sugg√©rons de cr√©er un dossier <em>projects</em> dans
votre dossier utilisateur et de ranger tous vos projets l√†-dedans.</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the ‚ÄúHello, world!‚Äù project within the *projects* directory.
-->
<p>Ouvrez un terminal et √©crivez les commandes suivantes pour cr√©er un
dossier <em>projects</em> et un dossier pour le projet ‚ÄúHello, world!‚Äù √† l'int√©rieur
de ce dossier <em>projects</em>.</p>
<!--
For Linux, macOS, and PowerShell on Windows, enter this:
-->
<p>Sous Linux, macOS et PowerShell sous Windows, √©crivez ceci¬†:</p>
<!--
```console
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```
-->
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Avec CMD sous Windows, √©crivez ceci¬†:</p>
<!--
```cmd
> mkdir "%USERPROFILE%\projects"
> cd /d "%USERPROFILE%\projects"
> mkdir hello_world
> cd hello_world
```
-->
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3 id="√âcrire-et-ex√©cuter-un-programme-rust"><a class="header" href="#√âcrire-et-ex√©cuter-un-programme-rust">√âcrire et ex√©cuter un programme Rust</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If you‚Äôre using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>Ensuite, cr√©ez un nouveau fichier source et appelez-le <em>main.rs</em>. Les fichiers
Rust se terminent toujours par l'extension <em>.rs</em>. Si vous utilisez plusieurs
mots dans votre nom de fichier, utilisez un tiret bas (<code>_</code>) pour
les s√©parer. Par exemple, vous devriez utiliser <em>hello_world.rs</em> au lieu de
<em>helloworld.rs</em>.</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>Maintenant, ouvrez le fichier <em>main.rs</em> que vous venez de cr√©er et entrez le
code de l'encart 1-1.</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">Fichier¬†: main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">Encart 1-1¬†: Un programme qui affiche <code>Hello, world!</code>
</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>Enregistrez le fichier et retournez dans votre terminal. Sur Linux
ou macOS, √©crivez les commandes suivantes pour compiler et ex√©cuter le fichier¬†:</p>
<!--
```console
$ rustc main.rs
$ ./main
Hello, world!
```
-->
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Sur Windows, √©crivez la commande <code>.\main.exe</code> √† la place de <code>.\main</code>¬†:</p>
<!--
```powershell
> rustc main.rs
> .\main.exe
Hello, world!
```
-->
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you don‚Äôt see this output, refer back to the
[‚ÄúTroubleshooting‚Äù][troubleshooting]<!-- ignore -- > part of the Installation
section for ways to get help.
-->
<p>Peu importe votre syst√®me d'exploitation, la cha√Æne de caract√®res
<code>Hello, world!</code> devrait s'√©crire dans votre terminal. Si cela ne s'affiche pas,
r√©f√©rez-vous √† la partie <a href="ch01-01-installation.html#d%C3%A9pannage">&quot;D√©pannage&quot;</a><!-- ignore --> du
chapitre d'installation pour vous aider.</p>
<!--
If `Hello, world!` did print, congratulations! You‚Äôve officially written a Rust
program. That makes you a Rust programmer‚Äîwelcome!
-->
<p>Si <code>Hello, world!</code> s'affiche, f√©licitations ! Vous avez officiellement √©crit un
programme Rust. Cela fait de vous un d√©veloppeur Rust ‚Äî bienvenue !</p>
<!--
### Anatomy of a Rust Program
-->
<h3 id="structure-dun-programme-rust"><a class="header" href="#structure-dun-programme-rust">Structure d'un programme Rust</a></h3>
<!--
Let‚Äôs review in detail what just happened in your ‚ÄúHello, world!‚Äù program.
Here‚Äôs the first piece of the puzzle:
-->
<p>Regardons en d√©tail ce qui s'est pass√© dans votre programme ‚ÄúHello, world!‚Äù.
Voici le premier morceau du puzzle¬†:</p>
<!--
```rust
fn main() {

}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>Ces lignes d√©finissent une fonction dans Rust. La fonction <code>main</code> est sp√©ciale¬†:
c'est toujours le premier code qui est ex√©cut√© dans tous les programmes
en Rust. La premi√®re ligne d√©clare une fonction qui s'appelle <code>main</code>, qui n'a
pas de param√®tre et qui ne retourne aucune valeur. S'il y avait des param√®tres,
ils seraient plac√©s entre les parenth√®ses <code>()</code>.</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It‚Äôs good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>√Ä noter en outre que le corps de la fonction est plac√© entre des accolades
<code>{}</code>. Rust en a besoin autour du corps de chaque fonction. C'est une
bonne pratique d'ins√©rer l'accolade ouvrante sur la m√™me ligne que la
d√©claration de la fonction, en ajoutant une espace entre les deux.</p>
<!--
If you want to stick to a standard style across Rust projects, you can use an
automatic formatter tool called `rustfmt` to format your code in a particular
style. The Rust team has included this tool with the standard Rust distribution,
like `rustc`, so it should already be installed on your computer! Check the
online documentation for more details.
-->
<p>Si vous souhaitez formater le code de vos projets Rust de mani√®re standardis√©,
vous pouvez utiliser un outil de formatage automatique tel que <code>rustfmt</code>.
L'√©quipe de Rust a int√©gr√© cet outil dans la distribution standard de Rust,
comme pour <code>rustc</code> par exemple, donc il est probablement d√©j√† install√© sur votre
ordinateur¬†! Consultez la documentation en ligne pour en savoir plus.</p>
<!--
Inside the `main` function is the following code:
-->
<p>√Ä l'int√©rieur de la fonction <code>main</code>, nous avons le code suivant¬†:</p>
<!--
```rust
    println!("Hello, world!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here.
-->
<p>Cette ligne fait tout le travail dans ce petit programme¬†: il √©crit le texte √†
l'√©cran. Il y a quatre d√©tails importants √† noter ici.</p>
<!--
First, Rust style is to indent with four spaces, not a tab.
-->
<p>Premi√®rement, le style de Rust est d'indenter avec quatre espaces, et non pas
avec une tabulation.</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). We‚Äôll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a `!`
means that you‚Äôre calling a macro instead of a normal function, and that macros
don‚Äôt always follow the same rules as functions.
-->
<p>Deuxi√®mement, <code>println!</code> fait appel √† une macro Rust. S'il appelait une
fonction √† la place, cela serait √©crit <code>println</code> (sans le <code>!</code>). Nous aborderons
les macros Rust plus en d√©tail dans le chapitre 19. Pour l'instant, vous avez
juste √† savoir qu'utiliser un <code>!</code> signifie que vous utilisez une macro plut√¥t
qu'une fonction classique. Les macros ne suivent pas toujours les m√™mes r√®gles
que les fonctions.</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>Troisi√®mement, vous voyez la cha√Æne de caract√®res <code>&quot;Hello, world!&quot;</code>. Nous
envoyons cette cha√Æne en argument √† <code>println!</code> et cette cha√Æne est affich√©e
√† l'√©cran.</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>Quatri√®mement, nous terminons la ligne avec un point-virgule (<code>;</code>), qui indique
que cette expression est termin√©e et que la suivante est pr√™te √† commencer. La
plupart des lignes de Rust se terminent avec un point-virgule.</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3 id="la-compilation-et-lex√©cution-sont-des-√©tapes-s√©par√©es"><a class="header" href="#la-compilation-et-lex√©cution-sont-des-√©tapes-s√©par√©es">La compilation et l'ex√©cution sont des √©tapes s√©par√©es</a></h3>
<!--
You‚Äôve just run a newly created program, so let‚Äôs examine each step in the
process.
-->
<p>Vous venez de lancer un nouveau programme fra√Æchement cr√©√©, donc penchons-nous
sur chaque √©tape du processus.</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Avant de lancer un programme Rust, vous devez le compiler en utilisant le
compilateur Rust en entrant la commande <code>rustc</code> et en lui passant le nom de
votre fichier source, comme ceci¬†:</p>
<!--
```console
$ rustc main.rs
```
-->
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, you‚Äôll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>Si vous avez de l'exp√©rience en C ou en C++, vous observerez des similarit√©s
avec <code>gcc</code> ou <code>clang</code>.
Apr√®s avoir compil√© avec succ√®s, Rust produit un binaire ex√©cutable.</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell. On Linux and macOS, you‚Äôll see two
files. With PowerShell on Windows, you‚Äôll see the same three files that you
would see using CMD.
-->
<p>Avec Linux, macOS et PowerShell sous Windows, vous pouvez voir l'ex√©cutable en
utilisant la commande <code>ls</code> dans votre terminal. Avec Linux et macOS,
vous devriez voir deux fichiers. Avec PowerShell sous Windows, vous devriez voir
les trois m√™mes fichiers que vous verriez en utilisant CMD.</p>
<!--
```console
$ ls
main  main.rs
```
-->
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>Avec CMD sous Windows, vous devez saisir la commande suivante¬†:</p>
<!--
```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```
-->
<pre><code class="language-cmd">&gt; dir /B %= l'option /B demande √† n'afficher que les noms de fichiers =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
Windows, a file containing debugging information with the *.pdb* extension.
From here, you run the *main* or *main.exe* file, like this:
-->
<p>Ceci affiche le fichier de code source avec l'extension <em>.rs</em>, le fichier
ex√©cutable (<em>main.exe</em> sous Windows, mais <em>main</em> sur toutes les autres
plateformes) et, quand on utilise Windows, un fichier qui contient des
informations de d√©bogage avec l'extension <em>.pdb</em>. Dans ce dossier, vous pouvez
ex√©cuter le fichier <em>main</em> ou <em>main.exe</em> comme ceci¬†:</p>
<!--
```console
$ ./main # or .\main.exe on Windows
```
-->
<pre><code class="language-console">$ ./main # ou .\main.exe sous Windows
</code></pre>
<!--
If *main.rs* was your ‚ÄúHello, world!‚Äù program, this line would print `Hello,
world!` to your terminal.
-->
<p>Si <em>main.rs</em> √©tait votre programme ‚ÄúHello, world!‚Äù, cette ligne devrait afficher
<code>Hello, world!</code> dans votre terminal.</p>
<!--
If you‚Äôre more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>Si vous connaissez un langage dynamique, comme Ruby, Python, ou JavaScript, vous
n'avez peut-√™tre pas l'habitude de compiler puis lancer votre programme dans des
√©tapes s√©par√©es.
Rust est un langage √† <em>compilation anticip√©e</em>, ce qui veut dire que
vous pouvez compiler le programme et le donner √† quelqu'un d'autre, et il peut
l'ex√©cuter sans avoir Rust d'install√©. Si vous donnez √† quelqu'un un fichier
<em>.rb</em>, <em>.py</em> ou <em>.js</em>, il a besoin d'avoir respectivement un interpr√©teur Ruby,
Python, ou Javascript d'install√©. Cependant, avec ces langages, vous n'avez
besoin que d'une seule commande pour compiler et ex√©cuter votre programme.
Dans la conception d'un langage, tout est une question de compromis.</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, you‚Äôll want to manage all the options and make it easy to share your
code. Next, we‚Äôll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>Compiler avec <code>rustc</code> peut suffire pour de petits programmes, mais au fur et √†
mesure que votre programme grandit, vous allez avoir besoin de r√©gler plus
d'options et faciliter le partage de votre code. √Ä la page suivante, nous allons
d√©couvrir l'outil Cargo, qui va vous aider √† √©crire des programmes Rust √†
l'√©preuve de la r√©alit√©.</p>
<!--
[troubleshooting]: ch01-01-installation.html#troubleshooting
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Hello, Cargo!
-->
<h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rust‚Äôs build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
*dependencies*.)
-->
<p>Cargo est le syst√®me de compilation et de gestion de paquets de Rust. La plupart
des Rustac√©s utilisent cet outil pour g√©rer les projets Rust, car Cargo
s'occupe de nombreuses t√¢ches pour vous, comme compiler votre code, t√©l√©charger
les biblioth√®ques dont votre code d√©pend, et compiler ces biblioth√®ques. (On
appelle <em>d√©pendance</em> une biblioth√®que n√©cessaire pour votre code.)</p>
<!--
The simplest Rust programs, like the one we‚Äôve written so far, don‚Äôt have any
dependencies. So if we had built the ‚ÄúHello, world!‚Äù project with Cargo, it
would only use the part of Cargo that handles building your code. As you write
more complex Rust programs, you‚Äôll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>Des programmes Rust tr√®s simples, comme le petit que nous avons √©crit pr√©c√©demment,
n'ont pas de d√©pendance. Donc si nous avions compil√© le projet ‚ÄúHello, world!‚Äù
avec Cargo, cela n'aurait fait appel qu'√† la fonctionnalit√© de Cargo qui
s'occupe de la compilation de votre code. Quand vous √©crirez des programmes Rust
plus complexes, vous ajouterez des d√©pendances, et si vous cr√©ez un projet en
utilisant Cargo, l'ajout des d√©pendances sera plus facile √† faire.</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you‚Äôre using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[‚ÄúInstallation‚Äù][installation]<!-- ignore -- > section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Comme la large majorit√© des projets Rust utilisent Cargo, la suite de ce livre
va supposer que vous utilisez aussi Cargo. Cargo s'installe avec Rust si vous
avez utilis√© l'installateur officiel pr√©sent√© dans la section
<a href="ch01-01-installation.html#installation">‚ÄúInstallation‚Äù</a><!-- ignore -->. Si vous avez install√© Rust
autrement, v√©rifiez que Cargo est install√© en utilisant la commande suivante
dans votre terminal¬†:</p>
<!--
```console
$ cargo --version
```
-->
<pre><code class="language-console">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>Si vous voyez un num√©ro de version, c'est qu'il est install√©¬†! Si vous voyez une
erreur comme <code>Commande non trouv√©e</code> (ou <code>command not found</code>), alors consultez la
documentation de votre m√©thode d'installation pour savoir comment installer
s√©par√©ment Cargo.</p>
<!--
### Creating a Project with Cargo
-->
<h3 id="cr√©er-un-projet-avec-cargo"><a class="header" href="#cr√©er-un-projet-avec-cargo">Cr√©er un projet avec Cargo</a></h3>
<!--
Let‚Äôs create a new project using Cargo and look at how it differs from our
original ‚ÄúHello, world!‚Äù project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>Cr√©ons un nouveau projet en utilisant Cargo et analysons les diff√©rences avec
notre projet initial ‚ÄúHello, world!‚Äù. Retournez dans votre dossier <em>projects</em>
(ou l√† o√π vous avez d√©cid√© d'enregistrer votre code). Ensuite, sur n'importe
quel syst√®me d'exploitation, lancez les commandes suivantes¬†:</p>
<!--
```console
$ cargo new hello_cargo
$ cd hello_cargo
```
-->
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command created a new directory called *hello_cargo*. We‚Äôve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>La premi√®re commande a cr√©e un nouveau dossier appel√© <em>hello_cargo</em>. Nous avons
appel√© notre projet <em>hello_cargo</em>, et Cargo cr√©e ses fichiers dans un dossier
avec le m√™me nom.</p>
<!--
Go into the *hello_cargo* directory and list the files. You‚Äôll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside.
-->
<p>Rendez-vous dans le dossier <em>hello_cargo</em> et afficher la liste des fichiers.
Vous constaterez que Cargo a g√©n√©r√© deux fichiers et un dossier pour nous¬†: un
fichier <em>Cargo.toml</em> et un dossier <em>src</em> avec un fichier <em>main.rs</em> √†
l'int√©rieur.</p>
<!--
It has also initialized a new Git repository along with a *.gitignore* file.
Git files won‚Äôt be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.
-->
<p>Il a aussi cr√©√© un nouveau d√©p√¥t Git ainsi qu'un fichier <em>.gitignore</em>. Les
fichiers de Git ne seront pas g√©n√©r√©s si vous lancez <code>cargo new</code> au sein d'un
d√©p√¥t Git¬†; vous pouvez d√©sactiver ce comportement temporairement en utilisant
<code>cargo new --vcs=git</code>.</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>Note¬†: Git est un syst√®me de gestion de versions tr√®s r√©pandu. Vous pouvez
changer <code>cargo new</code> pour utiliser un autre syst√®me de gestion de versions
ou ne pas en utiliser du tout en √©crivant le drapeau <code>--vcs</code>.
Lancez <code>cargo new --help</code> pour en savoir plus sur les options disponibles.</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>Ouvrez <em>Cargo.toml</em> dans votre √©diteur de texte favori. Son contenu devrait
√™tre similaire au code dans l'encart 1-2.</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">Encart 1-2¬†: Contenu de <em>Cargo.toml</em> g√©n√©r√© par <code>cargo new</code></span></p>
<!--
This file is in the [*TOML*](https://toml.io)<!-- ignore -- > (*Tom‚Äôs Obvious,
Minimal Language*) format, which is Cargo‚Äôs configuration format.
-->
<p>Ce fichier est au format <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom‚Äôs
Obvious, Minimal Language</em>), qui est le format de configuration de Cargo.</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we‚Äôll add other sections.
-->
<p>La premi√®re ligne, <code>[package]</code>, est un en-t√™te de section qui indique que les
instructions suivantes configurent un paquet. Au fur et √† mesure que nous
ajouterons plus de d√©tails √† ce fichier, nous ajouterons des sections
suppl√©mentaires.</p>
<!--
The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We‚Äôll talk
about the `edition` key in [Appendix E][appendix-e]<!-- ignore -- >.
-->
<p>Les trois lignes suivantes d√©finissent les informations de configuration dont
Cargo a besoin pour compiler votre programme¬†: le nom, la version, et l'√©dition
de Rust √† utiliser. Nous aborderons la cl√© <code>edition</code> dans
l'<a href="appendix-05-editions.html">Annexe E</a><!-- ignore -->.</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project‚Äôs dependencies. In Rust, packages of code are referred to as
*crates*. We won‚Äôt need any other crates for this project, but we will in the
first project in Chapter 2, so we‚Äôll use this dependencies section then.
-->
<p>La derni√®re ligne, <code>[dependencies]</code>, est le d√©but d'une section qui vous permet
de lister les d√©pendances de votre projet. Dans Rust, les paquets de code sont
d√©sign√©s sous le nom de <em>crates</em>. Nous n'allons pas utiliser de <em>crate</em> pour ce
projet, mais nous le ferons pour le premier projet au chapitre 2¬†; nous
utiliserons alors cette section √† ce moment-l√†.</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>Maintenant, ouvrez <em>src/main.rs</em> et jetez-y un coup d'≈ìil¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a ‚ÄúHello, world!‚Äù program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our previous project and
the project Cargo generated are that Cargo placed the code in the *src*
directory, and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargo a g√©n√©r√© un programme ‚ÄúHello, world!‚Äù pour vous, exactement comme celui
que nous avons √©crit dans l'encart 1-1¬†! Pour le moment, les seules diff√©rences
entre notre projet pr√©c√©dent et le projet que Cargo a g√©n√©r√© sont que Cargo a
plac√© le code dans le dossier <em>src</em>, et que nous avons un fichier de
configuration <em>Cargo.toml</em> √† la racine du dossier projet.</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There‚Äôs a place for everything, and
everything is in its place.
-->
<p>Cargo pr√©voit de stocker vos fichiers sources dans le dossier <em>src</em>. Le dossier
parent est l√† uniquement pour les fichiers README, pour les informations √†
propos de la licence, pour les fichiers de configuration et tout ce qui n'est
pas directement reli√© √† votre code. Utiliser Cargo vous aide √† structurer vos
projets. Il y a un endroit pour tout, et tout est √† sa place.</p>
<!--
If you started a project that doesn‚Äôt use Cargo, as we did with the ‚ÄúHello,
world!‚Äù project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>Si vous commencez un projet sans utiliser Cargo, comme nous l'avons fait avec
le projet ‚ÄúHello, world!‚Äù, vous pouvez le transformer en projet qui
utilise Cargo. D√©placez le code de votre projet dans un dossier <em>src</em> et cr√©ez
un fichier <em>Cargo.toml</em> ad√©quat.</p>
<!--
### Building and Running a Cargo Project
-->
<h3 id="compiler-et-ex√©cuter-un-projet-cargo"><a class="header" href="#compiler-et-ex√©cuter-un-projet-cargo">Compiler et ex√©cuter un projet Cargo</a></h3>
<!--
Now let‚Äôs look at what‚Äôs different when we build and run the ‚ÄúHello, world!‚Äù
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>Maintenant, regardons ce qu'il y a de diff√©rent quand nous compilons et
ex√©cutons le programme ‚ÄúHello, world!‚Äù avec Cargo¬†! √Ä l'int√©rieur de votre
dossier <em>hello_cargo</em>, compilez votre projet en utilisant la commande suivante¬†:</p>
<!--
```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```
-->
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>Cette commande cr√©e un fichier ex√©cutable dans <em>target/debug/hello_cargo</em> (ou
<em>target\debug\hello_cargo.exe</em> sous Windows) plut√¥t que de le d√©poser dans votre
dossier courant. Vous pouvez lancer l'ex√©cutable avec cette commande¬†:</p>
<!--
```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
<pre><code class="language-console">$ ./target/debug/hello_cargo # ou .\target\debug\hello_cargo.exe sous Windows
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn‚Äôt have dependencies, so the
file is a bit sparse. You won‚Äôt ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>Si tout s'est bien pass√©, <code>Hello, world!</code> devrait s'afficher dans le terminal.
Lancer <code>cargo build</code> pour la premi√®re fois devrait aussi mener Cargo √† cr√©er
un nouveau fichier √† la racine du dossier projet¬†: <em>Cargo.lock</em>. Ce fichier
garde une trace des versions exactes des d√©pendances de votre
projet. Ce projet n'a pas de d√©pendance, donc le fichier est un peu vide. Vous
n'aurez jamais besoin de changer ce fichier manuellement¬†; Cargo va g√©rer son
contenu pour vous.</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>Nous venons de compiler un projet avec <code>cargo build</code> avant de l'ex√©cuter avec
<code>./target/debug/hello_cargo</code>, mais nous pouvons aussi utiliser <code>cargo run</code> pour
compiler le code et ensuite lancer l'ex√©cutable dans une seule et m√™me
commande¬†:</p>
<!--
```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didn‚Äôt see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn‚Äôt changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>Notez que cette fois-ci, nous ne voyons pas de messages indiquant que Cargo a
compil√© <code>hello_cargo</code>. Cargo a d√©tect√© que les fichiers n'avaient pas chang√©,
donc il a juste ex√©cut√© le binaire. Si vous aviez modifi√© votre code source,
Cargo aurait recompil√© le projet avant de le lancer, et vous auriez eu les
messages suivants¬†:</p>
<!--
```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn‚Äôt produce an executable:
-->
<p>Cargo fournit aussi une commande appel√©e <code>cargo check</code>. Elle v√©rifie rapidement
votre code pour s'assurer qu'il est compilable, mais ne produit pas
d'ex√©cutable¬†:</p>
<!--
```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```
-->
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you‚Äôre
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they‚Äôre ready to use the executable.
-->
<p>Dans quel cas n'aurions-nous pas besoin d'un ex√©cutable ? Parfois, <code>cargo check</code>
est bien plus rapide que <code>cargo build</code>, car il saute l'√©tape de cr√©ation de
l'ex√©cutable. Si vous v√©rifiez votre travail continuellement pendant que vous
√©crivez votre code, utiliser <code>cargo check</code> acc√©l√®rera le processus¬†! C'est
pourquoi de nombreux Rustac√©s utilisent p√©riodiquement <code>cargo check</code> quand ils
√©crivent leur programme afin de s'assurer qu'il compile. Ensuite, ils lancent
<code>cargo build</code> quand ils sont pr√™ts √† utiliser l'ex√©cutable.</p>
<!--
Let‚Äôs recap what we‚Äôve learned so far about Cargo:
-->
<p>R√©capitulons ce que nous avons appris sur Cargo¬†:</p>
<!--
* We can create a project using `cargo new`.
* We can build a project using `cargo build`.
* We can build and run a project in one step using `cargo run`.
* We can build a project without producing a binary to check for errors using
  `cargo check`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<ul>
<li>Nous pouvons cr√©er un projet en utilisant <code>cargo new</code>.</li>
<li>Nous pouvons compiler un projet en utilisant <code>cargo build</code>.</li>
<li>Nous pouvons compiler puis ex√©cuter un projet en une seule fois en utilisant
<code>cargo run</code>.</li>
<li>Nous pouvons compiler un projet sans produire de binaire afin de v√©rifier
l'existance d'erreurs en utilisant <code>cargo check</code>.</li>
<li>Au lieu d'enregistrer le r√©sultat de la compilation dans le m√™me dossier que
votre code, Cargo l'enregistre dans le dossier <em>target/debug</em>.</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you‚Äôre working on. So, at this point, we‚Äôll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Un autre avantage d'utiliser Cargo est que les commandes sont les m√™mes peu
importe le syst√®me d'exploitation que vous utilisez.
Donc √† partir de maintenant, nous n'allons plus faire d'op√©rations sp√©cifiques
√† Linux et macOS par rapport √† Windows.</p>
<!--
### Building for Release
-->
<h3 id="compiler-pour-diffuser"><a class="header" href="#compiler-pour-diffuser">Compiler pour diffuser</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you‚Äôll give to a user that won‚Äôt be rebuilt
repeatedly and that will run as fast as possible. If you‚Äôre benchmarking your
code‚Äôs running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>Quand votre projet est finalement pr√™t √† √™tre diffus√©, vous pouvez utiliser
<code>cargo build --release</code> pour le compiler en l'optimisant. Cette commande va
cr√©er un ex√©cutable dans <em>target/release</em> au lieu de <em>target/debug</em>. Ces
optimisations rendent votre code Rust plus rapide √† ex√©cuter, mais l'utiliser
rallonge le temps de compilation de votre programme. C'est pourquoi il y a deux
diff√©rents profils¬†: un pour le d√©veloppement, quand vous voulez recompiler
rapidement et souvent, et un autre pour compiler le programme final qui sera
livr√© √† un utilisateur, qui n'aura pas besoin d'√™tre recompil√© √† plusieurs
reprises et qui s'ex√©cutera aussi vite que possible. Si vous √©valuez le temps
d'ex√©cution de votre code, assurez-vous de lancer <code>cargo build --release</code> et
d'utiliser l'ex√©cutable dans <em>target/release</em> pour vos bancs de test.</p>
<!--
### Cargo as Convention
-->
<h3 id="cargo-comme-convention"><a class="header" href="#cargo-comme-convention">Cargo comme convention</a></h3>
<!--
With simple projects, Cargo doesn‚Äôt provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it‚Äôs much easier to let
Cargo coordinate the build.
-->
<p>Pour des projets simples, Cargo n'apporte pas grand-chose par rapport √† <code>rustc</code>,
mais il vous montrera son int√©r√™t au fur et √† mesure
que vos programmes deviendront plus complexes. Avec des projets complexes
compos√©s de plusieurs <em>crates</em>, il est plus facile de laisser Cargo prendre en
charge la coordination de la compilation.</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you‚Äôll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project‚Äôs directory, and build:
-->
<p>M√™me si le projet <code>hello_cargo</code> est simple, il utilise maintenant une grande
partie de l'outillage que vous rencontrerez dans votre carri√®re avec Rust. En
effet, pour travailler sur n'importe quel projet Rust existant, vous n'avez
qu'√† saisir les commandes suivantes pour t√©l√©charger le code avec Git, vous
d√©placer dans le dossier projet et compiler¬†:</p>
<!--
```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```
-->
<pre><code class="language-console">$ git clone example.org/projet_quelconque
$ cd projet_quelconque
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].
-->
<p>Pour plus d'informations √† propos de Cargo, vous pouvez consulter <a href="https://doc.rust-lang.org/cargo/">sa
documentation</a>.</p>
<!--
[its documentation]: https://doc.rust-lang.org/cargo/
-->
<!--
## Summary
-->
<h2 id="r√©sum√©"><a class="header" href="#r√©sum√©">R√©sum√©</a></h2>
<!--
You‚Äôre already off to a great start on your Rust journey! In this chapter,
you‚Äôve learned how to:
-->
<p>Vous √™tes d√©j√† bien lanc√© dans votre p√©riple avec Rust ! Dans ce chapitre, vous
avez appris comment¬†:</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a ‚ÄúHello, world!‚Äù program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li>Installer la derni√®re version stable de Rust en utilisant <code>rustup</code></li>
<li>Mettre √† jour Rust vers une nouvelle version</li>
<li>Ouvrir la documentation install√©e en local</li>
<li>√âcrire et ex√©cuter un programme ‚ÄúHello, world!‚Äù en utilisant directement
<code>rustc</code></li>
<li>Cr√©er et ex√©cuter un nouveau projet en utilisant les conventions de Cargo</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we‚Äôll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>C'est le moment id√©al pour construire un programme plus ambitieux pour
s'habituer √† lire et √©crire du code Rust. Donc, au chapitre 2, nous allons
√©crire un programme de <em>jeu de devinettes</em>.
Si vous pr√©f√©rez commencer par apprendre comment les principes de programmation
de base fonctionnent avec Rust, rendez-vous au chapitre 3, puis revenez au
chapitre 2.</p>
<!--
[installation]: ch01-01-installation.html#installation
[appendix-e]: appendix-05-editions.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Programming a Guessing Game
-->
<h1 id="programmer-le-jeu-du-plus-ou-du-moins"><a class="header" href="#programmer-le-jeu-du-plus-ou-du-moins">Programmer le jeu du plus ou du moins</a></h1>
<!--
Let‚Äôs jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You‚Äôll learn about `let`, `match`, methods, associated
functions, using external crates, and more! In the following chapters, we‚Äôll
explore these ideas in more detail. In this chapter, you‚Äôll practice the
fundamentals.
-->
<p>Entrons dans le vif du sujet en travaillant ensemble sur un projet concret¬†!
Ce chapitre pr√©sente quelques concepts couramment utilis√©s en Rust en vous
montrant comment les utiliser dans un v√©ritable programme. Nous aborderons
notamment les instructions <code>let</code> et <code>match</code>, les m√©thodes et fonctions
associ√©es, l'utilisation des <em>crates</em>, et bien plus encore¬†! Dans les chapitres
suivants, nous approfondirons ces notions. Dans ce chapitre, vous n'allez
exercer que les principes de base.</p>
<!--
We‚Äôll implement a classic beginner programming problem: a guessing game. Here‚Äôs
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>Nous allons coder un programme fr√©quemment r√©alis√© par les d√©butants en
programmation¬†: <em>le jeu du plus ou du moins</em>. Le principe de ce jeu est le
suivant¬†: le programme va tirer au sort un nombre entre 1 et 100. Il invitera
ensuite le joueur √† saisir un nombre qu'il pense deviner. Apr√®s la saisie, le
programme indiquera si le nombre saisi par le joueur est trop grand ou trop
petit. Si le nombre saisi est le bon, le jeu affichera un message de
f√©licitations et se fermera.</p>
<!--
## Setting Up a New Project
-->
<h2 id="mise-en-place-dun-nouveau-projet"><a class="header" href="#mise-en-place-dun-nouveau-projet">Mise en place d'un nouveau projet</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>Pour cr√©er un nouveau projet, rendez-vous dans le dossier <em>projects</em> que
vous avez cr√©√© au chapitre 1 et utilisez Cargo pour cr√©er votre projet, comme
ceci¬†:</p>
<!--
```console
$ cargo new guessing_game
$ cd guessing_game
```
-->
<pre><code class="language-console">$ cargo new jeu_du_plus_ou_du_moins
$ cd jeu_du_plus_ou_du_moins
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The second command changes to the new project‚Äôs
directory.
-->
<p>La premi√®re commande, <code>cargo new</code>, prend comme premier argument le nom de notre
projet (<code>jeu_du_plus_ou_du_moins</code>). La seconde commande nous d√©place dans le
dossier de notre nouveau projet cr√©√© par Cargo.</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>Regardons le fichier <em>Cargo.toml</em> qui a √©t√© g√©n√©r√©¬†:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<!--
As you saw in Chapter 1, `cargo new` generates a ‚ÄúHello, world!‚Äù program for
you. Check out the *src/main.rs* file:
-->
<p>Comme vous l'avez exp√©riment√© dans le chapitre 1, <code>cargo new</code> g√©n√®re un
programme <em>‚ÄúHello, world!‚Äù</em> pour vous. Ouvrez le fichier <em>src/main.rs</em>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now let‚Äôs compile this ‚ÄúHello, world!‚Äù program and run it in the same step
using the `cargo run` command:
-->
<p>Maintenant, lan√ßons la compilation de ce programme ‚ÄúHello, world!‚Äù et
son ex√©cution en une seule commande avec <code>cargo run</code>¬†:</p>
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as we‚Äôll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p>Cette commande <code>run</code> est tr√®s pratique lorsqu'on souhaite it√©rer rapidement
sur un projet, comme c'est le cas ici, pour tester rapidement chaque
modification avant de passer √† la suivante.</p>
<!--
Reopen the *src/main.rs* file. You‚Äôll be writing all the code in this file.
-->
<p>Ouvrez √† nouveau le fichier <em>src/main.rs</em>. C'est dans ce fichier que nous
√©crirons la totalit√© de notre code.</p>
<!--
## Processing a Guess
-->
<h2 id="traitement-dun-nombre-saisi"><a class="header" href="#traitement-dun-nombre-saisi">Traitement d'un nombre saisi</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we‚Äôll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*.
-->
<p>La premi√®re partie du programme consiste √† demander au joueur de saisir du
texte, √† traiter cette saisie, et √† v√©rifier que la saisie correspond au format
attendu.
Commen√ßons par permettre au joueur de saisir son nombre. Entrez le
code de l'encart 2-1 dans le fichier <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Devinez le nombre¬†!&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span>
-->
<p><span class="caption">Encart 2-1¬†: Code permettant de r√©cup√©rer une saisie
utilisateur et de l'afficher</span></p>
<!--
This code contains a lot of information, so let‚Äôs go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` input/output library into scope. The `io` library comes from the
standard library, known as `std`:
-->
<p>Ce code contient beaucoup d'informations, nous allons donc l'analyser petit
√† petit. Pour obtenir la saisie utilisateur et ensuite l'afficher, nous avons
besoin d'importer la biblioth√®que d'entr√©e/sortie <code>io</code> (initiales
de <em>input/output</em>) afin de pouvoir l'utiliser. La biblioth√®que <code>io</code> provient de
la biblioth√®que standard, connue sous le nom de <code>std</code>¬†:</p>
<!--
```rust,ignore
use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
By default, Rust has a few items defined in the standard library that it brings
into the scope of every program. This set is called the *prelude*, and you can
see everything in it [in the standard library documentation][prelude].
-->
<p>Par d√©faut, Rust importe dans la port√©e de tous les programmes quelques
fonctionnalit√©s d√©finies dans la biblioth√®que standard. Cela s'appelle <em>l'√©tape
pr√©liminaire (the prelude)</em>, et vous pouvez en savoir plus dans sa
<a href="https://doc.rust-lang.org/std/prelude/index.html">documentation de la biblioth√®que standard</a><!-- ignore -->.</p>
<!--
If a type you want to use isn‚Äôt in the prelude, you have to bring that type
into scope explicitly with a `use` statement. Using the `std::io` library
provides you with a number of useful features, including the ability to accept
user input.
-->
<p>Si vous
voulez utiliser un type qui ne s'y trouve pas, vous devrez l'importer
explicitement avec l'instruction <code>use</code>. L'utilisation de la biblioth√®que
<code>std::io</code> vous apporte de nombreuses fonctionnalit√©s utiles, comme ici la
possibilit√© de r√©cup√©rer une saisie utilisateur.</p>
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>Comme vous l'avez vu au chapitre 1, la fonction <code>main</code> est le point d'entr√©e
du programme¬†:</p>
<!--
```rust,ignore
# use std::io;
# 
fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`, indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p>Le mot cl√© <code>fn</code> d√©clare une nouvelle fonction, les parenth√®ses <code>()</code> indiquent
que cette fonction n'accepte aucun param√®tre, et l'accolade ouvrante <code>{</code> marque
le d√©but du corps de la fonction.</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>Comme vous l'avez √©galement appris au chapitre 1, <code>println!</code> est une macro qui
affiche une cha√Æne de caract√®res √† l'√©cran¬†:</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Devinez le nombre¬†!&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);
<span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
This code is printing a prompt stating what the game is and requesting input
from the user.
-->
<p>Ce code affiche du texte qui indique le titre de notre jeu, et un autre qui
demande au joueur d'entrer un nombre.</p>
<!--
### Storing Values with Variables
-->
<h3 id="enregistrer-des-donn√©es-dans-des-variables"><a class="header" href="#enregistrer-des-donn√©es-dans-des-variables">Enregistrer des donn√©es dans des variables</a></h3>
<!--
Next, we‚Äôll create a *variable* to store the user input, like this:
-->
<p>Ensuite, on cr√©e une <em>variable</em> pour stocker la saisie de l'utilisateur, comme
ceci¬†:</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
    let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span>    let mut supposition = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
Now the program is getting interesting! There‚Äôs a lot going on in this little
line. We use the `let` statement to create the variable. Here‚Äôs another example:
-->
<p>Le programme commence √† devenir int√©ressant¬†! Il se passe beaucoup de choses
dans cette petite ligne. Nous utilisons l'instruction <code>let</code> pour cr√©er la
variable. Voici un autre exemple¬†:</p>
<!--
```rust,ignore
let apples = 5;
```
-->
<pre><code class="language-rust ignore">let pommes = 5;
</code></pre>
<!--
This line creates a new variable named `apples` and binds it to the value 5. In
Rust, variables are immutable by default. We‚Äôll be discussing this concept in
detail in the [‚ÄúVariables and Mutability‚Äù][variables-and-mutability]<!-- ignore
-- > section in Chapter 3. To make a variable mutable, we add `mut` before the
variable name:
-->
<p>Cette ligne permet de cr√©er une nouvelle variable nomm√©e <code>pommmes</code> et √† lui
assigner la valeur 5. Par d√©faut en Rust, les variables sont immuables.
Nous aborderons plus en d√©tail cette notion dans la section <a href="ch03-01-variables-and-mutability.html">‚ÄúVariables et
Mutabilit√©‚Äù</a><!-- ignore --> au chapitre 3. Pour
rendre une variable mutable <em>(c'est-√†-dire modifiable)</em>, nous ajoutons <code>mut</code>
devant le nom de la variable¬†:</p>
<!--
```rust,ignore
let apples = 5; // immutable
let mut bananas = 5; // mutable
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pommes = 5; // immuable
let mut bananes = 5; // mutable, modifiable
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments. We‚Äôll discuss comments in more
> detail in [Chapter 3][comments]<!-- ignore -- >.
-->
<blockquote>
<p>Remarque¬†: La syntaxe <code>//</code> permet de commencer un commentaire qui s'√©tend
jusqu'√† la fin de la ligne. Rust ignore tout ce qu'il y a dans un
commentaire. Nous verrons plus en d√©tail les commentaires dans le
<a href="ch03-04-comments.html">chapitre 3</a><!-- ignore -->.</p>
</blockquote>
<!--
Returning to the guessing game program, you now know that `let mut guess` will
introduce a mutable variable named `guess`. The equal sign (`=`) tells Rust we
want to bind something to the variable now. On the right of the equals sign is
the value that `guess` is bound to, which is the result of calling
`String::new`, a function that returns a new instance of a `String`.
[`String`][string]<!-- ignore -- > is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>Lorsque vous revenez sur le jeu du plus ou du moins, vous comprenez donc
maintenant que la ligne <code>let mut supposition</code> permet de cr√©er une variable
mutable nomm√©e <code>supposition</code>. Le signe √©gal (<code>=</code>) indique √† Rust que nous
voulons d√©sormais lier quelquechose √† la variable. A la droite du signe √©gal,
nous avons la valeur li√©e √† <code>supposition</code>, qui est ici le r√©sultat de
l'utilisation de <code>String::new</code>, qui est une fonction qui retourne une nouvelle
instance de <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> est un type de cha√Æne de caract√®res fourni
par la biblioth√®que standard, qui est une portion de texte encod√©e en UTF-8 et
dont la longueur peut augmenter.</p>
<!--
The `::` syntax in the `::new` line indicates that `new` is an associated
function of the `String` type. An *associated function* is a function that‚Äôs
implemented on a type, in this case `String`. This `new` function creates a
new, empty string. You‚Äôll find a `new` function on many types, because it‚Äôs a
common name for a function that makes a new value of some kind.
-->
<p>La syntaxe <code>::</code> dans <code>String::new()</code> indique que <code>new</code> est une fonction
associ√©e au type <code>String</code>. Une <em>fonction associ√©e</em> est une fonction qui est
impl√©ment√©e sur un type, ici <code>String</code>. Cette fonction <code>new</code> cr√©e une nouvelle
cha√Æne de caract√®res vide, une nouvelle <code>String</code>. Vous trouverez fr√©quemment
une fonction <code>new</code> sur d'autres types, car c'est un nom souvent donn√© √† une
fonction qui cr√©e une nouvelle valeur ou instance d'un type.</p>
<!--
In full, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>En d√©finitif, la ligne <code>let mut supposition = String::new();</code> cr√©e une nouvelle
variable mutable qui contient une nouvelle cha√Æne de caract√®res vide, une
instance de <code>String</code>. Ouf¬†!</p>
<!--
### Receiving User Input
-->
<h3 id="recueillir-la-saisie-utilisateur"><a class="header" href="#recueillir-la-saisie-utilisateur">Recueillir la saisie utilisateur</a></h3>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now we‚Äôll call
the `stdin` function from the `io` module, which will allow us to handle user
input:
-->
<p>Rappelez-vous que nous avons import√© les fonctionnalit√©s d'entr√©e/sortie de la
biblioth√®que standard avec <code>use std::io;</code> √† la premi√®re ligne de notre
programme. Nous allons maintenant appeler la fonction <code>stdin</code> du module <code>io</code>,
qui va nous permettre de traiter la saisie utilisateur¬†:</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
    io::stdin()
        .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut supposition)
<span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
If we hadn‚Äôt imported the `io` library with `use std::io` at the beginning of
the program, we could still use the function by writing this function call as
`std::io::stdin`. The `stdin` function returns an instance of
[`std::io::Stdin`][iostdin]<!-- ignore -- >, which is a type that represents a
handle to the standard input for your terminal.
-->
<p>Si nous n'avions pas import√© la biblioth√®que <code>io</code> avec <code>use std::io</code> au d√©but
du programme, on aurait toujours pu utiliser la fonction en √©crivant l'appel √†
la fonction de cette mani√®re¬†: <code>std::io::stdin</code>. La fonction <code>stdin</code> retourne
une instance de <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, qui est un type qui
repr√©sente une r√©f√©rence abstraite <em>(handle)</em> vers l'entr√©e standard du
terminal dans lequel vous avez lanc√© le programme.</p>
<!--
Next, the line `.read_line(&mut guess)` calls the [`read_line`][read_line]<!--
ignore -- > method on the standard input handle to get input from the user.
We‚Äôre also passing `&mut guess` as the argument to `read_line` to tell it what
string to store the user input in. The full job of `read_line` is to take
whatever the user types into standard input and append that into a string
(without overwriting its contents), so we therefore pass that string as an
argument. The string argument needs to be mutable so the method can change the
string‚Äôs content.
-->
<p>Ensuite, la ligne <code>.read_line(&amp;mut supposition)</code> appelle la m√©thode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> sur l'entr√©e standard afin d'obtenir
la saisie utilisateur.
Nous passons aussi <code>&amp;mut supposition</code> en argument de <code>read_line</code> pour lui
indiquer dans quelle cha√Æne de caract√®re il faut stocker la saisie utilisateur.
Le but final de <code>read_line</code> est de r√©cup√©rer tout ce que l'utilisateur √©crit
dans l'entr√©e standard et de l'ajouter √† la fin d'une cha√Æne de caract√®res
(sans √©craser son contenu)¬†; c'est pourquoi nous passons cette cha√Æne de
caract√®res en argument. Cet argument doit √™tre mutable pour que <code>read_line</code>
puisse en modifier le contenu.</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust‚Äôs major advantages is how safe and easy it is to use
references. You don‚Äôt need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p>Le <code>&amp;</code> indique que cet argument est une <em>r√©f√©rence</em>, ce qui permet de laisser
plusieurs morceaux de votre code acc√©der √† une m√™me donn√©e sans avoir besoin
de copier ces donn√©es dans la m√©moire plusieurs fois. Les r√©f√©rences sont une
fonctionnalit√© complexe, et un des avantages majeurs de Rust est qu'il rend s√ªr
et simple l'utilisation des r√©f√©rences. Il n'est pas n√©cessaire de trop
s'apesantir sur les r√©f√©rences pour terminer ce programme.
Pour l'instant, tout ce que vous devez savoir est que comme les variables, les
r√©f√©rences sont immuables par d√©faut.
D'o√π la n√©cessit√© d'√©crire <code>&amp;mut supposition</code> au lieu de <code>&amp;supposition</code> pour la
rendre mutable. (Le chapitre 4 expliquera plus en d√©tail les r√©f√©rences.)</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3 id="g√©rer-les-erreurs-potentielles-avec-le-type-result"><a class="header" href="#g√©rer-les-erreurs-potentielles-avec-le-type-result">G√©rer les erreurs potentielles avec le type <code>Result</code></a></h3>
<!--
We‚Äôre still working on this line of code. Although we‚Äôre now discussing a third
line of text, it‚Äôs still part of a single logical line of code. The next part
is this method:
-->
<p>Nous avons encore du travail sur cette ligne de code. M√™me si nous allons
rajouter une troisi√®me ligne de code, elle ne fait partie que d'une seule ligne
de code. Cette nouvelle partie rajoute cette m√©thode¬†:</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
        .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span>        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
We could have written this code as:
-->
<p>Nous aurions pu √©crire ce code de cette mani√®re¬†:</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition).expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so it‚Äôs best to divide it. It‚Äôs
often wise to introduce a newline and other whitespace to help break up long
lines when you call a method with the `.method_name()` syntax. Now let‚Äôs
discuss what this line does.
-->
<p>Cependant, une longue ligne de code n'est pas toujours facile √† lire, c'est donc
une bonne pratique de la diviser. Il est parfois utile d'ajouter une nouvelle
ligne et des espaces afin de d√©sagr√©ger les longues lignes lorsque vous
appelerez une m√©thode, comme ici avec la syntaxe <code>.nom_de_la_methode()</code>.
Maintenant, voyons √† quoi sert cette ligne.</p>
<!--
As mentioned earlier, `read_line` puts whatever the user enters into the string
we pass to it, but it also returns a value‚Äîin this case, an
[`io::Result`][ioresult]<!-- ignore -- >. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result]<!-- ignore -- >
as well as specific versions for submodules, such as `io::Result`. The `Result`
types are [*enumerations*][enums]<!-- ignore -- >, often referred to as *enums*,
which can have a fixed set of possibilities known as *variants*. Enums are
often used with `match`, a conditional that makes it convenient to execute
different code based on which variant an enum value is when the conditional is
evaluated.
-->
<p>Comme expliqu√© pr√©c√©demment, <code>read_line</code> stocke dans la variable qu'on lui
passe en argument tout ce que l'utilisateur a saisi, mais cette fonction
retourne aussi une valeur ‚àí dans notre cas, de type
<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Il existe plusieurs types nomm√©s
<code>Result</code> dans la biblioth√®que standard de Rust¬†: un type g√©n√©rique
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> ainsi que des d√©clinaisons sp√©cifiques √†
des sous-modules, comme <code>io::Result</code>. Les types <code>Result</code> sont des
<a href="ch06-00-enums.html"><em>√©num√©rations</em></a><!-- ignore -->, aussi appel√©es <em>enums</em>, qui peuvent
avoir un certain nombre de valeurs pr√©d√©finies que l'on appelle <em>variantes</em>.
Les √©num√©rations sont souvent utilis√©es avec <code>match</code>, une structure
conditionelle qui facilite l'ex√©cution d'un code diff√©rent en fonction de la
variante dans l'√©num√©ration au moment de son √©valuation.</p>
<!--
Chapter 6 will cover enums in more detail. The purpose of these `Result` types
is to encode error-handling information.
-->
<p>Le chapitre 6 explorera les √©num√©rations plus en d√©tail. La raison d'√™tre du
type <code>Result</code> est de coder des informations pour la gestion des erreurs.</p>
<!--
`Result`‚Äôs variants are `Ok` and `Err`. The `Ok` variant indicates the operation
was successful, and inside `Ok` is the successfully generated value. The `Err`
variant means the operation failed, and `Err` contains information about how or
why the operation failed.
-->
<p>Les variantes de <code>Result</code> sont <code>Ok</code> et <code>Err</code>. La variante <code>Ok</code> signifie que
l'op√©ration a fonctionn√©, et √† l'int√©rieur de <code>Ok</code> se trouve la valeur g√©n√©r√©e
avec succ√®s. La variante <code>Err</code> signifie que l'op√©ration a √©chou√©, et <code>Err</code>
contient les informations d√©crivant comment ou pourquoi l'op√©ration a √©chou√©.</p>
<!--
Values of the `Result` type, like values of any type, have methods defined on
them. An instance of `io::Result` has an [`expect` method][expect]<!-- ignore
-- > that you can call. If this instance of `io::Result` is an `Err` value,
`expect` will cause the program to crash and display the message that you
passed as an argument to `expect`. If the `read_line` method returns an `Err`,
it would likely be the result of an error coming from the underlying operating
system. If this instance of `io::Result` is an `Ok` value, `expect` will take
the return value that `Ok` is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in the user‚Äôs input.
-->
<p>Les valeurs du type <code>Result</code>, comme pour tous les types, ont des m√©thodes
qui leur sont associ√©es. Par exemple, une instance de <code>io::Result</code> a une
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">m√©thode <code>expect</code></a><!-- ignore --> que vous pouvez utiliser. Si cette
instance de <code>io::Result</code> a pour valeur la variante <code>Err</code>, l'appel √† <code>expect</code>
fera planter le programme et affichera le message que vous avez pass√© en
argument de <code>expect</code>. Si l'appel √† <code>read_line</code> retourne une variante <code>Err</code>, ce
sera probablement d√ª √† une erreur du syst√®me d'exploitation. Si en revanche
<code>read_line</code> a pour valeur la variante <code>Ok</code>, <code>expect</code> r√©cup√®rera le
contenu du <code>Ok</code>, qui est le r√©sultat de l'op√©ration, et vous le retournera afin
que vous puissiez l'utiliser. Dans notre exemple, ce r√©sultat est le nombre
d'octets de la saisie utilisateur.</p>
<!--
If you don‚Äôt call `expect`, the program will compile, but you‚Äôll get a warning:
-->
<p>Si on n'appelle pas <code>expect</code>, le programme compilera, mais avec un
avertissement¬†:</p>
<!--
```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  -- > src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut supposition);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `jeu_du_plus_ou_du_moins` (bin &quot;jeu_du_plus_ou_du_moins&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
Rust warns that you haven‚Äôt used the `Result` value returned from `read_line`,
indicating that the program hasn‚Äôt handled a possible error.
-->
<p>Rust nous pr√©vient que l'on ne fait rien du <code>Result</code> que nous fournit
<code>read_line</code>, et que par cons√©quent notre programme ne g√®re pas une erreur
potentielle.</p>
<!--
The right way to suppress the warning is to actually write error handling, but
in our case we just want to crash this program when a problem occurs, so we can
use `expect`. You‚Äôll learn about recovering from errors in [Chapter
9][recover]<!-- ignore -- >.
-->
<p>La meilleure fa√ßon de masquer cet avertissement est de r√©ellement √©crire le
code permettant de g√©rer l'erreur, mais dans notre cas on a seulement besoin de
faire planter le programme si un probl√®me survient, on utilise donc <code>expect</code>.
Nous verrons dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore --> comment g√©rer
correctement les erreurs.</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3 id="afficher-des-valeurs-gr√¢ce-aux-espaces-r√©serv√©s-de-println"><a class="header" href="#afficher-des-valeurs-gr√¢ce-aux-espaces-r√©serv√©s-de-println">Afficher des valeurs gr√¢ce aux espaces r√©serv√©s de <code>println!</code></a></h3>
<!--
Aside from the closing curly bracket, there‚Äôs only one more line to discuss in
the code so far:
-->
<p>Mis √† part l'accolade fermante, il ne nous reste plus qu'une seule ligne √†
√©tudier dans le code que nous avons pour l'instant¬†:</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
    println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span>    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
<span class="boring">}
</span></code></pre>
<!--
This line prints the string that now contains the user‚Äôs input. The `{}` set of
curly brackets is a placeholder: think of `{}` as little crab pincers that hold
a value in place. You can print more than one value using curly brackets: the
first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>Cette ligne affiche la cha√Æne de caract√®res qui contient maintenant ce que
l'utilisateur a saisi. La paire d'accolades <code>{}</code> repr√©sente un espace r√©serv√©¬†:
imaginez qu'il s'agit de pinces de crabes qui gardent la place d'une valeur.
Vous pouvez afficher plusieurs valeurs en utilisant des accolades¬†: la premi√®re
paire d'accolades affichera la premi√®re valeur list√©e apr√®s la cha√Æne de
formatage, la deuxi√®me paire d'accolades affichera la deuxi√®me valeur, et ainsi
de suite. Pour afficher plusieurs valeurs en appelant <code>println!</code> une seule
fois, on ferait comme ceci¬†:</p>
<!--
```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} et y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>Ce code afficherait <code>x = 5 et y = 10</code>.</p>
<!--
### Testing the First Part
-->
<h3 id="test-de-la-premi√®re-partie"><a class="header" href="#test-de-la-premi√®re-partie">Test de la premi√®re partie</a></h3>
<!--
Let‚Äôs test the first part of the guessing game. Run it using `cargo run`:
-->
<p>Pour tester notre d√©but de programme, lan√ßons-le √† l'aide de la commande
<code>cargo run</code>¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre¬†!
Veuillez entrer un nombre.
6
Votre nombre¬†: 6
</code></pre>
<!--
At this point, the first part of the game is done: we‚Äôre getting input from the
keyboard and then printing it.
-->
<p>√Ä ce stade, la premi√®re partie de notre programme est termin√©e¬†: nous avons
r√©cup√©r√© la saisie du clavier et nous l'affichons √† l'√©cran.</p>
<!--
## Generating a Secret Number
-->
<h2 id="g√©n√©rer-le-nombre-secret"><a class="header" href="#g√©n√©rer-le-nombre-secret">G√©n√©rer le nombre secret</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. We‚Äôll use a random number between 1 and 100 so the game isn‚Äôt too
difficult. Rust doesn‚Äôt yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate] with
said functionality.
-->
<p>Maintenant, il nous faut g√©n√©rer un nombre secret que notre joueur va devoir
deviner. Ce nombre devra √™tre diff√©rent √† chaque fois pour qu'on puisse
s'amuser √† y jouer plusieurs fois. Nous allons tirer au sort un nombre compris
entre 1 et 100 pour que le jeu ne soit pas trop difficile. Rust n'embarque pas
pour l'instant de fonctionnalit√© de g√©n√©ration de nombres al√©atoires dans sa
biblioth√®que standard. Cependant, l'√©quipe de Rust propose une
<a href="https://crates.io/crates/rand"><em>crate</em> <code>rand</code></a> qui offre la possibilit√© de le faire.</p>
<!--
### Using a Crate to Get More Functionality
-->
<h3 id="√âtendre-les-fonctionnalit√©s-de-rust-avec-une-crate"><a class="header" href="#√âtendre-les-fonctionnalit√©s-de-rust-avec-une-crate">√âtendre les fonctionnalit√©s de Rust avec une <em>crate</em></a></h3>
<!--
Remember that a crate is a collection of Rust source code files. The project
we‚Äôve been building is a *binary crate*, which is an executable. The `rand`
crate is a *library crate*, which contains code intended to be used in other
programs, and can‚Äôt be executed on its own.
-->
<p>Souvenez-vous, une <em>crate</em> est un ensemble de fichiers de code source Rust. Le
projet sur lequel nous travaillons est une <em>crate</em> binaire, qui est un programme
ex√©cutable. La <em>crate</em> <code>rand</code> est une <em>crate de biblioth√®que</em>, qui contient du
code qui peut √™tre utilis√© dans d'autres programmes, et qui ne peut pas √™tre
ex√©cut√© tout seul.</p>
<!--
Cargo‚Äôs coordination of external crates is where Cargo really shines. Before we
can write code that uses `rand`, we need to modify the *Cargo.toml* file to
include the `rand` crate as a dependency. Open that file now and add the
following line to the bottom beneath the `[dependencies]` section header that
Cargo created for you. Be sure to specify `rand` exactly as we have here, with
this version number, or the code examples in this tutorial may not work.
-->
<p>La coordination des <em>crates</em> externes est un domaine dans lequel Cargo excelle.
Avant d'√©crire le code qui utilisera <code>rand</code>, il nous faut √©diter le fichier
<em>Cargo.toml</em> pour y sp√©cifier <code>rand</code> en tant que d√©pendance. Ouvrez donc
maintenant ce fichier et ajoutez la ligne suivante √† la fin, en dessous de
l'en-t√™te de section <code>[dependencies]</code> que Cargo a cr√©√© pour vous. Assurez-vous
de sp√©cifier <code>rand</code> exactement comme dans le bout de code suivant, avec ce
num√©ro de version, ou sinon les exemples de code de ce tutoriel pourraient ne
pas fonctionner.</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
rand = "0.8.3"
```
-->
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of that
section that continues until another section starts. In `[dependencies]` you
tell Cargo which external crates your project depends on and which versions of
those crates you require. In this case, we specify the `rand` crate with the
semantic version specifier `0.8.3`. Cargo understands [Semantic
Versioning][semver]<!-- ignore -- > (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.8.3` is actually shorthand
for `^0.8.3`, which means any version that is at least `0.8.3` but below
`0.9.0`. Cargo considers these versions to have public APIs compatible with
version `0.8.3`, and this specification ensures you‚Äôll get the latest patch
release that will still compile with the code in this chapter. Any version
`0.9.0` or greater is not guaranteed to have the same API as what the following
examples use.
-->
<p>Dans le fichier <em>Cargo.toml</em>, tout ce qui suit une en-t√™te fait partie de cette
section, et ce jusqu'√† ce qu'une autre section d√©bute. Dans <code>[dependencies]</code>,
vous indiquez √† Cargo de quelles <em>crates</em> externes votre
projet d√©pend, et de quelle version de ces <em>crates</em> vous avez besoin.
Dans notre cas, on ajoute comme d√©pendance la crate <code>rand</code> avec la version
s√©mantique <code>0.8.3</code>. Cargo arrive √† interpr√©ter le
<a href="http://semver.org">versionnage s√©mantique</a><!-- ignore --> (aussi appel√© <em>SemVer</em>), qui
est une convention d'√©criture de num√©ros de version. En r√©alit√©, <code>0.8.3</code> est
une abr√©viation pour <code>^0.8.3</code>, ce qui signifie ‚Äútoute version ult√©rieure ou
√©gale √† <code>0.8.3</code> mais strictement ant√©rieure √† <code>0.9.0</code>‚Äù. Cargo consid√®re que ces
versions ont des API publiques compatibles avec la version <code>0.8.3</code>, et cette
indication garantit que vous obtiendrez la derni√®re version de correction qui
compilera encore avec le code de ce chapitre. Il n'est pas garanti que les
versions <code>0.9.0</code> et ult√©rieures aient la m√™me API que celle utilis√©e dans les
exemples suivants.</p>
<!--
Now, without changing any of the code, let‚Äôs build the project, as shown in
Listing 2-2.
-->
<p>Maintenant, sans apporter le moindre changement au code, lan√ßons une compilation
du projet, comme dans l'encart 2-2¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -- >
-->
<!--
```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">Encart 2-2¬†: R√©sultat du lancement de <code>cargo build</code> apr√®s
avoir ajout√© la <em>crate</em> <code>rand</code> comme d√©pendance</span></p>
<!--
You may see different version numbers (but they will all be compatible with the
code, thanks to SemVer!), different lines (depending on the operating system),
and the lines may be in a different order.
-->
<p>Il est possible que vous ne voyiez pas exactement les m√™mes num√©ros de version,
(mais ils seront compatibles avec votre code, gr√¢ce au <em>versionnage
s√©mantique</em>¬†!), diff√©rentes lignes (en fonction de votre syst√®me
d'exploitation), et les lignes ne seront pas forc√©ment affich√©es dans le m√™me
ordre.</p>
<!--
When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the *registry*, which is a copy of data
from [Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.
-->
<p>Lorsque nous ajoutons une d√©pendance externe, Cargo r√©cup√®re les derni√®res
versions de tout ce dont cette d√©pendance a besoin depuis le <em>registre</em>, qui est une
copie des donn√©es de <a href="https://crates.io/">Crates.io</a>. Crates.io est l√† o√π les
d√©veloppeurs de l'√©cosyst√®me Rust publient leurs projets open source afin de
les rendre disponibles aux autres.</p>
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates listed that aren‚Äôt already downloaded. In this case,
although we only listed `rand` as a dependency, Cargo also grabbed other crates
that `rand` depends on to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.
-->
<p>Une fois le registre mis √† jour, Cargo lit la section <code>[dependencies]</code> et se
charge de t√©l√©charger les <em>crates</em> qui y sont list√©s que vous n'avez pas encore
t√©l√©charg√©. Dans notre cas, bien que nous n'ayons sp√©cifi√© qu'une seule
d√©pendance, <code>rand</code>, Cargo a aussi t√©l√©charg√© d'autres <em>crates</em> dont d√©pend
<code>rand</code> pour fonctionner. Une fois le t√©l√©chargement termin√© des <em>crates</em>, Rust
les compile, puis compile notre projet avec les d√©pendances disponibles.</p>
<!--
If you immediately run `cargo build` again without making any changes, you
won‚Äôt get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven‚Äôt changed anything
about them in your *Cargo.toml* file. Cargo also knows that you haven‚Äôt changed
anything about your code, so it doesn‚Äôt recompile that either. With nothing to
do, it simply exits.
-->
<p>Si vous relancez tout de suite <code>cargo build</code> sans changer quoi que ce soit, vous
n'obtiendrez rien d'autre que la ligne <code>Finished</code>. Cargo sait qu'il a d√©j√†
t√©l√©charg√© et compil√© les d√©pendances, et que vous n'avez rien chang√© dans votre
fichier <em>Cargo.toml</em>. Cargo sait aussi que vous n'avez rien chang√© dans votre
code, donc il ne le recompile pas non plus. √âtant donn√© qu'il n'a rien √† faire,
Cargo se termine tout simplement.</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, you‚Äôll only see two lines of output:
-->
<p>Si vous ouvrez le fichier <em>src/main.rs</em>, faites un changement tr√®s simple,
enregistrez le fichier, et relancez la compilation, vous verrez s'afficher
uniquement deux lignes¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -- >
-->
<!--
```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```
-->
<pre><code class="language-console">$ cargo build
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies haven‚Äôt changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those.
-->
<p>Ces lignes nous informent que Cargo a recompil√© uniquement √† cause de notre
petit changement dans le fichier <em>src/main.rs</em>. Les d√©pendances n'ayant pas
chang√©, Cargo sait qu'il peut simplement r√©utiliser ce qu'il a d√©j√† t√©l√©charg√©
et compil√© pr√©c√©demment.</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4 id="assurer-la-reproductibilit√©-des-compilations-avec-le-fichier-cargolock"><a class="header" href="#assurer-la-reproductibilit√©-des-compilations-avec-le-fichier-cargolock">Assurer la reproductibilit√© des compilations avec le fichier <em>Cargo.lock</em></a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, say that
next week version 0.8.4 of the `rand` crate comes out, and that version
contains an important bug fix, but it also contains a regression that will
break your code. To handle this, Rust creates the *Cargo.lock* file the first
time you run `cargo build`, so we now have this in the *guessing_game*
directory.
-->
<p>Cargo embarque une fonctionnalit√© qui garantie que vous pouvez recompiler le
m√™me art√©fact √† chaque fois que vous ou quelqu'un d'autre compile votre code¬†:
Cargo va utiliser uniquement les versions de d√©pendances que vous avez
utilis√©es jusqu'√† ce que vous indiquiez le contraire.
Par exemple, immaginons que la semaine prochaine, la version 0.8.4 de la
<em>crate</em> <code>rand</code> est publi√©e, et qu'elle apporte une correction importante, mais
aussi qu'elle produit une r√©gression qui va casser votre code. Pour √©viter cela,
Rust cr√©e le fichier <em>Cargo.lock</em> la premi√®re fois que vous utilisez
<code>cargo build</code>, donc nous l'avons d√©sormais dans le dossier
<em>jeu_du_plus_ou_du_moins</em>.</p>
<!--
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.8.3` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>Quand vous compilez un projet pour la
premi√®re fois, Cargo d√©termine toutes les versions de d√©pendances qui
correspondent √† vos crit√®res et les √©crit dans le fichier <em>Cargo.lock</em>. Quand
vous recompilerez votre projet plus tard, Cargo verra que le fichier
<em>Cargo.lock</em> existe et utilisera les versions pr√©cis√©es √† l'int√©rieur au lieu
de recommencer √† d√©terminer toutes les versions demand√©es.
Ceci vous permet d'avoir automatiquement des compilations reproductibles.
En d'autres termes, votre projet va rester sur la version <code>0.8.3</code> jusqu'√† ce
que vous le mettiez √† jour explicitement, gr√¢ce au fichier <em>Cargo.lock</em>.</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4 id="mettre-√†-jour-une-crate-vers-sa-nouvelle-version"><a class="header" href="#mettre-√†-jour-une-crate-vers-sa-nouvelle-version">Mettre √† jour une <em>crate</em> vers sa nouvelle version</a></h4>
<!--
When you *do* want to update a crate, Cargo provides the command `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. Cargo will then write those
versions to the *Cargo.lock* file. Otherwise, by default, Cargo will only look
for versions greater than `0.8.3` and less than `0.9.0`. If the `rand` crate
has released the two new versions `0.8.4` and `0.9.0` you would see the
following if you ran `cargo update`:
-->
<p>Lorsque vous souhaitez r√©ellement mettre √† jour une <em>crate</em>, Cargo vous fournit
la commande <code>update</code>, qui va ignorer le fichier <em>Cargo.lock</em> et va rechercher
toutes les versions qui correspondent √† vos crit√®res dans <em>Cargo.toml</em>. Cargo
va ensuite √©crire ces versions dans le fichier <em>Cargo.lock</em>. Sinon par d√©faut,
Cargo va rechercher uniquement les versions plus grandes que <code>0.8.3</code> et
inf√©rieures √† <code>0.9.0</code>. Si la <em>crate</em> <code>rand</code> a √©t√© publi√©e en deux nouvelles
versions <code>0.8.4</code> et <code>0.9.0</code>, alors vous verrez ceci si vous lancez
<code>cargo update</code>¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -- >
-->
<!--
```console
$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
```
-->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
<!--
Cargo ignores the `0.9.0` release. At this point, you would also notice a
change in your *Cargo.lock* file noting that the version of the `rand` crate
you are now using is `0.8.4`. To use `rand` version `0.9.0` or any version in
the `0.9.x` series, you‚Äôd have to update the *Cargo.toml* file to look like
this instead:
-->
<p>Cargo ignore la version <code>0.9.0</code>. √Ä partir de ce moment, vous pouvez aussi
constater un changement dans le fichier <em>Cargo.lock</em> indiquant que la version
de la <em>crate</em> <code>rand</code> que vous utilisez maintenant est la <code>0.8.4</code>. Pour utiliser
<code>rand</code> en version <code>0.9.0</code> ou toute autre version dans la s√©rie des <code>0.9.x</code>, il
vous faut mettre √† jour le fichier <em>Cargo.toml</em> comme ceci¬†:</p>
<!--
```toml
[dependencies]
rand = "0.9.0"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>La prochaine fois que vous lancerez <code>cargo build</code>, Cargo mettra √† jour son
registre de <em>crates</em> disponibles et r√©√©valuera vos exigences vis-√†-vis de <code>rand</code>
selon la nouvelle version que vous avez sp√©cifi√©e.</p>
<!--
There‚Äôs a lot more to say about [Cargo][doccargo]<!-- ignore -- > and [its
ecosystem][doccratesio]<!-- ignore -- > which we‚Äôll discuss in Chapter 14, but
for now, that‚Äôs all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p>Il y a encore plus √† dire √† propos de <a href="http://doc.crates.io">Cargo</a><!-- ignore --> et de
<a href="http://doc.crates.io/crates-io.html">son √©cosyst√®me</a><!-- ignore --> que nous aborderons au chapitre 14,
mais pour l'instant, c'est tout ce qu'il vous faut savoir. Cargo
facilite la r√©utilisation des biblioth√®ques, pour que les Rustac√©s soient
capables d'√©crire des petits projets issus d'un assemblage d'un certain
nombre de paquets.</p>
<!--
### Generating a Random Number
-->
<h3 id="g√©n√©rer-un-nombre-al√©atoire"><a class="header" href="#g√©n√©rer-un-nombre-al√©atoire">G√©n√©rer un nombre al√©atoire</a></h3>
<!--
Let‚Äôs start using `rand` to generate a number to guess. The next step is to
update *src/main.rs*, as shown in Listing 2-3.
-->
<p>Commen√ßons d√©sormais √† utiliser <code>rand</code> pour g√©n√©rer un nombre √† deviner. La
prochaine √©tape est de modifier <em>src/main.rs</em> comme dans l'encart 2-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombre¬†!&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1..101);

    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

        println!(&quot;Votre nombre¬†: {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a random
number</span>
-->
<p><span class="caption">Encart 2-3¬†: Ajout du code pour g√©n√©rer un nombre
al√©atoire</span></p>
<!--
First, we add the line `use rand::Rng`. The `Rng` trait defines methods that
random number generators implement, and this trait must be in scope for us to
use those methods. Chapter 10 will cover traits in detail.
-->
<p>D'abord, nous avons ajout√© la ligne <code>use rand::Rng</code>. Le <em>trait</em> <code>Rng</code> d√©finit
les m√©thodes impl√©ment√©es par les g√©n√©rateurs de nombres al√©atoires, et ce
<em>trait</em> doit √™tre accessible √† notre code pour qu'on puisse utiliser ces
m√©thodes. Le chapitre 10 expliquera plus en d√©tail les <em>traits</em>.</p>
<!--
Next, we‚Äôre adding two lines in the middle. In the first line, we call the
`rand::thread_rng` function that gives us the particular random number
generator that we‚Äôre going to use: one that is local to the current thread of
execution and seeded by the operating system. Then we call the `gen_range`
method on the random number generator. This method is defined by the `Rng`
trait that we brought into scope with the `use rand::Rng` statement. The
`gen_range` method takes a range expression as an argument and generates a
random number in the range. The kind of range expression we‚Äôre using here takes
the form `start..end` and is inclusive on the lower bound but exclusive on the
upper bound, so we need to specify `1..101` to request a number between 1 and
100. Alternatively, we could pass the range `1..=100`, which is equivalent.
-->
<p>Ensuite, nous ajoutons deux lignes au milieu. A la premi√®re ligne, nous
appelons la fonction <code>rand::thread_rng</code> qui nous fournit le g√©n√©rateur de
nombres al√©atoires particulier que nous allons utiliser¬†: il est propre au fil
d'ex√©cution courant et g√©n√©r√© par le syst√®me d'exploitation. Ensuite, nous
appelons la m√©thode <code>gen_range</code> sur le g√©n√©rateur de nombres al√©atoires. Cette
m√©thode est d√©finie par le <em>trait</em> <code>Rng</code> que nous avons import√© avec
l'instruction <code>use rand::Rng</code>. La m√©thode <code>gen_range</code> prend une expression
d'intervalle en param√®tre et g√©n√®re un nombre al√©atoire au sein de
l'intervalle. Le genre d'expression d'intervalle utilis√© ici est de la forme
<code>d√©but..fin</code> et inclut la borne inf√©rieure mais exclut la borne sup√©rieure,
nous avons donc besoin de pr√©ciser <code>1..101</code> pour demander un nombre entre 1
et 100. De mani√®re √©quivalente, nous pourrions √©galement passer l'intervalle
ferm√© <code>1..=100</code></p>
<!--
> Note: You won‚Äôt just know which traits to use and which methods and functions
> to call from a crate, so each crate has documentation with instructions for
> using it. Another neat feature of Cargo is that running the `cargo doc
> --open` command will build documentation provided by all of your dependencies
> locally and open it in your browser. If you‚Äôre interested in other
> functionality in the `rand` crate, for example, run `cargo doc --open` and
> click `rand` in the sidebar on the left.
-->
<blockquote>
<p>Remarque¬†: vous ne pourrez pas deviner quels <em>traits</em>, m√©thodes et
fonctions utiliser avec une <em>crate</em>, donc chaque <em>crate</em> a une documentation
qui donne des indications sur son utilisation. Une autre fonctionnalit√©
int√©ressante de Cargo est que vous pouvez utiliser la commande
<code>cargo doc --open</code>, qui va construire localement la documentation int√©gr√©e
par toutes vos d√©pendances et va l'ouvrir dans votre navigateur. Si vous vous
int√©ressez √† d'autres fonctionnalit√©s de la <em>crate</em> <code>rand</code>, par exemple, vous
pouvez lancer <code>cargo doc --open</code> et cliquer sur <code>rand</code> dans la barre lat√©rale
sur la gauche.</p>
</blockquote>
<!--
The second new line prints the secret number. This is useful while we‚Äôre
developing the program to be able to test it, but we‚Äôll delete it from the
final version. It‚Äôs not much of a game if the program prints the answer as soon
as it starts!
-->
<p>La seconde nouvelle ligne affiche le nombre secret. C'est pratique lors du
d√©veloppement pour pouvoir le tester, mais nous l'enl√®verons dans la version
finale. Ce n'est pas vraiment un jeu si le programme affiche la r√©ponse d√®s
qu'il d√©marre¬†!</p>
<!--
Try running the program a few times:
-->
<p>Essayez de lancer le programme plusieurs fois¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre¬†!
Le nombre secret est¬†: 7
Veuillez entrer un nombre.
4
Votre nombre¬†: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre¬†!
Le nombre secret est¬†: 83
Veuillez entrer un nombre.
5
Votre nombre¬†: 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>Vous devriez obtenir des nombres al√©atoires diff√©rents, et ils devraient √™tre
tous compris entre 1 et 100. Beau travail¬†!</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2 id="comparer-le-nombre-saisi-au-nombre-secret"><a class="header" href="#comparer-le-nombre-saisi-au-nombre-secret">Comparer le nombre saisi au nombre secret</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won‚Äôt compile quite yet, as we
will explain.
-->
<p>Maintenant que nous avons une saisie utilisateur et un nombre al√©atoire, nous
pouvons les comparer. Cette √©tape est √©crite dans l'encart 2-4. Sachez toutefois
que le code ne se compile pas encore, nous allons l'expliquer par la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // -- partie masqu√©e ici --
<span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span>
    println!(&quot;Votre nombre¬†: {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagn√©¬†!&quot;),
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">Encart 2-4¬†: Traitement des valeurs possibles saisies en
comparant les deux nombres</span></p>
<!--
First we add another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. The `Ordering` type
is another enum and has the variants `Less`, `Greater`, and `Equal`. These are
the three outcomes that are possible when you compare two values.
-->
<p>Premi√®rement, nous ajoutons une autre instruction <code>use</code>, qui importe
<code>std::cmp::Ordering</code> √† port√©e de notre code depuis la biblioth√®que standard.
Le type <code>Ordering</code> est une autre √©num√©ration et a les variantes <code>Less</code>
<em>(inf√©rieur)</em>, <code>Greater</code> <em>(sup√©rieur)</em> et <code>Equal</code> <em>(√©gal)</em>. Ce sont les trois
issues possibles lorsqu'on compare deux valeurs.</p>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it‚Äôs
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match]<!-- ignore -- > expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>Ensuite, nous ajoutons cinq nouvelles lignes √† la fin qui utilisent le type
<code>Ordering</code>. La m√©thode <code>cmp</code> compare deux valeurs et peut √™tre appel√©e sur
tout ce qui peut √™tre compar√©. Elle prend en param√®tre une r√©f√©rence de ce qu'on
veut comparer¬†: ici, nous voulons comparer <code>supposition</code> et <code>nombre_secret</code>.
Ensuite, cela retourne une variante de l'√©num√©ration <code>Ordering</code> que nous avons
import√©e avec l'instruction <code>use</code>. Nous utilisons une expression
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> pour d√©cider quoi faire ensuite en fonction de
quelle variante de <code>Ordering</code> a √©t√© retourn√©e √† l'appel de <code>cmp</code> avec
<code>supposition</code> et <code>nombre_secret</code>.</p>
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* to
match against, and the code that should be run if the value given to `match`
fits that arm‚Äôs pattern. Rust takes the value given to `match` and looks
through each arm‚Äôs pattern in turn. Patterns and the `match` construct are
powerful Rust features that let you express a variety of situations your code
might encounter and make sure that you handle them all. These features will be
covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p>Une expression <code>match</code> est compos√©e de <em>branches</em>. Une branche est constitu√©e
d'un <em>motif (pattern)</em> avec lequel elle doit correspondre et du code qui sera
ex√©cut√© si la valeur donn√©e au <code>match</code> correspond bien au motif de cette
branche. Rust prend la valeur donn√©e √† <code>match</code> et la compare au motif de chaque
branche √† tour de r√¥le. Les motifs et la structure de contr√¥le <code>match</code> sont des
fonctionnalit√©s puissantes de Rust qui vous permettent de d√©crire une multitude
de sc√©narios que votre code peut rencontrer et de s'assurer que vous les g√©rez
toutes. Ces fonctionnalit√©s seront expliqu√©es plus en d√©tail respectivement
dans le chapitre 6 et le chapitre 18.</p>
<!--
Let‚Äôs walk through an example with the `match` expression we use here. Say that
the user has guessed 50 and the randomly generated secret number this time is
38. When the code compares 50 to 38, the `cmp` method will return
`Ordering::Greater`, because 50 is greater than 38. The `match` expression gets
the `Ordering::Greater` value and starts checking each arm‚Äôs pattern. It looks
at the first arm‚Äôs pattern, `Ordering::Less`, and sees that the value
`Ordering::Greater` does not match `Ordering::Less`, so it ignores the code in
that arm and moves to the next arm. The next arm‚Äôs pattern is
`Ordering::Greater`, which *does* match `Ordering::Greater`! The associated
code in that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>Voyons un exemple avec l'expression <code>match</code> que nous avons utilis√© ici. Disons
que l'utilisateur a saisi le nombre 50 et que le nombre secret g√©n√©r√©
al√©atoirement a cette fois-ci comme valeur 38. Quand le code compare 50 √† 38,
la m√©thode <code>cmp</code> va retourner <code>Ordering::Greater</code>, car 50 est plus grand
que 38. L'expression <code>match</code> obtient la valeur <code>Ordering::Greater</code> et commence
√† v√©rifier le motif de chaque branche. Elle consulte le motif de la premi√®re
branche, <code>Ordering::Less</code> et remarque que la valeur <code>Ordering::Greater</code> ne
correspond pas au motif <code>Ordering::Less</code>¬†; elle ignore donc le code de cette
branche et passe √† la suivante. Le motif de la branche suivante est
<code>Ordering::Greater</code>, qui correspond √† <code>Ordering::Greater</code>¬†! Le code associ√© √†
cette branche va √™tre ex√©cut√© et va afficher √† l'√©cran <code>C'est moins¬†!</code>.
L'expression <code>match</code> se termine ensuite, car elle n'a pas besoin de consulter
les autres branches de ce sc√©nario.</p>
<!--
However, the code in Listing 2-4 won‚Äôt compile yet. Let‚Äôs try it:
-->
<p>Cependant, notre code dans l'encart 2-4 ne compile pas encore. Essayons de le
faire¬†:</p>
<!--
```console
$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- > src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   -- > src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   -- > /Users/carolnichols/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.3/src/rng.rs:129:12
    |
129 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
8   |     let secret_number = rand::thread_rng().gen_range::<T, R>(1..101);
    |                                                     ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `guessing_game` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match supposition.cmp(&amp;nombre_secret) {
   |                           ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `jeu_du_plus_ou_du_moins` due to previous error

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let nombre_secret = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `nombre_secret` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   --&gt; /Users/carolnichols/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.3/src/rng.rs:129:12
    |
129 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
8   |     let nombre_secret = rand::thread_rng().gen_range::&lt;T, R&gt;(1..101);
    |                                                     ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `guessing_game` due to 2 previous errors
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let mut guess = String::new()`, Rust was able to infer that `guess` should be
a `String` and didn‚Äôt make us write the type. The `secret_number`, on the other
hand, is a number type. A few of Rust‚Äôs number types can have a value between 1
and 100: `i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a
64-bit number; as well as others. Unless otherwise specified, Rust defaults to
an `i32`, which is the type of `secret_number` unless you add type information
elsewhere that would cause Rust to infer a different numerical type. The reason
for the error is that Rust cannot compare a string and a number type.
-->
<p>Le message d'erreur nous indique que nous sommes dans un cas de types non
compatibles <em>(mismatched types)</em>. Rust a un syst√®me de types fort et statique.
Cependant, il a aussi une fonctionnalit√© d'inf√©rence de type. Quand nous avons
√©crit <code>let mut supposition = String::new()</code>, Rust a pu en d√©duire que
<code>supposition</code> devait √™tre une <code>String</code> et ne nous a pas demand√© d'√©crire le
type. D'autre part, <code>nombre_secret</code> est d'un type de nombre. Quelques types de
nombres de Rust peuvent avoir une valeur entre 1 et 100¬†: <code>i32</code>, un nombre
entier encod√© sur 32 bits¬†; <code>u32</code>, un nombre entier de 32 bits non sign√©
(positif ou nul)¬†; <code>i64</code>, un nombre entier encod√© sur 64 bits¬†; parmi tant
d'autres. Rust utilise par d√©faut un <code>i32</code>, qui est le type de <code>nombre_secret</code>,
√† moins que vous pr√©cisiez quelque part une information de type qui am√®nerait
Rust √† inf√©rer un type de nombre diff√©rent. La raison de cette erreur est que
Rust ne peut pas comparer une cha√Æne de caract√®res √† un nombre.</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the secret number. We do so
by adding this line to the `main` function body:
-->
<p>Au bout du compte, nous voulons convertir la <code>String</code> que le programme r√©cup√®re
de la saisie utilisateur en un nombre, pour qu'on puisse la comparer
num√©riquement au nombre secret. Nous allons faire ceci en ajoutant cette ligne
suppl√©mentaire dans le corps de la fonction <code>main</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span>    // -- partie masqu√©e ici --

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre¬†!&quot;);

    println!(&quot;Votre nombre¬†: {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagn√©¬†!&quot;),
    }
<span class="boring">}
</span></code></pre>
<!--
The line is:
-->
<p>La nouvelle ligne est¬†:</p>
<!--
```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```
-->
<pre><code class="language-rust ignore">let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre¬†!&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesn‚Äôt the program already have
a variable named `guess`? It does, but helpfully Rust allows us to *shadow* the
previous value of `guess` with a new one. Shadowing lets us reuse the `guess`
variable name rather than forcing us to create two unique variables, such as
`guess_str` and `guess` for example. We‚Äôll cover this in more detail in Chapter
3, but for now know that this feature is often used when you want to convert a
value from one type to another type.
-->
<p>Nous cr√©ons une variable qui s'appelle <code>supposition</code>. Mais attendez, le
programme n'a-t-il pas d√©j√† une variable qui s'appelle <code>supposition</code>¬†?
C'est le cas, mais heureusement Rust nous permet de <em>masquer</em> la valeur
pr√©c√©dente de <code>supposition</code> avec une nouvelle.
Le masquage <em>(shadowing)</em> nous permet de r√©utiliser le nom de variable
<code>supposition</code>, plut√¥t que de nous forcer √† cr√©er deux variables distinctes,
telles que <code>supposition_str</code> et <code>supposition</code> par exemple.
Nous verrons cela plus en d√©tails au chapitre 3, mais pour le moment cette
fonctionnalit√© est souvent utilis√©e dans des situations o√π on veut convertir
une valeur d'un type √† un autre.</p>
<!--
We bind this new variable to the expression `guess.trim().parse()`. The `guess`
in the expression refers to the original `guess` variable that contained the
input as a string. The `trim` method on a `String` instance will eliminate any
whitespace at the beginning and end, which we must do to be able to compare the
string to the `u32`, which can only contain numerical data. The user must press
<span class="keystroke">enter</span> to satisfy `read_line` and input their
guess, which adds a newline character to the string. For example, if the user
types <span class="keystroke">5</span> and presses <span
class="keystroke">enter</span>, `guess` looks like this: `5\n`. The `\n`
represents ‚Äúnewline‚Äù. (On Windows, pressing <span
class="keystroke">enter</span> results in a carriage return and a newline,
`\r\n`). The `trim` method eliminates `\n` or `\r\n`, resulting in just `5`.
-->
<p>Nous lions cette nouvelle variable √† l'expression <code>supposition.trim().parse()</code>.
Le <code>supposition</code> dans l'expression se r√©f√®re √† la variable <code>supposition</code>
initiale qui contenait la saisie utilisateur en tant que cha√Æne de caract√®res.
<code>String</code> contenant la saisie utilisateur. La m√©thode <code>trim</code> sur une instance
de <code>String</code> va enlever les espaces et autres <em>whitespaces</em> au d√©but et √† la
fin, ce que nous devons faire pour comparer la cha√Æne au <code>u32</code>, qui ne peut
√™tre constitu√© que de chiffres. L'utilisateur doit appuyer sur
<span class="keystroke">entr√©e</span> pour mettre fin √† <code>read_line</code> et
r√©cup√©rer leur supposition, ce qui va rajouter un caract√®re de fin de ligne √†
la cha√Æne de caract√®res. Par exemple, si l'utilisateur √©crit
<span class="keystroke">5</span> et appuie sur <span class="keystroke">entr√©e
</span>, <code>supposition</code> aura alors cette valeur¬†: <code>5\n</code>.
Le <code>\n</code> repr√©sente une fin de ligne (√† noter que sur Windows, appuyer sur
<span class="keystroke">entr√©e</span> r√©sulte en un retour chariot suivi d'une
fin de ligne, <code>\r\n</code>). La m√©thode <code>trim</code> enl√®ve <code>\n</code> et <code>\r\n</code>, il ne reste donc
plus que <code>5</code>.</p>
<!--
The [`parse` method on strings][parse]<!-- ignore -- > parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust we‚Äôll annotate the variable‚Äôs type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. It‚Äôs a good default choice for a small positive number. You‚Äôll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p>La <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">m√©thode <code>parse</code> des cha√Ænes de caract√®res</a><!-- ignore --> interpr√®te
une cha√Æne de caract√®res en une sorte de nombre. Comme cette m√©thode peut
interpr√©ter plusieurs types de nombres, nous devons indiquer √† Rust le type
exact de nombre que nous voulons en utilisant <code>let supposition: u32</code>.
Le deux-points (<code>:</code>) apr√®s <code>supposition</code> indique √† Rust que nous voulons
pr√©ciser le type de la variable.
Rust embarque quelques types de nombres¬†; le <code>u32</code> utilis√© ici est un
entier non sign√© sur 32 bits.
C'est un bon choix par d√©faut pour un petit nombre positif.
Vous d√©couvrirez d'autres types de nombres dans le chapitre 3.
De plus, l'annotation <code>u32</code> dans ce programme d'exemple et la
comparaison avec <code>nombre_secret</code> permet √† Rust d'en d√©duire que <code>nombre_secret</code>
doit √™tre lui aussi un <code>u32</code>. Donc maintenant, la comparaison se fera
entre deux valeurs du m√™me type¬†!</p>
<!--
The `parse` method will only work on characters that can logically be converted
into numbers and so can easily cause errors. If, for example, the string
contained `Aüëç%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in [‚ÄúHandling Potential Failure with the
`Result` Type‚Äù](#handling-potential-failure-with-the-result-type)<!-- ignore
-- >). We‚Äôll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldn‚Äôt create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p>La m√©thode <code>parse</code> va fonctionner uniquement sur des caract√®res qui peuvent
√™tre logiquement convertis en nombres et donc peut facilement mener √† une
erreur. Si par exemple, le texte contient <code>Aüëç%</code>, il ne sera pas possible de le
convertir en nombre. Comme elle peut √©chouer, la m√©thode <code>parse</code> retourne un
type <code>Result</code>, comme celui que la m√©thode <code>read_line</code> retourne (comme nous
l'avons vu plus t√¥t dans <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">‚ÄúG√©rer les erreurs potentielles avec le type
<code>Result</code>‚Äù</a><!-- ignore-->).
Nous allons g√©rer ce <code>Result</code> de la m√™me mani√®re, avec √† nouveau la m√©thode
<code>expect</code>. Si <code>parse</code> retourne une variante <code>Err</code> de <code>Result</code> car elle ne peut
pas cr√©er un nombre √† partir de la cha√Æne de caract√®res, l'appel √†
<code>expect</code> va faire planter le jeu et va afficher le message que nous lui avons
pass√© en param√®tre. Si <code>parse</code> arrive √† convertir la cha√Æne de caract√®res en
nombre, alors elle retournera la variante <code>Ok</code> de <code>Result</code>, et <code>expect</code> va
retourner le nombre qu'il nous faut qui est stock√© dans la variante <code>Ok</code>.</p>
<!--
Let‚Äôs run the program now!
-->
<p>Ex√©cutons ce programme, maintenant¬†!</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre¬†!
Le nombre secret est¬†: 58
Veuillez entrer un nombre.
  76
Votre nombre¬†: 76
C'est moins¬†!
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>Tr√®s bien¬†!
M√™me si des espaces ont √©t√© ajout√©es avant la supposition, le programme a quand
m√™me compris que l'utilisateur a saisi 76. Lancez le programme plusieurs
fois pour v√©rifier qu'il se comporte correctement avec diff√©rentes saisies¬†:
devinez le nombre correctement, saisissez un nombre qui est trop grand, et
saisissez un nombre qui est trop petit.</p>
<!--
We have most of the game working now, but the user can make only one guess.
Let‚Äôs change that by adding a loop!
-->
<p>La majeure partie du jeu fonctionne d√©sormais, mais l'utilisateur ne peut faire
qu'une seule supposition. Corrigeons cela en ajoutant une boucle¬†!</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2 id="permettre-plusieurs-suppositions-avec-les-boucles"><a class="header" href="#permettre-plusieurs-suppositions-avec-les-boucles">Permettre plusieurs suppositions avec les boucles</a></h2>
<!--
The `loop` keyword creates an infinite loop. We‚Äôll add a loop to give users
more chances at guessing the number:
-->
<p>Le mot-cl√© <code>loop</code> cr√©e une boucle infinie. Nous allons ajouter une boucle pour
donner aux utilisateurs plus de chances de deviner le nombre¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
    // --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

# 
#         let mut guess = String::new();
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
#         let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#         println!("You guessed: {}", guess);
# 
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    // -- partie masqu√©e ici --

    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        // -- partie masqu√©e ici --

<span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">
</span>        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
            Ordering::Equal =&gt; println!(&quot;Vous avez gagn√©¬†!&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, we‚Äôve moved everything from the guess input prompt onward into
a loop. Be sure to indent the lines inside the loop another four spaces each
and run the program again. The program will now ask for another guess forever,
which actually introduces a new problem. It doesn‚Äôt seem like the user can quit!
-->
<p>Comme vous pouvez le remarquer, nous avons d√©plac√© dans une boucle tout le code
de l'invite √† entrer le nombre. Assurez-vous d'indenter correctement les lignes
dans la boucle avec quatre nouvelles espaces pour chacune, et lancez √† nouveau
le programme. Le programme va d√©sormais demander un nombre √† l'infini, ce qui
est un nouveau probl√®me. Il n'est pas possible pour l'utilisateur de
l'arr√™ter¬†!</p>
<!--
The user could always interrupt the program by using the keyboard shortcut
<span class="keystroke">ctrl-c</span>. But there‚Äôs another way to escape this
insatiable monster, as mentioned in the `parse` discussion in [‚ÄúComparing the
Guess to the Secret Number‚Äù](#comparing-the-guess-to-the-secret-number)<!--
ignore -- >: if the user enters a non-number answer, the program will crash. We
can take advantage of that to allow the user to quit, as shown here:
-->
<p>L'utilisateur pourrait quand m√™me interrompre le programme en utilisant le
raccourci clavier <span class="keystroke">ctrl-c</span>.
Mais il y a une autre fa√ßon d'√©chapper √† ce monstre insatiable, comme nous
l'avons abord√© dans la partie <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">‚ÄúComparer le nombre saisi au nombre
secret‚Äù</a><!-- ignore -->¬†: si
l'utilisateur saisit quelque chose qui n'est pas un nombre, le programme va
planter. Nous pouvons proc√©der ainsi pour permettre √† l'utilisateur de quitter,
comme ci-dessous¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-- >
-->
<!-- markdownlint-disable -->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<!-- markdownlint-restore -->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre¬†!
Le nombre secret est¬†: 59
Veuillez entrer un nombre.
45
Votre nombre¬†: 45
C'est plus¬†!
Veuillez entrer un nombre.
60
Votre nombre¬†: 60
C'est moins¬†!
Veuillez entrer un nombre.
59
Votre nombre¬†: 59
Vous avez gagn√©¬†!
Veuillez entrer un nombre.
quitter
thread 'main' panicked at 'Veuillez entrer un nombre¬†!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: Run with `RUST_BACKTRACE=1` for a backtrace
</code></pre>
<!--
Typing `quit` will quit the game, but as you‚Äôll notice so will entering any
other non-number input. This is suboptimal to say the least; we want the game
to also stop when the correct number is guessed.
-->
<p>Taper <code>quitter</code> va bien fermer le jeu, mais comme vous pouvez le remarquer,
toute autre saisie qui n'est pas un nombre le ferait aussi. Ce m√©canisme laisse
franchement √† d√©sirer¬†; nous voudrions que le jeu s'arr√™te aussi lorsque le bon
nombre est devin√©.</p>
<!--
### Quitting After a Correct Guess
-->
<h3 id="arr√™ter-le-programme-apr√®s-avoir-gagn√©"><a class="header" href="#arr√™ter-le-programme-apr√®s-avoir-gagn√©">Arr√™ter le programme apr√®s avoir gagn√©</a></h3>
<!--
Let‚Äôs program the game to quit when the user wins by adding a `break` statement:
-->
<p>Faisons en sorte que le jeu s'arr√™te quand le joueur gagne en ajoutant
l'instruction <code>break</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
#         let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#         println!("You guessed: {}", guess);
# 
        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">
</span>        // -- partie masqu√©e ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagn√©¬†!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p>Ajouter la ligne <code>break</code> apr√®s <code>Vous avez gagn√©¬†!</code> fait sortir le programme de
la boucle quand le joueur a correctement devin√© le nombre secret. Et quitter la
boucle veut aussi dire terminer le programme, car ici la boucle est la derni√®re
partie de <code>main</code>.</p>
<!--
### Handling Invalid Input
-->
<h3 id="g√©rer-les-saisies-invalides"><a class="header" href="#g√©rer-les-saisies-invalides">G√©rer les saisies invalides</a></h3>
<!--
To further refine the game‚Äôs behavior, rather than crashing the program when
the user inputs a non-number, let‚Äôs make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as shown in Listing 2-5.
-->
<p>Pour am√©liorer le comportement du jeu, plut√¥t que de faire planter le programme
quand l'utilisateur saisit quelque chose qui n'est pas un nombre, faisons en
sorte que le jeu ignore ce qui n'est pas un nombre afin que l'utilisateur puisse
continuer √† essayer de deviner. Nous pouvons faire ceci en modifiant la ligne o√π
<code>supposition</code> est converti d'une <code>String</code> en un <code>u32</code>, comme dans l'encart 2-5¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span>        // -- partie masqu√©e ici --

        io::stdin()
            .read_line(&amp;mut supposition)
            .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombre¬†: {}&quot;, supposition);

        // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagn√©¬†!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">Encart 2-5¬†: Ignorer une saisie qui n'est pas un nombre
et demander un nouveau nombre plut√¥t que de faire planter le programme</span></p>
<!--
We switch from an `expect` call to a `match` expression to move from crashing
on an error to handling the error. Remember that `parse` returns a `Result`
type and `Result` is an enum that has the variants `Ok` and `Err`. We‚Äôre using a
`match` expression here, as we did with the `Ordering` result of the `cmp`
method.
-->
<p>Nous rempla√ßons un appel √† <code>expect</code> par une expression <code>match</code> pour passer
d'une erreur qui fait planter le programme √† une erreur proprement g√©r√©e.
N'oubliez pas que <code>parse</code> retourne un type <code>Result</code> et que <code>Result</code> est une
√©num√©ration qui a pour variantes <code>Ok</code> et <code>Err</code>. Nous utilisons ici une
expression <code>match</code> comme nous l'avons d√©j√† fait avec le r√©sultat de type
<code>Ordering</code> de la m√©thode <code>cmp</code>.</p>
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first arm‚Äôs pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable we‚Äôre creating.
-->
<p>Si <code>parse</code> arrive √† convertir la cha√Æne de caract√®res en nombre, cela va
retourner la variante <code>Ok</code> qui contient le nombre qui en r√©sulte. Cette variante
va correspondre au motif de la premi√®re branche, et l'expression <code>match</code> va
simplement retourner la valeur de <code>nombre</code> que <code>parse</code> a trouv√©e et qu'elle a
mise dans la variante <code>Ok</code>.
Ce nombre va se retrouver l√† o√π nous en avons besoin,
dans la variable <code>supposition</code> que nous sommes en train de cr√©er.</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does
match the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, we‚Äôre saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second arm‚Äôs code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So, effectively, the
program ignores all errors that `parse` might encounter!
-->
<p>Si <code>parse</code> n'arrive <em>pas</em> √† convertir la cha√Æne de caract√®res en nombre, elle
va retourner la variante <code>Err</code> qui contient plus d'informations sur l'erreur. La
variante <code>Err</code> ne correspond pas au motif <code>Ok(nombre)</code> de la premi√®re branche,
mais elle correspond au motif <code>Err(_)</code> de la seconde branche. Le tiret bas,
<code>_</code>, est une valeur passe-partout¬†; dans notre exemple, nous disons
que nous voulons correspondre √† toutes les valeurs de <code>Err</code>, peu importe quelle
information elles ont √† l'int√©rieur d'elles-m√™mes. Donc le programme va ex√©cuter
le code de la seconde branche, <code>continue</code>, qui indique au programme de se rendre
√† la prochaine it√©ration de <code>loop</code> et de demander un nouveau nombre. Ainsi, le
programme ignore toutes les erreurs que <code>parse</code> pourrait rencontrer¬†!</p>
<!--
Now everything in the program should work as expected. Let‚Äôs try it:
-->
<p>Maintenant, le programme devrait fonctionner correctement. Essayons-le¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre¬†!
Le nombre secret est¬†: 61
Veuillez entrer un nombre.
10
Votre nombre¬†: 10
C'est plus¬†!
Veuillez entrer un nombre.
99
Votre nombre¬†: 99
C'est moins¬†!
Veuillez entrer un nombre.
foo
Veuillez entrer un nombre.
61
Votre nombre¬†: 61
Vous avez gagn√©¬†!
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let‚Äôs delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code.
-->
<p>Super¬†! Avec notre petite touche finale, nous avons fini notre jeu du plus ou du
moins. Rappelez-vous que le programme affiche toujours le nombre secret. C'√©tait
pratique pour les tests, mais cela g√¢che le jeu. Supprimons le <code>println!</code> qui
affiche le nombre secret. L'encart 2-6 repr√©sente le code final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Devinez le nombre¬†!&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1..101);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        let mut supposition = String::new();

        io::stdin()
            .read_line(&amp;mut supposition)
            .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombre¬†: {}&quot;, supposition);

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagn√©¬†!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">Encart 2-6¬†: Code complet du jeu du plus ou du moins
</span></p>
<!--
## Summary
-->
<h2 id="r√©sum√©-1"><a class="header" href="#r√©sum√©-1">R√©sum√©</a></h2>
<!--
At this point, you‚Äôve successfully built the guessing game. Congratulations!
-->
<p>Si vous √™tes arriv√© jusqu'ici, c'est que vous avez construit avec succ√®s le jeu
du plus ou du moins. F√©licitations¬†!</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, functions, the use of external crates, and more. In the next
few chapters, you‚Äôll learn about these concepts in more detail. Chapter 3
covers concepts that most programming languages have, such as variables, data
types, and functions, and shows how to use them in Rust. Chapter 4 explores
ownership, a feature that makes Rust different from other languages. Chapter 5
discusses structs and method syntax, and Chapter 6 explains how enums work.
-->
<p>Ce projet √©tait une mise en pratique pour vous initier √† de nombreux concepts de
Rust¬†: <code>let</code>, <code>match</code>, les m√©thodes, les fonctions associ√©es, l'utilisation de
<em>crates</em> externes, et bien plus. Dans les prochains chapitres, vous allez en
apprendre plus sur ces concepts. Le chapitre 3 va traiter des concepts utilis√©s
par la plupart des langages de programmation, comme les variables, les types de
donn√©es, et les fonctions, et vous montrera comment les utiliser avec Rust. Le
chapitre 4 expliquera la possession <em>(ownership)</em>, qui est une fonctionnalit√©
qui distingue Rust des autres langages. Le chapitre 5 abordera les structures et
les syntaxes des m√©thodes, et le chapitre 6 expliquera comment les √©num√©rations
fonctionnent.</p>
<!--
[prelude]: ../std/prelude/index.html
[variables-and-mutability]: ch03-01-variables-and-mutability.html#variables-and-mutability
[comments]: ch03-04-comments.html
[string]: ../std/string/struct.String.html
[iostdin]: ../std/io/struct.Stdin.html
[read_line]: ../std/io/struct.Stdin.html#method.read_line
[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html
[enums]: ch06-00-enums.html
[expect]: ../std/result/enum.Result.html#method.expect
[recover]: ch09-02-recoverable-errors-with-result.html
[randcrate]: https://crates.io/crates/rand
[semver]: http://semver.org
[cratesio]: https://crates.io/
[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html
[match]: ch06-02-match.html
[parse]: ../std/primitive.str.html#method.parse
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Common Programming Concepts
-->
<h1 id="les-concepts-courants-de-programmation"><a class="header" href="#les-concepts-courants-de-programmation">Les concepts courants de programmation</a></h1>
<!--
This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we‚Äôll discuss them in the context of Rust and explain the conventions
around using these concepts.
-->
<p>Ce chapitre explique des concepts qui apparaissent dans presque tous les
langages de programmation, et la mani√®re dont ils fonctionnent en Rust. De
nombreux langages sont bas√©s sur des concepts communs. Les concepts pr√©sent√©s
dans ce chapitre ne sont pas sp√©cifiques √† Rust, mais nous les appliquerons
√† Rust et nous expliquerons les conventions qui leur sont li√©es.</p>
<!--
Specifically, you‚Äôll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.
-->
<p>Plus pr√©cis√©ment, vous allez apprendre les concepts de variables, les types de
base, les fonctions, les commentaires, et les structures de contr√¥le. Ces
notions fondamentales seront pr√©sentes dans tous les programmes Rust, et les
apprendre d√®s le d√©but vous procurera de solides bases pour d√©buter.</p>
<!--
> #### Keywords
>
> The Rust language has a set of *keywords* that are reserved for use by
> the language only, much as in other languages. Keep in mind that you cannot
> use these words as names of variables or functions. Most of the keywords have
> special meanings, and you‚Äôll be using them to do various tasks in your Rust
> programs; a few have no current functionality associated with them but have
> been reserved for functionality that might be added to Rust in the future. You
> can find a list of the keywords in [Appendix A][appendix_a]<!-- ignore -- >.
-->
<blockquote>
<h4 id="mots-cl√©s"><a class="header" href="#mots-cl√©s">Mots-cl√©s</a></h4>
<p>Le langage Rust poss√®de un ensemble de <em>mots-cl√©s</em> qui ont √©t√© r√©serv√©s pour
l'usage exclusif du langage, tout comme le font d'autres langages. Gardez √†
l'esprit que vous ne pouvez pas utiliser ces mots pour des noms de variables
ou de fonctions. La plupart des mots-cl√©s ont une signification sp√©ciale, et
vous les utiliserez pour r√©aliser de diff√©rentes t√¢ches dans vos programmes
Rust¬†; quelques-uns n'ont aucune fonctionnalit√© active pour le moment, mais
ont √©t√© r√©serv√©s pour √™tre ajout√©s plus tard √† Rust.
Vous pouvez trouver la liste de ces mots-cl√©s dans
<a href="appendix-01-keywords.html">l'annexe A</a><!-- ignore -->.</p>
</blockquote>
<!--
[appendix_a]: appendix-01-keywords.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Variables and Mutability
-->
<h2 id="les-variables-et-la-mutabilit√©"><a class="header" href="#les-variables-et-la-mutabilit√©">Les variables et la mutabilit√©</a></h2>
<!--
As mentioned in the [‚ÄúStoring Values with
Variables‚Äù][storing-values-with-variables]<!-- ignore -- > section, by default
variables are immutable. This is one of many nudges Rust gives you to write
your code in a way that takes advantage of the safety and easy concurrency that
Rust offers. However, you still have the option to make your variables mutable.
Let‚Äôs explore how and why Rust encourages you to favor immutability and why
sometimes you might want to opt out.
-->
<p>Tel qu'abord√© au <a href="ch02-00-guessing-game-tutorial.html">chapitre 2</a><!-- ignore -->,
par d√©faut, les variables sont <em>immuables</em>. C'est un des nombreux coups de pouce
de Rust pour √©crire votre code de fa√ßon √† garantir la s√©curit√© et la concurrence
sans probl√®me. Cependant, vous avez quand m√™me la possibilit√© de rendre vos
variables mutables <em>(modifiables)</em>. Explorons comment et pourquoi Rust vous
encourage √† favoriser l'immuabilit√©, et pourquoi parfois vous pourriez choisir
d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you can‚Äôt change
that value. To illustrate this, let‚Äôs generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
li√©e √† un nom, vous ne pouvez pas changer cette valeur. √Ä titre d'illustration,
g√©n√©rons un nouveau projet appel√© <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code. This code won‚Äôt compile just yet, we‚Äôll first
examine the immutability error.
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant. Ce code ne se compile pas pour le
moment, nous allons commencer par √©tudier l'erreur d'immutabilit√©.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ci¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;La valeur de x est¬†: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but really they only mean your program
isn‚Äôt safely doing what you want it to do yet; they do *not* mean that you‚Äôre
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide √† trouver les erreurs dans
vos programmes. Les erreurs de compilation peuvent s'av√©rer frustrantes, mais
elles signifient en r√©alit√© que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute s√©curit√©¬†; elles ne
signifient <em>pas</em> que vous √™tes un mauvais d√©veloppeur¬†! M√™me les Rustac√©s
exp√©riment√©s continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `` cannot
assign twice to immutable variable `x` ``, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du probl√®me est qu'il est
<code>impossible d'assigner √† deux reprises la variable immuable `x`</code>
(<code>cannot assign twice to immutable variable `x`</code>).</p>
<!--
It‚Äôs important that we get compile-time errors when we attempt to change a
value that‚Äôs designated as immutable because this very situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, it‚Äôs possible
that the first part of the code won‚Äôt do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only *sometimes*. The Rust
compiler guarantees that when you state a value won‚Äôt change, it really won‚Äôt
change, so you don‚Äôt have to keep track of it yourself. Your code is thus
easier to reason through.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a √©t√© d√©clar√©e comme immuable,
car cette situation particuli√®re peut donner lieu √† des bogues. Si une partie
de notre code part du principe qu'une valeur ne changera jamais et qu'une autre
partie de notre code modifie cette valeur, il est possible que la premi√®re
partie du code ne fasse pas ce pour quoi elle a √©t√© con√ßue. La cause de ce
genre de bogue peut √™tre difficile √† localiser apr√®s coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur. Le
compilateur Rust garantit que lorsque vous d√©clarez qu'une valeur ne change
pas, elle ne va jamais changer, donc vous n'avez pas √† vous en soucier. Votre
code est ainsi plus facile √† ma√Ætriser.</p>
<!--
But mutability can be very useful, and can make code more convenient to write.
Variables are immutable only by default; as you did in Chapter 2, you can make
them mutable by adding `mut` in front of the variable name. Adding `mut` also
conveys intent to future readers of the code by indicating that other parts of
the code will be changing this variable‚Äôs value.
-->
<p>Mais la mutabilit√© peut s'av√©rer tr√®s utile, et peut faciliter la r√©daction du
code. Les variables sont immuables par d√©faut¬†; mais comme vous l'avez fait au
chapitre 2, vous pouvez les rendre mutables en ajoutant <code>mut</code> devant le nom de
la variable. L'ajout de <code>mut</code> va aussi signaler l'intention aux futurs lecteurs
de ce code que d'autres parties du code vont modifier la valeur de cette
variable.</p>
<!--
For example, let‚Äôs change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsi¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous ex√©cutons le programme, nous obtenons¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
La valeur de x est¬†: 5
La valeur de x est¬†: 6
</code></pre>
<!--
We‚Äôre allowed to change the value bound to `x` from `5` to `6` when `mut`
is used. There are multiple trade-offs to consider in addition to the
prevention of bugs. For example, in cases where you‚Äôre using large data
structures, mutating an instance in place may be faster than copying and
returning newly allocated instances. With smaller data structures, creating new
instances and writing in a more functional programming style may be easier to
think through, so lower performance might be a worthwhile penalty for gaining
that clarity.
-->
<p>En utilisant <code>mut</code>, nous avons permis √† la valeur li√©e √† <code>x</code> de passer de <code>5</code> √†
<code>6</code>. Il y a d'autres compromis √† envisager, en plus de la pr√©vention des
bogues. Par exemple, dans le cas o√π vous utiliseriez des grosses structures de
donn√©es, muter une instance d√©j√† existante peut √™tre plus rapide que copier et
retourner une instance nouvellement allou√©e. Avec des structures de donn√©es
plus petites, cr√©er de nouvelles instances avec un style de programmation
fonctionnelle peut rendre le code plus facile √† comprendre, donc il peut valoir
le coup de sacrifier un peu de performance pour que le code gagne en clart√©.</p>
<!--
### Constants
-->
<h3 id="les-constantes"><a class="header" href="#les-constantes">Les constantes</a></h3>
<!--
Like immutable variables, *constants* are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.
-->
<p>Comme les variables immuables, les <em>constantes</em> sont des valeurs qui sont li√©es
√† un nom et qui ne peuvent √™tre modifi√©es, mais il y a quelques diff√©rences
entre les constantes et les variables.</p>
<!--
First, you aren‚Äôt allowed to use `mut` with constants. Constants aren‚Äôt just
immutable by default‚Äîthey‚Äôre always immutable. You declare constants using the
`const` keyword instead of the `let` keyword, and the type of the value *must*
be annotated. We‚Äôre about to cover types and type annotations in the next
section, [‚ÄúData Types,‚Äù][data-types]<!-- ignore -- > so don‚Äôt worry about the
details right now. Just know that you must always annotate the type.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par d√©faut ‚àí elles sont toujours immuables. On
d√©clare les constantes en utilisant le mot-cl√© <code>const</code> √† la place du mot-cl√©
<code>let</code>, et le type de la valeur <em>doit</em> √™tre indiqu√©. Nous allons aborder les
types et les annotations de types dans la prochaine section, <a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">‚ÄúLes types de
donn√©es‚Äù</a><!-- ignore -->, donc ne vous souciez pas des d√©tails pour
le moment. Sachez seulement que vous devez toujours indiquer le type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent √™tre d√©clar√©es √† n'importe quel endroit du code, y
compris la port√©e globale, ce qui les rend tr√®s utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de conna√Ætre.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a value that could only be computed at runtime.
-->
<p>La derni√®re diff√©rence est que les constantes ne peuvent √™tre d√©finies que par
une expression constante, et non pas le r√©sultat d'une valeur qui ne pourrait
√™tre calcul√©e qu'√† l'ex√©cution.</p>
<!--
Here‚Äôs an example of a constant declaration:
-->
<p>Voici un exemple d'une d√©claration de constante¬†:</p>
<!--
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TROIS_HEURES_EN_SECONDES: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<!--
The constant‚Äôs name is `THREE_HOURS_IN_SECONDS` and its value is set to the
result of multiplying 60 (the number of seconds in a minute) by 60 (the number
of minutes in an hour) by 3 (the number of hours we want to count in this
program). Rust‚Äôs naming convention for constants is to use all uppercase with
underscores between words. The compiler is able to evaluate a limited set of
operations at compile time, which lets us choose to write out this value in a
way that‚Äôs easier to understand and verify, rather than setting this constant
to the value 10,800. See the [Rust Reference‚Äôs section on constant
evaluation][const-eval] for more information on what operations can be used
when declaring constants.
-->
<p>Le nom de la constante est <code>TROIS_HEURES_EN_SECONDES</code> et sa valeur est d√©finie
comme √©tant le r√©sultat de la multiplication de 60 (le nombre de secondes dans
une minute) par 60 (le nombre de minutes dans une heure) par 3 (le nombre
d'heures que nous voulons calculer dans ce programme).
En Rust, la convention de nommage des constantes est de les √©crire tout en
majuscule avec des tirets bas entre les mots. Le compilateur peut calculer un
certain nombre d'op√©rations √† la compilation, ce qui nous permet d'√©crire
cette valeur de fa√ßon √† la comprendre plus facilement et √† la v√©rifier, plut√¥t
que de d√©finir cette valeur √† 10 800. Vous pouvez consulter la <a href="https://doc.rust-lang.org/reference/const_eval.html">section de la
r√©f√©rence Rust √† propos des √©valuations des constantes</a> pour en
savoir plus sur les op√©rations qui peuvent √™tre utilis√©es pour d√©clarer des
constantes.</p>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in. This property makes constants useful for values in your
application domain that multiple parts of the program might need to know about,
such as the maximum number of points any player of a game is allowed to earn or
the speed of light.
-->
<p>Les constantes sont valables pendant toute la dur√©e d'ex√©cution du programme
au sein de la port√©e dans laquelle elles sont d√©clar√©es. Cette caract√©ristique
rends les constantes tr√®s utiles lorsque plusieurs parties du programme doivent
conna√Ætre certaines valeurs, comme par exemple le nombre maximum de points
qu'un joueur est autoris√© √† gagner ou encore la vitesse de la lumi√®re.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>D√©clarer des valeurs cod√©es en dur et utilis√©es tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs d√©veloppeurs. Cela permet √©galement de
n'avoir qu'un seul endroit de votre code √† modifier si cette valeur cod√©e en dur
doit √™tre mise √† jour √† l'avenir.</p>
<!--
### Shadowing
-->
<h3 id="le-masquage"><a class="header" href="#le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in [Chapter
2][comparing-the-guess-to-the-secret-number]<!-- ignore -- >, you can declare a
new variable with the same name as a previous variable. Rustaceans say that the
first variable is *shadowed* by the second, which means that the second
variable‚Äôs value is what the program sees when the variable is used. We can
shadow a variable by using the same variable‚Äôs name and repeating the use of
the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans le <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">Chapitre
2</a><!-- ignore -->, on peut d√©clarer
une nouvelle variable avec le m√™me nom qu'une variable pr√©c√©dente. Les Rustac√©s
disent que la premi√®re variable est <em>masqu√©e</em> par la seconde, ce qui signifie
que la valeur de la seconde variable sera ce que le programme verra lorsque
nous utiliserons cette variable. Nous pouvons cr√©er un masque d'une variable en
utilisant le m√™me nom de variable et en r√©utilisant le mot-cl√© <code>let</code> comme
ci-dessous¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;La valeur de x dans la port√©e interne est : {}&quot;, x);
    }

    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. Then, within an inner scope, the third `let` statement also
shadows `x`, multiplying the previous value by `2` to give `x` a value of `12`.
When that scope is over, the inner shadowing ends and `x` returns to being `6`.
When we run this program, it will output the following:
-->
<p>Au d√©but, ce programme lie <code>x</code> √† la valeur <code>5</code>. Puis il cr√©e un masque de <code>x</code>
en r√©p√©tant <code>let x =</code>, en r√©cup√©rant la valeur d'origine et lui ajoutant <code>1</code>¬†:
la valeur de <code>x</code> est d√©sormais <code>6</code>. Ensuite, √† l'int√©rieur de la port√©e interne,
la troisi√®me instruction <code>let</code> cr√©e un autre masque de <code>x</code>, en r√©cup√©rant la
pr√©c√©dente valeur et en la multipliant par <code>2</code> pour donner √† <code>x</code> la valeur
finale de <code>12</code>. D√®s que nous sortons de cette port√©e, le masque prends fin, et
<code>x</code> revient √† la valeur <code>6</code>. Lorsque nous ex√©cutons ce programme, nous obtenons
ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
La valeur de x dans la port√©e interne est : 12
La valeur de x est¬†: 6
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because we‚Äôll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>Cr√©er un masque est diff√©rent que de marquer une variable comme √©tant <code>mut</code>,
car √† moins d'utiliser une nouvelle fois le mot-cl√© <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de r√©assigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable apr√®s que ces
transformations ont √©t√© appliqu√©es.</p>
<!--
The other difference between `mut` and shadowing is that because we‚Äôre
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, and then we want to store that input as a number:
-->
<p>Comme nous cr√©ons une nouvelle variable lorsque nous utilisons le mot-cl√© <code>let</code>
une nouvelle fois, l'autre diff√©rence entre le <code>mut</code> et la cr√©ation d'un masque
est que cela nous permet de changer le type de la valeur, mais en r√©utilisant
le m√™me nom. Par exemple, imaginons un programme qui demande √† l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, et ensuite nous voulons stocker cette saisie sous forme de
nombre¬†:</p>
<!--
```rust
# fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let espaces = &quot;   &quot;;
    let espaces = espaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
The first `spaces` variable is a string type and the second `spaces` variable
is a number type. Shadowing thus spares us from having to come up with
different names, such as `spaces_str` and `spaces_num`; instead, we can reuse
the simpler `spaces` name. However, if we try to use `mut` for this, as shown
here, we‚Äôll get a compile-time error:
-->
<p>La premi√®re variable <code>espaces</code> est du type cha√Æne de caract√®res <em>(string)</em> et
la seconde variable <code>espaces</code> est du type nombre. L'utilisation du masquage
nous √©vite ainsi d'avoir √† trouver des noms diff√©rents, comme <code>espaces_str</code> et
<code>espaces_num</code>¬†; nous pouvons plut√¥t simplement r√©utiliser le nom <code>espaces</code>.
Cependant, si nous essayons d'utiliser <code>mut</code> pour faire ceci, comme ci-dessous,
nous avons une erreur de compilation¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut espaces = &quot;   &quot;;
    espaces = espaces.len();
<span class="boring">}
</span></code></pre>
<!--
The error says we‚Äôre not allowed to mutate a variable‚Äôs type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variable¬†:</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut espaces = &quot;   &quot;;
  |                       ----- expected due to this value
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
Now that we‚Äôve explored how variables work, let‚Äôs look at more data types they
can have.
-->
<p>Maintenant que nous avons d√©couvert comment fonctionnent les variables, √©tudions
les types de donn√©es qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Data Types
-->
<h2 id="les-types-de-donn√©es"><a class="header" href="#les-types-de-donn√©es">Les types de donn√©es</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. We‚Äôll look at
two data type subsets: scalar and compound.
-->
<p>Chaque valeur en Rust est d'un <em>type</em> bien d√©termin√©, qui indique √† Rust quel
genre de donn√©es il manipule pour qu'il sache comment traiter ces donn√©es.
Nous allons nous int√©resser √† deux cat√©gories de types de donn√©es¬†: les
scalaires et les compos√©s.</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the [‚ÄúComparing the Guess to the Secret
Number‚Äù][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Gardez √† l'esprit que Rust est un langage <em>statiquement typ√©</em>, ce qui signifie
qu'il doit conna√Ætre les types de toutes les variables au moment de la
compilation. Le compilateur peut souvent d√©duire quel type utiliser en se basant
sur la valeur et sur la fa√ßon dont elle est utilis√©e. Dans les cas o√π plusieurs
types sont envisageables, comme lorsque nous avons converti une cha√Æne de
caract√®res en un type num√©rique en utilisant <code>parse</code> dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">‚ÄúComparer le nombre saisi au nombre
secret‚Äù</a><!-- ignore -->
du chapitre 2, nous devons ajouter une annotation de type, comme ceci¬†:</p>
<!--
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let supposition: u32 = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre¬†!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
If we don‚Äôt add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>Si nous n'ajoutons pas l'annotation de type ici, Rust affichera l'erreur
suivante, signifiant que le compilateur a besoin de plus d'informations pour
d√©terminer quel type nous souhaitons utiliser¬†:</p>
<!--
```console
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 -- > src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let supposition = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre¬†!&quot;);
  |         ^^^^^^^^^^^ consider giving `supposition` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<!--
You‚Äôll see different type annotations for other data types.
-->
<p>Vous d√©couvrirez diff√©rentes annotations de type au fur et √† mesure que nous
aborderons les autres types de donn√©es.</p>
<!--
### Scalar Types
-->
<h3 id="types-scalaires"><a class="header" href="#types-scalaires">Types scalaires</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let‚Äôs jump into how they work in Rust.
-->
<p>Un type <em>scalaire</em> repr√©sente une seule valeur. Rust poss√®de quatre types
principaux de scalaires¬†: les entiers, les nombres √† virgule flottante, les
bool√©ens et les caract√®res. Vous les connaissez s√ªrement d'autres langages de
programmation. Regardons comment ils fonctionnent avec Rust.</p>
<!--
#### Integer Types
-->
<h4 id="types-de-nombres-entiers"><a class="header" href="#types-de-nombres-entiers">Types de nombres entiers</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value it‚Äôs associated with should be an unsigned integer (signed integer types
start with `i`, instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. We can use any of these variants to declare
the type of an integer value.
-->
<p>Un <em>entier</em> est un nombre sans partie d√©cimale. Nous avons utilis√© un entier
pr√©c√©demment dans le chapitre 2, le type <code>u32</code>. Cette d√©claration de type
indique que la valeur √† laquelle elle est associ√©e doit √™tre un entier non sign√©
encod√© sur 32 bits dans la m√©moire (les entiers pouvant prendre des valeurs
n√©gatives commencent par un <code>i</code> (comme <em>integer</em>¬†: ‚Äúentier‚Äù), plut√¥t que par un
<code>u</code> comme <em>unsigned</em>¬†: ‚Äúnon sign√©‚Äù). Le tableau 3-1 montre les types
d'entiers int√©gr√©s au langage. Nous pouvons utiliser chacune de ces variantes
pour d√©clarer le type d'une valeur enti√®re.</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">Tableau 3-1¬†: les types d'entiers en Rust</span></p>
<!--
| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |
-->
<table><thead><tr><th>Taille</th><th>Sign√©</th><th>Non sign√©</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>archi</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refer to whether it‚Äôs possible for the number to be
negative‚Äîin other words, whether the number needs to have a sign with it
(signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It‚Äôs like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it‚Äôs safe to assume the number is positive, it‚Äôs shown with no sign.
Signed numbers are stored using [two‚Äôs
complement](https://en.wikipedia.org/wiki/Two%27s_complement)<!-- ignore -- >
representation.
-->
<p>Chaque variante peut √™tre sign√©e ou non sign√©e et poss√®de une taille explicite.
<em>Sign√©</em> et <em>non sign√©</em> veut dire respectivement que le nombre peut prendre ou
non des valeurs n√©gatives ‚Äî en d'autres termes, si l'on peut lui attribuer un
signe (sign√©) ou s'il sera toujours positif et que l'on peut donc le repr√©senter
sans signe (non sign√©). C'est comme √©crire des nombres sur du papier¬†: quand le
signe est important, le nombre est √©crit avec un signe plus ou un signe moins¬†;
en revanche, quand le nombre est forc√©ment positif, on peut l'√©crire sans son
signe. Les nombres sign√©s sont stock√©s en utilisant le <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">compl√©ment √†
deux</a><!-- ignore -->.</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>Chaque variante sign√©e peut stocker des nombres allant de ‚àí(2<sup><em>n</em> ‚àí 1</sup>)
√† 2<sup><em>n</em> ‚àí 1</sup> ‚àí 1 inclus, o√π <em>n</em> est le nombre de bits que cette
variante utilise.
Un <code>i8</code> peut donc stocker des nombres allant de ‚àí(2<sup>7</sup>) √†
2<sup>7</sup> ‚àí 1, c'est-√†-dire de ‚àí128 √† 127. Les variantes non sign√©es peuvent
stocker des nombres de 0 √† 2<sup><em>n</em></sup> ‚àí 1, donc un <code>u8</code> peut stocker
des nombres allant de 0 √† 2<sup>8</sup> ‚àí 1, c'est-√†-dire de 0 √† 255.</p>
<!--
Additionally, the `isize` and `usize` types depend on the architecture of the
computer your program is running on, which is denoted in the table as ‚Äúarch‚Äù:
64 bits if you‚Äôre on a 64-bit architecture and 32 bits if you‚Äôre on a 32-bit
architecture.
-->
<p>De plus, les types <code>isize</code> et <code>usize</code> d√©pendent de l'architecture de
l'ordinateur sur lequel votre programme va s'ex√©cuter, d'o√π la ligne ‚Äúarchi‚Äù¬†:
64 bits si vous utilisez une architecture 64 bits, ou 32 bits si vous utilisez
une architecture 32 bits.</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as `57u8`, to designate the type. Number literals can also use `_` as a
visual separator to make the number easier to read, such as `1_000`, which will
have the same value as if you had specified `1000`.
-->
<p>Vous pouvez √©crire des litt√©raux d'entiers dans chacune des formes d√©crites dans
le tableau 3-2. Notez que les litt√©raux num√©riques qui peuvent √™tre de plusieurs types
num√©riques autorisent l'utilisation d'un suffixe de type, tel que <code>57u8</code>, afin de
pr√©ciser leur type. Les nombres litt√©raux peuvent aussi utiliser <code>_</code> comme
s√©parateur visuel afin de les rendre plus lisible, comme par exemple <code>1_000</code>,
qui a la m√™me valeur que si vous aviez renseign√© <code>1000</code>.</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">Tableau 3-2¬†: les litt√©raux d'entiers en Rust</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>Litt√©ral num√©rique</th><th>Exemple</th></tr></thead><tbody>
<tr><td>D√©cimal</td><td><code>98_222</code></td></tr>
<tr><td>Hexad√©cimal</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binaire</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Octet (<code>u8</code> seulement)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If you‚Äôre unsure, Rust‚Äôs
defaults are generally good places to start: integer types default to `i32`.
The primary situation in which you‚Äôd use `isize` or `usize` is when indexing
some sort of collection.
-->
<p>Comment pouvez-vous d√©terminer le type d'entier √† utiliser¬†? Si vous n'√™tes pas
s√ªr, les choix par d√©faut de Rust sont g√©n√©ralement de bons choix¬†: le type
d'entier par d√©faut est le <code>i32</code>. La principale utilisation d'un <code>isize</code> ou d'un
<code>usize</code> est lorsque l'on indexe une quelconque collection.</p>
<!--
> ##### Integer Overflow
>
> Let‚Äôs say you have a variable of type `u8` that can hold values between 0 and
> 255. If you try to change the variable to a value outside of that range, such
> as 256, *integer overflow* will occur, which can result in one of two
> behaviors. When you‚Äôre compiling in debug mode, Rust includes checks for
> integer overflow that cause your program to *panic* at runtime if this
> behavior occurs. Rust uses the term panicking when a program exits with an
> error; we‚Äôll discuss panics in more depth in the [‚ÄúUnrecoverable Errors with
> `panic!`‚Äù][unrecoverable-errors-with-panic]<!-- ignore -- > section in Chapter
> 9.
>
> When you‚Äôre compiling in release mode with the `--release` flag, Rust does
> *not* include checks for integer overflow that cause panics. Instead, if
> overflow occurs, Rust performs *two‚Äôs complement wrapping*. In short, values
> greater than the maximum value the type can hold ‚Äúwrap around‚Äù to the minimum
> of the values the type can hold. In the case of a `u8`, the value 256 becomes
> 0, the value 257 becomes 1, and so on. The program won‚Äôt panic, but the
> variable will have a value that probably isn‚Äôt what you were expecting it to
> have. Relying on integer overflow‚Äôs wrapping behavior is considered an error.
>
> To explicitly handle the possibility of overflow, you can use these families
> of methods provided by the standard library for primitive numeric types:
>
> - Wrap in all modes with the `wrapping_*` methods, such as `wrapping_add`
> - Return the `None` value if there is overflow with the `checked_*` methods
> - Return the value and a boolean indicating whether there was overflow with
>   the `overflowing_*` methods
> - Saturate at the value‚Äôs minimum or maximum values with `saturating_*`
>   methods
-->
<blockquote>
<h5 id="d√©passement-dentier"><a class="header" href="#d√©passement-dentier">D√©passement d'entier</a></h5>
<p>Imaginons que vous avez une variable de type <code>u8</code> qui peut stocker des
valeurs entre 0 et 255. Si vous essayez de changer la variable pour une valeur
en dehors de cet intervalle, comme 256, vous aurez un d√©passement d'entier
<em>(integer overflow)</em>, qui peut se compter de deux mani√®re. Lorsque vous
compilez en mode d√©bogage, Rust embarque des v√©rifications pour d√©tecter les
cas de d√©passements d'entiers qui pourraient faire <em>paniquer</em> votre programme
√† l'ex√©cution si ce ph√©nom√®ne se produit. Rust utilise le terme <em>paniquer</em>
quand un programme se termine avec une erreur¬†; nous verrons plus en d√©tail
les <em>paniques</em> dans une section du <a href="ch09-01-unrecoverable-errors-with-panic.html">chapitre
9</a><!-- ignore -->.</p>
<p>Lorsque vous compilez en mode publication <em>(release)</em> avec le drapeau
<code>--release</code>, Rust ne va <em>pas</em> v√©rifier les potentiels d√©passements d'entiers
qui peuvent faire paniquer le programme. En revanche, en cas de d√©passement,
Rust va effectuer un <em>rebouclage du compl√©ment √† deux</em>. Pour faire simple, les
valeurs sup√©rieures √† la valeur maximale du type seront ‚Äúreboucl√©es‚Äù depuis la
valeur minimale que le type peut stocker. Dans le cas d'un <code>u8</code>, la valeur 256
devient 0, la valeur 257 devient 1, et ainsi de suite. Le programme ne va
paniquer, mais la variable va avoir une valeur qui n'est probablement pas ce
que vous attendez √† avoir. Se fier au comportement du rebouclage lors du
d√©passement d'entier est consid√©r√© comme une faute.</p>
<p>Pour g√©rer explicitement le d√©passement, vous pouvez utiliser les familles
de m√©thodes suivantes qu'offrent la biblioth√®que standard sur les types de
nombres primitifs¬†:</p>
<ul>
<li>Enveloppez les op√©rations avec les m√©thodes <code>wrapping_*</code>, comme par exemple
<code>wrapping_add</code></li>
<li>Retourner la valeur <code>None</code> s'il y a un d√©passement avec des m√©thodes
<code>checked_*</code></li>
<li>Retourner la valeur et un bool√©en qui indique s'il y a eu un d√©passement
avec des m√©thodes <code>overflowing_*</code></li>
<li>Saturer √† la valeur minimale ou maximale avec des m√©thodes <code>saturating_*</code></li>
</ul>
</blockquote>
<!--
#### Floating-Point Types
-->
<h4 id="types-de-nombres-√†-virgule-flottante"><a class="header" href="#types-de-nombres-√†-virgule-flottante">Types de nombres √† virgule flottante</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rust‚Äôs floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs it‚Äôs roughly the same speed as `f32` but is capable of
more precision. All floating-point types are signed.
-->
<p>Rust poss√®de √©galement deux types primitifs pour les <em>nombres √† virgule
flottante</em> (ou <em>flottants</em>), qui sont des nombres avec des d√©cimales. Les types
de flottants en Rust sont les <code>f32</code> et les <code>f64</code>, qui ont respectivement une
taille en m√©moire de 32 bits et 64 bits. Le type par d√©faut est le <code>f64</code> car sur
les processeurs r√©cents ce type est quasiment aussi rapide qu'un <code>f32</code> mais est
plus pr√©cis. Tous les flottants ont un signe.</p>
<!--
Here‚Äôs an example that shows floating-point numbers in action:
-->
<p>Voici un exemple montrant l'utilisation de nombres √† virgule flottante¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Ficher¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>Les nombres √† virgule flottante sont repr√©sent√©s selon la norme IEEE-754. Le
type <code>f32</code> est un flottant √† simple pr√©cision, et le <code>f64</code> est √† double
pr√©cision.</p>
<!--
#### Numeric Operations
-->
<h4 id="les-op√©rations-num√©riques"><a class="header" href="#les-op√©rations-num√©riques">Les op√©rations num√©riques</a></h4>
<!--
Rust supports the basic mathematical operations you‚Äôd expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
Integer division rounds down to the nearest integer. The following code shows
how you‚Äôd use each numeric operation in a `let` statement:
-->
<p>Rust offre les op√©rations math√©matiques de base dont vous auriez besoin pour
tous les types de nombres¬†: addition, soustraction, multiplication, division et
modulo. Les divisions d'entiers arrondissent le r√©sultat √† l'entier le plus
pr√®s. Le code suivant montre comment utiliser chacune des op√©rations num√©riques
avec une instruction <code>let</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let somme = 5 + 10;

    // soustraction
    let difference = 95.5 - 4.3;

    // multiplication
    let produit = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let arrondi = 2 / 3; // retournera 0

    // modulo
    let reste = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. [Appendix B][appendix_b]<!-- ignore -- > contains a
list of all operators that Rust provides.
-->
<p>Chaque expression de ces instructions utilise un op√©rateur math√©matique et
calcule une valeur unique, qui est ensuite attribu√©e √† une variable. <a href="appendix-02-operators.html">L'annexe B</a><!-- ignore -->
pr√©sente une liste de tous les op√©rateurs que Rust fournit.</p>
<!--
#### The Boolean Type
-->
<h4 id="le-type-bool√©en"><a class="header" href="#le-type-bool√©en">Le type bool√©en</a></h4>
<!--
As in most other programming languages, a Boolean type in Rust has two possible
values: `true` and `false`. Booleans are one byte in size. The Boolean type in
Rust is specified using `bool`. For example:
-->
<p>Comme dans la plupart des langages de programmation, un type bool√©en a deux
valeurs possibles en Rust¬†: <code>true</code> (vrai) et <code>false</code> (faux). Les bool√©ens
prennent un octet en m√©moire. Le type bool√©en est d√©sign√© en utilisant <code>bool</code>.
Par exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // avec une annotation de type explicite
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. We‚Äôll cover how `if` expressions work in Rust in the [‚ÄúControl
Flow‚Äù][control-flow]<!-- ignore -- > section.
-->
<p>Les valeurs bool√©ennes sont principalement utilis√©es par les structures
conditionnelles, comme l'expression <code>if</code>. Nous aborderons le fonctionnement
de <code>if</code> en Rust dans la section
<a href="ch03-05-control-flow.html#les-structures-de-contr%C3%B4le">‚ÄúLes structures de contr√¥le‚Äù</a><!-- ignore -->.</p>
<!--
#### The Character Type
-->
<h4 id="le-type-caract√®re"><a class="header" href="#le-type-caract√®re">Le type caract√®re</a></h4>
<!--
Rust‚Äôs `char` type is the language‚Äôs most primitive alphabetic type. Here‚Äôs
some examples of declaring `char` values:
-->
<p>Le type <code>char</code> (comme <em>character</em>) est le type de caract√®re le plus
rudimentaire. Voici quelques exemples de d√©claration de valeurs de type
<code>char</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let heart_eyed_cat = 'üòª';
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let chat_aux_yeux_de_coeur = 'üòª';
}
</code></pre></pre>
<!--
Note that we specify `char` literals with single quotes, as opposed to string
literals, which use double quotes. Rust‚Äôs `char` type is four bytes in size and
represents a Unicode Scalar Value, which means it can represent a lot more than
just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji;
and zero-width spaces are all valid `char` values in Rust. Unicode Scalar
Values range from `U+0000` to `U+D7FF` and `U+E000` to `U+10FFFF` inclusive.
However, a ‚Äúcharacter‚Äù isn‚Äôt really a concept in Unicode, so your human
intuition for what a ‚Äúcharacter‚Äù is may not match up with what a `char` is in
Rust. We‚Äôll discuss this topic in detail in [‚ÄúStoring UTF-8 Encoded Text with
Strings‚Äù][strings]<!-- ignore -- > in Chapter 8.
-->
<p>Notez que nous renseignons un lit√©ral <code>char</code> avec des guillemets simples,
contrairement aux litt√©raux de cha√Æne de caract√®res, qui n√©c√©ssite des doubles
guillemets. Le type <code>char</code> de Rust prend quatre octets en m√©moire et repr√©sente
une valeur scalaire Unicode, ce qui veut dire que cela repr√©sente plus de
caract√®res que l'ASCII. Les lettres accentu√©es¬†; les caract√®res chinois,
japonais et cor√©ens¬†; les emoji¬†; les espaces de largeur nulle ont tous une
valeur pour <code>char</code> avec Rust. Les valeurs scalaires Unicode vont de <code>U+0000</code> √†
<code>U+D7FF</code> et de <code>U+E000</code> √† <code>U+10FFFF</code> inclus. Cependant, le concept de
‚Äúcaract√®re‚Äù n'est pas clairement d√©fini par Unicode, donc votre notion de
‚Äúcaract√®re‚Äù peut ne pas correspondre √† ce qu'est un <code>char</code> en Rust. Nous
aborderons ce sujet plus en d√©tail au <a href="ch08-02-strings.html">chapitre 8</a><!-- ignore -->.</p>
<!--
### Compound Types
-->
<h3 id="les-types-compos√©s"><a class="header" href="#les-types-compos√©s">Les types compos√©s</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p>Les <em>types compos√©s</em> peuvent regrouper plusieurs valeurs dans un seul type. Rust
a deux types compos√©s de base¬†: les <em>tuples</em> et les tableaux <em>(arrays)</em>.</p>
<!--
#### The Tuple Type
-->
<h4 id="le-type-tuple"><a class="header" href="#le-type-tuple">Le type <em>tuple</em></a></h4>
<!--
A tuple is a general way of grouping together a number of values with a variety
of types into one compound type. Tuples have a fixed length: once declared,
they cannot grow or shrink in size.
-->
<p>Un <em>tuple</em> est une mani√®re g√©n√©rale de regrouper plusieurs valeurs
de types diff√©rents en un seul type compos√©. Les tuples ont une taille fix√©e¬†:
√† partir du moment o√π ils ont √©t√© d√©clar√©s, on ne peut pas y ajouter ou enlever
des valeurs.</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don‚Äôt have to be the same. We‚Äôve added optional
type annotations in this example:
-->
<p>Nous cr√©ons un <em>tuple</em> en √©crivant une liste s√©par√©e par des virgules entre des
parenth√®ses. Chaque emplacement dans le tuple a un type, et les types de chacune
des valeurs dans le tuple n'ont pas forc√©ment besoin d'√™tre les m√™mes.
Nous avons ajout√© des annotations de type dans cet exemple, mais c'est
optionnel¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>La variable <code>tup</code> est li√©e √† tout le tuple, car un tuple est consid√©r√©
comme √©tant un unique √©l√©ment compos√©. Pour obtenir un √©l√©ment pr√©cis de ce
tuple, nous pouvons utiliser un filtrage par motif <em>(pattern matching)</em> pour
d√©structurer ce tuple, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;La valeur de y est¬†: {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>Le programme commence par cr√©er un tuple et il l'assigne √† la variable <code>tup</code>.
Il utilise ensuite un motif avec <code>let</code> pour prendre <code>tup</code> et le scinder en
trois variables distinctes¬†: <code>x</code>, <code>y</code>, et <code>z</code>.
On appelle cela <em>d√©structurer</em>, car il divise le tuple en trois parties.
Puis finalement, le programme affiche la valeur de <code>y</code>, qui est <code>6.4</code>.</p>
<!--
We can also access a tuple element directly by using a period (`.`) followed by
the index of the value we want to access. For example:
-->
<p>Nous pouvons aussi acc√©der directement √† chaque √©l√©ment du tuple en utilisant
un point (<code>.</code>) suivi de l'indice de la valeur que nous souhaitons obtenir. Par
exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let cinq_cents = x.0;

    let six_virgule_quatre = x.1;

    let un = x.2;
}
</code></pre></pre>
<!--
This program creates the tuple `x` and then makes new variables for each
element by using their respective indices. As with most programming languages,
the first index in a tuple is 0.
-->
<p>Ce programme cr√©e le tuple <code>x</code> puis cr√©e une nouvelle variable pour
chaque √©l√©ment en utilisant leur indices respectifs. Comme dans de nombreux
langages de programmation, le premier indice d'un tuple est 0.</p>
<!--
The tuple without any values, `()`, is a special type that has only one value,
also written `()`. The type is called the *unit type* and the value is called
the *unit value*. Expressions implicitly return the unit value if they don‚Äôt
return any other value.
-->
<p>Le tuple sans aucune valeur, <code>()</code>, est un type sp√©cial qui a une seule et unique
valeur, qui s'√©crit aussi <code>()</code>. Ce type est aussi appel√© le <em>type unit√©</em> et la
valeur est appel√©e <em>valeur unit√©</em>. Les expressions retournent implicitement la
valeur unit√© si elles ne retournent aucune autre valeur.</p>
<!--
#### The Array Type
-->
<h4 id="le-type-tableau"><a class="header" href="#le-type-tableau">Le type tableau</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Unlike arrays in
some other languages, arrays in Rust have a fixed length.
-->
<p>Un autre moyen d'avoir une collection de plusieurs valeurs est d'utiliser
un <em>tableau</em>. Contrairement aux tuples, chaque √©l√©ment d'un tableau doit √™tre du
m√™me type. Contrairement aux tableaux de certains autres langages, les tableaux
de Rust ont une taille fixe.</p>
<!--
We write the values in an array as a comma-separated list inside square
brackets:
-->
<p>Nous √©crivons les valeurs dans un tableau via une liste entre des crochets,
s√©par√©e par des virgules¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in [Chapter
4][stack-and-heap]<!-- ignore -- >) or when you want to ensure you always have a
fixed number of elements. An array isn‚Äôt as flexible as the vector type,
though. A vector is a similar collection type provided by the standard library
that *is* allowed to grow or shrink in size. If you‚Äôre unsure whether to use an
array or a vector, chances are you should use a vector. [Chapter
8][vectors]<!-- ignore -- > discusses vectors in more detail.
-->
<p>Les tableaux sont utiles quand vous voulez que vos donn√©es soient allou√©es sur
la pile <em>(stack)</em> plut√¥t que sur le tas <em>(heap)</em> (nous expliquerons la pile et
le tas au chapitre 4) ou lorsque vous voulez vous assurer que vous avez toujours
un nombre fixe d'√©l√©ments. Cependant, un tableau n'est pas aussi flexible qu'un
vecteur <em>(vector)</em>. Un vecteur est un type de collection de donn√©es similaire
qui est fourni par la biblioth√®que standard qui, lui, peut grandir ou r√©tr√©cir
en taille. Si vous ne savez pas si vous devez utiliser un tableau ou un
vecteur, il y a de fortes chances que vous devriez utiliser un vecteur. Le
<a href="ch08-01-vectors.html">chapitre 8</a><!-- ignore --> expliquera les vecteurs.</p>
<!--
However, arrays are more useful when you know the number of elements will not
need to change. For example, if you were using the names of the month in a
program, you would probably use an array rather than a vector because you know
it will always contain 12 elements:
-->
<p>Toutefois, les tableaux s'av√®rent plus utiles lorsque vous savez que le nombre
d'√©l√©ments n'aura pas besoin de changer. Par exemple, si vous utilisez les noms
des mois dans un programme, vous devriez probablement utiliser un tableau
plut√¥t qu'un vecteur car vous savez qu'il contient toujours 12 √©l√©ments¬†:</p>
<!--
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mois = [&quot;Janvier&quot;, &quot;F√©vrier&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;,
            &quot;Ao√ªt&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;D√©cembre&quot;];
<span class="boring">}
</span></code></pre></pre>
<!--
You write an array‚Äôs type using square brackets with the type of each element,
a semicolon, and then the number of elements in the array, like so:
-->
<p>Vous pouvez √©crire le type d'un tableau en utilisant des crochets et entre ces
crochets y ajouter le type de chaque √©l√©ment, un point-virgule, et ensuite le
nombre d'√©l√©ments dans le tableau, comme ceci¬†:</p>
<!--
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the array contains five elements.
-->
<p>Ici, <code>i32</code> est le type de chaque √©l√©ment. Apr√®s le point-virgule, le nombre <code>5</code>
indique que le tableau contient cinq √©l√©ments.</p>
<!--
You can also initialize an array to contain the same value for each element by
specifying the initial value, followed by a semicolon, and then the length of
the array in square brackets, as shown here:
-->
<p>Vous pouvez initialiser un tableau pour qu'il contienne toujours la m√™me valeur
pour chaque √©l√©ment, vous pouvez pr√©ciser la valeur initiale, suivie par un
point-virgule, et ensuite la taille du tableau, le tout entre crochets, comme
ci-dessous¬†:</p>
<!--
```rust
let a = [3; 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>Le tableau <code>a</code> va contenir <code>5</code> √©l√©ments qui auront tous la valeur
initiale <code>3</code>. C'est la m√™me chose que d'√©crire <code>let a = [3, 3, 3, 3, 3];</code> mais
de mani√®re plus concise.</p>
<!--
##### Accessing Array Elements
-->
<h5 id="acc√©der-aux-√©l√©ments-dun-tableau"><a class="header" href="#acc√©der-aux-√©l√©ments-dun-tableau">Acc√©der aux √©l√©ments d'un tableau</a></h5>
<!--
An array is a single chunk of memory of a known, fixed size that can be
allocated on the stack. You can access elements of an array using indexing,
like this:
-->
<p>Un tableau est un simple bloc de m√©moire de taille connue et fixe, qui peut √™tre
allou√© sur la pile. Vous pouvez acc√©der aux √©l√©ments d'un tableau en utilisant
l'indexation, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let premier = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>Dans cet exemple, la variable qui s'appelle <code>premier</code> aura la valeur <code>1</code>, car
c'est la valeur √† l'indice <code>[0]</code> dans le tableau. La variable <code>second</code>
r√©cup√®rera la valeur <code>2</code> depuis l'indice <code>[1]</code> du tableau.</p>
<!--
##### Invalid Array Element Access
-->
<h5 id="acc√®s-incorrect-√†-un-√©l√©ment-dun-tableau"><a class="header" href="#acc√®s-incorrect-√†-un-√©l√©ment-dun-tableau">Acc√®s incorrect √† un √©l√©ment d'un tableau</a></h5>
<!--
Let‚Äôs see what happens if you try to access an element of an array that is past
the end of the array. Say you run this code, similar to the guessing game in
Chapter 2, to get an array index from the user:
-->
<p>D√©couvrons ce qui se passe quand vous essayez d'acc√©der √† un √©l√©ment d'un
tableau qui se trouve apr√®s la fin du tableau¬†? Imaginons que vous ex√©cutiez le
code suivant, similaire au jeu du plus ou du moins du chapitre 2, pour demander
un indice de tableau √† l'utilisateur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,panics
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```
-->
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Veuillez entrer un indice de tableau.&quot;);

    let mut indice = String::new();

    io::stdin()
        .read_line(&amp;mut indice)
        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);

    let indice: usize = indice
        .trim()
        .parse()
        .expect(&quot;L'indice entr√© n'est pas un nombre&quot;);

    let element = a[indice];

    println!(
        &quot;La valeur de l'√©l√©ment d'indice {} est¬†: {}&quot;,
        indice, element
    );
}
</code></pre>
<!--
This code compiles successfully. If you run this code using `cargo run` and
enter 0, 1, 2, 3, or 4, the program will print out the corresponding value at
that index in the array. If you instead enter a number past the end of the
array, such as 10, you‚Äôll see output like this:
-->
<p>Ce code compile avec succ√®s. Si vous ex√©cutez ce code avec <code>cargo run</code> et que
vous entrez 0, 1, 2, 3 ou 4, le programme affichera la valeur correspondante √†
cet indice dans le tableau. Si au contraire, vous entrez un indice apr√®s la fin
du tableau tel que 10, ceci s'affichera¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-- >

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The program resulted in a *runtime* error at the point of using an invalid
value in the indexing operation. The program exited with an error message and
didn‚Äôt execute the final `println!` statement. When you attempt to access an
element using indexing, Rust will check that the index you‚Äôve specified is less
than the array length. If the index is greater than or equal to the length,
Rust will panic. This check has to happen at runtime, especially in this case,
because the compiler can‚Äôt possibly know what value a user will enter when they
run the code later.
-->
<p>Le programme a rencontr√© une erreur <em>√† l'ex√©cution</em>, au moment d'utiliser une
valeur invalide comme indice. Le programme s'est arr√™t√© avec un message d'erreur
et n'a pas ex√©cut√© la derni√®re instruction <code>println!</code>. Quand vous essayez
d'acc√©der √† un √©l√©ment en utilisant l'indexation, Rust va v√©rifier que l'indice
que vous avez demand√© est plus petit que la taille du tableau. Si l'indice est
sup√©rieur ou √©gal √† la taille du tableau, Rust va <em>paniquer</em>. Cette v√©rification
doit avoir lieu √† l'ex√©cution, surtout dans ce cas, parce que le compilateur ne
peut pas deviner la valeur qu'entrera l'utilisateur quand il ex√©cutera le code
plus tard.</p>
<!--
This is an example of Rust‚Äôs memory safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust‚Äôs error handling.
-->
<p>C'est un exemple de mise en pratique des principes de s√©curit√© de la m√©moire par
Rust. Dans de nombreux langages de bas niveau, ce genre de v√©rification n'est
pas effectu√©e, et quand vous utilisez un indice incorrect, de la m√©moire
invalide peut √™tre r√©cup√©r√©e. Rust vous prot√®ge de ce genre d'erreur en quittant
imm√©diatement l'ex√©cution au lieu de permettre l'acc√®s en m√©moire et continuer
son d√©roulement. Le chapitre 9 expliquera la gestion d'erreurs de Rust.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[wrapping]: ../std/num/struct.Wrapping.html
[appendix_b]: appendix-02-operators.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Functions
-->
<h2 id="les-fonctions"><a class="header" href="#les-fonctions">Les fonctions</a></h2>
<!--
Functions are prevalent in Rust code. You‚Äôve already seen one of the most
important functions in the language: the `main` function, which is the entry
point of many programs. You‚Äôve also seen the `fn` keyword, which allows you to
declare new functions.
-->
<p>Les fonctions sont tr√®s utilis√©es dans le code Rust. Vous avez d√©j√† vu l'une des
fonctions les plus importantes du langage¬†: la fonction <code>main</code>, qui est le point
d'entr√©e de beaucoup de programmes. Vous avez aussi vu le mot-cl√© <code>fn</code>, qui vous
permet de d√©clarer des nouvelles fonctions.</p>
<!--
Rust code uses *snake case* as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words.
Here‚Äôs a program that contains an example function definition:
-->
<p>Le code Rust utilise le <em>snake case</em> comme convention de style de nom des
fonctions et des variables, toutes les lettres sont en minuscule et on utilise
des tirets bas pour s√©parer les mots. Voici un programme qui est un exemple de
d√©finition de fonction¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    une_autre_fonction();
}

fn une_autre_fonction() {
    println!(&quot;Une autre fonction.&quot;);
}
</code></pre></pre>
<!--
We define a function in Rust by entering `fn` followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function
body begins and ends.
-->
<p>Nous d√©finissons une fonction avec Rust en saisissant <code>fn</code> suivi par un nom de
fonction ainsi qu'une paire de parenth√®ses. Les accolades indiquent au
compilateur o√π le corps de la fonction commence et o√π il se termine.</p>
<!--
We can call any function we‚Äôve defined by entering its name followed by a set
of parentheses. Because `another_function` is defined in the program, it can be
called from inside the `main` function. Note that we defined `another_function`
*after* the `main` function in the source code; we could have defined it before
as well. Rust doesn‚Äôt care where you define your functions, only that they‚Äôre
defined somewhere.
-->
<p>Nous pouvons appeler n'importe quelle fonction que nous avons d√©finie en
utilisant son nom, suivi d'une paire de parenth√®ses. Comme <code>une_autre_fonction</code>
est d√©finie dans le programme, elle peut √™tre appel√©e √† l'int√©rieur de la
fonction <code>main</code>. Remarquez que nous avons d√©fini <code>une_autre_fonction</code> <em>apr√®s</em>
la fonction <code>main</code> dans le code source¬†; nous aurions aussi pu la d√©finir avant.
Rust ne se soucie pas de l'endroit o√π vous d√©finissez vos fonctions, du moment
qu'elles sont bien d√©finies quelque part.</p>
<!--
Let‚Äôs start a new binary project named *functions* to explore functions
further. Place the `another_function` example in *src/main.rs* and run it. You
should see the following output:
-->
<p>Cr√©ons un nouveau projet de binaire qui s'appellera <em>functions</em> afin d'en
apprendre plus sur les fonctions. Ajoutez l'exemple <code>une_autre_fonction</code> dans le
<em>src/main.rs</em> et ex√©cutez-le. Vous devriez avoir ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Une autre fonction.
</code></pre>
<!--
The lines execute in the order in which they appear in the `main` function.
First, the ‚ÄúHello, world!‚Äù message prints, and then `another_function` is
called and its message is printed.
-->
<p>Les lignes s'ex√©cutent dans l'ordre dans lequel elles apparaissent dans la
fonction <code>main</code>. D'abord, le message <code>Hello, world!</code> est √©crit, et ensuite
<code>une_autre_fonction</code> est appel√©e et son message est affich√©.</p>
<!--
### Parameters
-->
<h3 id="les-param√®tres"><a class="header" href="#les-param√®tres">Les param√®tres</a></h3>
<!--
We can define functions to have *parameters*, which are special variables that
are part of a function‚Äôs signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called *arguments*, but in casual conversation, people tend to use
the words *parameter* and *argument* interchangeably for either the variables
in a function‚Äôs definition or the concrete values passed in when you call a
function.
-->
<p>Nous pouvons d√©finir des fonctions avec des <em>param√®tres</em>, qui sont des
variables sp√©ciales qui font partie de la signature de la fonction. Quand une
fonction a des param√®tres, vous pouvez lui fournir des valeurs concr√®tes avec
ces param√®tres. Techniquement, ces valeurs concr√®tes sont appel√©es des
<em>arguments</em>, mais dans une conversation courante, on a tendance √†
confondre les termes <em>param√®tres</em> et <em>arguments</em> pour d√©signer soit les
variables dans la d√©finition d'une fonction, soit les valeurs concr√®tes pass√©es
quand on appelle une fonction.</p>
<!--
In this version of `another_function` we add a parameter:
-->
<p>Dans cette version de <code>une_autre_fonction</code>, nous ajoutons un param√®tre¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    une_autre_fonction(5);
}

fn une_autre_fonction(x: i32) {
    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre></pre>
<!--
Try running this program; you should get the following output:
-->
<p>En ex√©cutant ce programme, vous devriez obtenir ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
La valeur de x est¬†: 5
</code></pre>
<!--
The declaration of `another_function` has one parameter named `x`. The type of
`x` is specified as `i32`. When we pass `5` in to `another_function`, the
`println!` macro puts `5` where the pair of curly brackets were in the format
string.
-->
<p>La d√©claration de <code>une_autre_fonction</code> a un param√®tre nomm√© <code>x</code>. Le type de
<code>x</code> a √©t√© d√©clar√© comme <code>i32</code>. Quand nous passons <code>5</code> √† <code>une_autre_fonction</code>, la
macro <code>println!</code> place <code>5</code> l√† o√π la paire d'accolades <code>{}</code> a √©t√© plac√©e dans la
cha√Æne de formatage.</p>
<!--
In function signatures, you *must* declare the type of each parameter. This is
a deliberate decision in Rust‚Äôs design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean.
-->
<p>Dans la signature d'une fonction, vous <em>devez</em> d√©clarer le type de chaque
param√®tre. C'est un choix d√©lib√©r√© de conception de Rust¬†: exiger l'annotation
de type dans la d√©finition d'une fonction fait en sorte que le compilateur n'a
presque plus besoin que vous les utilisiez autre part pour qu'il comprenne avec
quel type vous souhaitez travailler.</p>
<!--
When defining multiple parameters, separate the parameter declarations with
commas, like this:
-->
<p>Lorsque vous d√©finissez plusieurs param√®tres, s√©parez les param√®tres avec des
virgules, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    afficher_mesure_avec_unite(5, 'h');
}

fn afficher_mesure_avec_unite(valeur: i32, unite: char) {
    println!(&quot;La mesure est : {}{}&quot;, valeur, unite);
}
</code></pre></pre>
<!--
This example creates a function named `print_labeled_measurement` with two
parameters. The first parameter is named `value` and is an `i32`. The second is
named `unit_label` and is type `char`. The function then prints text containing
both the `value` and the `unit_label`.
-->
<p>Cet exemple cr√©e la fonction <code>afficher_mesure_avec_unite</code> qui a deux param√®tres.
Le premier param√®tre s'appelle <code>valeur</code> et est un <code>i32</code>. Le second, <code>nom_unite</code>,
est de type <code>char</code>. La fonction affiche ensuite le texte qui contient les
valeurs de <code>valeur</code> et de <code>nom_unite</code>.</p>
<!--
Let‚Äôs try running this code. Replace the program currently in your *functions*
project‚Äôs *src/main.rs* file with the preceding example and run it using `cargo
run`:
-->
<p>Essayons d'ex√©cuter ce code. Remplacez le programme pr√©sent actuellement dans
votre fichier <em>src/main.rs</em> de votre projet <em>functions</em> par l'exemple pr√©c√©dent
et lancez-le en utilisant <code>cargo run</code>¬†:</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
La mesure est : 5h
</code></pre>
<!--
Because we called the function with `5` as the value for `value` and `'h'` as
the value for `unit_label`, the program output contains those values.
-->
<p>Comme nous avons appel√© la fonction avec la valeur <code>5</code> pour <code>valeur</code> et <code>'h'</code>
pour <code>nom_unite</code>, la sortie de ce programme contient ces valeurs.</p>
<!--
### Statements and Expressions
-->
<h3 id="instructions-et-expressions"><a class="header" href="#instructions-et-expressions">Instructions et expressions</a></h3>
<!--
Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions we‚Äôve covered haven‚Äôt included an ending
expression, but you have seen an expression as part of a statement. Because
Rust is an expression-based language, this is an important distinction to
understand. Other languages don‚Äôt have the same distinctions, so let‚Äôs look at
what statements and expressions are and how their differences affect the bodies
of functions.
-->
<p>Les corps de fonctions sont constitu√©s d'une s√©rie d'instructions qui se
termine √©ventuellement par une expression. Jusqu'√† pr√©sent, les fonctions que
nous avons vu n'avaient pas d'expression √† la fin, mais vous avez d√©j√† vu une
expression faire partie d'une instruction. Comme Rust est un langage bas√© sur
des expressions, il est important de faire la distinction. D'autres langages ne
font pas de telles distinctions, donc penchons-nous sur ce que sont les
instructions et les expressions et comment leurs diff√©rences influent sur le
corps des fonctions.</p>
<!--
*Statements* are instructions that perform some action and do not return a
value. *Expressions* evaluate to a resulting value. Let‚Äôs look at some examples.
-->
<p>Les <em>instructions</em> effectuent des actions et ne retournent aucune valeur.
Les <em>expressions</em> sont √©valu√©es pour retourner une valeur comme r√©sultat.
Voyons quelques exemples.</p>
<!--
We‚Äôve actually already used statements and expressions. Creating a variable and
assigning a value to it with the `let` keyword is a statement. In Listing 3-1,
`let y = 6;` is a statement.
-->
<p>Nous avons d√©j√† utilis√© des instructions et des expressions. La cr√©ation d'une
variable en lui assignant une valeur avec le mot-cl√© <code>let</code> est une instruction.
Dans l'encart 3-1, <code>let y = 6;</code> est une instruction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let y = 6;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<!-- markdownlint-disable -->
<!--
<span class="caption">Listing 3-1: A `main` function declaration containing one statement</span>
-->
<!-- markdownlint-restore -->
<p><span class="caption">Encart 3-1¬†: une fonction <code>main</code> qui contient une
instruction</span></p>
<!--
Function definitions are also statements; the entire preceding example is a
statement in itself.
-->
<p>La d√©finition d'une fonction est aussi une instruction¬†; l'int√©gralit√© de
l'exemple pr√©c√©dent est une instruction √† elle toute seule.</p>
<!--
Statements do not return values. Therefore, you can‚Äôt assign a `let` statement
to another variable, as the following code tries to do; you‚Äôll get an error:
-->
<p>Une instruction ne retourne pas de valeur. Ainsi, vous ne pouvez pas assigner
le r√©sultat d'une instruction <code>let</code> √† une autre variable, comme le code suivant
essaye de le faire, car vous obtiendrez une erreur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = (let y = 6);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<!--
When you run this program, the error you‚Äôll get looks like this:
-->
<p>Quand vous ex√©cutez ce programme, l'erreur que vous obtenez devrait ressembler √†
ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 -- > src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are experimental
 -- > src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information
  = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`

warning: unnecessary parentheses around assigned value
 -- > src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  | 

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  | 

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<!--
The `let y = 6` statement does not return a value, so there isn‚Äôt anything for
`x` to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write `x = y = 6` and have both `x` and `y` have the value
`6`; that is not the case in Rust.
-->
<p>L'instruction <code>let y = 6</code> ne retourne pas de valeur, donc cela ne peut pas
devenir une valeur de <code>x</code>. Ceci est diff√©rent d'autres langages, comme le C ou
Ruby, o√π l'assignation retourne la valeur de l'assignation. Dans ces
langages, vous pouvez √©crire <code>x = y = 6</code> et avoir ainsi <code>x</code> et <code>y</code> qui ont
chacun la valeur <code>6</code>¬†; cela n'est pas possible avec Rust.</p>
<!--
Expressions evaluate to a value and make up most of the rest of the code that
you‚Äôll write in Rust. Consider a math operation, such as `5 + 6`, which is an
expression that evaluates to the value `11`. Expressions can be part of
statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an
expression that evaluates to the value `6`. Calling a function is an
expression. Calling a macro is an expression. A new scope block created with
curly brackets is an expression, for example:
-->
<p>Les expressions sont calcul√©es en tant que valeur et seront ce que vous √©crirez
le plus en Rust (hormis les instructions). Prenez une op√©ration math√©matique,
comme <code>5 + 6</code>, qui est une expression qui s'√©value √† la valeur <code>11</code>. Les
expressions peuvent faire partie d'une instruction¬†: dans l'encart 3-1, le <code>6</code>
dans l'instruction <code>let y = 6;</code> est une expression qui s'√©value √† la valeur <code>6</code>.
L'appel de fonction est aussi une expression. L'appel de macro est une
expression. Un nouveau bloc de port√©e que nous cr√©ons avec des accolades est
une expression, par exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;La valeur de y est¬†: {}&quot;, y);
}
</code></pre></pre>
<!--
This expression:
-->
<p>L'expression suivante‚Ä¶</p>
<!--
```rust,ignore
{
    let x = 3;
    x + 1
}
```
-->
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<!--
is a block that, in this case, evaluates to `4`. That value gets bound to `y`
as part of the `let` statement. Note that the `x + 1` line doesn‚Äôt have a
semicolon at the end, unlike most of the lines you‚Äôve seen so far. Expressions
do not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, and it will then not return a value.
Keep this in mind as you explore function return values and expressions next.
-->
<p>‚Ä¶ est un bloc qui, dans ce cas, s'√©value √† <code>4</code>. Cette valeur est assign√©e √† <code>y</code>
dans le cadre de l'instruction <code>let</code>. Remarquez la ligne <code>x + 1</code> ne se termine
pas par un point-virgule, ce qui est diff√©rent de la plupart des lignes que
vous avez vues jusque l√†. Les expressions n'ont pas de point-virgule de fin de
ligne. Si vous ajoutez un point-virgule √† la fin de l'expression, vous la
transformez en instruction, et elle ne va donc pas retourner de valeur. Gardez
ceci √† l'esprit quand nous aborderons prochainement les valeurs de retour des
fonctions ainsi que les expressions.</p>
<!--
### Functions with Return Values
-->
<h3 id="les-fonctions-qui-retournent-des-valeurs"><a class="header" href="#les-fonctions-qui-retournent-des-valeurs">Les fonctions qui retournent des valeurs</a></h3>
<!--
Functions can return values to the code that calls them. We don‚Äôt name return
values, but we must declare their type after an arrow (`->`). In Rust, the
return value of the function is synonymous with the value of the final
expression in the block of the body of a function. You can return early from a
function by using the `return` keyword and specifying a value, but most
functions return the last expression implicitly. Here‚Äôs an example of a
function that returns a value:
-->
<p>Les fonctions peuvent retourner des valeurs au code qui les appelle.
Nous ne nommons pas les valeurs de retour, mais nous devons d√©clarer
leur type apr√®s une fl√®che (<code>-&gt;</code>). En Rust, la valeur de retour de la fonction
est la m√™me que la valeur de l'expression finale dans le corps de la fonction.
Vous pouvez sortir pr√©matur√©ment d'une fonction en utilisant le mot-cl√© <code>return</code>
et en pr√©cisant la valeur de retour, mais la plupart des fonctions vont
retourner implicitement la derni√®re expression.
Voici un exemple d'une fonction qui retourne une valeur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn cinq() -&gt; i32 {
    5
}

fn main() {
    let x = cinq();

    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}
</code></pre></pre>
<!--
There are no function calls, macros, or even `let` statements in the `five`
function‚Äîjust the number `5` by itself. That‚Äôs a perfectly valid function in
Rust. Note that the function‚Äôs return type is specified too, as `-> i32`. Try
running this code; the output should look like this:
-->
<p>Il n'y a pas d'appel de fonction, de macro, ni m√™me d'instruction <code>let</code> dans la
fonction <code>cinq</code> ‚Äî uniquement le nombre <code>5</code> tout seul. C'est une fonction
parfaitement valide avec Rust. Remarquez que le type de retour de la fonction a
√©t√© pr√©cis√© aussi, avec <code>-&gt; i32</code>. Essayez d'ex√©cuter ce code¬†; le r√©sultat
devrait ressembler √† ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
La valeur de x est¬†: 5
</code></pre>
<!--
The `5` in `five` is the function‚Äôs return value, which is why the return type
is `i32`. Let‚Äôs examine this in more detail. There are two important bits:
first, the line `let x = five();` shows that we‚Äôre using the return value of a
function to initialize a variable. Because the function `five` returns a `5`,
that line is the same as the following:
-->
<p>Le <code>5</code> dans <code>cinq</code> est la valeur de retour de la fonction, ce qui explique le
type de retour de <code>i32</code>. Regardons cela plus en d√©tail. Il y a deux √©l√©ments
importants¬†: premi√®rement, la ligne <code>let x = cinq();</code> dit que nous utilisons
la valeur de retour de la fonction pour initialiser la variable. Comme la
fonction <code>cinq</code> retourne un <code>5</code>, cette ligne revient √† faire ceci¬†:</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Second, the `five` function has no parameters and defines the type of the
return value, but the body of the function is a lonely `5` with no semicolon
because it‚Äôs an expression whose value we want to return.
-->
<p>Deuxi√®mement, la fonction <code>cinq</code> n'a pas de param√®tre et d√©clare le type de
valeur de retour, mais le corps de la fonction est un simple <code>5</code> sans
point-virgule car c'est une expression dont nous voulons retourner la valeur.</p>
<!--
Let‚Äôs look at another example:
-->
<p>Regardons un autre exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<!--
Running this code will print `The value of x is: 6`. But if we place a
semicolon at the end of the line containing `x + 1`, changing it from an
expression to a statement, we‚Äôll get an error.
-->
<p>Ex√©cuter ce code va afficher <code>La valeur de x est¬†: 6</code>. Mais si nous ajoutons un
point-virgule √† la fin de la ligne qui contient <code>x + 1</code>, ce qui la transforme
d'une expression √† une instruction, nous obtenons une erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x est¬†: {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<!--
Compiling this code produces an error, as follows:
-->
<p>Compiler ce code va produire une erreur, comme ci-dessous¬†:</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 -- > src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_un(x: i32) -&gt; i32 {
  |    -------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<!--
The main error message, ‚Äúmismatched types,‚Äù reveals the core issue with this
code. The definition of the function `plus_one` says that it will return an
`i32`, but statements don‚Äôt evaluate to a value, which is expressed by `()`,
the unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.
-->
<p>Le message d'erreur principal, ‚Äúmismatched types‚Äù <em>(types inad√©quats)</em> donne le
c≈ìur du probl√®me de ce code. La d√©finition de la fonction <code>plus_un</code> dit qu'elle
va retourner un <code>i32</code>, mais les instructions ne retournent pas de valeur, ceci
est donc repr√©sent√© par <code>()</code>, le type unit√©. Par cons√©quent, rien n'est
retourn√©, ce qui contredit la d√©finition de la fonction et provoque une erreur.
Rust affiche un message qui peut aider √† corriger ce probl√®me¬†: il sugg√®re
d'enlever le point-virgule, ce qui va r√©soudre notre probl√®me.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Comments
-->
<h2 id="les-commentaires"><a class="header" href="#les-commentaires">Les commentaires</a></h2>
<!--
All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave *comments* in
their source code that the compiler will ignore but people reading the source
code may find useful.
-->
<p>Tous les d√©veloppeurs s'efforcent de rendre leur code facile √† comprendre, mais
parfois il est n√©cessaire d'√©crire des explications suppl√©mentaires. Dans ce
cas, les d√©veloppeurs laissent des <em>commentaires</em> dans leur code source que le
compilateur va ignorer mais qui peuvent √™tre utiles pour les personnes qui
lisent le code source.</p>
<!--
Here‚Äôs a simple comment:
-->
<p>Voici un simple commentaire¬†:</p>
<!--
```rust
// hello, world
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust, the idiomatic comment style starts a comment with two slashes, and the
comment continues until the end of the line. For comments that extend beyond a
single line, you‚Äôll need to include `//` on each line, like this:
-->
<p>Avec Rust, les commentaires classiques commencent avec deux barres obliques et
continuent jusqu'√† la fin de la ligne. Pour les commentaires qui font plus
d'une seule ligne, vous aurez besoin d'ajouter <code>//</code> sur chaque ligne, comme
ceci¬†:</p>
<!--
```rust
// So we‚Äôre doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what‚Äôs going on.
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Donc ici on fait quelque chose de compliqu√©, tellement long que nous avons
// besoin de plusieurs lignes de commentaires pour le faire¬†! Heureusement,
// ce commentaire va expliquer ce qui se passe.
<span class="boring">}
</span></code></pre></pre>
<!--
Comments can also be placed at the end of lines containing code:
-->
<p>Les commentaires peuvent aussi √™tre aussi ajout√©s √† la fin d'une ligne qui
contient du code¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let lucky_number = 7; // I‚Äôm feeling lucky today
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_chanceux = 7; // Je me sens chanceux aujourd'hui
}
</code></pre></pre>
<!--
But you‚Äôll more often see them used in this format, with the comment on a
separate line above the code it‚Äôs annotating:
-->
<p>Mais parfois, vous pourrez les voir utilis√©s de cette mani√®re, avec le
commentaire sur une ligne s√©par√©e au-dessus du code qu'il annote¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    // I‚Äôm feeling lucky today
    let lucky_number = 7;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Je me sens chanceux aujourd'hui
    let nombre_chanceux = 7;
}
</code></pre></pre>
<!--
Rust also has another kind of comment, documentation comments, which we‚Äôll
discuss in the ‚ÄúPublishing a Crate to Crates.io‚Äù section of Chapter 14.
-->
<p>Rust a aussi un autre type de commentaire, les commentaires de documentation,
que nous aborderons au chapitre 14.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Control Flow
-->
<h2 id="les-structures-de-contr√¥le"><a class="header" href="#les-structures-de-contr√¥le">Les structures de contr√¥le</a></h2>
<!--
The ability to run some code depending on if a condition is true, or run some
code repeatedly while a condition is true, are basic building blocks in most
programming languages. The most common constructs that let you control the flow
of execution of Rust code are `if` expressions and loops.
-->
<p>Pouvoir ex√©cuter ou non du code si une condition est v√©rifi√©e, ou ex√©cuter du
code de fa√ßon r√©p√©t√©e tant qu'une condition est v√©rifi√©e, sont des
constructions √©l√©mentaires dans la plupart des langages de programmation. Les
structures de contr√¥le les plus courantes en Rust sont les expressions <code>if</code> et
les boucles.</p>
<!--
### `if` Expressions
-->
<h3 id="les-expressions-if"><a class="header" href="#les-expressions-if">Les expressions <code>if</code></a></h3>
<!--
An `if` expression allows you to branch your code depending on conditions. You
provide a condition and then state, ‚ÄúIf this condition is met, run this block
of code. If the condition is not met, do not run this block of code.‚Äù
-->
<p>Une expression <code>if</code> vous permet de diviser votre code en fonction de conditions.
Vous pr√©cisez une condition et vous choisissez ensuite¬†: ‚ÄúSi cette condition est
remplie, alors ex√©cuter ce bloc de code. Si la condition n'est pas remplie,
ne pas ex√©cuter ce bloc de code.‚Äù</p>
<!--
Create a new project called *branches* in your *projects* directory to explore
the `if` expression. In the *src/main.rs* file, input the following:
-->
<p>Cr√©ez un nouveau projet appel√© <em>branches</em> dans votre dossier <em>projects</em> pour
d√©couvrir les expressions <code>if</code>. Dans le fichier <em>src/main.rs</em>, √©crivez ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre &lt; 5 {
        println!(&quot;La condition est v√©rifi√©e&quot;);
    } else {
        println!(&quot;La condition n'est pas v√©rifi√©e&quot;);
    }
}
</code></pre></pre>
<!--
All `if` expressions start with the keyword `if`, followed by a condition. In
this case, the condition checks whether or not the variable `number` has a
value less than 5. We place the block of code to execute if the condition is true
immediately after the condition inside curly brackets. Blocks of code
associated with the conditions in `if` expressions are sometimes called *arms*,
just like the arms in `match` expressions that we discussed in the [‚ÄúComparing
the Guess to the Secret Number‚Äù][comparing-the-guess-to-the-secret-number]<!--
ignore -- > section of Chapter 2.
-->
<p>Une expression <code>if</code> commence par le mot-cl√© <code>if</code>, suivi d'une condition.
Dans notre cas, la condition v√©rifie si oui ou non la variable <code>nombre</code> a une
valeur inf√©rieure √† 5. Nous ajoutons le bloc de code √† ex√©cuter si la condition
est v√©rifi√©e imm√©diatement apr√®s la condition entre des accolades. Les blocs de
code associ√©s √† une condition dans une expression <code>if</code> sont parfois appel√©s des
<em>branches</em>, exactement comme les branches dans les expressions <code>match</code> que nous
avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">‚ÄúComparer le nombre saisi au nombre
secret‚Äù</a><!-- ignore --> du
chapitre 2.</p>
<!--
Optionally, we can also include an `else` expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you don‚Äôt provide an `else` expression and
the condition is false, the program will just skip the `if` block and move on
to the next bit of code.
-->
<p>√âventuellement, vous pouvez aussi ajouter une expression <code>else</code>, ce que nous
avons fait ici, pour pr√©ciser un bloc alternatif de code qui sera ex√©cut√© dans
le cas o√π la condition est fausse (elle n'est pas v√©rifi√©e). Si
vous ne renseignez pas d'expression <code>else</code> et que la condition n'est pas
v√©rifi√©e, le programme va simplement sauter le bloc de <code>if</code> et passer au
prochain morceau de code.</p>
<!--
Try running this code; you should see the following output:
-->
<p>Essayez d'ex√©cuter ce code¬†; vous verrez ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition est v√©rifi√©e
</code></pre>
<!--
Let‚Äôs try changing the value of `number` to a value that makes the condition
`false` to see what happens:
-->
<p>Essayons de changer la valeur de <code>nombre</code> pour une valeur qui rend la condition
non v√©rifi√©e pour voir ce qui se passe¬†:</p>
<!--
```rust,ignore
# fn main() {
    let number = 7;
# 
#     if number < 5 {
#         println!("condition was true");
#     } else {
#         println!("condition was false");
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let nombre = 7;
<span class="boring">
</span><span class="boring">    if nombre &lt; 5 {
</span><span class="boring">        println!(&quot;La condition est v√©rifi√©e&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;La condition n'est pas v√©rifi√©e&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the program again, and look at the output:
-->
<p>Ex√©cutez √† nouveau le programme, et regardez le r√©sultat¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition n'est pas v√©rifi√©e
</code></pre>
<!--
It‚Äôs also worth noting that the condition in this code *must* be a `bool`. If
the condition isn‚Äôt a `bool`, we‚Äôll get an error. For example, try running the
following code:
-->
<p>Il est aussi int√©ressant de noter que la condition dans ce code <em>doit</em> √™tre un
<code>bool</code>. Si la condition n'est pas un <code>bool</code>, nous aurons une erreur. Par
exemple, essayez d'ex√©cuter le code suivant¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombre = 3;

    if nombre {
        println!(&quot;Le nombre √©tait trois&quot;);
    }
}
</code></pre>
<!--
The `if` condition evaluates to a value of `3` this time, and Rust throws an
error:
-->
<p>La condition <code>if</code> vaut <code>3</code> cette fois, et Rust l√®ve une erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 -- > src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if nombre {
  |        ^^^^^^ expected bool, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The error indicates that Rust expected a `bool` but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
`if` with a Boolean as its condition. If we want the `if` code block to run
only when a number is not equal to `0`, for example, we can change the `if`
expression to the following:
-->
<p>Cette erreur explique que Rust attendait un <code>bool</code> mais a obtenu un entier
<em>(integer)</em>. Contrairement √† des langages comme Ruby et JavaScript, Rust
ne va pas essayer de convertir automatiquement les types non bool√©ens en
bool√©ens. Vous devez √™tre pr√©cis et toujours fournir un bool√©en √† la condition
d'un <code>if</code>. Si nous voulons que le bloc de code du <code>if</code> soit ex√©cut√© quand le
nombre est diff√©rent de <code>0</code>, par exemple, nous pouvons changer l'expression <code>if</code>
par la suivante¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre != 0 {
        println!(&quot;Le nombre valait autre chose que z√©ro&quot;);
    }
}
</code></pre></pre>
<!--
Running this code will print `number was something other than zero`.
-->
<p>Ex√©cuter ce code va bien afficher <code>Le nombre valait autre chose que z√©ro</code>.</p>
<!--
#### Handling Multiple Conditions with `else if`
-->
<h4 id="g√©rer-plusieurs-conditions-avec-else-if"><a class="header" href="#g√©rer-plusieurs-conditions-avec-else-if">G√©rer plusieurs conditions avec <code>else if</code></a></h4>
<!--
You can use multiple conditions by combining `if` and `else` in an `else if`
expression. For example:
-->
<p>Vous pouvez utiliser plusieurs conditions en combinant <code>if</code> et <code>else</code> dans une
expression <code>else if</code>. Par exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 6;

    if nombre % 4 == 0 {
        println!(&quot;Le nombre est divisible par 4&quot;);
    } else if nombre % 3 == 0 {
        println!(&quot;Le nombre est divisible par 3&quot;);
    } else if nombre % 2 == 0 {
        println!(&quot;Le nombre est divisible par 2&quot;);
    } else {
        println!(&quot;Le nombre n'est pas divisible par 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<!--
This program has four possible paths it can take. After running it, you should
see the following output:
-->
<p>Ce programme peut choisir entre quatre chemins diff√©rents. Apr√®s l'avoir
ex√©cut√©, vous devriez voir le r√©sultat suivant¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Le nombre est divisible par 3
</code></pre>
<!--
When this program executes, it checks each `if` expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we don‚Äôt see the output `number is divisible by 2`, nor do we
see the `number is not divisible by 4, 3, or 2` text from the `else` block.
That‚Äôs because Rust only executes the block for the first true condition, and
once it finds one, it doesn‚Äôt even check the rest.
-->
<p>Quand ce programme s'ex√©cute, il v√©rifie chaque expression <code>if</code> √† tour de r√¥le
et ex√©cute le premier bloc dont la condition est v√©rifi√©e. Notez que m√™me si 6
est divisible par 2, nous ne voyons pas le message <code>Le nombre est divisible par 2</code>, ni le message <code>Le nombre n'est pas divisible par 4, 3 ou 2</code> du bloc <code>else</code>.
C'est parce que Rust n'ex√©cute que le bloc de la premi√®re condition v√©rifi√©e,
et d√®s lors qu'il en a trouv√© une, il ne va pas chercher √† v√©rifier les
suivantes.</p>
<!--
Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.
-->
<p>Utiliser trop d'expressions <code>else if</code> peut encombrer votre code, donc si vous
en avez plus d'une, vous devriez envisager de remanier votre code. Le chapitre 6
pr√©sente une construction puissante appel√©e <code>match</code> pour de tels cas.</p>
<!--
#### Using `if` in a `let` Statement
-->
<h4 id="utiliser-if-dans-une-instruction-let"><a class="header" href="#utiliser-if-dans-une-instruction-let">Utiliser <code>if</code> dans une instruction <code>let</code></a></h4>
<!--
Because `if` is an expression, we can use it on the right side of a `let`
statement to assign the outcome to a variable, as in Listing 3-2.
-->
<p>Comme <code>if</code> est une expression, nous pouvons l'utiliser √† droite d'une
instruction <code>let</code> pour assigner le r√©sultat √† une variable, comme dans l'encart
3-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let nombre = if condition { 5 } else { 6 };

    println!(&quot;La valeur du nombre est¬†: {}&quot;, nombre);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span>
-->
<p><span class="caption">Encart 3-2¬†: assigner le r√©sultat d'une expression <code>if</code> √†
une variable</span></p>
<!--
The `number` variable will be bound to a value based on the outcome of the `if`
expression. Run this code to see what happens:
-->
<p>La variable <code>nombre</code> va avoir la valeur du r√©sultat de l'expression <code>if</code>.
Ex√©cutez ce code pour d√©couvrir ce qui va se passer¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
La valeur du nombre est¬†: 5
</code></pre>
<!--
Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole `if` expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the `if` must be
the same type; in Listing 3-2, the results of both the `if` arm and the `else`
arm were `i32` integers. If the types are mismatched, as in the following
example, we‚Äôll get an error:
-->
<p>Souvenez-vous que les blocs de code s'ex√©cutent jusqu'√† la derni√®re expression
qu'ils contiennent, et que les nombres tout seuls sont aussi des expressions.
Dans notre cas, la valeur de toute l'expression <code>if</code> d√©pend de quel bloc de code
elle va ex√©cuter. Cela veut dire que chaque valeur qui peut √™tre le r√©sultat de
chaque branche du <code>if</code> doivent √™tre du m√™me type¬†; dans l'encart 3-2, les
r√©sultats des branches <code>if</code> et <code>else</code> sont tous deux des entiers <code>i32</code>. Si
les types ne sont pas identiques, comme dans l'exemple suivant, nous allons
obtenir une erreur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let nombre = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;La valeur du nombre est¬†: {}&quot;, nombre);
}
</code></pre>
<!--
When we try to compile this code, we‚Äôll get an error. The `if` and `else` arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons une erreur. Les
branches <code>if</code> et <code>else</code> ont des types de valeurs qui ne sont pas compatibles, et
Rust indique exactement o√π trouver le probl√®me dans le programme¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 -- > src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let nombre = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The expression in the `if` block evaluates to an integer, and the expression in
the `else` block evaluates to a string. This won‚Äôt work because variables must
have a single type, and Rust needs to know at compile time what type the
`number` variable is, definitively. Knowing the type of `number` lets the
compiler verify the type is valid everywhere we use `number`. Rust wouldn‚Äôt be
able to do that if the type of `number` was only determined at runtime; the
compiler would be more complex and would make fewer guarantees about the code
if it had to keep track of multiple hypothetical types for any variable.
-->
<p>L'expression dans le bloc <code>if</code> donne un entier, et l'expression dans le bloc
<code>else</code> donne une cha√Æne de caract√®res. Ceci ne fonctionne pas car les variables
doivent avoir un seul type, et Rust a besoin de savoir de quel type est la
variable <code>nombre</code> au moment de la compilation. Savoir le type de <code>nombre</code>
permet au compilateur de v√©rifier que le type est valable n'importe o√π nous
utilisons <code>nombre</code>. Rust ne serait pas capable de faire cela si le type de
<code>nombre</code> √©tait d√©termin√© uniquement √† l'ex√©cution¬†; car le compilateur
deviendrait plus complexe et nous donnerait moins de garanties sur le code s'il
devait prendre en compte tous les types hypoth√©tiques pour une variable.</p>
<!--
### Repetition with Loops
-->
<h3 id="les-r√©p√©titions-avec-les-boucles"><a class="header" href="#les-r√©p√©titions-avec-les-boucles">Les r√©p√©titions avec les boucles</a></h3>
<!--
It‚Äôs often useful to execute a block of code more than once. For this task,
Rust provides several *loops*, which will run through the code inside the loop
body to the end and then start immediately back at the beginning. To
experiment with loops, let‚Äôs make a new project called *loops*.
-->
<p>Il est parfois utile d'ex√©cuter un bloc de code plus d'une seule fois. Dans ce
but, Rust propose plusieurs types de <em>boucles</em>, qui parcourt le code √†
l'int√©rieur du corps de la boucle jusqu'√† la fin et recommence imm√©diatement du
d√©but. Pour tester les boucles, cr√©ons un nouveau projet appel√© <em>loops</em>.</p>
<!--
Rust has three kinds of loops: `loop`, `while`, and `for`. Let‚Äôs try each one.
-->
<p>Rust a trois types de boucles¬†: <code>loop</code>, <code>while</code>, et <code>for</code>. Essayons chacune
d'elles.</p>
<!--
#### Repeating Code with `loop`
-->
<h4 id="r√©p√©ter-du-code-avec-loop"><a class="header" href="#r√©p√©ter-du-code-avec-loop">R√©p√©ter du code avec <code>loop</code></a></h4>
<!--
The `loop` keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.
-->
<p>Le mot-cl√© <code>loop</code> demande √† Rust d'ex√©cuter un bloc de code encore et encore
jusqu'√† l'infini ou jusqu'√† ce que vous lui demandiez explicitement de
s'arr√™ter.</p>
<!--
As an example, change the *src/main.rs* file in your *loops* directory to look
like this:
-->
<p>Par exemple, changez le fichier <em>src/main.rs</em> dans votre dossier <em>loops</em> comme
ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;√Ä nouveau¬†!&quot;);
    }
}
</code></pre>
<!--
When we run this program, we‚Äôll see `again!` printed over and over continuously
until we stop the program manually. Most terminals support the keyboard shortcut
<span class="keystroke">ctrl-c</span> to interrupt a program that is stuck in
a continual loop. Give it a try:
-->
<p>Quand nous ex√©cutons ce programme, nous voyons <code>√Ä nouveau¬†!</code> s'afficher encore
et encore en continu jusqu'√† ce qu'on arr√™te le programme manuellement. La
plupart des terminaux utilisent un raccourci clavier, <span class="keystroke">
ctrl-c</span>, pour arr√™ter un programme qui est bloqu√© dans une boucle infinie.
Essayons cela¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-- >
-->
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
√Ä nouveau¬†!
√Ä nouveau¬†!
√Ä nouveau¬†!
√Ä nouveau¬†!
^C√Ä nouveau¬†!
</code></pre>
<!--
The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word `again!` printed after the `^C`,
depending on where the code was in the loop when it received the interrupt
signal.
-->
<p>Le symbole <code>^C</code> repr√©sente le moment o√π vous avez appuy√© sur
<span class="keystroke">ctrl-c</span>. Vous devriez voir ou non le texte
<code>√Ä nouveau¬†!</code> apr√®s le <code>^C</code>, en fonction de l√† o√π la boucle en √©tait dans votre
code quand elle a re√ßu le signal d'arr√™t.</p>
<!--
Fortunately, Rust also provides a way to break out of a loop using code. You
can place the `break` keyword within the loop to tell the program when to stop
executing the loop. Recall that we did this in the guessing game in the
[‚ÄúQuitting After a Correct Guess‚Äù][quitting-after-a-correct-guess]<!-- ignore
-- > section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.
-->
<p>Heureusement, Rust fournit aussi un autre moyen de sortir d'une boucle en
utilisant du code. Vous pouvez ajouter le mot-cl√© <code>break</code> √† l'int√©rieur de la boucle
pour demander au programme d'arr√™ter la boucle. Souvenez-vous que nous avions
fait ceci dans le jeu de devinettes, dans la section <a href="ch02-00-guessing-game-tutorial.html#arr%C3%AAter-le-programme-apr%C3%A8s-avoir-gagn%C3%A9">‚ÄúArr√™ter le programme
apr√®s avoir gagn√©‚Äù</a><!-- ignore --> du chapitre 2
afin de quitter le programme quand l'utilisateur gagne le jeu en devinant le
bon nombre.</p>
<!--
We also used `continue` in the guessing game, which in a loop tells the program
to skip over any remaining code in this iteration of the loop and go to the
next iteration.
-->
<p>Nous avons √©galement <code>continue</code> dans le jeu du plus ou du moins, qui dans une
boucle demande au programme de sauter le code restant dans cette iteration de
la boucle et passer directement √† la prochaine it√©ration.</p>
<!--
If you have loops within loops, `break` and `continue` apply to the innermost
loop at that point. You can optionally specify a *loop label* on a loop that we
can then use with `break` or `continue` to specify that those keywords apply to
the labeled loop instead of the innermost loop. Here‚Äôs an example with two
nested loops:
-->
<p>Si vous avez des boucles imbriqu√©es dans d'autres boucles, <code>break</code> et <code>continue</code>
s'appliquent uniquement √† la boucle au plus bas niveau. Si vous en avez besoin,
vous pouvez associer une <em>etiquette de boucle</em> √† une boucle que nous pouvons
ensuite utiliser en association avec <code>break</code> ou <code>continue</code> pour pr√©ciser que
ces mot-cl√©s s'appliquent sur la boucle correspondant √† l'√©tiquette plut√¥t qu'√†
la boucle la plus proche possible. Voici un exemple avec deux boucles
imbriqu√©es¬†:</p>
<!--
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;
    'increment: loop {
        println!(&quot;compteur = {}&quot;, compteur);
        let mut restant = 10;

        loop {
            println!(&quot;restant = {}&quot;, restant);
            if restant == 9 {
                break;
            }
            if compteur == 2 {
                break 'increment;
            }
            restant -= 1;
        }

        compteur += 1;
    }
    println!(&quot;Fin du compteur = {}&quot;, compteur);
}
</code></pre></pre>
<!--
The outer loop has the label `'counting_up`, and it will count up from 0 to 2.
The inner loop without a label counts down from 10 to 9. The first `break` that
doesn‚Äôt specify a label will exit the inner loop only. The `break
'counting_up;` statement will exit the outer loop. This code prints:
-->
<p>La boucle la plus √† l'ext√©rieur a l'√©tiquette <code>increment</code>, et elle va
incr√©menter de 0 √† 2. La boucle √† l'int√©rieur n'a pas d'√©tiquette et va
d√©crementer de 10 √† 9. Le premier <code>break</code> qui ne pr√©cise pas d'√©tiquette va
arr√™ter uniquement la boucle interne. L'instruction <code>break 'increment;</code> va
arr√™ter la boucle la plus √† l'ext√©rieur. Ce code va afficher¬†:</p>
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
compteur = 0
restant = 10
restant = 9
compteur = 1
restant = 10
restant = 9
compteur = 2
restant = 10
Fin du compteur = 2
</code></pre>
<!--
#### Returning Values from Loops
-->
<h4 id="retourner-des-valeurs-dune-boucle"><a class="header" href="#retourner-des-valeurs-dune-boucle">Retourner des valeurs d'une boucle</a></h4>
<!--
One of the uses of a `loop` is to retry an operation you know might fail, such
as checking whether a thread has completed its job. You might also need to pass
the result of that operation out of the loop to the rest of your code. To do
this, you can add the value you want returned after the `break` expression you
use to stop the loop; that value will be returned out of the loop so you can
use it, as shown here:
-->
<p>L'une des utilisations d'une boucle <code>loop</code> est de r√©essayer une op√©ration qui
peut √©chouer, comme v√©rifier si une t√¢che a termin√© son travail. Vous aurez
aussi peut-√™tre besoin de passer le r√©sultat de l'op√©ration au reste de votre
code √† l'ext√©rieur de cette boucle. Pour ce faire, vous pouvez ajouter la
valeur que vous voulez retourner apr√®s l'expression <code>break</code> que vous utilisez
pour stopper la boucle¬†; cette valeur sera retourn√©e √† l'ext√©rieur de la boucle
pour que vous puissiez l'utiliser, comme ci-dessous¬†:</p>
<!--
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;

    let resultat = loop {
        compteur += 1;

        if compteur == 10 {
            break compteur * 2;
        }
    };

    println!(&quot;Le r√©sultat est {}&quot;, resultat);
}
</code></pre></pre>
<!--
Before the loop, we declare a variable named `counter` and initialize it to
`0`. Then we declare a variable named `result` to hold the value returned from
the loop. On every iteration of the loop, we add `1` to the `counter` variable,
and then check whether the counter is equal to `10`. When it is, we use the
`break` keyword with the value `counter * 2`. After the loop, we use a
semicolon to end the statement that assigns the value to `result`. Finally, we
print the value in `result`, which in this case is 20.
-->
<p>Avant la boucle, nous d√©clarons une variable avec le nom <code>compteur</code> et nous
l'initialisons √† <code>0</code>. Ensuite, nous d√©clarons une variable <code>resultat</code> pour
stocker la valeur retourn√©e de la boucle. √Ä chaque it√©ration de la boucle, nous
ajoutons <code>1</code> √† la variable <code>compteur</code>, et ensuite nous v√©rifions si le compteur
est √©gal √† <code>10</code>. Lorsque c'est le cas, nous utilisons le mot-cl√© <code>break</code> avec la
valeur <code>compteur * 2</code>. Apr√®s la boucle, nous utilisons un point-virgule pour
terminer l'instruction qui assigne la valeur √† <code>resultat</code>. Enfin, nous
affichons la valeur de <code>resultat</code>, qui est 20 dans ce cas-ci.</p>
<!--
#### Conditional Loops with `while`
-->
<h4 id="les-boucles-conditionnelles-avec-while"><a class="header" href="#les-boucles-conditionnelles-avec-while">Les boucles conditionnelles avec <code>while</code></a></h4>
<!--
A program will often need to evaluate a condition within a loop. While the
condition is true, the loop runs. When the condition ceases to be true, the
program calls `break`, stopping the loop. It‚Äôs possible to implement behavior
like this using a combination of `loop`, `if`, `else`, and `break`; you could
try that now in a program, if you‚Äôd like. However, this pattern is so common
that Rust has a built-in language construct for it, called a `while` loop. In
Listing 3-3, we use `while` to loop the program three times, counting down each
time, and then, after the loop, print a message and exit.
-->
<p>Un programme a souvent besoin d'√©valuer une condition dans une boucle.
Tant que la condition est vraie, la boucle tourne. Quand la condition arr√™te
d'√™tre vraie, le programme appelle <code>break</code>, ce qui arr√™te la boucle. Il est
possible d'impl√©menter un comportement comme celui-ci en combinant <code>loop</code>,
<code>if</code>, <code>else</code> et <code>break</code>¬†; vous pouvez essayer de le faire, si vous voulez.
Cependant, cette utilisation est si fr√©quente que Rust a une construction pour
cela, int√©gr√©e dans le langage, qui s'appelle une boucle <code>while</code>. Dans l'encart
3-3, nous utilisons <code>while</code>¬†pour boucler trois fois, en d√©cr√©mentant √† chaque
fois, et ensuite, apr√®s la boucle, il va afficher un message et se fermer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut nombre = 3;

    while nombre != 0 {
        println!(&quot;{}¬†!&quot;, nombre);

        nombre -= 1;
    }

    println!(&quot;D√âCOLLAGE¬†!!!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-3: Using a `while` loop to run code while a
condition holds true</span>
-->
<p><span class="caption">Encart 3-3: utiliser une boucle <code>while</code> pour ex√©cuter du
code tant qu'une condition est vraie</span></p>
<!--
This construct eliminates a lot of nesting that would be necessary if you used
`loop`, `if`, `else`, and `break`, and it‚Äôs clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.
-->
<p>Cette construction √©limine beaucoup d'imbrications qui seraient n√©cessaires si
vous utilisiez <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code>, et c'est aussi plus clair. Tant
que la condition est vraie, le code est ex√©cut√©¬†; sinon, il quitte la boucle.</p>
<!--
#### Looping Through a Collection with `for`
-->
<h4 id="boucler-dans-une-collection-avec-for"><a class="header" href="#boucler-dans-une-collection-avec-for">Boucler dans une collection avec <code>for</code></a></h4>
<!--
You can choose to use the `while` construct to loop over the elements of a
collection, such as an array. For example, the loop in Listing 3-4 prints each
element in the array `a`.
-->
<p>Vous pouvez choisir d'utiliser la construction <code>while</code> pour it√©rer sur les
√©l√©ments d'une collection, comme les tableaux. Par exemple, la boucle dans
l'encart 3-4 affiche chaque √©l√©ment pr√©sent dans le tableau <code>a</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;La valeur est¬†: {}&quot;, a[indice]);

        indice += 1;
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-4: Looping through each element of a collection
using a `while` loop</span>
-->
<p><span class="caption">Encart 3-4¬†: it√©ration sur les √©l√©ments d'une collection
en utilisant une boucle <code>while</code></span></p>
<!--
Here, the code counts up through the elements in the array. It starts at index
`0`, and then loops until it reaches the final index in the array (that is,
when `index < 5` is no longer true). Running this code will print every element
in the array:
-->
<p>Ici, le code parcourt le tableau √©l√©ment par √©l√©ment.
Il commence √† l'indice <code>0</code>, et ensuite boucle jusqu'√† ce qu'il atteigne l'indice
final du tableau (ce qui correspond au moment o√π la condition <code>index &lt; 5</code> n'est
plus vraie). Ex√©cuter ce code va afficher chaque √©l√©ment du tableau¬†:</p>
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
La valeur est¬†: 10
La valeur est¬†: 20
La valeur est¬†: 30
La valeur est¬†: 40
La valeur est¬†: 50
</code></pre>
<!--
All five array values appear in the terminal, as expected. Even though `index`
will reach a value of `5` at some point, the loop stops executing before trying
to fetch a sixth value from the array.
-->
<p>Les cinq valeurs du tableau s'affichent toutes dans le terminal, comme attendu.
M√™me si <code>indice</code> va atteindre la valeur <code>5</code> √† un moment, la boucle arr√™tera de
s'ex√©cuter avant d'essayer de r√©cup√©rer une sixi√®me valeur du tableau.</p>
<!--
However, this approach is error prone; we could cause the program to panic if
the index value or test condition are incorrect. For example, if you changed
the definition of the `a` array to have four elements but forgot to update the
condition to `while index < 4`, the code would panic. It‚Äôs also slow, because
the compiler adds runtime code to perform the conditional check of whether the
index is within the bounds of the array on every iteration through the loop.
-->
<p>Cependant, cette approche pousse √† l'erreur¬†; nous pourrions faire paniquer le
programme si la valeur de l'indice est trop grand ou que la condition du test
est incorrecte. Par exemple, si vous changez la d√©finition du tableau <code>a</code> pour
avoir quatre √©l√©ments, mais que nous oublions de modifier la condition dans
<code>while indice &lt; 4</code>, le code paniquera. De plus, c'est lent, car le compilateur
ajoute du code pour effectuer √† l'ex√©cution la v√©rification que l'indice est
compris dans les limites du tableau, et cela √† chaque it√©ration de la boucle.</p>
<!--
As a more concise alternative, you can use a `for` loop and execute some code
for each item in a collection. A `for` loop looks like the code in Listing 3-5.
-->
<p>Pour une alternative plus concise, vous pouvez utiliser une boucle <code>for</code> et
ex√©cuter du code pour chaque √©l√©ment dans une collection. Une boucle <code>for</code>
s'utilise comme dans le code de l'encart 3-5.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;La valeur est¬†: {}&quot;, element);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-5: Looping through each element of a collection
using a `for` loop</span>
-->
<p><span class="caption">Encart 3-5¬†: it√©rer sur chaque √©l√©ment d'une collection
en utilisant une boucle <code>for</code></span></p>
<!--
When we run this code, we‚Äôll see the same output as in Listing 3-4. More
importantly, we‚Äôve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.
-->
<p>Lorsque nous ex√©cutons ce code, nous obtenons les m√™mes messages que dans
l'encart 3-4. Mais ce qui est plus important, c'est que nous avons am√©lior√© la
s√©curit√© de notre code et √©limin√© le risque de bogues qui pourraient survenir
si on d√©passait la fin du tableau, ou si on n'allait pas jusqu'au bout
et qu'on ratait quelques √©l√©ments.</p>
<!--
Using the `for` loop, you wouldn‚Äôt need to remember to change any other code if
you changed the number of values in the array, as you would with the method
used in Listing 3-4.
-->
<p>En utilisant la boucle <code>for</code>, vous n'aurez pas √† vous rappeler de changer le
code si vous changez le nombre de valeurs dans le tableau, comme vous devriez
le faire dans la m√©thode utilis√©e dans l'encart 3-4.</p>
<!--
The safety and conciseness of `for` loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a `while` loop
in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that
would be to use a `Range`, provided by the standard library, which generates
all numbers in sequence starting from one number and ending before another
number.
-->
<p>La s√©curit√© et la concision de la boucle <code>for</code> en font la construction de boucle
la plus utilis√©e avec Rust. M√™me dans des situations dans lesquelles vous
voudriez ex√©cuter du code plusieurs fois, comme l'exemple du d√©compte qui
utilisait une boucle <code>while</code> dans l'encart 3-3, la plupart des Rustac√©s
utiliseraient une boucle <code>for</code>. Il faut pour cela utiliser un intervalle
<code>Range</code>, fourni par la biblioth√®que standard pour g√©n√©rer dans l'ordre tous les
nombres compris entre un certain nombre et un autre nombre.</p>
<!--
Here‚Äôs what the countdown would look like using a `for` loop and another method
we‚Äôve not yet talked about, `rev`, to reverse the range:
-->
<p>Voici ce que le d√©compte aurait donn√© en utilisant une boucle <code>for</code> et une autre
m√©thode que nous n'avons pas encore vue, <code>rev</code>, qui inverse l'intervalle¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    for nombre in (1..4).rev() {
        println!(&quot;{}¬†!&quot;, nombre);
    }
    println!(&quot;D√âCOLLAGE¬†!!!&quot;);
}
</code></pre></pre>
<!--
This code is a bit nicer, isn‚Äôt it?
-->
<p>Ce code est un peu plus sympa, non¬†?</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-2"><a class="header" href="#r√©sum√©-2">R√©sum√©</a></h2>
<!--
You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, `if` expressions, and loops!
To practice with the concepts discussed in this chapter, try building
programs to do the following:
-->
<p>Vous y √™tes arriv√©¬†! C'√©tait un chapitre important¬†: vous avez appris les
variables, les types scalaires et compos√©s, les fonctions, les commentaires, les
expressions <code>if</code>, et les boucles¬†!
Pour pratiquer un peu les concepts abord√©s dans ce chapitre, voici quelques
programmes que vous pouvez essayer de cr√©er¬†:</p>
<!--
* Convert temperatures between Fahrenheit and Celsius.
* Generate the nth Fibonacci number.
* Print the lyrics to the Christmas carol ‚ÄúThe Twelve Days of Christmas,‚Äù
  taking advantage of the repetition in the song.
-->
<ul>
<li>Convertir des temp√©ratures entre les degr√©s Fahrenheit et Celsius.</li>
<li>G√©n√©rer le <em>n</em>-i√®me nombre de Fibonacci.</li>
<li>Afficher les paroles de la chanson de No√´l <em>The Twelve Days of Christmas</em> en
profitant de l'aspect r√©p√©titif de la chanson.</li>
</ul>
<!--
When you‚Äôre ready to move on, we‚Äôll talk about a concept in Rust that *doesn‚Äôt*
commonly exist in other programming languages: ownership.
-->
<p>Quand vous serez pr√™t √† aller plus loin, nous aborderons une notion de Rust
qui n'existe <em>pas</em> dans les autres langages de programmation¬†: la possession
<em>(ownership)</em>.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[quitting-after-a-correct-guess]:
ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Understanding Ownership
-->
<h1 id="comprendre-la-possession"><a class="header" href="#comprendre-la-possession">Comprendre la possession</a></h1>
<!--
Ownership is Rust‚Äôs most unique feature and has deep implications for the rest
of the language. It enables Rust to make memory safety guarantees without
needing a garbage collector, so it‚Äôs important to understand how ownership
works. In this chapter, we‚Äôll talk about ownership as well as several related
features: borrowing, slices, and how Rust lays data out in memory.
-->
<p>La possession (<em>ownership</em>) est la fonctionnalit√© la plus remarquable de Rust,
et a des implications en profondeur dans l'ensemble du langage. Elle permet √†
Rust de garantir la s√©curit√© de la m√©moire sans avoir besoin d'un
ramasse-miettes (<em>garbage collector</em>), donc il est important de comprendre
comment la possession fonctionne. Dans ce chapitre, nous aborderons la
possession, ainsi que d'autres fonctionnalit√©s associ√©es¬†: l'emprunt, les
<em>slices</em> et la fa√ßon dont Rust agence les donn√©es en m√©moire.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## What Is Ownership?
-->
<h2 id="quest-ce-que-la-possession-"><a class="header" href="#quest-ce-que-la-possession-">Qu'est-ce que la possession¬†?</a></h2>
<!--
*Ownership* is a set of rules that governs how a Rust program manages memory.
All programs have to manage the way they use a computer‚Äôs memory while running.
Some languages have garbage collection that constantly looks for no-longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks. If
any of the rules are violated, the program won‚Äôt compile. None of the features
of ownership will slow down your program while it‚Äôs running.
-->
<p><em>La possession</em> est un jeu de r√®gles qui gouvernent la gestion de la m√©moire
par un programme Rust. Tous les programmes doivent g√©rer la fa√ßon dont ils
utilisent la m√©moire lorsqu'ils s'ex√©cutent. Certains langages ont un
ramasse-miettes qui scrute constamment la m√©moire qui n'est plus utilis√©e
pendant qu'il s'ex√©cute¬†; dans d'autres langages, le d√©veloppeur doit
explicitement allouer et lib√©rer la m√©moire. Rust adopte une troisi√®me
approche¬†: la m√©moire est g√©r√©e avec un syst√®me de possession qui repose sur un
jeu de r√®gles que le compilateur v√©rifie au moment de la compilation. Si une de
ces r√®gles a √©t√© enfreinte, le programme ne sera pas compil√©. Aucune des
fonctionnalit√©s de la possession ne ralentit votre programme √† l'ex√©cution.</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the easier you‚Äôll find it to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>Comme la possession est un nouveau principe pour de nombreux d√©veloppeurs,
cela prend un certain temps pour s'y familiariser. La bonne nouvelle est que
plus vous devenez exp√©riment√© avec Rust et ses r√®gles de possession, plus vous
d√©velopperez naturellement et facilement du code s√ªr et efficace. Gardez bien
cela √† l'esprit¬†!</p>
<!--
When you understand ownership, you‚Äôll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you‚Äôll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>Lorsque vous comprendrez la possession, vous aurez des bases solides pour
comprendre les fonctionnalit√©s qui font la particularit√© de Rust. Dans ce
chapitre, vous allez apprendre la possession en pratiquant avec plusieurs
exemples qui se concentrent sur une structure de donn√©es tr√®s courante¬†: les
cha√Ænes de caract√®res.</p>
<!--
> ### The Stack and the Heap
>
> Many programming languages don‚Äôt require you to think about the stack and the
> heap very often. But in a systems programming language like Rust, whether a
> value is on the stack or the heap affects how the language behaves and why
> you have to make certain decisions. Parts of ownership will be described in
> relation to the stack and the heap later in this chapter, so here is a brief
> explanation in preparation.
>
> Both the stack and the heap are parts of memory available to your code to use
> at runtime, but they are structured in different ways. The stack stores
> values in the order it gets them and removes the values in the opposite
> order. This is referred to as *last in, first out*. Think of a stack of
> plates: when you add more plates, you put them on top of the pile, and when
> you need a plate, you take one off the top. Adding or removing plates from
> the middle or bottom wouldn‚Äôt work as well! Adding data is called *pushing
> onto the stack*, and removing data is called *popping off the stack*. All
> data stored on the stack must have a known, fixed size. Data with an unknown
> size at compile time or a size that might change must be stored on the heap
> instead.
>
> The heap is less organized: when you put data on the heap, you request a
> certain amount of space. The memory allocator finds an empty spot in the heap
> that is big enough, marks it as being in use, and returns a *pointer*, which
> is the address of that location. This process is called *allocating on the
> heap* and is sometimes abbreviated as just *allocating*. Pushing values onto
> the stack is not considered allocating. Because the pointer to the heap is a
> known, fixed size, you can store the pointer on the stack, but when you want
> the actual data, you must follow the pointer. Think of being seated at a
> restaurant. When you enter, you state the number of people in your group, and
> the staff finds an empty table that fits everyone and leads you there. If
> someone in your group comes late, they can ask where you‚Äôve been seated to
> find you.
>
> Pushing to the stack is faster than allocating on the heap because the
> allocator never has to search for a place to store new data; that location is
> always at the top of the stack. Comparatively, allocating space on the heap
> requires more work, because the allocator must first find a big enough space
> to hold the data and then perform bookkeeping to prepare for the next
> allocation.
>
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. It‚Äôs most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data that‚Äôs close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
>
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the function‚Äôs
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
>
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so you don‚Äôt run out of space are all problems that ownership
> addresses. Once you understand ownership, you won‚Äôt need to think about the
> stack and the heap very often, but knowing that the main purpose of ownership
> is to manage heap data can help explain why it works the way it does.
-->
<blockquote>
<h3 id="la-pile-et-le-tas"><a class="header" href="#la-pile-et-le-tas">La pile et le tas</a></h3>
<p>De nombreux langages ne n√©cessitent pas de se pr√©occuper de la
pile (<em>stack</em>) et du tas (<em>heap</em>). Mais dans un langage de programmation
syst√®me comme Rust, le fait qu'une donn√©e soit sur la pile ou sur le tas a une influence
sur le comportement du langage et explique pourquoi nous devons faire certains
choix. Nous d√©crirons plus loin dans ce chapitre comment la possession
fonctionne vis-√†-vis de la pile et du tas, voici donc une br√®ve explication au
pr√©alable.</p>
<p>La pile et le tas sont tous les deux des emplacements de la m√©moire √†
disposition de votre code lors de son ex√©cution, mais sont organis√©s de fa√ßon
diff√©rente. La pile enregistre les valeurs dans l'ordre qu'elle les re√ßoit et
enl√®ve les valeurs dans l'autre sens. C'est ce que l'on appelle le principe
de <em>dernier entr√©, premier sorti</em>. C'est comme une pile d'assiettes¬†: quand
vous ajoutez des nouvelles assiettes, vous les d√©posez sur le dessus de la
pile, et quand vous avez besoin d'une assiette, vous en prenez une sur le
dessus. Ajouter ou enlever des assiettes au milieu ou en bas ne serait pas
aussi efficace¬†! Ajouter une donn√©e sur la pile se dit <em>empiler</em> et en retirer
une se dit <em>d√©piler</em>. Toutes donn√©e stock√©e dans la pile doit avoir une
taille connue et fixe. Les donn√©es avec une taille inconnue au moment de la
compilation ou une taille qui peut changer doivent plut√¥t √™tre stock√©es sur
le tas.</p>
<p>Le tas est moins bien organis√©¬†: lorsque vous ajoutez des donn√©es sur le tas,
vous demandez une certaine quantit√© d'espace m√©moire. Le gestionnaire de
m√©moire va trouver un emplacement dans le tas qui est suffisamment grand, va
le marquer comme √©tant en cours d'utilisation, et va retourner un <em>pointeur</em>,
qui est l'adresse de cet emplacement. Cette proc√©dure est appel√©e <em>allocation
sur le tas</em>, ce qu'on abr√®ge parfois en <em>allocation</em> tout court. L'ajout de
valeurs sur la pile n'est pas consid√©r√© comme une allocation. Comme le
pointeur vers le tas a une taille connue et fixe, on peut stocker ce pointeur
sur la pile, mais quand on veut la vraie donn√©e, il faut suivre le pointeur.</p>
<p>C'est comme si vous vouliez manger au restaurant. Quand vous entrez, vous
indiquez le nombre de personnes dans votre groupe, et le personnel trouve une
table vide qui peut recevoir tout le monde, et vous y conduit. Si quelqu'un
dans votre groupe arrive en retard, il peut leur demander o√π vous √™tes assis
pour vous rejoindre.</p>
<p>Empiler sur la pile est plus rapide qu'allouer sur le tas car le gestionnaire
ne va jamais avoir besoin de chercher un emplacement pour y stocker les
nouvelles donn√©es¬†; il le fait toujours au sommet de la pile. En comparaison,
allouer de la place sur le tas demande plus de travail, car le gestionnaire
doit d'abord trouver un espace assez grand pour stocker les donn√©es et mettre
√† jour son suivi pour pr√©parer la prochaine allocation.</p>
<p>Acc√©der √† des donn√©es dans le tas est plus lent que d'acc√©der aux donn√©es sur
la pile car nous devons suivre un pointeur pour les obtenir. Les processeurs
modernes sont plus rapides s'ils se d√©placent moins dans la m√©moire. Pour
continuer avec notre analogie, imaginez un serveur dans un restaurant qui
prend les commandes de nombreuses tables. C'est plus efficace de r√©cup√©rer
toutes les commandes √† une seule table avant de passer √† la table suivante.
Prendre une commande √† la table A, puis prendre une commande √† la table B,
puis ensuite une autre √† la table A, puis une autre √† la table B serait un
processus bien plus lent. De la m√™me mani√®re, un processeur sera plus efficace
dans sa t√¢che s'il travaille sur des donn√©es qui sont proches les unes des
autres (comme c'est le cas sur la pile) plut√¥t que si elles sont plus
√©loign√©es (comme cela peut √™tre le cas sur le tas). Allouer une grande
quantit√© de m√©moire sur le tas peut aussi prendre beaucoup de temps.</p>
<p>Quand notre code utilise une fonction, les valeurs pass√©es √† la fonction
(incluant, potentiellement, des pointeurs de donn√©es sur le tas) et les
variables locales √† la fonction sont d√©pos√©es sur la pile. Quand l'utilisation
de la fonction est termin√©e, ces donn√©es sont retir√©es de la pile.</p>
<p>La possession nous aide √† ne pas nous pr√©occuper de faire attention √† quelles
parties du code utilisent quelles donn√©es sur le tas, de minimiser la
quantit√© de donn√©es en double sur le tas, ou encore de veiller √† lib√©rer les
donn√©es inutilis√©es sur le tas pour que nous ne soyons pas √† court d'espace.
Quand vous aurez compris la possession, vous n'aurez plus besoin de vous
pr√©occuper de la pile et du tas tr√®s souvent, mais savoir que le but
principal de la possession est de g√©rer les donn√©es du tas peut vous aider √†
comprendre pourquoi elle fonctionne de cette mani√®re.</p>
</blockquote>
<!--
### Ownership Rules
-->
<h3 id="les-r√®gles-de-la-possession"><a class="header" href="#les-r√®gles-de-la-possession">Les r√®gles de la possession</a></h3>
<!--
First, let‚Äôs take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>Tout d'abord, d√©finissons les r√®gles de la possession. Gardez √† l'esprit ces
r√®gles pendant que nous travaillons sur des exemples qui les illustrent¬†:</p>
<!--
* Each value in Rust has a variable that‚Äôs called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Chaque valeur en Rust a une variable qui s'appelle son <em>propri√©taire</em>.</li>
<li>Il ne peut y avoir qu'un seul propri√©taire √† la fois.</li>
<li>Quand le propri√©taire sortira de la port√©e, la valeur sera supprim√©e.</li>
</ul>
<!--
### Variable Scope
-->
<h3 id="port√©e-de-la-variable"><a class="header" href="#port√©e-de-la-variable">Port√©e de la variable</a></h3>
<!--
Now that we‚Äôre past basic Rust syntax, we won‚Äôt include all the `fn main() {`
code in examples, so if you‚Äôre following along, make sure to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>Maintenant
que nous avons vu la syntaxe Rust de base, nous n'allons plus ajouter tout le
code du style <code>fn main() {</code> dans les exemples, donc si vous voulez reproduire
les exemples, assurez-vous de les placer manuellement dans une fonction <code>main</code>. Par
cons√©quent, nos exemples seront plus concis, nous permettant de nous concentrer
sur les d√©tails de la situation plut√¥t que sur du code normalis√©.</p>
<!--
As a first example of ownership, we‚Äôll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:
-->
<p>Pour le premier exemple de possession, nous allons analyser la <em>port√©e</em> de
certaines variables. Une port√©e est une zone dans un programme dans laquelle un
√©l√©ment est en vigueur. Admettons la variable suivante¬†:</p>
<!--
```rust
let s = "hello";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it‚Äôs declared until the end of the current *scope*. Listing 4-1 shows a
program with comments annotating where the variable `s` would be valid.
-->
<p>La variable <code>s</code> fait r√©f√©rence √† un litt√©ral de cha√Æne de caract√®res, o√π la
valeur de la cha√Æne est cod√©e en dur dans notre programme. La variable est en
vigueur √† partir du moment o√π elle est d√©clar√©e jusqu'√† la fin de la <em>port√©e</em>
actuelle. L'encart 4-1 nous pr√©sente un programme avec des commentaires pour
indiquer quand la variable <code>s</code> est en vigueur¬†:</p>
<!--
```rust
# fn main() {
    {                      // s is not valid here, it‚Äôs not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                    // s n'est pas en vigueur ici, elle n'est pas encore d√©clar√©e
        let s = &quot;hello&quot;; // s est en vigueur √† partir de ce point

        // on fait des choses avec s ici
    }                    // cette port√©e est maintenant termin√©e, et s n'est plus en vigueur
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span>
-->
<p><span class="caption">Encart 4-1¬†: Une variable et la port√©e dans laquelle elle
est en vigueur.</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>Autrement dit, il y a ici deux √©tapes importantes¬†:</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li>Quand <code>s</code> rentre <em>dans la port√©e</em>, elle est en vigueur.</li>
<li>Cela reste ainsi jusqu'√† ce qu'elle <em>sorte de la port√©e</em>.</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we‚Äôll build on top of this
understanding by introducing the `String` type.
-->
<p>Pour le moment, la relation entre les port√©es et les conditions pour lesquelles
les variables sont en vigueur sont similaires √† d'autres langages de
programmation. Maintenant, nous allons aller plus loin en y ajoutant le type
<code>String</code>.</p>
<!--
### The `String` Type
-->
<h3 id="le-type-string"><a class="header" href="#le-type-string">Le type <code>String</code></a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the [‚ÄúData Types‚Äù][data-types]<!-- ignore -- > section
of Chapter 3. The types covered previously are all a known size, can be stored
on the stack and popped off the stack when their scope is over, and can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope. But we want to
look at data that is stored on the heap and explore how Rust knows when to
clean up that data, and the `String` type is a great example.
-->
<p>Pour illustrer les r√®gles de la possession, nous avons besoin d'un type de
donn√©e qui est plus complexe que ceux que nous avons rencontr√©s dans la section
<a href="ch03-02-data-types.html">‚ÄúTypes de donn√©es‚Äù</a><!-- ignore --> du chapitre 3. Les types que
nous avons vus pr√©c√©demment ont tous une taille connue et peuvent √™tre stock√©s
sur la pile ainsi que retir√©s de la pile lorsque la port√©e n'en a plus besoin,
et peuvent aussi √™tre rapidement et facilement copi√©s afin de constituer une nouvelle
instance ind√©pendante si une autre partie du code a besoin d'utiliser la m√™me
valeur dans une port√©e diff√©rente. Mais nous voulons exp√©rimenter le stockage
de donn√©es sur le tas et d√©couvrir comment Rust sait quand il doit nettoyer ces
donn√©es, et le type <code>String</code> est un bon exemple.</p>
<!--
We‚Äôll concentrate on the parts of `String` that relate to ownership. These
aspects also apply to other complex data types, whether they are provided by
the standard library or created by you. We‚Äôll discuss `String` in more depth in
[Chapter 8][ch8]<!-- ignore -- >.
-->
<p>Nous allons nous concentrer sur les caract√©ristiques de <code>String</code> qui sont li√©es
√† la possession. Ces aspects s'appliquent √©galement √† d'autres types de donn√©es
complexes, qu'ils soient fournis par la biblioth√®que standard ou qu'ils soient
cr√©√©s par vous. Nous verrons <code>String</code> plus en d√©tail dans le <a href="ch08-02-strings.html">chapitre
8</a><!-- ignore -->.</p>
<!--
We‚Äôve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren‚Äôt suitable for every
situation in which we may want to use text. One reason is that they‚Äôre
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type manages
data allocated on the heap and as such is able to store an amount of text that
is unknown to us at compile time. You can create a `String` from a string
literal using the `from` function, like so:
-->
<p>Nous avons d√©j√† vu les litt√©raux de cha√Ænes de caract√®res, quand une valeur de
cha√Æne est cod√©e en dur dans notre programme. Les litt√©raux de cha√Ænes sont
pratiques, mais ils ne conviennent pas toujours √† tous les cas o√π on veut
utiliser du texte. Une des raisons est qu'ils sont immuables. Une autre raison
est qu'on ne conna√Æt pas forc√©ment le contenu des cha√Ænes de caract√®res quand
nous √©crivons notre code¬†: par exemple, comment faire si nous voulons r√©cup√©rer
du texte saisi par l'utilisateur et l'enregistrer¬†? Pour ces cas-ci, Rust a un
second type de cha√Æne de caract√®res, <code>String</code>. Ce type g√®re ses donn√©es sur le
tas et est ainsi capable de stocker une quantit√© de texte qui nous est inconnue
au moment de la compilation. Vous pouvez cr√©er une <code>String</code> √† partir d'un
litt√©ral de cha√Æne de caract√®res en utilisant la fonction <code>from</code>, comme ceci¬†:</p>
<!--
```rust
let s = String::from("hello");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon `::` operator allows us to namespace this particular `from`
function under the `String` type rather than using some sort of name like
`string_from`. We‚Äôll discuss this syntax more in the [‚ÄúMethod
Syntax‚Äù][method-syntax]<!-- ignore -- > section of Chapter 5 and when we talk
about namespacing with modules in [‚ÄúPaths for Referring to an Item in the
Module Tree‚Äù][paths-module-tree]<!-- ignore -- > in Chapter 7.
-->
<p>L'op√©rateur double deux-points <code>::</code> nous permet d'appeler cette fonction
sp√©cifique dans l'espace de nom du type <code>String</code> plut√¥t que d'utiliser un nom
comme <code>string_from</code>. Nous verrons cette syntaxe plus en d√©tail dans la section
<a href="ch05-03-method-syntax.html">‚ÄúSyntaxe de m√©thode‚Äù</a><!-- ignore --> du chapitre 5 et lorsque
nous aborderons les espaces de noms dans la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúLes chemins pour d√©signer
un √©l√©ment dans l'arborescence de module‚Äù</a><!-- ignore --> du
chapitre 7.</p>
<!--
This kind of string *can* be mutated:
-->
<p>Ce type de cha√Æne de caract√®res <em>peut</em> √™tre mutable¬†:</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() ajoute un litt√©ral de cha√Æne dans une String
    
    println!(&quot;{}&quot;, s); // Cela va afficher `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<!--
So, what‚Äôs the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>Donc, quelle est la diff√©rence ici¬†? Pourquoi <code>String</code> peut √™tre mutable, mais
pourquoi les litt√©raux de cha√Ænes ne peuvent pas l'√™tre¬†? La diff√©rence
se trouve dans la fa√ßon dont ces deux types travaillent avec la m√©moire.</p>
<!--
### Memory and Allocation
-->
<h3 id="m√©moire-et-allocation"><a class="header" href="#m√©moire-et-allocation">M√©moire et allocation</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal‚Äôs immutability. Unfortunately, we can‚Äôt put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>Dans le cas d'un litt√©ral de cha√Æne de caract√®res, nous connaissons le contenu
au moment de la compilation donc le texte est cod√© en dur directement dans
l'ex√©cutable final. Voil√† pourquoi ces litt√©raux de cha√Ænes de caract√®res sont
performants et rapides. Mais ces caract√©ristiques viennent de leur immuabilit√©.
Malheureusement, on ne peut pas accorder une grosse r√©gion de m√©moire dans le
binaire pour chaque morceau de texte qui n'a pas de taille connue au moment de
la compilation et dont la taille pourrait changer pendant l'ex√©cution de ce
programme.</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p>Avec le type <code>String</code>, pour nous permettre d'avoir un texte mutable et qui peut
s'agrandir, nous devons allouer une quantit√© de m√©moire sur le tas, inconnue
au moment de la compilation, pour stocker le contenu. Cela signifie que¬†:</p>
<!--
* The memory must be requested from the memory allocator at runtime.
* We need a way of returning this memory to the allocator when we‚Äôre
  done with our `String`.
-->
<ul>
<li>La m√©moire doit √™tre demand√©e aupr√®s du gestionnaire de m√©moire lors de
l'ex√©cution.</li>
<li>Nous avons besoin d'un moyen de rendre cette m√©moire au gestionnaire lorsque
nous aurons fini d'utiliser notre <code>String</code>.</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>Nous nous occupons de ce premier point¬†: quand nous appelons <code>String::from</code>, son
impl√©mentation demande la m√©moire dont elle a besoin. C'est pratiquement
toujours ainsi dans la majorit√© des langages de programmation.</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track of and cleans up memory that isn‚Äôt being used
anymore, and we don‚Äôt need to think about it. In most languages without a GC,
it‚Äôs our responsibility to identify when memory is no longer being used and
call code to explicitly return it, just as we did to request it. Doing this
correctly has historically been a difficult programming problem. If we forget,
we‚Äôll waste memory. If we do it too early, we‚Äôll have an invalid variable. If
we do it twice, that‚Äôs a bug too. We need to pair exactly one `allocate` with
exactly one `free`.
-->
<p>Cependant, le deuxi√®me point est diff√©rent. Dans des langages avec un
<em>ramasse-miettes</em>, le ramasse-miettes surveille et nettoie la m√©moire qui n'est
plus utilis√©e, sans que nous n'ayons √† nous en pr√©occuper. Dans la pluspart des
langages sans ramasse-miettes, c'est de notre responsabilit√© d'identifier quand
cette m√©moire n'est plus utilis√©e et d'appeler du code pour explicitement la
lib√©rer, comme nous l'avons fait pour la demander auparavant. Historiquement,
faire ceci correctement a toujours √©t√© une difficult√© pour les d√©veloppeurs. Si
nous oublions de le faire, nous allons gaspiller de la m√©moire. Si nous le
faisons trop t√¥t, nous allons avoir une variable invalide. Si nous le faisons
deux fois, cela produit aussi un bogue. Nous devons associer exactement un
<code>allocate</code> avec exactement un <code>free</code>.</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here‚Äôs a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rust prend un chemin diff√©rent¬†: la m√©moire est automatiquement lib√©r√©e d√®s
que la variable qui la poss√®de sort de la port√©e. Voici une version de notre
exemple de port√©e de l'encart 4-1 qui utilise une <code>String</code> plut√¥t qu'un litt√©ral
de cha√Æne de caract√®res¬†:</p>
<!--
```rust
# fn main() {
    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s est en vigueur √† partir de ce point
    
        // on fait des choses avec s ici
    }                                  // cette port√©e est d√©sormais termin√©e, et s
                                       // n'est plus en vigueur maintenant
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the allocator: when `s` goes out of scope. When a variable goes out of
scope, Rust calls a special function for us. This function is called
[`drop`][drop]<!-- ignore -- >, and it‚Äôs where the author of `String` can put
the code to return the memory. Rust calls `drop` automatically at the closing
curly bracket.
-->
<p>Il y a un moment naturel o√π nous devons rendre la m√©moire de notre
<code>String</code> au gestionnaire¬†: quand <code>s</code> sort de la port√©e. Quand une variable sort
de la port√©e, Rust appelle une fonction sp√©ciale pour nous. Cette fonction
s'appelle <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, et c'est dans celle-ci que l'auteur de
<code>String</code> a pu mettre le code pour lib√©rer la m√©moire. Rust appelle
automatiquement <code>drop</code> √† l'accolade fermante <code>}</code>.</p>
<!--
> Note: In C++, this pattern of deallocating resources at the end of an item‚Äôs
> lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
> The `drop` function in Rust will be familiar to you if you‚Äôve used RAII
> patterns.
-->
<blockquote>
<p>Remarque¬†: en C++, cette fa√ßon de lib√©rer des ressources √† la fin de la
dur√©e de vie d'un √©l√©ment est parfois appel√©e <em>l'acquisition d'une ressource
est une initialisation (RAII)</em>. La fonction <code>drop</code> de Rust vous sera famili√®re
si vous avez d√©j√† utilis√© des techniques de RAII.</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we‚Äôve allocated on the heap. Let‚Äôs explore some of those situations now.
-->
<p>Cette fa√ßon de faire a un impact profond sur la fa√ßon dont le code Rust est
√©crit. Cela peut sembler simple dans notre cas, mais le comportement du code
peut √™tre surprenant dans des situations plus compliqu√©es o√π nous voulons
avoir plusieurs variables utilisant des donn√©es que nous avons affect√©es sur le
tas. Examinons une de ces situations d√®s √† pr√©sent.</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4 id="les-interactions-entre-les-variables-et-les-donn√©es--le-d√©placement"><a class="header" href="#les-interactions-entre-les-variables-et-les-donn√©es--le-d√©placement">Les interactions entre les variables et les donn√©es¬†: le d√©placement</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Let‚Äôs look at an example using an integer in Listing 4-2.
-->
<p>Plusieurs variables peuvent interagir avec les m√™mes donn√©es de diff√©rentes
mani√®res en Rust. Regardons un exemple avec un entier dans l'encart 4-2¬†:</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span>
-->
<p><span class="caption">Encart 4-2¬†: Assigner l'entier de la variable <code>x</code> √† <code>y</code>
</span></p>
<!--
We can probably guess what this is doing: ‚Äúbind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.‚Äù We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>Nous pouvons probablement deviner ce que ce code fait¬†: ‚ÄúAssigner la valeur <code>5</code>
√† <code>x</code>¬†; ensuite faire une copie de cette valeur de <code>x</code> et l'assigner √† <code>y</code>.‚Äù
Nous avons maintenant deux variables, <code>x</code> et <code>y</code>, et chacune vaut <code>5</code>. C'est
effectivement ce qui se passe, car les entiers sont des valeurs simples avec une
taille connue et fix√©e, et ces deux valeurs <code>5</code> sont stock√©es sur la pile.</p>
<!--
Now let‚Äôs look at the `String` version:
-->
<p>Maintenant, essayons une nouvelle version avec <code>String</code>¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar, so we might assume that the way it works would be the
same: that is, the second line would make a copy of the value in `s1` and bind
it to `s2`. But this isn‚Äôt quite what happens.
-->
<p>Cela ressemble beaucoup, donc nous allons supposer que cela fonctionne pareil
que pr√©c√©demment¬†: ainsi, la seconde ligne va faire une copie de la valeur de
<code>s1</code> et l'assigner √† <code>s2</code>. Mais ce n'est pas tout √† fait ce qu'il se passe.</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>Regardons l'illustration 4-1 pour d√©couvrir ce qui arrive √† <code>String</code> sous le
capot. Une <code>String</code> est constitu√©e de trois √©l√©ments, pr√©sents sur la gauche¬†:
un pointeur vers la m√©moire qui contient le contenu de la cha√Æne de caract√®res,
une taille, et une capacit√©. Ce groupe de donn√©es est stock√© sur la pile. √Ä
droite, nous avons la m√©moire sur le tas qui contient les donn√©es.</p>
<!-- markdownlint-disable -->
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une string en m√©moire" src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>
-->
<p><span class="caption">Illustration 4-1¬†: Repr√©sentation en m√©moire d'une
<code>String</code> qui contient la valeur <code>&quot;hello&quot;</code> assign√©e √† <code>s1</code>.</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the allocator. The difference between length
and capacity matters, but not in this context, so for now, it‚Äôs fine to ignore
the capacity.
-->
<p>La taille est la quantit√© de m√©moire, en octets, que le contenu de la <code>String</code>
utilise actuellement. La capacit√© est la quantit√© totale de m√©moire, en octets,
que la <code>String</code> a re√ßue du gestionnaire. La diff√©rence entre la taille et la
capacit√© est importante, mais pas pour notre exemple, donc pour l'instant, ce
n'est pas grave d'ignorer la capacit√©.</p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p>Quand nous assignons <code>s1</code> √† <code>s2</code>, les donn√©es de la <code>String</code> sont copi√©es, ce
qui veut dire que nous copions le pointeur, la taille et la capacit√© qui sont
stock√©s sur la pile. Nous ne copions pas les donn√©es stock√©es sur le tas
auxquelles le pointeur se r√©f√®re. Autrement dit, la repr√©sentation des donn√©es
dans la m√©moire ressemble √† l'illustration 4-2.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 qui pointent vers la m√™me valeur" src="img/trpl04-02.svg"
class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>
-->
<p><span class="caption">Illustration 4-2¬†: Repr√©sentation en m√©moire de la
variable <code>s2</code> qui a une copie du pointeur, de la taille et de la capacit√© de
<code>s1</code></span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>Cette repr√©sentation <em>n'est pas</em> comme l'illustration 4-3, qui repr√©senterait la
m√©moire si Rust avait aussi copi√© les donn√©es sur le tas. Si Rust faisait ceci,
l'op√©ration <code>s2 = s1</code> pourrait potentiellement √™tre tr√®s co√ªteuse en termes de
performances d'ex√©cution si les donn√©es sur le tas √©taient volumineuses.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 √† deux endroits" src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>
-->
<p><span class="caption">Illustration 4-3¬†: Une autre possibilit√© de ce que
pourrait faire <code>s2 = s1</code> si Rust copiait aussi les donn√©es du tas</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>Pr√©c√©demment, nous avons dit que quand une variable sortait de la port√©e, Rust
appelait automatiquement la fonction <code>drop</code> et nettoyait la m√©moire sur le tas
allou√©e pour cette variable. Mais l'illustration 4-2 montre que les deux
pointeurs de donn√©es pointeraient au m√™me endroit. C'est un probl√®me¬†: quand
<code>s2</code> et <code>s1</code> sortent de la port√©e, elles vont essayer toutes les deux de
lib√©rer la m√™me m√©moire. C'est ce qu'on appelle une erreur de <em>double
lib√©ration</em> et c'est un des bogues de s√©curit√© de m√©moire que nous avons
mentionn√©s pr√©c√©demment. Lib√©rer la m√©moire deux fois peut mener √† des
corruptions de m√©moire, ce qui peut potentiellement mener √† des vuln√©rabilit√©s
de s√©curit√©.</p>
<!--
To ensure memory safety, after the line `let s2 = s1`, Rust considers `s1` as
no longer valid. Therefore, Rust doesn‚Äôt need to free anything when `s1` goes
out of scope. Check out what happens when you try to use `s1` after `s2` is
created; it won‚Äôt work:
-->
<p>Pour garantir la s√©curit√© de la m√©moire, apr√®s la ligne <code>let s2 = s1</code>, Rust
consid√®re que <code>s1</code> n'est plus en vigueur. Par cons√©quent, Rust n'a pas besoin
de lib√©rer quoi que ce soit lorsque <code>s1</code> sort de la port√©e. Regardez ce qu'il
se passe quand vous essayez d'utiliser <code>s1</code> apr√®s que <code>s2</code> est cr√©√©, cela ne va
pas fonctionner¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<!--
You‚Äôll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>Vous allez avoir une erreur comme celle-ci, car Rust vous d√©fend d'utiliser la
r√©f√©rence qui n'est plus en vigueur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 -- > src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
If you‚Äôve heard the terms *shallow copy* and *deep copy* while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of calling it a
shallow copy, it‚Äôs known as a *move*. In this example, we would say that
`s1` was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>Si vous avez d√©j√† entendu parler de <em>copie superficielle</em> et de <em>copie
profonde</em> en utilisant d'autres langages, l'id√©e de copier le pointeur, la
taille et la capacit√© sans copier les donn√©es peut vous faire penser √† de la
copie superficielle. Mais comme Rust neutralise aussi la premi√®re variable, au
lieu d'appeler cela une copie superficielle, on appelle cela un <em>d√©placement</em>.
Ici, nous pourrions dire que <code>s1</code> a √©t√© <em>d√©plac√©</em> dans <code>s2</code>. Donc ce qui se
passe r√©ellement est d√©crit par l'illustration 4-4.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 d√©plac√© dans s2" src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>
-->
<p><span class="caption">Illustration 4-4¬†: Repr√©sentation de la m√©moire apr√®s que
<code>s1</code> a √©t√© neutralis√©e</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and we‚Äôre done.
-->
<p>Cela r√©sout notre probl√®me¬†! Avec seulement <code>s2</code> en vigueur, quand elle
sortira de la port√©e, elle seule va lib√©rer la m√©moire, et c'est tout.</p>
<!--
In addition, there‚Äôs a design choice that‚Äôs implied by this: Rust will never
automatically create ‚Äúdeep‚Äù copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>De plus, cela signifie qu'il y a eu un choix de conception¬†: Rust ne va jamais
cr√©er automatiquement de copie ‚Äúprofonde‚Äù de vos donn√©es. Par cons√©quent, toute
copie <em>automatique</em> peut √™tre consid√©r√©e comme peu co√ªteuse en termes de
performances d'ex√©cution.</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4 id="les-interactions-entre-les-variables-et-les-donn√©es--le-clonage"><a class="header" href="#les-interactions-entre-les-variables-et-les-donn√©es--le-clonage">Les interactions entre les variables et les donn√©es¬†: le clonage</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. We‚Äôll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you‚Äôve probably seen them before.
-->
<p>Si nous <em>voulons</em> faire une copie profonde des donn√©es sur le tas d'une
<code>String</code>, et pas seulement des donn√©es sur la pile, nous pouvons utiliser une
m√©thode commune qui s'appelle <code>clone</code>. Nous aborderons la syntaxe des m√©thodes
au chapitre 5, mais comme les m√©thodes sont des outils courants dans de
nombreux langages, vous les avez probablement utilis√©es auparavant.</p>
<!--
Here‚Äôs an example of the `clone` method in action:
-->
<p>Voici un exemple d'utilisation de la m√©thode <code>clone</code>¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>Cela fonctionne tr√®s bien et c'est ainsi que vous pouvez reproduire le
comportement d√©crit dans l'illustration 4-3, o√π les donn√©es du tas sont copi√©es.</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. It‚Äôs a visual indicator that something
different is going on.
-->
<p>Quand vous voyez un appel √† <code>clone</code>, vous savez que du code arbitraire est
ex√©cut√© et que ce code peut √™tre co√ªteux. C'est un indicateur visuel qu'il se
passe quelque chose de diff√©rent.</p>
<!--
#### Stack-Only Data: Copy
-->
<h4 id="donn√©es-uniquement-sur-la-pile--la-copie"><a class="header" href="#donn√©es-uniquement-sur-la-pile--la-copie">Donn√©es uniquement sur la pile¬†: la copie</a></h4>
<!--
There‚Äôs another wrinkle we haven‚Äôt talked about yet. This code using integers ‚Äì
part of which was shown in Listing 4-2 ‚Äì works and is valid:
-->
<p>Il y a un autre d√©tail dont on n'a pas encore parl√©. Le code suivant utilise
des entiers - on en a vu une partie dans l'encart 4-2¬†- il fonctionne et
est correct¬†:</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we don‚Äôt have a call to
`clone`, but `x` is still valid and wasn‚Äôt moved into `y`.
-->
<p>Mais ce code semble contredire ce que nous venons d'apprendre¬†: nous n'avons
pas appel√© <code>clone</code>, mais <code>x</code> est toujours en vigueur et n'a pas √©t√© d√©plac√©
dans <code>y</code>.</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there‚Äôs no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, there‚Äôs no difference
between deep and shallow copying here, so calling `clone` wouldn‚Äôt do anything
different from the usual shallow copying and we can leave it out.
-->
<p>La raison est que les types comme les entiers ont une taille connue au moment de
la compilation et sont enti√®rement stock√©s sur la pile, donc la copie des
vraies valeurs est rapide √† faire. Cela signifie qu'il n'y a pas de raison que
nous voudrions neutraliser <code>x</code> apr√®s avoir cr√©√© la variable <code>y</code>. En d'autres
termes, il n'y a pas ici de diff√©rence entre la copie superficielle et profonde,
donc appeler <code>clone</code> ne ferait rien d'autre qu'une copie superficielle classique
et on peut s'en passer.</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types that are stored on the stack like integers are (we‚Äôll talk more about
traits in Chapter 10). If a type implements the `Copy` trait, a variable is
still valid after assignment to another variable. Rust won‚Äôt let us annotate a
type with `Copy` if the type, or any of its parts, has implemented the `Drop`
trait. If the type needs something special to happen when the value goes out of
scope and we add the `Copy` annotation to that type, we‚Äôll get a compile-time
error. To learn about how to add the `Copy` annotation to your type to
implement the trait, see [‚ÄúDerivable Traits‚Äù][derivable-traits]<!-- ignore -- >
in Appendix C.
-->
<p>Rust a une annotation sp√©ciale appel√©e le trait <code>Copy</code> que nous pouvons utiliser
sur des types comme les entiers qui sont stock√©s sur la pile (nous verrons les
traits dans le chapitre 10). Si un type impl√©mente le trait <code>Copy</code>, une
variable sera toujours en vigueur apr√®s avoir √©t√© affect√©e √† une autre
variable. Rust ne nous autorisera pas √† annoter un type avec le trait <code>Copy</code> si
ce type, ou un de ses √©l√©ments, a impl√©ment√© le trait <code>Drop</code>. Si ce type a
besoin que quelque chose de sp√©cial se produise quand la valeur sort de la
port√©e et que nous ajoutons l'annotation <code>Copy</code> sur ce type, nous aurons une
erreur au moment de la compilation. Pour savoir comment ajouter l'annotation
<code>Copy</code> sur votre type pour impl√©menter le trait, r√©f√©rez-vous √† <a href="appendix-03-derivable-traits.html">l'annexe
C</a><!-- ignore --> sur les traits d√©rivables.</p>
<!--
So what types implement the `Copy` trait? You can check the documentation for
the given type to be sure, but as a general rule, any group of simple scalar
values can implement `Copy`, and nothing that requires allocation or is some
form of resource can implement `Copy`. Here are some of the types that
implement `Copy`:
-->
<p>Donc, quels sont les types qui impl√©mentent le trait <code>Copy</code>¬†? Vous pouvez
regarder dans la documentation pour un type donn√© pour vous en assurer, mais de
mani√®re g√©n√©rale, tout groupe de valeur scalaire peut impl√©menter <code>Copy</code>, et
tout ce qui ne n√©cessite pas d'allocation de m√©moire ou tout autre forme de
ressource qui impl√©mente <code>Copy</code>. Voici quelques types qui impl√©mentent <code>Copy</code>¬†:</p>
<!--
* All the integer types, such as `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, such as `f64`.
* The character type, `char`.
* Tuples, if they only contain types that also implement `Copy`. For example,
  `(i32, i32)` implements `Copy`, but `(i32, String)` does not.
-->
<ul>
<li>Tous les types d'entiers, comme <code>u32</code>.</li>
<li>Le type bool√©en, <code>bool</code>, avec les valeurs <code>true</code> et <code>false</code>.</li>
<li>Tous les types de flottants, comme <code>f64</code>.</li>
<li>Le type de caract√®re, <code>char</code>.</li>
<li>Les tuples, mais uniquement s'ils contiennent des types qui impl√©mentent
aussi <code>Copy</code>. Par exemple, le <code>(i32, i32)</code> impl√©mente <code>Copy</code>, mais pas
<code>(i32, String)</code>.</li>
</ul>
<!--
### Ownership and Functions
-->
<h3 id="la-possession-et-les-fonctions"><a class="header" href="#la-possession-et-les-fonctions">La possession et les fonctions</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>La syntaxe pour passer une valeur √† une fonction est similaire √† celle pour
assigner une valeur √† une variable. Passer une variable √† une fonction va la
d√©placer ou la copier, comme l'assignation. L'encart 4-3 est un exemple avec
quelques commentaires qui montrent o√π les variables rentrent et sortent de la
port√©e¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello&quot;);  // s rentre dans la port√©e.

  prendre_possession(s);  // La valeur de s est d√©plac√©e dans la fonction‚Ä¶
                          // ‚Ä¶ et n'est plus en vigueur √† partir d'ici

  let x = 5;              // x rentre dans la port√©e.

  creer_copie(x);         // x va √™tre d√©plac√©e dans la fonction,
                          // mais i32 est Copy, donc on peut
                          // utiliser x ensuite.

} // Ici, x sort de la port√©e, puis ensuite s. Mais puisque la valeur de s a
// √©t√© d√©plac√©e, il ne se passe rien de sp√©cial.

fn prendre_possession(texte: String) { // texte rentre dans la port√©e.
  println!(&quot;{}&quot;, texte);
} // Ici, texte sort de la port√©e et `drop` est appel√©. La m√©moire est lib√©r√©e.

fn creer_copie(entier: i32) { // entier rentre dans la port√©e.
  println!(&quot;{}&quot;, entier);
} // Ici, entier sort de la port√©e. Il ne se passe rien de sp√©cial.
</code></pre></pre>
<!--
<span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span>
-->
<p><span class="caption">Encart 4-3¬†: Les fonctions avec les possessions et les
port√©es qui sont comment√©es</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p>Si on essayait d'utiliser <code>s</code> apr√®s l'appel √† <code>prendre_possession</code>, Rust
d√©clencherait une erreur √† la compilation. Ces v√©rifications statiques
nous prot√®gent des erreurs. Essayez d'ajouter du code au <code>main</code> qui utilise <code>s</code>
et <code>x</code> pour d√©couvrir lorsque vous pouvez les utiliser et lorsque les r√®gles de
la possession vous emp√™chent de le faire.</p>
<!--
### Return Values and Scope
-->
<h3 id="les-valeurs-de-retour-et-les-port√©es"><a class="header" href="#les-valeurs-de-retour-et-les-port√©es">Les valeurs de retour et les port√©es</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 shows an example
of a function that returns some value, with similar annotations as those in
Listing 4-3.
-->
<p>Retourner des valeurs peut aussi transf√©rer leur possession. L'encart 4-4
montre un exemple d'une fonction qui retourne une valeur, avec des annotations
similaires √† celles de l'encart 4-3¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s1 = donne_possession();     // donne_possession d√©place sa valeur de
                                   // retour dans s1

  let s2 = String::from(&quot;hello&quot;);  // s2 rentre dans la port√©e

  let s3 = prend_et_rend(s2);      // s2 est d√©plac√©e dans
                                   // prend_et_rend, qui elle aussi
                                   // d√©place sa valeur de retour dans s3.
} // Ici, s3 sort de la port√©e et est √©limin√©e. s2 a √©t√© d√©plac√©e donc il ne se
  // passe rien. s1 sort aussi de la port√©e et est √©limin√©e.

fn donne_possession() -&gt; String {      // donne_possession va d√©placer sa
                                       // valeur de retour dans la
                                       // fonction qui l'appelle.

  let texte = String::from(&quot;yours&quot;);   // texte rentre dans la port√©e.

  texte                                // texte est retourn√©e et
                                       // est d√©plac√©e vers le code qui
                                       // l'appelle.
}

// Cette fonction va prendre une String et en retourne aussi une.
fn prend_et_rend(texte: String) -&gt; String { // texte rentre dans la port√©e.

  texte  // texte est retourn√©e et d√©plac√©e vers le code qui l'appelle.
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">Encart 4-4¬†: Transferts de possession des valeurs de
retour</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless ownership
of the data has been moved to another variable.
-->
<p>La possession d'une variable suit toujours le m√™me sch√©ma √† chaque fois¬†:
assigner une valeur √† une autre variable la d√©place. Quand une variable qui
contient des donn√©es sur le tas sort de la port√©e, la valeur sera nettoy√©e avec
<code>drop</code> √† moins que la possession de cette donn√©e soit donn√©e √† une autre
variable.</p>
<!--
While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? It‚Äôs quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.
-->
<p>M√™me si cela fonctionne, il est un peu fastidieux de prendre la possession puis
ensuite de retourner la possession √† chaque fonction. Et qu'est-ce qu'il se
passe si nous voulons qu'une fonction utilise une valeur, mais n'en prenne pas
possession¬†? C'est assez p√©nible que tout ce que nous passons doit √™tre
retourn√© si nous voulons l'utiliser √† nouveau, en plus de toutes les donn√©es
qui d√©coulent du corps de la fonction que nous voulons aussi r√©cup√©rer.</p>
<!--
Rust does let us return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>Rust nous permet de retourner plusieurs valeurs √† l'aide d'un tuple, comme
ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, taille) = calculer_taille(s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s2, taille);
}

fn calculer_taille(s: String) -&gt; (String, usize) {
    let taille = s.len(); // len() retourne la taille d'une String.

    (s, taille)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">Encart 4-5¬†: Retourner la possession des param√®tres</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for using a value without
transferring ownership, called *references*.
-->
<p>Mais c'est trop laborieux et beaucoup de travail pour un principe qui devrait
√™tre banal. Heureusement pour nous, Rust a une fonctionnalit√© pour utiliser une
valeur sans avoir √† transf√©rer la possession, avec ce qu'on appelle les
<em>r√©f√©rences</em>.</p>
<!-- markdownlint-disable -->
<!--
[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## References and Borrowing
-->
<h2 id="les-r√©f√©rences-et-lemprunt"><a class="header" href="#les-r√©f√©rences-et-lemprunt">Les r√©f√©rences et l'emprunt</a></h2>
<!--
The issue with the tuple code in Listing 4-5 is that we have to return the
`String` to the calling function so we can still use the `String` after the
call to `calculate_length`, because the `String` was moved into
`calculate_length`. Instead, we can provide a reference to the `String` value.
A *reference* is like a pointer in that it‚Äôs an address we can follow to access
data stored at that address that is owned by some other variable. Unlike a
pointer, a reference is guaranteed to point to a valid value of a particular
type. Here is how you would define and use a `calculate_length` function that
has a reference to an object as a parameter instead of taking ownership of the
value:
-->
<p>La difficult√© avec le code du tuple √† la fin de la section pr√©c√©dente est que
nous avons besoin de retourner la <code>String</code> au code appelant pour qu'il puisse
continuer √† utiliser la <code>String</code> apr√®s l'appel √† <code>calculer_taille</code>, car la
<code>String</code> a √©t√© d√©plac√©e dans <code>calculer_taille</code>. √Ä la place, nous pouvons
fournir une r√©f√©rence √† la valeur de la String. Une <em>r√©f√©rence</em> est comme un
pointeur dans le sens o√π c'est une adresse que nous pouvons suivre pour acc√©der
√† la donn√©e stock√©e √† cette adresse qui est poss√©d√©e par une autre variable.
Mais contrairement aux pointeurs, une r√©f√©rence garantit de pointer vers une
valeur en vigueur, d'un type bien d√©termin√©. Voici comment d√©finir et utiliser
une fonction <code>calculer_taille</code> qui prend une <em>r√©f√©rence</em> √† un objet en
param√®tre plut√¥t que de prendre possession de la valeur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
}

fn calculer_taille(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!--
First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass `&s1` into
`calculate_length` and, in its definition, we take `&String` rather than
`String`. These ampersands represent *references*, and they allow you to refer
to some value without taking ownership of it. Figure 4-5 depicts this concept.
-->
<p>Premi√®rement, on peut observer que tout le code des <em>tuples</em> dans la
d√©claration des variables et dans la valeur de retour de la fonction a √©t√©
enlev√©. Deuxi√®mement, remarquez que nous passons <code>&amp;s1</code> √† <code>calculer_taille</code>, et
que dans sa d√©finition, nous utilisons <code>&amp;String</code> plut√¥t que <code>String</code>. Ces
esperluettes repr√©sentent les <em>r√©f√©rences</em>, et elles permettent de vous r√©f√©rer
√† une valeur sans en prendre possession. L'illustration 4-5 illustre ce
concept.</p>
<!-- markdownlint-disable -->
<!--
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img alt="&String s qui pointe vers la String s1" src="img/trpl04-05.svg"
class="center" /></p>
<!--
<span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String
s1`</span>
-->
<p><span class="caption">Illustration 4-5¬†: Un sch√©ma de la <code>&amp;String s</code> qui pointe
vers la <code>String s1</code></span></p>
<!--
> Note: The opposite of referencing by using `&` is *dereferencing*, which is
> accomplished with the dereference operator, `*`. We‚Äôll see some uses of the
> dereference operator in Chapter 8 and discuss details of dereferencing in
> Chapter 15.
-->
<blockquote>
<p>Remarque¬†: l'oppos√© de la cr√©ation de r√©f√©rences avec <code>&amp;</code> est le
<em>d√©r√©f√©rencement</em>, qui s'effectue avec l'op√©rateur de d√©r√©f√©rencement, <code>*</code>.
Nous allons voir quelques utilisations de l'op√©rateur de d√©r√©f√©rencement dans
le chapitre 8 et nous aborderons les d√©tails du d√©r√©f√©rencement dans le
chapitre 15.</p>
</blockquote>
<!--
Let‚Äôs take a closer look at the function call here:
-->
<p>Regardons de plus pr√®s l'appel √† la fonction¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
# fn calculate_length(s: &String) -> usize {
#     s.len()
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculer_taille(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<!--
The `&s1` syntax lets us create a reference that *refers* to the value of `s1`
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference stops being used.
-->
<p>La syntaxe <code>&amp;s1</code> nous permet de cr√©er une r√©f√©rence qui se <em>r√©f√®re</em> √† la valeur
de <code>s1</code> mais n'en prend pas possession. Et comme elle ne la poss√®de pas, la
valeur vers laquelle elle pointe ne sera pas lib√©r√©e quand cette r√©f√©rence
ne sera plus utilis√©e.</p>
<!--
Likewise, the signature of the function uses `&` to indicate that the type of
the parameter `s` is a reference. Let‚Äôs add some explanatory annotations:
-->
<p>De la m√™me mani√®re, la signature de la fonction utilise <code>&amp;</code> pour indiquer que
le type du param√®tre <code>s</code> est une r√©f√©rence. Ajoutons quelques commentaires
explicatifs¬†:</p>
<!--
```rust
# fn main() {
#     let s1 = String::from("hello");
# 
#     let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let long = calculer_taille(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculer_taille(s: &amp;String) -&gt; usize { // s est une r√©f√©rence √† une String
  s.len()
} // Ici, s sort de la port√©e. Mais comme elle ne prend pas possession de ce
  // √† quoi elle fait r√©f√©rence, il ne se passe rien.
</code></pre></pre>
<!--
The scope in which the variable `s` is valid is the same as any function
parameter‚Äôs scope, but the value pointed to by the reference is not dropped
when `s` stops being used because `s` doesn‚Äôt have ownership. When functions
have references as parameters instead of the actual values, we won‚Äôt need to
return the values in order to give back ownership, because we never had
ownership.
-->
<p>La port√©e dans laquelle la variable <code>s</code> est en vigueur est la m√™me que toute
port√©e d'un param√®tre de fonction, mais la valeur point√©e par la r√©f√©rence
n'est pas lib√©r√©e quand <code>s</code> n'est plus utilis√©, car <code>s</code> n'en prends pas
possession. Lorsque les fonctions ont des r√©f√©rences en param√®tres au lieu des
valeurs r√©elles, nous n'avons pas besoin de retourner les valeurs pour les
rendre, car nous n'en avons jamais pris possession.</p>
<!--
We call the action of creating a reference *borrowing*. As in real life, if a
person owns something, you can borrow it from them. When you‚Äôre done, you have
to give it back. You don‚Äôt own it.
-->
<p>Nous appelons <em>l'emprunt</em> l'action de cr√©er une r√©f√©rence. Comme dans la vie
r√©elle, quand un objet appartient √† quelqu'un, vous pouvez le lui emprunter. Et
quand vous avez fini, vous devez le lui rendre. Vous ne le poss√©dez pas.</p>
<!--
So what happens if we try to modify something we‚Äôre borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn‚Äôt work!
-->
<p>Donc qu'est-ce qui se passe si nous essayons de modifier quelque chose que nous
empruntons¬†? Essayez le code dans l'encart 4-6. Attention, spoiler¬†: cela ne
fonctionne pas¬†!</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    changer(&amp;s);
}

fn changer(texte: &amp;String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 4-6: Attempting to modify a borrowed value</span>
-->
<p><span class="caption">Entr√©e 4-6¬†: Tentative de modification d'une valeur
emprunt√©e.</span></p>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 -- > src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*texte` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn changer(texte: &amp;String) {
  |                   ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     texte.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ `texte` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Just as variables are immutable by default, so are references. We‚Äôre not
allowed to modify something we have a reference to.
-->
<p>Comme les variables sont immuables par d√©faut, les r√©f√©rences le sont aussi.
Nous ne sommes pas autoris√©s √† modifier une chose quand nous avons une r√©f√©rence
vers elle.</p>
<!--
### Mutable References
-->
<h3 id="les-r√©f√©rences-mutables"><a class="header" href="#les-r√©f√©rences-mutables">Les r√©f√©rences mutables</a></h3>
<!--
We can fix the code from Listing 4-6 to allow us to modify a borrowed value
with just a few small tweaks that use, instead, a *mutable reference*:
-->
<p>Nous pouvons r√©soudre le code de l'encart 4-6 pour nous permettre de modifier
une valeur emprunt√©e avec quelques petites modification qui utilisent plut√¥t
une <em>r√©f√©rence mutable</em>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    changer(&amp;mut s);
}

fn changer(texte: &amp;mut String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!--
First, we change `s` to be `mut`. Then we create a mutable reference with `&mut
s` where we call the `change` function, and update the function signature to
accept a mutable reference with `some_string: &mut String`. This makes it very
clear that the `change` function will mutate the value it borrows.
-->
<p>D'abord, nous pr√©cisons que <code>s</code> est <code>mut</code>. Ensuite, nous avons cr√©√© une
r√©f√©rence mutable avec <code>&amp;mut s</code> o√π nous appelons la fonction <code>change</code> et nous
avons modifi√© la signature pour accepter de prendre une r√©f√©rence mutable avec
<code>texte: &amp;mut String</code>. Cela pr√©cise clairement que la fonction <code>change</code> va faire
muter la valeur qu'elle emprunte.</p>
<!--
Mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data at a time. This code that attempts to
create two mutable references to `s` will fail:
-->
<p>Les r√©f√©rences mutables ont une grosse contrainte¬†: vous ne pouvez avoir
qu'une seule r√©f√©rence mutable pour chaque donn√©e au m√™me moment. Le code
suivant qui va tenter de cr√©er deux r√©f√©rences mutables √† <code>s</code> va √©chouer¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 -- > src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
This error says that this code is invalid because we cannot borrow `s` as
mutable more than once at a time. The first mutable borrow is in `r1` and must
last until it‚Äôs used in the `println!`, but between the creation of that
mutable reference and its usage, we tried to create another mutable reference
in `r2` that borrows the same data as `r1`.
-->
<p>Cette erreur nous explique que ce code est invalide car nous ne pouvons pas
emprunter <code>s</code> de mani√®re mutable plus d'une fois au m√™me moment. Le premier
emprunt mutable est dans <code>r1</code> et doit perdurer jusqu'√† ce qu'il soit utilis√©
dans le <code>println!</code>, mais pourtant entre la cr√©ation de cette r√©f√©rence mutable
et son utilisation, nous avons essay√© de cr√©er une autre r√©f√©rence mutable dans
<code>r2</code> qui emprunte la m√™me donn√©e que dans <code>r1</code>.</p>
<!--
The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It‚Äôs something
that new Rustaceans struggle with, because most languages let you mutate
whenever you‚Äôd like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A *data race* is similar to a race
condition and happens when these three behaviors occur:
-->
<p>La limitation qui emp√™che d'avoir plusieurs r√©f√©rences mutables vers la m√™me
donn√©e au m√™me moment autorise les mutations, mais de mani√®re tr√®s contr√¥l√©e.
C'est quelque chose que les nouveaux Rustac√©s ont du mal √† surmonter, car la
plupart des langages vous permettent de modifier les donn√©es quand vous le
voulez. L'avantage d'avoir cette contrainte est que Rust peut emp√™cher les
acc√®s concurrents au moment de la compilation. Un <em>acc√®s concurrent</em> est une
situation de concurrence qui se produit lorsque ces trois facteurs se
combinent¬†:</p>
<!--
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* There‚Äôs no mechanism being used to synchronize access to the data.
-->
<ul>
<li>Deux pointeurs ou plus acc√®dent √† la m√™me donn√©e au m√™me moment.</li>
<li>Au moins un des pointeurs est utilis√© pour √©crire dans cette donn√©e.</li>
<li>On n'utilise aucun m√©canisme pour synchroniser l'acc√®s aux donn√©es.</li>
</ul>
<!--
Data races cause undefined behavior and can be difficult to diagnose and fix
when you‚Äôre trying to track them down at runtime; Rust prevents this problem
by refusing to compile code with data races!
-->
<p>L'acc√®s concurrent provoque des comportements ind√©finis et rend difficile le
diagnostic et la r√©solution de probl√®mes lorsque vous essayez de les reproduire
au moment de l'ex√©cution¬†; Rust √©vite ce probl√®me en refusant de compiler du
code avec des acc√®s concurrents¬†!</p>
<!--
As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not *simultaneous* ones:
-->
<p>Comme d'habitude, nous pouvons utiliser des accolades pour cr√©er une nouvelle
port√©e, pour nous permettre d'avoir plusieurs r√©f√©rences mutables, mais pas
<em>en m√™me temps</em>¬†:</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 sort de la port√©e ici, donc nous pouvons cr√©er une nouvelle r√©f√©rence
      // sans probl√®mes.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<!--
Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:
-->
<p>Rust impose une r√®gle similaire pour combiner les r√©f√©rences immuables et
mutables. Ce code va mener √† une erreur¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans probl√®me
    let r2 = &amp;s; // sans probl√®me
    let r3 = &amp;mut s; // GROS PROBLEME
    
    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // sans probl√®me
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // sans probl√®me
6 |     let r3 = &amp;mut s; // GROS PROBLEME
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Whew! We *also* cannot have a mutable reference while we have an immutable one
to the same value. Users of an immutable reference don‚Äôt expect the value to
suddenly change out from under them! However, multiple immutable references are
allowed because no one who is just reading the data has the ability to affect
anyone else‚Äôs reading of the data.
-->
<p>Ouah¬†! Nous ne pouvons pas <em>non plus</em> avoir une r√©f√©rence mutable pendant que
nous en avons une autre immuable vers la m√™me valeur. Les utilisateurs d'une
r√©f√©rence immuable ne s'attendent pas √† ce que sa valeur change soudainement¬†!
Cependant, l'utilisation de plusieurs r√©f√©rences immuables ne pose pas de
probl√®me, car simplement lire une donn√©e ne va pas affecter la lecture de la
donn√©e par les autres.</p>
<!--
Note that a reference‚Äôs scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references, the `println!`,
occurs before the mutable reference is introduced:
-->
<p>Notez bien que la port√©e d'une r√©f√©rence commence d√®s qu'elle est introduite et
se poursuit jusqu'au dernier endroit o√π cette r√©f√©rence est utilis√©e. Par
exemple, le code suivant va se compiler car la derni√®re utilisation de la
r√©f√©rence immuable, le <code>println!</code>, est situ√©e avant l'introduction de la
r√©f√©rence mutable¬†:</p>
<!--
```rust,edition2021
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans probl√®me
    let r2 = &amp;s; // sans probl√®me
    println!(&quot;{} et {}&quot;, r1, r2);
    //les variables r1 et r2 ne seront plus utilis√©s √† partir d'ici
    
    let r3 = &amp;mut s; // sans probl√®me
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<!--
The scopes of the immutable references `r1` and `r2` end after the `println!`
where they are last used, which is before the mutable reference `r3` is
created. These scopes don‚Äôt overlap, so this code is allowed. The ability of
the compiler to tell that a reference is no longer being used at a point before
the end of the scope is called *Non-Lexical Lifetimes* (NLL for short), and you
can read more about it in [The Edition Guide][nll].
-->
<p>Les port√©es des r√©f√©rences immuables <code>r1</code> et <code>r2</code> se terminent apr√®s le
<code>println!</code> o√π elles sont utilis√©es pour la derni√®re fois, c'est-√†-dire avant que
la r√©f√©rence mutable <code>r3</code> soit cr√©√©e. Ces port√©es ne se chevauchent pas, donc ce
code est autoris√©. La capacit√© du compilateur √† dire si une r√©f√©rence n'est plus
utilis√©e √† un endroit avant la fin de la port√©e s'appelle en Anglais les
<em>Non-Lexical Lifetimes</em> (ou NLL), et vous pouvez en apprendre plus dans le
<a href="https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">Guide de l'√©dition</a>.</p>
<!--
Even though borrowing errors may be frustrating at times, remember that it‚Äôs
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you don‚Äôt
have to track down why your data isn‚Äôt what you thought it was.
-->
<p>M√™me si ces erreurs d'emprunt peuvent parfois √™tre frustrantes, n'oubliez pas
que le compilateur de Rust nous signale un bogue potentiel en avance (au moment
de la compilation plut√¥t que l'ex√©cution) et vous montre o√π se situe exactement
le probl√®me. Ainsi, vous n'avez pas √† chercher pourquoi vos donn√©es ne
correspondent pas √† ce que vous pensiez qu'elles devraient √™tre.</p>
<!--
### Dangling References
-->
<h3 id="les-r√©f√©rences-pendouillantes"><a class="header" href="#les-r√©f√©rences-pendouillantes">Les r√©f√©rences pendouillantes</a></h3>
<!--
In languages with pointers, it‚Äôs easy to erroneously create a *dangling
pointer*--a pointer that references a location in memory that may have been
given to someone else--by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.
-->
<p>Avec les langages qui utilisent les pointeurs, il est facile de cr√©er par erreur
un <em>pointeur pendouillant</em> (<em>dangling pointer</em>), qui est un pointeur qui pointe
vers un emplacement m√©moire qui a √©t√© donn√© √† quelqu'un d'autre, en lib√©rant de
la m√©moire tout en conservant un pointeur vers cette m√©moire. En revanche, avec
Rust, le compilateur garantit que les r√©f√©rences ne seront jamais des r√©f√©rences
pendouillantes¬†: si nous avons une r√©f√©rence vers une donn√©e, le compilateur va
s'assurer que cette donn√©e ne va pas sortir de la port√©e avant que la r√©f√©rence
vers cette donn√©e en soit elle-m√™me sortie.</p>
<!--
Let‚Äôs try to create a dangling reference to see how Rust prevents them with a
compile-time error:
-->
<p>Essayons de cr√©er une r√©f√©rence pendouillante pour voir comment Rust va les
emp√™cher via une erreur au moment de la compilation¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_vers_rien = pendouille();
}

fn pendouille() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 -- > src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn pendouille() -&gt; &amp;String {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn pendouille() -&gt; &amp;'static String {
  |                    ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
This error message refers to a feature we haven‚Äôt covered yet: lifetimes. We‚Äôll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:
-->
<p>Ce message d'erreur fait r√©f√©rence √† une fonctionnalit√© que nous n'avons pas
encore vue¬†: les <em>dur√©es de vie</em>. Nous aborderons les dur√©es de vie dans le
chapitre 10. Mais, si vous mettez de c√¥t√© les parties qui parlent de dur√©es de
vie, le message explique pourquoi le code pose probl√®me¬†:</p>
<!--
```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
```
-->
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Ce qui peut se traduire par¬†:</p>
<pre><code class="language-text">Le type de retour de cette fonction contient une valeur emprunt√©e, mais il n'y a
plus aucune valeur qui peut √™tre emprunt√©e.
</code></pre>
<!--
Let‚Äôs take a closer look at exactly what‚Äôs happening at each stage of our
`dangle` code:
-->
<p>Regardons de plus pr√®s ce qui se passe exactement √† chaque √©tape de notre code
de <code>pendouille</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let reference_to_nothing = dangle();
# }
# 
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_vers_rien = pendouille();
</span><span class="boring">}
</span><span class="boring">
</span>fn pendouille() -&gt; &amp;String { // pendouille retourne une r√©f√©rence vers une String

  let s = String::from(&quot;hello&quot;); // s est une nouvelle String

  &amp;s // nous retournons une r√©f√©rence vers la String, s
} // Ici, s sort de la port√©e, et est lib√©r√©. Sa m√©moire dispara√Æt.
  // Attention, danger¬†!
</code></pre>
<!--
Because `s` is created inside `dangle`, when the code of `dangle` is finished,
`s` will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid `String`. That‚Äôs no good! Rust
won‚Äôt let us do this.
-->
<p>Comme <code>s</code> est cr√©√© dans <code>pendouille</code>, lorsque le code de <code>pendouille</code> est
termin√©, la variable <code>s</code> sera d√©sallou√©e. Mais nous avons essay√© de retourner
une r√©f√©rence vers elle. Cela veut dire que cette r√©f√©rence va pointer vers une
<code>String</code> invalide. Ce n'est pas bon ! Rust ne nous laissera pas faire cela.</p>
<!--
The solution here is to return the `String` directly:
-->
<p>Ici la solution est de renvoyer la <code>String</code> directement¬†:</p>
<!--
```rust
# fn main() {
#     let string = no_dangle();
# }
# 
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = ne_pendouille_pas();
</span><span class="boring">}
</span><span class="boring">
</span>fn ne_pendouille_pas() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<!--
This works without any problems. Ownership is moved out, and nothing is
deallocated.
-->
<p>Cela fonctionne sans probl√®me. La possession est transf√©r√©e √† la valeur de
retour de la fonction, et rien n'est d√©sallou√©.</p>
<!--
### The Rules of References
-->
<h3 id="les-r√®gles-de-r√©f√©rencement"><a class="header" href="#les-r√®gles-de-r√©f√©rencement">Les r√®gles de r√©f√©rencement</a></h3>
<!--
Let‚Äôs recap what we‚Äôve discussed about references:
-->
<p>R√©capitulons ce que nous avons vu √† propos des r√©f√©rences¬†:</p>
<!--
* At any given time, you can have *either* one mutable reference *or* any
  number of immutable references.
* References must always be valid.
-->
<ul>
<li>√Ä un instant donn√©, vous pouvez avoir <em>soit</em> une r√©f√©rence mutable, <em>soit</em> un
nombre quelconque de r√©f√©rences immuables.</li>
<li>Les r√©f√©rences doivent toujours √™tre en vigueur.</li>
</ul>
<!--
Next, we‚Äôll look at a different kind of reference: slices.
-->
<p>Ensuite, nous aborderons un autre type de r√©f√©rence¬†: les <em>slices</em>.</p>
<!--
[nll]: https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## The Slice Type
-->
<h2 id="le-type-slice"><a class="header" href="#le-type-slice">Le type slice</a></h2>
<!--
*Slices* let you reference a contiguous sequence of elements in a collection
rather than the whole collection. A slice is a kind of reference, so it does
not have ownership.
-->
<p>Une <em>slice</em> vous permet d'obtenir une r√©f√©rence vers une s√©quence continue
d'√©l√©ments d'une collection plut√¥t que toute la collection. Une slice est un
genre de r√©f√©rence, donc elle ne prend pas possession.</p>
<!--
Here‚Äôs a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesn‚Äôt find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>Voici un petit probl√®me de programmation¬†: √©crire une fonction qui prend une
cha√Æne de caract√®res et retourne le premier mot qu'elle trouve dans cette
cha√Æne. Si la fonction ne trouve pas d'espace dans la cha√Æne, cela veut dire
que la cha√Æne est en un seul mot, donc la cha√Æne en entier doit √™tre retourn√©e.</p>
<!--
Let‚Äôs work through how we‚Äôd write the signature of this function without using
slices, to understand the problem that slices will solve:
-->
<p>Voyons comment √©crire la signature de cette fonction sans utiliser les slices,
afin de comprendre le probl√®me que r√®glent les slices¬†:</p>
<!--
```rust,ignore
fn first_word(s: &String) -> ?
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; ?
</code></pre>
<!--
The `first_word` function has a `&String` as a parameter. We don‚Äôt want
ownership, so this is fine. But what should we return? We don‚Äôt really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word, indicated by a space. Let‚Äôs try that, as shown in Listing 4-7.
-->
<p>La fonction <code>premier_mot</code> prend un <code>&amp;String</code> comme param√®tre. Nous ne
voulons pas en prendre possession, donc c'est ce qu'il nous faut. Mais que
devons-nous retourner¬†? Nous n'avons aucun moyen de d√©signer une <em>partie</em>
d'une cha√Æne de caract√®res. Cependant, nous pouvons retourner l'indice de la
fin du mot, qui se produit lorsqu'il y a un espace. Essayons cela, dans
l'encart 4-7¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; usize {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">Encart 4-7¬†: La fonction <code>premier_mot</code> qui retourne
l'indice d'un octet provenant du param√®tre <code>String</code></span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, we‚Äôll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p>Comme nous avons besoin de parcourir la <code>String</code> √©l√©ment par √©l√©ment et de
v√©rifier si la valeur est une espace, nous convertissons notre <code>String</code> en un
tableau d'octets en utilisant la m√©thode <code>as_bytes</code>¬†:</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span>    let octets = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>Ensuite, nous cr√©ons un it√©rateur sur le tableau d'octets en utilisant la
m√©thode <code>iter</code>¬†:</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
    for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;element) in octets.iter().enumerate() {
<span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We‚Äôll discuss iterators in more detail in [Chapter 13][ch13]<!-- ignore -- >.
For now, know that `iter` is a method that returns each element in a collection
and that `enumerate` wraps the result of `iter` and returns each element as
part of a tuple instead. The first element of the tuple returned from
`enumerate` is the index, and the second element is a reference to the element.
This is a bit more convenient than calculating the index ourselves.
-->
<p>Nous aborderons plus en d√©tail les it√©rateurs dans le <a href="ch13-02-iterators.html">chapitre
13</a><!-- ignore -->. Pour le moment, sachez que <code>iter</code> est une m√©thode qui
retourne chaque √©l√©ment d'une collection, et que <code>enumerate</code> transforme le
r√©sultat de <code>iter</code> pour retourner plut√¥t chaque √©l√©ment comme un tuple. Le
premier √©l√©ment du tuple retourn√© par <code>enumerate</code> est l'indice, et le second
√©l√©ment est une r√©f√©rence vers l'√©l√©ment. C'est un peu plus pratique que de
calculer les indices par nous-m√™mes.</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple. We‚Äôll be discussing patterns more in [Chapter
6][ch6]<!-- ignore -- >. In the `for` loop, we specify a pattern that has `i`
for the index in the tuple and `&item` for the single byte in the tuple.
Because we get a reference to the element from `.iter().enumerate()`, we use
`&` in the pattern.
-->
<p>Comme la m√©thode <code>enumerate</code> retourne un tuple, nous pouvons utiliser des
motifs pour d√©structurer ce tuple. Nous verrons les motifs au <a href="ch06-02-match.html#des-motifs-reli%C3%A9s-%C3%A0-des-valeurs">chapitre
6</a><!-- ignore -->. Dans la boucle <code>for</code>, nous pr√©cisons un motif qui
indique que nous d√©finissons <code>i</code> pour l'indice au sein du tuple et <code>&amp;element</code>
pour l'octet dans le tuple. Comme nous obtenons une r√©f√©rence vers l'√©l√©ment
avec <code>.iter().enumerate()</code>, nous utilisons <code>&amp;</code> dans le motif.</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p>Au sein de la boucle <code>for</code>, nous recherchons l'octet qui repr√©sente l'espace en
utilisant la syntaxe de litt√©ral d'octet. Si nous trouvons une espace, nous
retournons sa position. Sinon, nous retournons la taille de la cha√Æne en
utilisant <code>s.len()</code>¬†:</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span>        if element == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but there‚Äôs a problem. We‚Äôre returning a `usize` on its own, but it‚Äôs
only a meaningful number in the context of the `&String`. In other words,
because it‚Äôs a separate value from the `String`, there‚Äôs no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>Nous avons maintenant une fa√ßon de trouver l'indice de la fin du premier mot
dans la cha√Æne de caract√®res, mais il y a un probl√®me. Nous retournons un
<code>usize</code> tout seul, mais il n'a du sens que lorsqu'il est li√© au <code>&amp;String</code>.
Autrement dit, comme il a une valeur s√©par√©e de la <code>String</code>, il n'y a pas de
garantie qu'il restera toujours valide dans le futur. Imaginons le programme
dans l'encart 4-8 qui utilise la fonction <code>premier_mot</code> de l'encart 4-7¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s); // la variable mot aura 5 comme valeur.

    s.clear(); // ceci vide la String, elle vaut maintenant &quot;&quot;.

    // mot a toujours la valeur 5 ici, mais il n'y a plus de cha√Æne qui donne
    // du sens √† la valeur 5. mot est maintenant compl√®tement invalide¬†!
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">Encart 4-8¬†: On stocke le r√©sultat de l'appel √† la
fonction <code>premier_mot</code> et ensuite on change le contenu de la <code>String</code></span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isn‚Äôt connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>Ce programme se compile sans aucune erreur et le ferait toujours si nous
utilisions <code>mot</code> apr√®s avoir appel√© <code>s.clear()</code>. Comme <code>mot</code> n'est pas du tout
li√© √† <code>s</code>, <code>mot</code> contient toujours la valeur <code>5</code>. Nous pourrions utiliser cette
valeur <code>5</code> avec la variable <code>s</code> pour essayer d'en extraire le premier mot, mais
cela serait un bogue, car le contenu de <code>s</code> a chang√© depuis que nous avons
enregistr√© <code>5</code> dans <code>mot</code>.</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p>Se pr√©occuper en permanence que l'indice pr√©sent dans <code>mot</code> ne soit plus
synchronis√© avec les donn√©es pr√©sentes dans <code>s</code> est fastidieux et source
d'erreur¬†! La gestion de ces indices est encore plus risqu√©e si nous √©crivons
une fonction <code>second_mot</code>. Sa signature ressemblerait √† ceci¬†:</p>
<!--
```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now we‚Äôre tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but aren‚Äôt tied to
that state at all. We have three unrelated variables floating around that
need to be kept in sync.
-->
<p>Maintenant, nous avons un indice de d√©but <em>et</em> un indice de fin, donc nous avons
encore plus de valeurs qui sont calcul√©es √† partir d'une donn√©e dans un √©tat
donn√©, mais qui ne sont pas li√©es du tout √† l'√©tat de cette donn√©e. Nous avons
trois variables isol√©es qui ont besoin d'√™tre maintenues √† jour.</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>Heureusement, Rust a une solution pour ce probl√®me¬†: les <em>slices</em> de cha√Ænes de
caract√®res.</p>
<!--
### String Slices
-->
<h3 id="les-slices-de-cha√Ænes-de-caract√®res"><a class="header" href="#les-slices-de-cha√Ænes-de-caract√®res">Les slices de cha√Ænes de caract√®res</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p>Une <em>slice de cha√Æne de caract√®res</em> (ou <em>slice de cha√Æne</em>) est une r√©f√©rence √†
une partie d'une <code>String</code>, et ressemble √† ceci¬†:</p>
<!--
```rust
# fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
Rather than a reference to the entire `String`, `hello` is a reference to a
portion of the `String`, specified in the extra `[0..5]` bit. We create slices
using a range within brackets by specifying `[starting_index..ending_index]`,
where `starting_index` is the first position in the slice and `ending_index` is
one more than the last position in the slice. Internally, the slice data
structure stores the starting position and the length of the slice, which
corresponds to `ending_index` minus `starting_index`. So in the case of `let
world = &s[6..11];`, `world` would be a slice that contains a pointer to the
byte at index 6 of `s` with a length value of 5.
-->
<p>Plut√¥t que d'√™tre une r√©f√©rence vers toute la <code>String</code>, <code>hello</code> est une
r√©f√©rence vers une partie de la <code>String</code>, comme indiqu√© dans la partie
suppl√©mentaire <code>[0..5]</code>. Nous cr√©ons des slices en utilisant un intervalle
entre crochets en sp√©cifiant <code>[indice_debut..indice_fin]</code>, o√π <code>indice_debut</code>
est la position du premier octet de la slice et <code>indice_fin</code> est la position
juste apr√®s le dernier octet de la slice. En interne, la structure de donn√©es
de la slice stocke la position de d√©part et la longueur de la slice, ce qui
correspond √† <code>indice_fin</code> moins <code>indice_debut</code>. Donc dans le cas de
<code>let world = &amp;s[6..11];</code>, <code>world</code> est une slice qui contient un pointeur vers
le sixi√®me octet de <code>s</code> et une longueur de 5.</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>L'illustration 4-6 montre ceci dans un sch√©ma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="world containing a pointer to the byte at index 6 of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="world contient un pointeur vers l'octet d'indice 6 de la String s et
une longueur de 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">Illustration 4-6¬†: Une slice de cha√Æne qui pointe vers
une partie d'une <code>String</code></span></p>
<!--
With Rust‚Äôs `..` range syntax, if you want to start at index zero, you can drop
the value before the two periods. In other words, these are equal:
-->
<p>Avec la syntaxe d'intervalle <code>..</code> de Rust, si vous voulez commencer √† l'indice
z√©ro, vous pouvez ne rien mettre avant les deux points. Autrement dit, ces deux
cas sont identiques¬†:</p>
<!--
```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>De la m√™me mani√®re, si votre slice contient le dernier octet de la <code>String</code>,
vous pouvez ne rien mettre √† la fin. Cela veut dire que ces deux cas sont
identiques¬†:</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[3..taille];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>Vous pouvez aussi ne mettre aucune limite pour cr√©er une slice de toute la
cha√Æne de caract√®res. Ces deux cas sont donc identiques¬†:</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[0..taille];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [‚ÄúStoring UTF-8 Encoded
> Text with Strings‚Äù][strings]<!-- ignore -- > section of Chapter 8.
-->
<blockquote>
<p>Remarque¬†: Les indices de l'intervalle d'une slice de cha√Æne doivent toujours
se trouver dans les zones acceptables de s√©paration des caract√®res encod√©s en
UTF-8. Si vous essayez de cr√©er une slice de cha√Æne qui s'arr√™te au milieu
d'un caract√®re encod√© sur plusieurs octets, votre programme va se fermer avec
une erreur. Afin de simplifier l'explication des slices de cha√Ænes, nous
utiliserons uniquement l'ASCII dans cette section¬†; nous verrons la gestion
d'UTF-8 dans la section <a href="ch08-02-strings.html">‚ÄúStocker du texte encod√© en UTF-8 avec les cha√Ænes de
caract√®res‚Äù</a><!-- ignore --> du chapitre 8.</p>
</blockquote>
<!--
With all this information in mind, let‚Äôs rewrite `first_word` to return a
slice. The type that signifies ‚Äústring slice‚Äù is written as `&str`:
-->
<p>Maintenant que nous savons tout cela, essayons de r√©√©crire <code>premier_mot</code> pour
qu'il retourne une slice. Le type pour les slices de cha√Ænes de caract√®res
s'√©crit <code>&amp;str</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>Nous r√©cup√©rons l'indice de la fin du mot de la m√™me fa√ßon que nous l'avions
fait dans l'encart 4-7, en cherchant la premi√®re occurrence d'une espace.
Lorsque nous trouvons une espace, nous retournons une slice de cha√Æne en
utilisant le d√©but de la cha√Æne de caract√®res et l'indice de l'espace comme
indices de d√©but et de fin respectivement.</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>D√©sormais, quand nous appelons <code>premier_mot</code>, nous r√©cup√©rons une unique valeur
qui est li√©e √† la donn√©e de base. La valeur se compose d'une r√©f√©rence vers le
point de d√©part de la slice et du nombre d'√©l√©ments dans la slice.</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p>Retourner une slice fonctionnerait aussi pour une fonction <code>second_mot</code>¬†:</p>
<!--
```rust,ignore
fn second_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API that‚Äôs much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn‚Äôt show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>Nous avons maintenant une API simple qui est bien plus difficile √† mal utiliser,
puisque le compilateur va s'assurer que les r√©f√©rences dans la <code>String</code> seront
toujours en vigueur. Vous souvenez-vous du bogue du programme de l'encart 4-8,
lorsque nous avions un indice vers la fin du premier mot mais qu'ensuite nous
avions vid√© la cha√Æne de caract√®res et que notre indice n'√©tait plus valide¬†? Ce
code √©tait logiquement incorrect, mais ne montrait pas imm√©diatement une erreur.
Les probl√®mes appara√Ætront plus tard si nous essayons d'utiliser l'indice du
premier mot avec une cha√Æne de caract√®res qui a √©t√© vid√©e. Les slices rendent ce
bogue impossible et nous signalent bien plus t√¥t que nous avons un probl√®me avec
notre code. Utiliser la version avec la slice de <code>premier_mot</code> va causer une
erreur de compilation¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn first_word(s: &String) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s);

    s.clear(); // Erreur¬†!

    println!(&quot;Le premier mot est¬†: {}&quot;, mot);
}
</code></pre>
<!--
Here‚Äôs the compiler error:
-->
<p>Voici l'erreur du compilateur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  -- > src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let mot = premier_mot(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Erreur¬†!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Le premier mot est¬†: {}&quot;, mot);
   |                                         --- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. The `println!`
after the call to `clear` uses the reference in `word`, so the immutable
reference must still be active at that point. Rust disallows the mutable
reference in `clear` and the immutable reference in `word` from existing at the
same time, and compilation fails. Not only has Rust made our API easier to use,
but it has also eliminated an entire class of errors at compile time!
-->
<p>Rappelons-nous que d'apr√®s les r√®gles d'emprunt, si nous avons une r√©f√©rence
immuable vers quelque chose, nous ne pouvons pas avoir une r√©f√©rence mutable
en m√™me temps. √âtant donn√© que <code>clear</code> a besoin de modifier la <code>String</code>, il a
besoin d'une r√©f√©rence mutable. Le <code>println!</code> qui a lieu apr√®s l'appel √† <code>clear</code>
utilise la r√©f√©rence √† <code>mot</code>, donc la r√©f√©rence immuable sera toujours en
vigueur √† cet endroit. Rust interdit la r√©f√©rence mutable dans <code>clear</code> et la
r√©f√©rence immuable pour <code>mot</code> au m√™me moment, et la compilation √©choue. Non
seulement Rust a simplifi√© l'utilisation de notre API, mais il a
aussi √©limin√© une cat√©gorie enti√®re d'erreurs au moment de la compilation¬†!</p>
<!--
#### String Literals Are Slices
-->
<h4 id="les-litt√©raux-de-cha√Æne-de-caract√®res-sont-aussi-des-slices"><a class="header" href="#les-litt√©raux-de-cha√Æne-de-caract√®res-sont-aussi-des-slices">Les litt√©raux de cha√Æne de caract√®res sont aussi des slices</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>Rappelez-vous lorsque nous avons appris que les litt√©raux de cha√Æne de
caract√®res √©taient enregistr√©s dans le binaire. Maintenant que nous connaissons
les slices, nous pouvons d√©sormais comprendre les litt√©raux de cha√Æne.</p>
<!--
```rust
let s = "Hello, world!";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: it‚Äôs a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>Ici, le type de <code>s</code> est un <code>&amp;str</code>¬†: c'est une slice qui pointe vers un endroit
pr√©cis du binaire. C'est aussi la raison pour laquelle les litt√©raux de cha√Æne
sont immuables¬†; <code>&amp;str</code> est une r√©f√©rence immuable.</p>
<!--
#### String Slices as Parameters
-->
<h4 id="les-slices-de-cha√Ænes-de-caract√®res-en-param√®tres"><a class="header" href="#les-slices-de-cha√Ænes-de-caract√®res-en-param√®tres">Les slices de cha√Ænes de caract√®res en param√®tres</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and that‚Äôs its signature:
-->
<p>Savoir que l'on peut utiliser des slices de litt√©raux et de <code>String</code> nous incite
√† apporter une petite am√©lioration √† <code>premier_mot</code>, dont voici la signature¬†:</p>
<!--
```rust,ignore
fn first_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>Un Rustac√© plus exp√©riment√© √©crirait plut√¥t la signature de l'encart 4-9, car
cela nous permet d'utiliser la m√™me fonction sur les <code>&amp;String</code> et aussi les
<code>&amp;str</code>¬†:</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // `first_word` works on slices of `String`s, whether partial or whole
#     let word = first_word(&my_string[0..6]);
#     let word = first_word(&my_string[..]);
#     // `first_word` also works on references to `String`s, which are equivalent
#     // to whole slices of `String`s
#     let word = first_word(&my_string);
# 
#     let my_string_literal = "hello world";
# 
#     // `first_word` works on slices of string literals, whether partial or whole
#     let word = first_word(&my_string_literal[0..6]);
#     let word = first_word(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = first_word(my_string_literal);
# }
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ma_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne avec les slices de `String`, que ce soit sur
</span><span class="boring">    // une partie ou sur sur son int√©gralit√©
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[0..6]);
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[..]);
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne √©galement sur des r√©f√©rences vers des `String`,
</span><span class="boring">    // qui sont √©quivalentes √† des slices de toute la `String`
</span><span class="boring">    let mot = premier_mot(&amp;ma_string);
</span><span class="boring">
</span><span class="boring">    let mon_litteral_de_chaine = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne avec les slices de litt√©raux de cha√Æne, qu'elles
</span><span class="boring">    // soient partielles ou int√©grales
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[0..6]);
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);
</span><span class="boring">
</span><span class="boring">    // Comme les litt√©raux de cha√Æne *sont* d√©j√† des slices de cha√Ænes,
</span><span class="boring">    // cela fonctionne aussi, sans la syntaxe de slice¬†!
</span><span class="boring">    let mot = premier_mot(mon_litteral_de_chaine);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">Encart 4-9¬†: Am√©lioration de la fonction <code>premier_mot</code> en
utilisant une slice de cha√Æne de caract√®res comme type du param√®tre <code>s</code></span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the `String` or a reference to the `String`. This
flexibility takes advantage of *deref coercions*, a feature we will cover in
the [‚ÄúImplicit Deref Coercions with Functions and
Methods‚Äù][deref-coercions]<!--ignore-- > section of Chapter 15. Defining a
function to take a string slice instead of a reference to a `String` makes our
API more general and useful without losing any functionality:
-->
<p>Si nous avons une slice de cha√Æne, nous pouvons la passer en argument
directement. Si nous avons une <code>String</code>, nous pouvons envoyer une r√©f√©rence ou
une slice de la <code>String</code>. Cette flexibilit√© nous est offerte par
l'<em>extrapolation de d√©r√©ferencement</em>, une fonctionnalit√© que nous allons
d√©couvrir dans <a href="ch15-02-deref.html">une section du Chapitre 15</a><!--ignore-->.
D√©finir une fonction qui prend une slice de cha√Æne plut√¥t qu'une r√©f√©rence √†
une <code>String</code> rend notre API plus g√©n√©rique et plus utile sans perdre aucune
fonctionnalit√©¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let ma_string = String::from(&quot;hello world&quot;);

    // `premier_mot` fonctionne avec les slices de `String`, que ce soit sur
    // une partie ou sur sur son int√©gralit√©
    let mot = premier_mot(&amp;ma_string[0..6]);
    let mot = premier_mot(&amp;ma_string[..]);

    // `premier_mot` fonctionne √©galement sur des r√©f√©rences vers des `String`,
    // qui sont √©quivalentes √† des slices de toute la `String`
    let mot = premier_mot(&amp;ma_string);

    let mon_litteral_de_chaine = &quot;hello world&quot;;

    // `premier_mot` fonctionne avec les slices de litt√©raux de cha√Æne, qu'elles
    // soient partielles ou int√©grales
    let mot = premier_mot(&amp;mon_litteral_de_chaine[0..6]);
    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);

    // Comme les litt√©raux de cha√Æne *sont* d√©j√† des slices de cha√Ænes,
    // cela fonctionne aussi, sans la syntaxe de slice¬†!
    let mot = premier_mot(mon_litteral_de_chaine);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3 id="les-autres-slices"><a class="header" href="#les-autres-slices">Les autres slices</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But there‚Äôs a
more general slice type, too. Consider this array:
-->
<p>Les slices de cha√Ænes de caract√®res, comme vous pouvez l'imaginer, sont
sp√©cifiques aux cha√Ænes de caract√®res. Mais il existe aussi un type de slice
plus g√©n√©rique. Imaginons ce tableau de donn√©es¬†:</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. We‚Äôd do so like this:
-->
<p>Tout comme nous pouvons nous r√©f√©rer √† une partie d'une cha√Æne de caract√®res,
nous pouvons nous r√©f√©rer √† une partie d'un tableau. Nous pouvons le faire comme
ceci¬†:</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. You‚Äôll use this kind of
slice for all sorts of other collections. We‚Äôll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>Cette slice est de type <code>&amp;[i32]</code>. Elle fonctionne de la m√™me mani√®re que les
slices de cha√Ænes de caract√®res, en enregistrant une r√©f√©rence vers le premier
√©l√©ment et une longueur. Vous utiliserez ce type de slice pour tous les autres
types de collections. Nous aborderons ces collections en d√©tail quand nous
verrons les vecteurs au chapitre 8.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-3"><a class="header" href="#r√©sum√©-3">R√©sum√©</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don‚Äôt have to write and debug extra code to get this control.
-->
<p>Les concepts de possession, d'emprunt et de slices garantissent la s√©curit√© de
la m√©moire dans les programmes Rust au moment de la compilation. Le langage Rust
vous donne le contr√¥le sur l'utilisation de la m√©moire comme tous les autres
langages de programmation syst√®me, mais le fait que celui qui poss√®de des
donn√©es nettoie automatiquement ces donn√©es quand il sort de la port√©e vous
permet de ne pas avoir √† √©crire et d√©boguer du code en plus pour avoir cette
fonctionnalit√©.</p>
<!--
Ownership affects how lots of other parts of Rust work, so we‚Äôll talk about
these concepts further throughout the rest of the book. Let‚Äôs move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>La possession influe sur de nombreuses autres fonctionnalit√©s de Rust, c'est
pourquoi nous allons encore parler de ces concepts plus loin dans le livre.
Passons maintenant au chapitre 5 et d√©couvrons comment regrouper des donn√©es
ensemble dans une <code>struct</code>.</p>
<!--
[ch13]: ch13-02-iterators.html
[ch6]: ch06-02-match.html#patterns-that-bind-to-values
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[deref-coercions]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods
-->
<div style="break-before: page; page-break-before: always;"></div><!-- # Using Structs to Structure Related Data -->
<h1 id="utiliser-les-structures-pour-structurer-des-donn√©es-apparent√©es"><a class="header" href="#utiliser-les-structures-pour-structurer-des-donn√©es-apparent√©es">Utiliser les structures pour structurer des donn√©es apparent√©es</a></h1>
<!--
A *struct*, or *structure*, is a custom data type that lets you package
together and name multiple related values that make up a meaningful group. If
you‚Äôre familiar with an object-oriented language, a *struct* is like an
object‚Äôs data attributes. In this chapter, we‚Äôll compare and contrast tuples
with structs to build on what you already know and demonstrate when structs are
a better way to group data. We‚Äôll demonstrate how to define and instantiate
structs. We‚Äôll discuss how to define associated functions, especially the kind
of associated functions called *methods*, to specify behavior associated with a
struct type. Structs and enums (discussed in Chapter 6) are the building blocks
for creating new types in your program‚Äôs domain to take full advantage of
Rust‚Äôs compile time type checking.
-->
<p>Une <em>struct</em>, ou <em>structure</em>, est un type de donn√©es personnalis√© qui vous
permet de rassembler plusieurs valeurs associ√©es et les nommer pour former un
groupe coh√©rent.
Si vous √™tes familier avec un langage orient√© objet, une structure est en
quelque sorte l'ensemble des attributs d'un objet.
Dans ce chapitre, nous comparerons les tuples avec les structures afin de
construire ce que vous connaissez d√©j√† et de montrer √† quels moments les
structures sont plus pertinentes pour grouper des donn√©es. Nous verrons comment
d√©finir les fonctions associ√©es, en particulier le type de fonctions associ√©es
que l'on appelle les <em>m√©thodes</em>, dans le but d'impl√©menter un comportement
associ√© au type d'une structure.
Les structures et les √©num√©rations (trait√©es au chapitre 6) sont les fondements
de la cr√©ation de nouveaux types au sein de votre programme pour tirer
pleinement parti des v√©rifications de types effectu√©es par Rust √† la
compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining and Instantiating Structs
-->
<h2 id="d√©finir-et-instancier-des-structures"><a class="header" href="#d√©finir-et-instancier-des-structures">D√©finir et instancier des structures</a></h2>
<!--
Structs are similar to tuples, discussed in [‚ÄúThe Tuple Type‚Äù][tuples]<!--
ignore -- > section, in that both hold multiple related values. Like tuples, the
pieces of a struct can be different types. Unlike with tuples, in a struct
you‚Äôll name each piece of data so it‚Äôs clear what the values mean. Adding these
names means that structs are more flexible than tuples: you don‚Äôt have to rely
on the order of the data to specify or access the values of an instance.
-->
<p>Les structures sont similaires aux tuples, qu'on a vus dans <a href="ch03-02-data-types.html">une section du
chapitre 3</a><!-- ignore -->, car tous les deux portent plusieurs valeurs
associ√©es. Comme pour les tuples, les √©l√©ments d'une structure peuvent √™tre de
diff√©rents types. Contrairement aux tuples, dans une structure on doit nommer
chaque √©l√©ment des donn√©es afin de clarifier le r√¥le de chaque valeur. L'ajout
de ces noms font que les structures sont plus flexibles que les tuples¬†: on n'a
pas √† utiliser l'ordre des donn√©es pour sp√©cifier ou acc√©der aux valeurs d'une
instance.</p>
<!--
To define a struct, we enter the keyword `struct` and name the entire struct. A
struct‚Äôs name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call *fields*. For example, Listing 5-1 shows a
struct that stores information about a user account.
-->
<p>Pour d√©finir une structure, on tape le mot-cl√© <code>struct</code> et on donne un nom √†
toute la structure. Le nom d'une structure devrait d√©crire l'utilisation des
√©l√©ments des donn√©es regroup√©s. Ensuite, entre des accolades, on d√©finit le nom
et le type de chaque √©l√©ment des donn√©es, qu'on appelle un <em>champ</em>. Par exemple,
l'encart 5-1 montre une structure qui stocke des informations √† propos d'un
compte d'utilisateur.</p>
<!--
```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Utilisateur {
    actif: bool,
    pseudo: String,
    email: String,
    nombre_de_connexions: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-1: A `User` struct definition</span>
-->
<p><span class="caption">Encart 5-1¬†: la d√©finition d'une structure
<code>Utilisateur</code></span></p>
<!--
To use a struct after we‚Äôve defined it, we create an *instance* of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing `key:
value` pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don‚Äôt have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.
-->
<p>Pour utiliser une structure apr√®s l'avoir d√©finie, on cr√©e une <em>instance</em> de
cette structure en indiquant des valeurs concr√®tes pour chacun des champs.
On cr√©e une instance en indiquant le nom de la structure puis en ajoutant des
accolades qui contiennent des paires de <code>cl√©: valeur</code>, o√π les cl√©s sont les noms
des champs et les valeurs sont les donn√©es que l'on souhaite stocker dans ces
champs. Nous n'avons pas √† pr√©ciser les champs dans le m√™me ordre qu'on les a
d√©clar√©s dans la structure. En d'autres termes, la d√©finition de la structure
d√©crit un gabarit pour le type, et les instances remplissent ce gabarit avec des
donn√©es pr√©cises pour cr√©er des valeurs de ce type. Par exemple, nous pouvons
d√©clarer un utilisateur pr√©cis comme dans l'encart 5-2.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-2: Creating an instance of the `User`
struct</span>
-->
<p><span class="caption">Encart 5-2¬†: cr√©ation d'une instance de la structure
<code>Utilisateur</code></span></p>
<!--
To get a specific value from a struct, we use dot notation. If we wanted
just this user‚Äôs email address, we could use `user1.email` wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the `email` field of a mutable `User` instance.
-->
<p>Pour obtenir une valeur sp√©cifique depuis une structure, on utilise la notation
avec le point. Si nous voulions seulement l'adresse e-mail de cet utilisateur,
on pourrait utiliser <code>utilisateur1.email</code> partout o√π on voudrait utiliser cette
valeur. Si l'instance est mutable, nous pourrions changer une valeur en
utilisant la notation avec le point et assigner une valeur √† ce champ en
particulier. L'encart 5-3 montre comment changer la valeur du champ <code>email</code>
d'une instance mutable de <code>Utilisateur</code>.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
    
    utilisateur1.email = String::from(&quot;unautremail@example.com&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-3: Changing the value in the `email` field of a
`User` instance</span>
-->
<p><span class="caption">Encart 5-3¬†: changement de la valeur du champ <code>email</code>
d'une instance de <code>Utilisateur</code></span></p>
<!--
Note that the entire instance must be mutable; Rust doesn‚Äôt allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.
-->
<p>√Ä noter que l'instance tout enti√®re doit √™tre mutable¬†; Rust ne nous permet pas
de marquer seulement certains champs comme mutables. Comme pour toute
expression, nous pouvons construire une nouvelle instance de la structure comme
derni√®re expression du corps d'une fonction pour retourner implicitement cette
nouvelle instance.</p>
<!--
Listing 5-4 shows a `build_user` function that returns a `User` instance with
the given email and username. The `active` field gets the value of `true`, and
the `sign_in_count` gets a value of `1`.
-->
<p>L'encart 5-4 montre une fonction <code>creer_utilisateur</code> qui retourne une instance
de <code>Utilisateur</code> avec l'adresse e-mail et le pseudo fournis. Le champ <code>actif</code>
prend la valeur <code>true</code> et le <code>nombre_de_connexions</code> prend la valeur <code>1</code>.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email: email,
        pseudo: pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-4: A `build_user` function that takes an email
and username and returns a `User` instance</span>
-->
<p><span class="caption">Encart 5-4¬†: une fonction <code>creer_utilisateur</code> qui prend
en entr√©e une adresse e-mail et un pseudo et retourne une instance de
<code>Utilisateur</code></span></p>
<!--
It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the `email` and `username` field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there‚Äôs a convenient shorthand!
-->
<p>Il est logique de nommer les param√®tres de fonction avec le m√™me nom que les
champs de la structure, mais devoir r√©p√©ter les noms de variables et de champs
<code>email</code> et <code>pseudo</code> est un peu p√©nible. Si la structure avait plus de champs,
r√©p√©ter chaque nom serait encore plus fatigant. Heureusement, il existe un
raccourci pratique¬†!</p>
<!--
<a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a>
### Using the Field Init Shorthand
-->
<p><a id="utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-m√™me-nom"></a></p>
<h3 id="utiliser-le-raccourci-dinitialisation-des-champs"><a class="header" href="#utiliser-le-raccourci-dinitialisation-des-champs">Utiliser le raccourci d'initialisation des champs</a></h3>
<!--
Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the *field init shorthand* syntax to rewrite
`build_user` so that it behaves exactly the same but doesn‚Äôt have the
repetition of `email` and `username`, as shown in Listing 5-5.
-->
<p>Puisque les noms des param√®tres et les noms de champs de la structure sont
exactement les m√™mes dans l'encart 5-4, on peut utiliser la syntaxe de
<em>raccourci d'initialisation des champs</em> pour r√©√©crire <code>creer_utilisateur</code> de
sorte qu'elle se comporte exactement de la m√™me fa√ßon sans avoir √† r√©p√©ter
<code>email</code> et <code>pseudo</code>, comme le montre l'encart 5-5.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email,
        pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-5: A `build_user` function that uses field init
shorthand because the `email` and `username` parameters have the same name as
struct fields</span>
-->
<p><span class="caption">Encart 5-5¬†: une fonction <code>creer_utilisateur</code> qui utilise
le raccourci d'initialisation des champs parce que les param√®tres <code>email</code> et
<code>pseudo</code> ont le m√™me nom que les champs de la structure</span></p>
<!--
Here, we‚Äôre creating a new instance of the `User` struct, which has a field
named `email`. We want to set the `email` field‚Äôs value to the value in the
`email` parameter of the `build_user` function. Because the `email` field and
the `email` parameter have the same name, we only need to write `email` rather
than `email: email`.
-->
<p>Ici, on cr√©e une nouvelle instance de la structure <code>Utilisateur</code>, qui poss√®de
un champ nomm√© <code>email</code>. On veut donner au champ <code>email</code> la valeur du param√®tre
<code>email</code> de la fonction <code>creer_utilisateur</code>. Comme le champ <code>email</code> et le
param√®tre <code>email</code> ont le m√™me nom, on a uniquement besoin d'√©crire <code>email</code>
plut√¥t que <code>email: email</code>.</p>
<!--
### Creating Instances From Other Instances With Struct Update Syntax
-->
<h3 id="cr√©er-des-instances-√†-partir-dautres-instances-avec-la-syntaxe-de-mise-√†-jour-de-structure"><a class="header" href="#cr√©er-des-instances-√†-partir-dautres-instances-avec-la-syntaxe-de-mise-√†-jour-de-structure">Cr√©er des instances √† partir d'autres instances avec la syntaxe de mise √† jour de structure</a></h3>
<!--
It‚Äôs often useful to create a new instance of a struct that includes most of
the values from another instance, but changes some. You can do this using
*struct update syntax*.
-->
<p>Il est souvent utile de cr√©er une nouvelle instance de structure qui comporte
la plupart des valeurs d'une autre instance tout en en changeant certaines.
Vous pouvez utiliser pour cela la <em>syntaxe de mise √† jour de structure</em>.</p>
<!--
First, in Listing 5-6 we show how to create a new `User` instance in `user2`
regularly, without the update syntax. We set a new value for `email` but
otherwise use the same values from `user1` that we created in Listing 5-2.
-->
<p>Tout d'abord, dans l'encart 5-6 nous montrons comment cr√©er une nouvelle
instance de <code>Utilisateur</code> dans <code>utilisateur2</code> sans la syntaxe de mise √† jour de
structure. On donne de nouvelles valeurs √† <code>email</code> et <code>pseudo</code> mais on utilise
pour les autres champs les m√™mes valeurs que dans <code>utilisateur1</code> qu'on a cr√©√© √†
l'encart 5-2.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn main() {
    // --snip--
# 
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span>
    let utilisateur2 = Utilisateur {
        actif: utilisateur1.actif,
        pseudo: utilisateur1.email,
        email: String::from(&quot;quelquundautre@example.com&quot;),
        nombre_de_connexions: utilisateur1.nombre_de_connexions,
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-6: Creating a new `User` instance using one of
the values from `user1`</span>
-->
<p><span class="caption">Encart 5-6¬†: cr√©ation d'une nouvelle instance de
<code>Utilisateur</code> en utilisant une des valeurs de <code>utilisateur1</code>.</span></p>
<!--
Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax `..` specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.
-->
<p>En utilisant la syntaxe de mise √† jour de structure, on peut produire le m√™me
r√©sultat avec moins de code, comme le montre l'encart 5-7. La syntaxe <code>..</code>
indique que les autres champs auxquels on ne donne pas explicitement de valeur
devraient avoir la m√™me valeur que dans l'instance pr√©cis√©e.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn main() {
    // --snip--
# 
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span>
    let utilisateur2 = Utilisateur {
        email: String::from(&quot;quelquundautre@example.com&quot;),
        ..utilisateur1
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-7: Using struct update syntax to set a new
`email` value for a `User` instance but use the rest of the values from
`user1`</span>
-->
<p><span class="caption">Encart 5-7¬†: utilisation de la syntaxe de mise √† jour de
structure pour assigner de nouvelles valeurs √† <code>email</code> d'une nouvelle instance
de <code>Utilisateur</code> tout en utilisant les autres valeurs de <code>utilisateur1</code></span></p>
<!--
The code in Listing 5-7 also creates an instance in `user2` that has a
different value for `email` but has the same values for the `username`,
`active`, and `sign_in_count` fields from `user1`. The `..user1` must come last
to specify that any remaining fields should get their values from the
corresponding fields in `user1`, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct‚Äôs definition.
-->
<p>Le code dans l'encart 5-7 cr√©e aussi une instance dans <code>utilisateur2</code> qui a une
valeur diff√©rente pour <code>email</code>, mais qui as les m√™mes valeurs pour les champs
<code>pseudo</code>, <code>actif</code> et <code>nombre_de_connexions</code> que <code>utilisateur1</code>. Le
<code>..utilisateur1</code> doit √™tre ins√©r√© √† la fin pour pr√©ciser que tous les champs
restants obtiendrons les valeurs des champs correspondants de <code>utilisateur1</code>,
mais nous pouvons renseigner les valeurs des champs dans n'importe quel ordre,
peu importe leur position dans la d√©finition de la structure.</p>
<!--
Note that the struct update syntax uses `=` like an assignment; this is
because it moves the data, just as we saw in the [‚ÄúWays Variables and Data
Interact: Move‚Äù][move]<!-- ignore -- > section. In this example, we can no
longer use `user1` after creating `user2` because the `String` in the
`username` field of `user1` was moved into `user2`. If we had given `user2` new
`String` values for both `email` and `username`, and thus only used the
`active` and `sign_in_count` values from `user1`, then `user1` would still be
valid after creating `user2`. The types of `active` and `sign_in_count` are
types that implement the `Copy` trait, so the behavior we discussed in the
[‚ÄúStack-Only Data: Copy‚Äù][copy]<!-- ignore -- > section would apply.
-->
<p>Veuillez notez que la syntaxe de la mise √† jour de structure utilise un <code>=</code>
comme le ferait une assignation¬†; car cela d√©place les donn√©es, comme nous
l'avons vu dans <a href="ch04-01-what-is-ownership.html">une des sections au chapitre 4</a><!-- ignore -->. Dans cet
exemple, nous ne pouvons plus utiliser <code>utilisateur1</code> apr√®s avoir cr√©√©
<code>utilisateur2</code> car la <code>String</code> dans le champ <code>pseudo</code> de <code>utilisateur1</code> a √©t√©
d√©plac√©e dans <code>utilisateur2</code>. Si nous avions donn√© des nouvelles valeurs pour
chacune des <code>String</code> <code>email</code> et <code>pseudo</code>, et que par cons√©quent nous aurions
d√©plac√© uniquement les valeurs de <code>actif</code> et de <code>nombre_de_connexions</code> √† partir
de <code>utilisateur1</code>, alors <code>utilisateur1</code> restera en vigueur apr√®s avoir cr√©√©
<code>utilisateur2</code>. Les types de <code>actif</code> et de <code>nombre_de_connexions</code> sont de types
qui impl√©mentent le trait <code>Copy</code>, donc le comportement d√©cris dans <a href="ch04-01-what-is-ownership.html">la section
√† propos de copy</a><!-- ignore --> aura lieu ici.</p>
<!--
### Using Tuple Structs without Named Fields to Create Different Types
-->
<h3 id="utilisation-de-structures-tuples-sans-champ-nomm√©-pour-cr√©er-des-types-diff√©rents"><a class="header" href="#utilisation-de-structures-tuples-sans-champ-nomm√©-pour-cr√©er-des-types-diff√©rents">Utilisation de structures tuples sans champ nomm√© pour cr√©er des types diff√©rents</a></h3>
<!--
Rust also supports structs that look similar to tuples, called *tuple
structs*. Tuple structs have the added meaning the struct name provides but
don‚Äôt have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple a different type from other tuples, and when naming each
field as in a regular struct would be verbose or redundant.
-->
<p>Rust prend aussi en charge des structures qui ressemblent √† des tuples,
appel√©es <em>structures tuples</em>. La signification d'une structure tuple est donn√©e
par son nom. En revanche, ses champs ne sont pas nomm√©s¬†; on ne pr√©cise que
leurs types. Les structures tuples servent lorsqu'on veut donner un nom √† un
tuple pour qu'il soit d'un type diff√©rent des autres tuples, et lorsque nommer
chaque champ comme dans une structure classique serait trop verbeux ou
redondant.</p>
<!--
To define a tuple struct, start with the `struct` keyword and the struct name
followed by the types in the tuple. For example, here we define and use
two tuple structs named `Color` and `Point`:
-->
<p>La d√©finition d'une structure tuple commence par le mot-cl√© <code>struct</code> et le nom
de la structure suivis des types des champs du tuple. Par exemple ci-dessous,
nous d√©finissons et utilisons deux structures tuples nomm√©es <code>Couleur</code> et
<code>Point</code>¬†:</p>
<!--
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Couleur(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let noir = Couleur(0, 0, 0);
    let origine = Point(0, 0, 0);
}
</code></pre></pre>
<!--
Note that the `black` and `origin` values are different types, because they‚Äôre
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type `Color` cannot take a `Point` as an
argument, even though both types are made up of three `i32` values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a `.` followed by the index to access an
individual value, and so on.
-->
<p>Notez que les valeurs <code>noir</code> et <code>origine</code> sont de types diff√©rents parce que ce
sont des instances de structures tuples diff√©rentes. Chaque structure que l'on
d√©finit constitue son propre type, m√™me si les champs au sein de la structure
ont les m√™mes types. Par exemple, une fonction qui prend un param√®tre de type
<code>Couleur</code> ne peut pas prendre un argument de type <code>Point</code> √† la place, bien que
ces deux types soient tous les deux constitu√©s de trois valeurs <code>i32</code>. Mis √†
part cela, les instances de stuctures tuples se comportent comme des tuples¬†: on
peut les d√©structurer en √©l√©ments individuels, on peut utiliser un <code>.</code> suivi de
l'indice pour acc√©der individuellement √† une valeur, et ainsi de suite.</p>
<!--
### Unit-Like Structs Without Any Fields
-->
<h3 id="les-structures-unit√©-sans-champs"><a class="header" href="#les-structures-unit√©-sans-champs">Les structures unit√©¬†sans champs</a></h3>
<!--
You can also define structs that don‚Äôt have any fields! These are called
*unit-like structs* because they behave similarly to `()`, the unit type that
we mentioned in [‚ÄúThe Tuple Type‚Äù][tuples]<!-- ignore -- > section. Unit-like
structs can be useful when you need to implement a trait on some type but don‚Äôt
have any data that you want to store in the type itself. We‚Äôll discuss traits
in Chapter 10. Here‚Äôs an example of declaring and instantiating a unit struct
named `AlwaysEqual`:
-->
<p>On peut aussi d√©finir des structures qui n'ont pas de champs¬†! Cela s'appelle
des <em>structures unit√©</em> parce qu'elles se comportent d'une fa√ßon analogue au type
unit√©, <code>()</code>, que nous avons vu dans <a href="ch03-02-data-types.html">la section sur les
tuples</a><!-- ignore -->. Les structures unit√© sont utiles lorsqu'on doit
impl√©menter un trait sur un type mais qu'on n'a aucune donn√©e √† stocker dans le
type en lui-m√™me. Nous aborderons les traits au chapitre 10. Voici un exemple
de d√©claration et d'instanciation d'une structure unit√© <code>ToujoursEgal</code>¬†:</p>
<!--
```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct ToujoursEgal;

fn main() {
    let sujet = ToujoursEgal;
}
</code></pre></pre>
<!--
To define `AlwaysEqual`, we use the `struct` keyword, the name we want, then a
semicolon. No need for curly brackets or parentheses! Then we can get an
instance of `AlwaysEqual` in the `subject` variable in a similar way: using the
name we defined, without any curly brackets or parentheses. Imagine that later
we‚Äôll implement behavior for this type such that every instance of
`AlwaysEqual` is always equal to every instance of any other type, perhaps to
have a known result for testing purposes. We wouldn‚Äôt need any data to
implement that behavior! You‚Äôll see in Chapter 10 how to define traits and
implement them on any type, including unit-like structs.
-->
<p>Pour d√©finir <code>ToujoursEgal</code>, nous utilisons le mot-cl√© <code>struct</code>, puis le nom que
nous voulons lui donner, et enfin un point-virgule. Pas besoin d'accolades ou de
parenth√®ses¬†! Ensuite, nous pouvons obtenir une instance de <code>ToujourEgal</code> dans
la variable <code>sujet</code> de la m√™me mani√®re¬†: utilisez le nom que vous avez d√©fini,
sans aucune accolade ou parenth√®se. Imaginez que plus tard nous allons
impl√©menter un comportement pour ce type pour que toutes les instances de
<code>ToujourEgal</code> soient toujours √©gales √† chaque instance de n'importe quel autre
type, peut-√™tre pour avoir un r√©sultat connu pour des besoins de tests. Nous
n'avons besoin d'aucune donn√©e pour impl√©menter ce comportement¬†! Vous verrez
au chapitre 10 comment d√©finir des traits et les impl√©menter sur n'importe quel
type, y compris sur les structures unit√©.</p>
<!--
> ### Ownership of Struct Data
>
> In the `User` struct definition in Listing 5-1, we used the owned `String`
> type rather than the `&str` string slice type. This is a deliberate choice
> because we want each instance of this struct to own all of its data and for
> that data to be valid for as long as the entire struct is valid.
>
> It‚Äôs also possible for structs to store references to data owned by something
> else, but to do so requires the use of *lifetimes*, a Rust feature that we‚Äôll
> discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
> is valid for as long as the struct is. Let‚Äôs say you try to store a reference
> in a struct without specifying lifetimes, like the following; this won‚Äôt work:
>
> <span class="filename">Filename: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -- >
>
> ```rust,ignore,does_not_compile
> struct User {
>     active: bool,
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
> }
>
> fn main() {
>     let user1 = User {
>         email: "someone@example.com",
>         username: "someusername123",
>         active: true,
>         sign_in_count: 1,
>     };
> }
> ```
>
> The compiler will complain that it needs lifetime specifiers:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:3:15
>   |
> 3 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 ~     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:4:12
>   |
> 4 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 |     username: &str,
> 4 ~     email: &'a str,
>   |
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs` due to 2 previous errors
> ```
>
> In Chapter 10, we‚Äôll discuss how to fix these errors so you can store
> references in structs, but for now, we‚Äôll fix errors like these using owned
> types like `String` instead of references like `&str`.
-->
<blockquote>
<h3 id="la-possession-des-donn√©es-dune-structure"><a class="header" href="#la-possession-des-donn√©es-dune-structure">La possession des donn√©es d'une structure</a></h3>
<p>Dans la d√©finition de la structure <code>Utilisateur</code> de l'encart 5-1, nous avions
utilis√© le type poss√©d√© <code>String</code> plut√¥t que le type de <em>slice</em> de cha√Æne de
caract√®res <code>&amp;str</code>. Il s'agit d'un choix d√©lib√©r√© puisque nous voulons que
chacune des instances de cette structure poss√®dent toutes leurs donn√©es et
que ces donn√©es restent valides tant que la structure tout enti√®re est
valide.</p>
<p>Il est aussi possible pour les structures de stocker des r√©f√©rences vers des
donn√©es poss√©d√©es par autre chose, mais cela n√©cessiterait d'utiliser des
<em>dur√©es de vie</em>, une fonctionnalit√© de Rust que nous aborderons au
chapitre 10. Les dur√©es de vie assurent que les donn√©es r√©f√©renc√©es par une
structure restent valides tant que la structure l'est aussi. Disons que vous
essayiez de stocker une r√©f√©rence dans une structure sans indiquer de dur√©es
de vie, comme ce qui suit, ce qui ne fonctionnera pas¬†:</p>
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct Utilisateur {
    actif: bool,
    pseudo: &amp;str,
    email: &amp;str,
    nombre_de_connexions: u64,
}

fn main() {
    let utilisateur1 = Utilisateur {
        email: &quot;quelquun@example.com&quot;,
        pseudo: &quot;pseudoquelconque123&quot;,
        actif: true,
        nombre_de_connexions: 1,
    };
}
</code></pre>
<p>Le compilateur r√©clamera l'ajout des dur√©es de vie¬†:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     pseudo: &amp;str,
  |             ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct Utilisateur&lt;'a&gt; {
2 |     actif: bool,
3 ~     pseudo: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct Utilisateur&lt;'a&gt; {
2 |     actif: bool,
3 |     pseudo: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>Au chapitre 10, nous aborderons la fa√ßon de corriger ces erreurs pour qu'on
puisse stocker des r√©f√©rences dans des structures, mais pour le moment, nous
r√©soudrons les erreurs comme celles-ci en utilisant des types poss√©d√©s comme
<code>String</code> plut√¥t que des r√©f√©rences comme <code>&amp;str</code>.</p>
</blockquote>
<!--
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -- >
-->
<!--
[tuples]: ch03-02-data-types.html#the-tuple-type
[move]: ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move
[copy]: ch04-01-what-is-ownership.html#stack-only-data-copy
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## An Example Program Using Structs
-->
<h2 id="un-exemple-de-programme-qui-utilise-des-structures"><a class="header" href="#un-exemple-de-programme-qui-utilise-des-structures">Un exemple de programme qui utilise des structures</a></h2>
<!--
To understand when we might want to use structs, let‚Äôs write a program that
calculates the area of a rectangle. We‚Äôll start by using single variables, and
then refactor the program until we‚Äôre using structs instead.
-->
<p>Pour comprendre dans quels cas nous voudrions utiliser des structures, √©crivons
un programme qui calcule l'aire d'un rectangle. Nous commencerons en utilisant
de simples variables, puis on remaniera le code jusqu'√† utiliser des structures
√† la place.</p>
<!--
Let‚Äôs make a new binary project with Cargo called *rectangles* that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project‚Äôs *src/main.rs*.
-->
<p>Cr√©ons un nouveau projet binaire avec Cargo nomm√© <em>rectangles</em> qui prendra la
largeur et la hauteur en pixels d'un rectangle et qui calculera l'aire de ce
rectangle. L'encart 5-8 montre un petit programme qui effectue cette t√¢che d'une
certaine mani√®re dans le <em>src/main.rs</em> de notre projet.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let largeur1 = 30;
    let hauteur1 = 50;

    println!(
        &quot;L'aire du rectangle est de {} pixels carr√©s.&quot;,
        aire(largeur1, hauteur1)
    );
}

fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
    largeur * hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by separate width and height variables</span>
-->
<p><span class="caption">Encart 5-8¬†: calcul de l'aire d'un rectangle d√©fini par
les variables distinctes <code>largeur</code> et <code>hauteur</code></span></p>
<!--
Now, run this program using `cargo run`:
-->
<p>Maintenant, lancez ce programme avec <code>cargo run</code>¬†:</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
L'aire du rectangle est de 1500 pixels carr√©s.
</code></pre>
<!--
This code succeeds in figuring out the area of the rectangle by calling the
`area` function with each dimension, but we can do more to make this code clear
and readable.
-->
<p>Ce code arrive √† d√©terminer l'aire du rectangle en appelant la fonction <code>aire</code>
avec chaque dimension, mais on peut faire mieux pour clarifier ce code et le
rendre plus lisible.</p>
<!--
The issue with this code is evident in the signature of `area`:
-->
<p>Le probl√®me de ce code se voit dans la signature de <code>aire</code>¬†:</p>
<!--
```rust,ignore
# fn main() {
#     let width1 = 30;
#     let height1 = 50;
# 
#     println!(
#         "The area of the rectangle is {} square pixels.",
#         area(width1, height1)
#     );
# }
# 
fn area(width: u32, height: u32) -> u32 {
#     width * height
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let largeur1 = 30;
</span><span class="boring">    let hauteur1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;L'aire du rectangle est de {} pixels carr√©s.&quot;,
</span><span class="boring">        aire(largeur1, hauteur1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
<span class="boring">    largeur * hauteur
</span><span class="boring">}
</span></code></pre>
<!--
The `area` function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters, and it‚Äôs not clear anywhere in our
program that the parameters are related. It would be more readable and more
manageable to group width and height together. We‚Äôve already discussed one way
we might do that in [‚ÄúThe Tuple Type‚Äù][the-tuple-type]<!-- ignore -- > section
of Chapter 3: by using tuples.
-->
<p>La fonction <code>aire</code> est cens√©e calculer l'aire d'un rectangle, mais la fonction
que nous avons √©crite a deux param√®tres, et il n'est pas pr√©cis√© nulle part
dans notre programme √† quoi sont li√©s les param√®tres. Il serait plus lisible et
plus g√©rable de regrouper ensemble la largeur et la hauteur. Nous avons d√©j√† vu
dans la section <a href="ch03-02-data-types.html">‚ÄúLe type <em>tuple</em>‚Äù</a><!-- ignore --> du chapitre 3
une fa√ßon qui nous permettrait de le faire¬†: en utilisant des tuples.</p>
<!--
### Refactoring with Tuples
-->
<h3 id="remanier-le-code-avec-des-tuples"><a class="header" href="#remanier-le-code-avec-des-tuples">Remanier le code avec des tuples</a></h3>
<!--
Listing 5-9 shows another version of our program that uses tuples.
-->
<p>L'encart 5-9 nous montre une autre version de notre programme qui utilise des
tuples.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;L'aire du rectangle est de {} pixels carr√©s.&quot;,
        aire(rect1)
    );
}

fn aire(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span>
-->
<p><span class="caption">Encart 5-9¬†: Renseigner la largeur et la hauteur du
rectangle dans un tuple</span></p>
<!--
In one way, this program is better. Tuples let us add a bit of structure, and
we‚Äôre now passing just one argument. But in another way, this version is less
clear: tuples don‚Äôt name their elements, so we have to index into the parts of
the tuple, making our calculation less obvious.
-->
<p>D'une certaine fa√ßon, ce programme est meilleur. Les tuples nous permettent de
structurer un peu plus et nous ne passons plus qu'un argument. Mais d'une autre
fa√ßon, cette version est moins claire¬†: les tuples ne donnent pas de noms √†
leurs √©l√©ments, donc il faut acc√©der aux √©l√©ments du tuple via leur indice, ce
qui rends plus compliqu√© notre calcul.</p>
<!--
Mixing up the width and height wouldn‚Äôt matter for the area calculation, but if
we want to draw the rectangle on the screen, it would matter! We would have to
keep in mind that `width` is the tuple index `0` and `height` is the tuple
index `1`. This would be even harder for someone else to figure out and keep in
mind if they were to use our code. Because we haven‚Äôt conveyed the meaning of
our data in our code, it‚Äôs now easier to introduce errors.
-->
<p>Le m√©lange de la largeur et la hauteur n'est pas important pour calculer l'aire,
mais si on voulait afficher le rectangle √† l'√©cran, cela serait probl√©matique¬†!
Il nous faut garder √† l'esprit que la <code>largeur</code> est l'√©l√©ment √† l'indice <code>0</code> du
tuple et que la <code>hauteur</code> est l'√©l√©ment √† l'indice <code>1</code>. Cela complexifie le
travail de quelqu'un d'autre de le comprendre et s'en souvenir pour qu'il
puisse l'utiliser. Comme on n'a pas exprim√© la signification de nos donn√©es
dans notre code, il est plus facile de faire des erreurs.</p>
<!--
### Refactoring with Structs: Adding More Meaning
-->
<h3 id="remanier-avec-des-structures--donner-plus-de-sens"><a class="header" href="#remanier-avec-des-structures--donner-plus-de-sens">Remanier avec des structures¬†: donner plus de sens</a></h3>
<!--
We use structs to add meaning by labeling the data. We can transform the tuple
we‚Äôre using into a struct with a name for the whole as well as names for the
parts, as shown in Listing 5-10.
-->
<p>On utilise des structures pour rendre les donn√©es plus expressives en leur
donnant des noms. On peut transformer le tuple que nous avons utilis√© en une
structure nomm√©e dont ses √©l√©ments sont aussi nomm√©s, comme le montre l'encart
5-10.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carr√©s.&quot;,
        aire(&amp;rect1)
    );
}

fn aire(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.largeur * rectangle.hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-10: Defining a `Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-10¬†: D√©finition d'une structure
<code>Rectangle</code></span></p>
<!--
Here we‚Äôve defined a struct and named it `Rectangle`. Inside the curly
brackets, we defined the fields as `width` and `height`, both of which have
type `u32`. Then in `main`, we created a particular instance of `Rectangle`
that has a width of 30 and a height of 50.
-->
<p>Ici, on a d√©fini une structure et on l'a appel√©e <code>Rectangle</code>. Entre les
accolades, on a d√©fini les champs <code>largeur</code> et <code>hauteur</code>, tous deux du type
<code>u32</code>. Puis dans <code>main</code>, on cr√©e une instance de <code>Rectangle</code> de largeur 30 et de
hauteur 50.</p>
<!--
Our `area` function is now defined with one parameter, which we‚Äôve named
`rectangle`, whose type is an immutable borrow of a struct `Rectangle`
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, `main` retains its ownership and can continue
using `rect1`, which is the reason we use the `&` in the function signature and
where we call the function.
-->
<p>Notre fonction <code>aire</code> est d√©sormais d√©finie avec un unique param√®tre, nomm√©
<code>rectangle</code>, et dont le type est une r√©f√©rence immuable vers une instance de la
structure <code>Rectangle</code>. Comme mentionn√© au chapitre 4, on pr√©f√®re emprunter la
structure au lieu d'en prendre possession. Ainsi, elle reste en possession de
<code>main</code> qui peut continuer √† utiliser <code>rect1</code>¬†; c'est pourquoi on utilise le <code>&amp;</code>
dans la signature de la fonction ainsi que dans l'appel de fonction.</p>
<!--
The `area` function accesses the `width` and `height` fields of the `Rectangle`
instance. Our function signature for `area` now says exactly what we mean:
calculate the area of `Rectangle`, using its `width` and `height` fields. This
conveys that the width and height are related to each other, and it gives
descriptive names to the values rather than using the tuple index values of `0`
and `1`. This is a win for clarity.
-->
<p>La fonction <code>aire</code> acc√®de aux champs <code>largeur</code> et <code>hauteur</code> de l'instance de
<code>Rectangle</code>. Notre signature de fonction pour <code>aire</code> est enfin explicite¬†:
calculer l'aire d'un <code>Rectangle</code> en utilisant ses champs <code>largeur</code> et <code>hauteur</code>.
Cela explique que la largeur et la hauteur sont li√©es entre elles, et cela donne
des noms descriptifs aux valeurs plut√¥t que d'utiliser les valeurs du tuple avec
les indices <code>0</code> et <code>1</code>. On gagne en clart√©.</p>
<!--
### Adding Useful Functionality with Derived Traits
-->
<h3 id="ajouter-des-fonctionnalit√©s-utiles-avec-les-traits-d√©riv√©s"><a class="header" href="#ajouter-des-fonctionnalit√©s-utiles-avec-les-traits-d√©riv√©s">Ajouter des fonctionnalit√©s utiles avec les traits d√©riv√©s</a></h3>
<!--
It‚Äôd be useful to be able to print an instance of `Rectangle` while we‚Äôre
debugging our program and see the values for all its fields. Listing 5-11 tries
using the [`println!` macro][println]<!-- ignore -- > as we have used in
previous chapters. This won‚Äôt work, however.
-->
<p>Cela serait pratique de pouvoir afficher une instance de <code>Rectangle</code> pendant
qu'on d√©bogue notre programme et de voir la valeur de chacun de ses champs.
L'encart 5-11 essaye de le faire en utilisant <a href="https://doc.rust-lang.org/std/macro.println.html">la macro
<code>println!</code></a><!-- ignore --> comme on l'a fait dans les chapitres
pr√©c√©dents. Cependant, cela ne fonctionne pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };

    println!(&quot;rect1 est {}&quot;, rect1);
}
</code></pre>
<!--
<span class="caption">Listing 5-11: Attempting to print a `Rectangle`
instance</span>
-->
<p><span class="caption">Encart 5-11¬†: Tentative d'afficher une instance de
<code>Rectangle</code></span></p>
<!--
When we compile this code, we get an error with this core message:
-->
<p>Lorsqu'on compile ce code, on obtient ce message d'erreur qui nous informe que
<code>Rectangle</code> n'impl√©mente pas le trait <code>std::fmt::Display</code>¬†:</p>
<!--
```text
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```
-->
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<!--
The `println!` macro can do many kinds of formatting, and by default, the curly
brackets tell `println!` to use formatting known as `Display`: output intended
for direct end user consumption. The primitive types we‚Äôve seen so far
implement `Display` by default, because there‚Äôs only one way you‚Äôd want to show
a `1` or any other primitive type to a user. But with structs, the way
`println!` should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn‚Äôt try to guess what we want, and structs don‚Äôt have a provided
implementation of `Display` to use with `println!` and the `{}` placeholder.
-->
<p>La macro <code>println!</code> peut faire toutes sortes de formatages textuels, et par
d√©faut, les accolades demandent √† <code>println!</code> d'utiliser le formatage appel√©
<code>Display</code>, pour convertir en texte destin√© √† √™tre vu par l'utilisateur final.
Les types primitifs qu'on a vus jusqu'ici impl√©mentent <code>Display</code> par d√©faut
puisqu'il n'existe qu'une seule fa√ßon d'afficher un <code>1</code> ou tout autre type
primitif √† l'utilisateur. Mais pour les structures, la fa√ßon dont <code>println!</code>
devrait formater son r√©sultat est moins claire car il y a plus de possibilit√©s
d'affichage¬†: Voulez-vous des virgules¬†? Voulez-vous afficher les accolades¬†?
Est-ce que tous les champs devraient √™tre affich√©s¬†? √Ä cause de ces ambigu√Øt√©s,
Rust n'essaye pas de deviner ce qu'on veut, et les structures n'impl√©mentent pas
<code>Display</code> par d√©faut pour l'utiliser avec <code>println!</code> et les espaces r√©serv√©s
<code>{}</code>.</p>
<!--
If we continue reading the errors, we‚Äôll find this helpful note:
-->
<p>Si nous continuons de lire les erreurs, nous trouvons cette remarque utile¬†:</p>
<!--
```text
   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```
-->
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Le compilateur nous informe que dans notre cha√Æne de formatage, on est peut-√™tre
en mesure d'utiliser <code>{:?}</code> (ou <code>{:#?}</code> pour un affichage plus √©l√©gant).</p>
<!--
Let‚Äôs try it! The `println!` macro call will now look like `println!("rect1 is
{:?}", rect1);`. Putting the specifier `:?` inside the curly brackets tells
`println!` we want to use an output format called `Debug`. The `Debug` trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we‚Äôre debugging our code.
-->
<p>Essayons cela¬†! L'appel de la macro <code>println!</code> ressemble maintenant √†
<code>println!(&quot;rect1 est {:?}&quot;, rect1);</code>. Ins√©rer le s√©lecteur <code>:?</code> entre les
accolades permet d'indiquer √† <code>println!</code> que nous voulons utiliser le formatage
appel√© <code>Debug</code>. Le trait <code>Debug</code> nous permet d'afficher notre structure d'une
mani√®re utile aux d√©veloppeurs pour qu'on puisse voir sa valeur pendant qu'on
d√©bogue le code.</p>
<!--
Compile the code with this change. Drat! We still get an error:
-->
<p>Compilez le code avec ce changement. Zut¬†! On a encore une erreur, nous
informant cette fois-ci que <code>Rectangle</code> n'impl√©mente pas <code>std::fmt::Debug</code>¬†:</p>
<!--
```text
error[E0277]: `Rectangle` doesn't implement `Debug`
```
-->
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<!--
But again, the compiler gives us a helpful note:
-->
<p>Mais une nouvelle fois, le compilateur nous fait une remarque utile¬†:</p>
<!--
```text
   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```
-->
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Il nous conseille d'ajouter <code>#[derive(Debug)]</code> ou d'impl√©menter manuellement
<code>std::fmt::Debug</code>.</p>
<!--
Rust *does* include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the outer attribute `#[derive(Debug)]` just before the
struct definition, as shown in Listing 5-12.
-->
<p>Rust <em>inclut</em> bel et bien une fonctionnalit√© pour afficher des informations de
d√©bogage, mais nous devons l'activer explicitement pour la rendre disponible sur
notre structure. Pour ce faire, on ajoute l'attribut externe <code>#[derive(Debug)]</code>
juste avant la d√©finition de la structure, comme le montre l'encart 5-12.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };

    println!(&quot;rect1 est {:?}&quot;, rect1);
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-12: Adding the attribute to derive the `Debug`
trait and printing the `Rectangle` instance using debug formatting</span>
-->
<p><span class="caption">Encart 5-12¬†: ajout de l'attribut pour d√©river le
trait <code>Debug</code> et afficher l'instance de <code>Rectangle</code> en utilisant le formatage
de d√©bogage</span></p>
<!--
Now when we run the program, we won‚Äôt get any errors, and we‚Äôll see the
following output:
-->
<p>Maintenant, quand on ex√©cute le programme, nous n'avons plus d'erreurs et ce
texte s'affiche √† l'√©cran¬†:</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 est Rectangle { largeur: 30, hauteur: 50 }
</code></pre>
<!--
Nice! It‚Äôs not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it‚Äôs useful to have output that‚Äôs a bit easier to read; in
those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string.
In this example, using the `{:#?}` style will output:
-->
<p>Super¬†! Ce n'est pas le plus beau des affichages, mais cela montre les
valeurs de tous les champs de cette instance, ce qui serait assur√©ment utile
lors du d√©bogage. Quand on a des structures plus grandes, il serait bien d'avoir
un affichage un peu plus lisible¬†; dans ces cas-l√†, on pourra utiliser <code>{:#?}</code>
au lieu de <code>{:?}</code> dans la cha√Æne de formatage. Dans cette exemple,
l'utilisation du style <code>{:#?}</code> va afficher ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 est Rectangle {
    largeur: 30,
    hauteur: 50,
}
</code></pre>
<!--
Another way to print out a value using the `Debug` format is to use the [`dbg!`
macro][dbg]<!-- ignore -- >, which takes ownership of an expression, prints the
file and line number of where that `dbg!` macro call occurs in your code along
with the resulting value of that expression, and returns ownership of the value.
-->
<p>Une autre fa√ßon d'afficher une valeur en utilisant le format <code>Debug</code> est
d'utiliser la <a href="https://doc.rust-lang.org/std/macro.dbg.html">macro <code>dbg!</code></a><!-- ignore -->, qui prend possession de
l'expression, affiche le nom du fichier et la ligne de votre code o√π se trouve
cet appel √† la macro <code>dbg!</code> ainsi que le r√©sultat de cette expression, puis
rend la possession de cette valeur.</p>
<!--
> Note: Calling the `dbg!` macro prints to the standard error console stream
> (`stderr`), as opposed to `println!` which prints to the standard output
> console stream (`stdout`). We‚Äôll talk more about `stderr` and `stdout` in the
> ‚Äú[‚ÄúWriting Error Messages to Standard Error Instead of Standard
> Output‚Äù section in Chapter 12][err]<!-- ignore -- >.
-->
<blockquote>
<p>Remarque : l'appel √† la macro <code>dbg!</code> √©crit dans le flux d'erreur standard
de la console (<code>stderr</code>), contrairement √† <code>println!</code> qui √©crit dans le flux
de sortie standard de la console (<code>stdout</code>). Nous reparlerons de <code>stderr</code> et
de <code>stdout</code> dans <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">une section du chapitre 12</a><!-- ignore -->.</p>
</blockquote>
<!--
Here‚Äôs an example where we‚Äôre interested in the value that gets assigned to the
`width` field, as well as the value of the whole struct in `rect1`:
-->
<p>Voici un exemple dans lequel nous nous int√©ressons √† la valeur assign√©e au
champ <code>largeur</code>, ainsi que la valeur de toute la structure <code>rect1</code>¬†:</p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let echelle = 2;
    let rect1 = Rectangle {
        largeur: dbg!(30 * echelle),
        hauteur: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></pre>
<!--
We can put `dbg!` around the expression `30 * scale` and, because `dbg!`
returns ownership of the expression‚Äôs value, the `width` field will get the
same value as if we didn‚Äôt have the `dbg!` call there. We don‚Äôt want `dbg!` to
take ownership of `rect1`, so we use a reference to `rect1` in the next call.
Here‚Äôs what the output of this example looks like:
-->
<p>Nous pouvons placer le <code>dbg!</code> autour de l'expression <code>30 * echelle</code> et, comme
<code>dbg!</code> retourne la possession de la valeur issue de l'expression, le champ
<code>largeur</code> va avoir la m√™me valeur que si nous n'avions pas appel√© <code>dbg!</code> ici.
Nous ne voulons pas que <code>dbg!</code> prenne possession de <code>rect1</code>, donc nous donnons
une r√©f√©rence √† <code>rect1</code> lors de son prochain appel. Voici √† quoi ressemble la
sortie de cet exemple¬†:</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * echelle = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    largeur: 60,
    hauteur: 50,
}
</code></pre>
<!--
We can see the first bit of output came from *src/main.rs* line 10, where we‚Äôre
debugging the expression `30 * scale`, and its resulting value is 60 (the
`Debug` formatting implemented for integers is to print only their value). The
`dbg!` call on line 14 of *src/main.rs* outputs the value of `&rect1`, which is
the `Rectangle` struct. This output uses the pretty `Debug` formatting of the
`Rectangle` type. The `dbg!` macro can be really helpful when you‚Äôre trying to
figure out what your code is doing!
-->
<p>Nous pouvons constater que la premi√®re sortie provient de la ligne 10
de <em>src/main.rs</em>, o√π nous d√©boguons l'expression <code>30 * echelle</code>, et son r√©sultat
est 60 (le formattage de <code>Debug</code> pour les entiers est d'afficher uniquement sa
valeur). L'appel √† <code>dbg!</code> √† la ligne 14 de <em>src/main.rs</em> affiche la valeur de
<code>&amp;rect1</code>, qui est une structure <code>Rectangle</code>. La macro <code>dbg!</code> peut √™tre tr√®s
utile lorsque vous essayez de comprendre ce que fait votre code¬†!</p>
<!--
In addition to the `Debug` trait, Rust has provided a number of traits for us
to use with the `derive` attribute that can add useful behavior to our custom
types. Those traits and their behaviors are listed in [Appendix C][app-c]<!--
ignore -- >. We‚Äôll cover how to implement these traits with custom behavior as
well as how to create your own traits in Chapter 10. There are also many
attributes other than `derive`; for more information, see [the ‚ÄúAttributes‚Äù
section of the Rust Reference][attributes].
-->
<p>En plus du trait <code>Debug</code>, Rust nous offre d'autres traits pour que nous
puissions les utiliser avec l'attribut <code>derive</code> pour ajouter des comportements
utiles √† nos propres types. Ces traits et leurs comportements sont list√©s √†
<a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore -->. Nous expliquerons comment impl√©menter ces
traits avec des comportements personnalis√©s et comment cr√©er vos propres traits
au chapitre 10. Il existe aussi de nombreux attributs autres que <code>derive</code>¬†; pour
en savoir plus, consultez <a href="https://doc.rust-lang.org/reference/attributes.html">la section ‚ÄúAttributs‚Äù de la r√©f√©rence de
Rust</a><!-- ignore -->.</p>
<!--
Our `area` function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our `Rectangle`
struct, because it won‚Äôt work with any other type. Let‚Äôs look at how we can
continue to refactor this code by turning the `area` function into an `area`
*method* defined on our `Rectangle` type.
-->
<p>Notre fonction <code>aire</code> est tr√®s sp√©cifique¬†: elle ne fait que calculer l'aire
d'un rectangle. Il serait utile de lier un peu plus ce comportement √† notre
structure <code>Rectangle</code>, puisque cela ne fonctionnera pas avec un autre type.
Voyons comment on peut continuer de remanier ce code en transformant la fonction
<code>aire</code> en <em>m√©thode</em> <code>aire</code> d√©finie sur notre type <code>Rectangle</code>.</p>
<!--
[the-tuple-type]: ch03-02-data-types.html#the-tuple-type
[app-c]: appendix-03-derivable-traits.md
[println]: ../std/macro.println.html
[dbg]: ../std/macro.dbg.html
[err]: ch12-06-writing-to-stderr-instead-of-stdout.html
[attributes]: ../reference/attributes.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Method Syntax
-->
<h2 id="la-syntaxe-des-m√©thodes"><a class="header" href="#la-syntaxe-des-m√©thodes">La syntaxe des m√©thodes</a></h2>
<!--
*Methods* are similar to functions: we declare them with the `fn` keyword and a
name, they can have parameters and a return value, and they contain some code
that‚Äôs run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum or a trait
object, which we cover in Chapters 6 and 17, respectively), and their first
parameter is always `self`, which represents the instance of the struct the
method is being called on.
-->
<p>Les <em>m√©thodes</em> sont similaires aux fonctions¬†: nous les d√©clarons avec le
mot-cl√© <code>fn</code> et un nom, elles peuvent avoir des param√®tres et une valeur de
retour, et elles contiennent du code qui est ex√©cut√© quand on la m√©thode est
appell√©e depuis un autre endroit. Contrairement aux fonctions, les m√©thodes
diff√®rent des fonctions parce qu'elles sont d√©finies dans le contexte d'une
structure (ou d'une √©num√©ration ou d'un objet de trait, que nous aborderons
respectivement aux chapitres 6 et 17) et que leur premier param√®tre est
toujours <code>self</code>, un mot-cl√© qui repr√©sente l'instance de la structure sur
laquelle on appelle la m√©thode.</p>
<!--
### Defining Methods
-->
<h3 id="d√©finir-des-m√©thodes"><a class="header" href="#d√©finir-des-m√©thodes">D√©finir des m√©thodes</a></h3>
<!--
Let‚Äôs change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p>Rempla√ßons la fonction <code>aire</code> qui prend une instance de <code>Rectangle</code> en param√®tre
par une m√©thode <code>aire</code> d√©finie sur la structure <code>Rectangle</code>, comme dans
l'encart 5-13.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carr√©s.&quot;,
        rect1.aire()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-13¬†: D√©finition d'une m√©thode <code>aire</code> sur la
structure <code>Rectangle</code></span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block for `Rectangle`. Everything within this `impl` block
will be associated with the `Rectangle` type. Then we move the `area` function
within the `impl` curly brackets and change the first (and in this case, only)
parameter to be `self` in the signature and everywhere within the body. In
`main`, where we called the `area` function and passed `rect1` as an argument,
we can instead use *method syntax* to call the `area` method on our `Rectangle`
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.
-->
<p>Pour d√©finir la fonction dans le contexte de <code>Rectangle</code>, nous d√©marrons un bloc
<code>impl</code> (<em>impl√©mentation</em>) pour <code>Rectangle</code>. Tout ce qui sera dans ce bloc <code>impl</code>
sera li√© au type <code>Rectangle</code>. Puis nous d√©pla√ßons la fonction <code>aire</code> entre les
accolades du <code>impl</code> et nous rempla√ßons le premier param√®tre (et dans notre cas,
le seul) par <code>self</code> dans la signature et dans tout le corps. Dans <code>main</code>, o√π
nous avons appel√© la fonction <code>aire</code> et pass√© <code>rect1</code> en argument, nous pouvons
utiliser √† la place la <em>syntaxe des m√©thodes</em> pour appeler la m√©thode <code>aire</code> sur
notre instance de <code>Rectangle</code>. La syntaxe des m√©thodes se place apr√®s
l'instance¬†: on ajoute un point suivi du nom de la m√©thode et des parenth√®ses
contenant les arguments s'il y en a.</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`.
The `&self` is actually short for `self: &Self`. Within an `impl` block, the
type `Self` is an alias for the type that the `impl` block is for. Methods must
have a parameter named `self` of type `Self` for their first parameter, so Rust
lets you abbreviate this with only the name `self` in the first parameter spot.
Note that we still need to use the `&` in front of the `self` shorthand to
indicate this method borrows the `Self` instance, just as we did in `rectangle:
&Rectangle`. Methods can take ownership of `self`, borrow `self` immutably as
we‚Äôve done here, or borrow `self` mutably, just as they can any other parameter.
-->
<p>Dans la signature de <code>aire</code>, nous utilisons <code>&amp;self</code> √† la place de
<code>rectangle: &amp;Rectangle</code>. Le <code>&amp;self</code> est un raccourci pour <code>self: &amp;Self</code>. Au
sein d'un bloc <code>impl</code>, le type de <code>Self</code> est un alias pour le type sur lequel
porte le <code>impl</code>. Les m√©thodes doivent avoir un param√®tre <code>self</code> du type <code>Self</code>
comme premier param√®tre afin que Rust puisse vous permettre d'abr√©ger en
renseignant uniquement <code>self</code> en premier param√®tre. Veuillez noter qu'il nous
faut quand m√™me utiliser le <code>&amp;</code> devant le raccourci <code>self</code>, pour indiquer que
cette m√©thode emprunte l'instance de <code>Self</code>, comme nous l'avions fait pour
<code>rectangle: &amp;Rectangle</code>. Les m√©thodes peuvent prendre possession de <code>self</code>,
emprunter <code>self</code> de fa√ßon immuable comme nous l'avons fait ici, ou emprunter
<code>self</code> de fa√ßon mutable, comme pour n'importe quel autre param√®tre.</p>
<!--
We‚Äôve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we don‚Äôt want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we‚Äôve called the method on as part of what the method does, we‚Äôd use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and you want
to prevent the caller from using the original instance after the transformation.
-->
<p>Nous avons choisi <code>&amp;self</code> ici pour la m√™me raison que nous avions utilis√©
<code>&amp;Rectangle</code> quand il s'agissait d'une fonction¬†; nous ne voulons pas en prendre
possession, et nous voulons seulement lire les donn√©es de la structure, pas les
modifier. Si nous voulions que la m√©thode modifie l'instance sur laquelle on
l'appelle, on utiliserait <code>&amp;mut self</code> comme premier param√®tre. Il est rare
d'avoir une m√©thode qui prend possession de l'instance en utilisant uniquement
<code>self</code> comme premier argument¬†; cette technique est g√©n√©ralement utilis√©e
lorsque la m√©thode transforme <code>self</code> en quelque chose d'autre et que vous voulez
emp√™cher le code appelant d'utiliser l'instance d'origine apr√®s la
transformation.</p>
<!--
The main reason for using methods instead of functions, in addition to providing
method syntax and not having to repeat the type of `self` in every method‚Äôs
signature, is for organization. We‚Äôve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>En compl√©ment de l'application de la syntaxe des m√©thodes et ainsi de ne pas
√™tre oblig√© de r√©p√©ter le type de <code>self</code> dans la signature de chaque m√©thode,
la principale raison d'utiliser les m√©thodes plut√¥t que de fonctions est pour
l'organisation. Nous avons mis tout ce qu'on pouvait faire avec une instance de
notre type dans un bloc <code>impl</code> plut√¥t que d'imposer aux futurs utilisateurs de
notre code √† rechercher les fonctionnalit√©s de <code>Rectangle</code> √† divers endroits de
la biblioth√®que que nous fournissons.</p>
<!--
Note that we can choose to give a method the same name as one of the struct‚Äôs
fields. For example, we can define a method on `Rectangle` also named `width`:
-->
<p>Notez que nous pourions faire en sorte qu'une m√©thode porte le m√™me nom qu'un
des champs de la structure. Par exemple, nous pourions d√©finir une m√©thode sur
<code>Rectangle</code> qui s'appelle elle aussi <code>largeur</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn largeur(&amp;self) -&gt; bool {
        self.largeur &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50,
    };

    if rect1.largeur() {
        println!(&quot;Le rectangle a une largeur non nulle¬†; elle vaut {}&quot;, rect1.largeur);
    }
}
</code></pre></pre>
<!--
Here, we‚Äôre choosing to make the `width` method return `true` if the value in
the instance‚Äôs `width` field is greater than 0, and `false` if the value is 0:
we can use a field within a method of the same name for any purpose. In `main`,
when we follow `rect1.width` with parentheses, Rust knows we mean the method
`width`. When we don‚Äôt use parentheses, Rust knows we mean the field `width`.
-->
<p>Ici, nous avons d√©fini la m√©thode <code>largeur</code> pour qu'elle retourne <code>true</code> si la
valeur dans le champ <code>largeur</code> est sup√©rieur ou √©gal √† 0, et <code>false</code> si la
valeur est 0¬†: nous pouvons utiliser un champ √† l'int√©rieur d'une m√©thode du
m√™me nom, pour n'importe quel usage. Dans le <code>main</code>, lorsque nous ajoutons des
parenth√®ses apr√®s <code>rect1.largeur</code>, Rust comprend que nous parlons de la m√©thode
<code>largeur</code>. Lorsque nous n'utilisons pas les parenth√®ses, Rust sait nous parlons
du champ <code>largeur</code>.</p>
<!--
Often, but not always, when we give methods with the same name as a field we
want it to only return the value in the field and do nothing else. Methods like
this are called *getters*, and Rust does not implement them automatically for
struct fields as some other languages do. Getters are useful because you can
make the field private but the method public and thus enable read-only access
to that field as part of the type‚Äôs public API. We will be discussing what
public and private are and how to designate a field or method as public or
private in Chapter 7.
-->
<p>Souvent, mais pas toujours, lorsque nous appellons une m√©thode avec le m√™me nom
qu'un champ, nous voulons qu'elle renvoie uniquement la valeur de ce champ et
ne fasse rien d'autre. Ces m√©thodes sont appel√©es des <em>accesseurs</em>, et Rust ne
les impl√©mente pas automatiquement pour les champs des structures comme le font
certains langages. Les accesseurs sont utiles pour rendre le champ priv√© mais
rendre la m√©thode publique et ainsi donner un acc√®s en lecture seule √† ce champ
dans l'API publique de ce type. Nous d√©velopperons les notions de publique et
priv√© et comment d√©finir un champ ou une m√©thode publique ou priv√©e au
chapitre 7.</p>
<!--
> ### Where‚Äôs the `->` Operator?
>
> In C and C++, two different operators are used for calling methods: you use
> `.` if you‚Äôre calling a method on the object directly and `->` if you‚Äôre
> calling the method on a pointer to the object and need to dereference the
> pointer first. In other words, if `object` is a pointer,
> `object->something()` is similar to `(*object).something()`.
>
> Rust doesn‚Äôt have an equivalent to the `->` operator; instead, Rust has a
> feature called *automatic referencing and dereferencing*. Calling methods is
> one of the few places in Rust that has this behavior.
>
> Here‚Äôs how it works: when you call a method with `object.something()`, Rust
> automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
> the method. In other words, the following are the same:
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -- >
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> The first one looks much cleaner. This automatic referencing behavior works
> because methods have a clear receiver‚Äîthe type of `self`. Given the receiver
> and name of a method, Rust can figure out definitively whether the method is
> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
> that Rust makes borrowing implicit for method receivers is a big part of
> making ownership ergonomic in practice.
-->
<blockquote>
<h3 id="o√π-est-lop√©rateur---"><a class="header" href="#o√π-est-lop√©rateur---">O√π est l'op√©rateur <code>-&gt;</code>¬†?</a></h3>
<p>En C et en C++, deux op√©rateurs diff√©rents sont utilis√©s pour appeler les
m√©thodes¬†: on utilise <code>.</code> si on appelle une m√©thode directement sur l'objet
et <code>-&gt;</code> si on appelle la m√©thode sur un pointeur vers l'objet et qu'il faut
d'abord d√©r√©f√©rencer le pointeur. En d'autres termes, si <code>objet</code> est un
pointeur, <code>objet-&gt;methode()</code> est similaire √† <code>(*objet).methode()</code>.</p>
<p>Rust n'a pas d'√©quivalent √† l'op√©rateur <code>-&gt;</code>¬†; √† la place, Rust a une
fonctionnalit√© appel√©e <em>r√©f√©rencement et d√©r√©f√©rencement automatiques</em>.
L'appel de m√©thodes est l'un des rares endroits de Rust o√π on retrouve ce
comportement.</p>
<p>Voil√† comment cela fonctionne¬†: quand on appelle une m√©thode avec
<code>objet.methode()</code>, Rust ajoute automatiquement le <code>&amp;</code>, <code>&amp;mut</code> ou <code>*</code> pour que
<code>objet</code> corresponde √† la signature de la m√©thode. Autrement dit, ces deux
lignes sont identiques¬†:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, autre: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_carre = f64::powi(autre.x - self.x, 2);
</span><span class="boring">       let y_carre = f64::powi(autre.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_carre + y_carre)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>La premi√®re ligne semble bien plus propre. Ce comportement du
(d√©)r√©f√©rencement automatique fonctionne parce que les m√©thodes ont une
cible claire¬†: le type de <code>self</code>. Compte tenu du nom de la m√©thode et
de l'instance sur laquelle elle s'applique, Rust peut d√©terminer de mani√®re
irr√©futable si la m√©thode lit (<code>&amp;self</code>), modifie (<code>&amp;mut self</code>) ou consomme
(<code>self</code>) l'instance. Le fait que Rust rend implicite l'emprunt pour les
instances sur lesquelles on appelle les m√©thodes am√©liore significativement
l'ergonomie de la possession.</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3 id="les-m√©thodes-avec-davantage-de-param√®tres"><a class="header" href="#les-m√©thodes-avec-davantage-de-param√®tres">Les m√©thodes avec davantage de param√®tres</a></h3>
<!--
Let‚Äôs practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self` (the first `Rectangle`); otherwise it should return `false`. That
is, once we‚Äôve defined the `can_hold` method, we want to be able to write the
program shown in Listing 5-14.
-->
<p>Entra√Ænons-nous √† utiliser des m√©thodes en impl√©mentant une seconde m√©thode sur
la structure <code>Rectangle</code>. Cette fois-ci, nous voulons qu'une instance de
<code>Rectangle</code> prenne une autre instance de <code>Rectangle</code> et qu'on retourne <code>true</code> si
le second <code>Rectangle</code> peut se dessiner int√©gralement √† l'int√©rieur de <code>self</code>
(le premier <code>Rectangle</code>)¬†; sinon, on renverra <code>false</code>. En d'autres termes, une
fois qu'on aura d√©fini la m√©thode <code>peut_contenir</code>, on veut pouvoir √©crire le
programme de l'encart 5-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };
    let rect2 = Rectangle {
        largeur: 10,
        hauteur: 40
    };
    let rect3 = Rectangle {
        largeur: 60,
        hauteur: 45
    };

    println!(&quot;rect1 peut-il contenir rect2¬†? {}&quot;, rect1.peut_contenir(&amp;rect2));
    println!(&quot;rect1 peut-il contenir rect3¬†? {}&quot;, rect1.peut_contenir(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">Encart 5-14¬†: Utilisation de la m√©thode <code>peut_contenir</code>
qui reste √† √©crire</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>Et on s'attend √† ce que le texte suivant s'affiche, puisque les deux dimensions
de <code>rect2</code> sont plus petites que les dimensions de <code>rect1</code>, mais <code>rect3</code> est
plus large que <code>rect1</code>¬†:</p>
<!--
```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
-->
<pre><code class="language-text">rect1 peut-il contenir rect2¬†? true
rect1 peut-il contenir rect3¬†? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean we‚Äôd need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Let‚Äôs add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>Nous voulons d√©finir une m√©thode, donc elle doit se trouver dans le bloc
<code>impl Rectangle</code>. Le nom de la m√©thode sera <code>peut_contenir</code> et elle prendra une
r√©f√©rence immuable vers un autre <code>Rectangle</code> en param√®tre. On peut d√©terminer le
type du param√®tre en regardant le code qui appelle la m√©thode¬†:
<code>rect1.peut_contenir(&amp;rect2)</code> prend en argument <code>&amp;rect2</code>, une r√©f√©rence immuable
vers <code>rect2</code>, une instance de <code>Rectangle</code>. Cela est logique puisque nous voulons
uniquement lire <code>rect2</code> (plut√¥t que de la modifier, ce qui aurait n√©cessit√© une
r√©f√©rence mutable) et nous souhaitons que <code>main</code> garde possession de <code>rect2</code>
pour qu'on puisse le r√©utiliser apr√®s avoir appel√© la m√©thode <code>peut_contenir</code>.
La valeur de retour de <code>peut_contenir</code> sera un bool√©en et l'impl√©mentation de la
m√©thode v√©rifiera si la largeur et la hauteur de <code>self</code> sont respectivement plus
grandes que la largeur et la hauteur de l'autre <code>Rectangle</code>. Ajoutons la
nouvelle m√©thode <code>peut_contenir</code> dans le bloc <code>impl</code> de l'encart 5-13, comme le
montre l'encart 5-15.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }

    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2¬†? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3¬†? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">Encart 5-15¬†: Impl√©mentation de la m√©thode <code>peut_contenir</code>
sur <code>Rectangle</code> qui prend une autre instance de <code>Rectangle</code> en param√®tre</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, we‚Äôll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>Lorsque nous ex√©cutons ce code avec la fonction <code>main</code> de l'encart 5-14, nous
obtenons l'affichage attendu. Les m√©thodes peuvent prendre plusieurs param√®tres
qu'on peut ajouter √† la signature apr√®s le param√®tre <code>self</code>, et ces param√®tres
fonctionnent de la m√™me mani√®re que les param√®tres des fonctions.</p>
<!--
### Associated Functions
-->
<h3 id="les-fonctions-associ√©es"><a class="header" href="#les-fonctions-associ√©es">Les fonctions associ√©es</a></h3>
<!--
All functions defined within an `impl` block are called *associated functions*
because they‚Äôre associated with the type named after the `impl`. We can define
associated functions that don‚Äôt have `self` as their first parameter (and thus
are not methods) because they don‚Äôt need an instance of the type to work with.
We‚Äôve already used one function like this: the `String::from` function that‚Äôs
defined on the `String` type.
-->
<p>Toutes les fonctions d√©finies dans un bloc <code>impl</code> s'appellent des <em>fonctions
associ√©es</em> car elles sont associ√©es au type renseign√© apr√®s le <code>impl</code>. Nous
pouvons aussi y d√©finir des fonctions associ√©es qui n'ont pas de <code>self</code> en
premier param√®tre (et donc ce ne sont pas des m√©thodes) car elles n'ont pas
besoin d'une instance du type sur lequel elles travaillent. Nous avons d√©j√†
utilis√© une fonction comme celle-ci¬†: la fonction <code>String::from</code> qui est
d√©finie sur le type <code>String</code>.</p>
<!--
Associated functions that aren‚Äôt methods are often used for constructors that
will return a new instance of the struct. For example, we could provide an
associated function that would have one dimension parameter and use that as
both width and height, thus making it easier to create a square `Rectangle`
rather than having to specify the same value twice:
-->
<p>Les fonctions associ√©es qui ne ne sont pas des m√©thodes sont souvent utilis√©es
comme constructeurs qui vont retourner une nouvelle instance de la structure.
Par exemple, on pourrait √©crire une fonction associ√©e qui prend une unique
dimension en param√®tre et l'utilise √† la fois pour la largeur et pour la
hauteur, ce qui rend plus ais√© la cr√©ation d'un <code>Rectangle</code> carr√© plut√¥t que
d'avoir √† indiquer la m√™me valeur deux fois¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
# 
# fn main() {
#     let sq = Rectangle::square(3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn carre(cote: u32) -&gt; Rectangle {
        Rectangle {
            largeur: cote,
            hauteur: cote
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mon_carre = Rectangle::carre(3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. We‚Äôll discuss modules in Chapter 7.
-->
<p>Pour appeler cette fonction associ√©e, on utilise la syntaxe <code>::</code> avec le nom de
la structure¬†; <code>let mon_carre = Rectangle::carre(3);</code> en est un exemple. Cette
fonction est cloisonn√©e dans l'espace de noms de la structure¬†: la syntaxe <code>::</code>
s'utilise aussi bien pour les fonctions associ√©es que pour les espaces de noms
cr√©√©s par des modules. Nous aborderons les modules au chapitre 7.</p>
<!--
### Multiple `impl` Blocks
-->
<h3 id="plusieurs-blocs-impl"><a class="header" href="#plusieurs-blocs-impl">Plusieurs blocs <code>impl</code></a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>Chaque structure peut avoir plusieurs blocs <code>impl</code>. Par exemple, l'encart 5-15
est √©quivalent au code de l'encart 5-16, o√π chaque m√©thode est dans son propre
bloc <code>impl</code>.</p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

impl Rectangle {
    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2¬†? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3¬†? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">Encart 5-16¬†: R√©√©criture de l'encart 5-15 en utilisant
plusieurs blocs <code>impl</code></span></p>
<!--
There‚Äôs no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. We‚Äôll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>Il n'y a aucune raison de s√©parer ces m√©thodes dans plusieurs blocs <code>impl</code> dans
notre exemple, mais c'est une syntaxe valide. Nous verrons un exemple de
l'utilit√© d'avoir plusieurs blocs <code>impl</code> au chapitre 10, o√π nous aborderons les
types g√©n√©riques et les traits.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-4"><a class="header" href="#r√©sum√©-4">R√©sum√©</a></h2>
<!--
Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In `impl` blocks, you can define
functions that are associated with your type, and methods are a kind of
associated function that let you specify the behavior that instances of your
structs have.
-->
<p>Les structures vous permettent de cr√©er des types personnalis√©s significatifs
pour votre domaine. En utilisant des structures, on peut relier entre elles
des donn√©es associ√©es et nommer chaque donn√©e pour rendre le code plus clair.
Dans des blocs <code>impl</code>, vous pouvez d√©finir des fonctions qui sont associ√©es √†
votre type, et les m√©thodes sont un genre de fonction associ√©e qui vous permet
de renseigner le comportement que doivent suivre les instances de votre
structure.</p>
<!--
But structs aren‚Äôt the only way you can create custom types: let‚Äôs turn to
Rust‚Äôs enum feature to add another tool to your toolbox.
-->
<p>Mais les structures ne sont pas le seul moyen de cr√©er des types personnalis√©s¬†:
nous allons maintenant voir les √©num√©rations de Rust, une fonctionnalit√© que
vous pourrez bient√¥t ajouter √† votre bo√Æte √† outils.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Enums and Pattern Matching
-->
<h1 id="les-√©num√©rations-et-le-filtrage-par-motif"><a class="header" href="#les-√©num√©rations-et-le-filtrage-par-motif">Les √©num√©rations et le filtrage par motif</a></h1>
<!--
In this chapter we‚Äôll look at *enumerations*, also referred to as *enums*.
Enums allow you to define a type by enumerating its possible *variants*. First,
we‚Äôll define and use an enum to show how an enum can encode meaning along with
data. Next, we‚Äôll explore a particularly useful enum, called `Option`, which
expresses that a value can be either something or nothing. Then we‚Äôll look at
how pattern matching in the `match` expression makes it easy to run different
code for different values of an enum. Finally, we‚Äôll cover how the `if let`
construct is another convenient and concise idiom available to handle enums in
your code.
-->
<p>Dans ce chapitre, nous allons aborder les <em>√©num√©rations</em>, aussi appel√©es
<em>enums</em>. Les √©num√©rations vous permettent de d√©finir un type en √©num√©rant ses
<em>variantes</em> possibles. Pour commencer, nous allons d√©finir et utiliser une
√©num√©ration pour voir comment une √©num√©ration peut donner du sens aux donn√©es.
Ensuite, nous examinerons une √©num√©ration particuli√®rement utile qui s'appelle
<code>Option</code> et qui permet de d√©crire des situations o√π la valeur peut √™tre soit
quelque chose, soit rien. Ensuite, nous regarderons comment le filtrage par
motif avec l'expression <code>match</code> peut faciliter l'ex√©cution de codes diff√©rents
pour chaque valeur d'une √©num√©ration. Enfin, nous analyserons pourquoi la
construction <code>if let</code> est un autre outil commode et concis √† disposition pour
traiter les √©num√©rations dans votre code.</p>
<!--
Enums are a feature in many languages, but their capabilities differ in each
language. Rust‚Äôs enums are most similar to *algebraic data types* in functional
languages, such as F#, OCaml, and Haskell.
-->
<p>Les √©num√©rations sont des fonctionnalit√©s pr√©sentes dans de nombreux langages,
mais leurs aptitudes varient d'un langage √† l'autre. Les √©num√©rations de Rust
sont plus proches des <em>types de donn√©es alg√©briques</em> des langages fonctionnels,
comme F#, OCaml et Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining an Enum
-->
<h2 id="d√©finir-une-√©num√©ration"><a class="header" href="#d√©finir-une-√©num√©ration">D√©finir une √©num√©ration</a></h2>
<!--
Enums are a way of defining custom data types in a different way than you do
with structs. Let‚Äôs look at a situation we might want to express in code and
see why enums are useful and more appropriate than structs in this case. Say we
need to work with IP addresses. Currently, two major standards are used for IP
addresses: version four and version six. Because these are the only
possibilities for an IP address that our program will come across, we can
*enumerate* all possible variants, which is where enumeration gets its name.
-->
<p>Les √©num√©rations permettent de d√©finir des types de donn√©es personnalis√©s de
mani√®re diff√©rente que vous l'avez fait avec les structures. Imaginons une
situation que nous voudrions exprimer avec du code et regardons pourquoi les
√©num√©rations sont utiles et plus appropri√©es que les structures dans ce cas.
Disons que nous avons besoin de travailler avec des adresses IP. Pour le
moment, il existe deux normes principales pour les adresses IP¬†: la version
quatre et la version six. Comme ce seront les seules possibilit√©s d'adresse IP
que notre programme va rencontrer, nous pouvons <em>√©num√©rer</em> toutes les variantes
possibles, d'o√π vient le nom de l'√©num√©ration.</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because an enum value can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>N'importe quelle adresse IP peut √™tre soit une adresse en version quatre, soit
en version six, mais pas les deux en m√™me temps. Cette propri√©t√© des adresses
IP est appropri√©e √† la structure de donn√©es d'√©num√©rations, car une valeur de
l'√©num√©ration ne peut √™tre qu'une de ses variantes. Les adresses en version
quatre et six sont toujours fondamentalement des adresses IP, donc elles
doivent √™tre trait√©es comme √©tant du m√™me type lorsque le code travaille avec
des situations qui s'appliquent √† n'importe quelle sorte d'adresse IP.</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are the
variants of the enum:
-->
<p>Nous pouvons exprimer ce concept dans le code en d√©finissant une √©num√©ration
<code>SorteAdresseIp</code> et en listant les diff√©rentes sortes possibles d'adresses IP
qu'elle peut avoir, <code>V4</code> et <code>V6</code>. Ce sont les variantes de l'√©num√©ration¬†:</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum SorteAdresseIp {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p><code>SorteAdresseIp</code> est maintenant un type de donn√©es personnalis√© que nous pouvons
utiliser n'importe o√π dans notre code.</p>
<!--
### Enum Values
-->
<h3 id="les-valeurs-d√©num√©rations"><a class="header" href="#les-valeurs-d√©num√©rations">Les valeurs d'√©num√©rations</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>Nous pouvons cr√©er des instances de chacune des deux variantes de
<code>SorteAdresseIp</code> de cette mani√®re¬†:</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let quatre = SorteAdresseIp::V4;
    let six = SorteAdresseIp::V6;
<span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. This is useful because now both values
`IpAddrKind::V4` and `IpAddrKind::V6` are of the same type: `IpAddrKind`. We
can then, for instance, define a function that takes any `IpAddrKind`:
-->
<p>Remarquez que les variantes de l'√©num√©ration sont dans un espace de nom qui se
situe avant leur nom, et nous utilisons un double deux-points pour les s√©parer
tous les deux. C'est utile car maintenant les deux valeurs <code>SorteAdresseIp::V4</code>
et <code>SorteAdresseIp::V6</code> sont du m√™me type¬†: <code>SorteAdresseIp</code>. Ensuite, nous
pouvons, par exemple, d√©finir une fonction qui accepte n'importe quelle
<code>SorteAdresseIp</code>¬†:</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn router(sorte_ip: SorteAdresseIp) { }
</code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>Et nous pouvons appeler cette fonction avec chacune des variantes¬†:</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span>    router(SorteAdresseIp::V4);
    router(SorteAdresseIp::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don‚Äôt have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might be tempted to tackle this problem with structs as shown in
Listing 6-1.
-->
<p>L'utilisation des √©num√©rations a encore plus d'avantages. En √©tudiant un peu
plus notre type d'adresse IP, nous constatons que pour le moment, nous ne
pouvons pas stocker <em>la donn√©e</em> de l'adresse IP¬†; nous savons seulement de
quelle sorte elle est. Avec ce que vous avez appris au chapitre 5, vous
pourriez √™tre tent√© de r√©soudre ce probl√®me avec des structures comme dans
l'encart 6-1.</p>
<!--
```rust
# fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SorteAdresseIp {
        V4,
        V6,
    }

    struct AdresseIp {
        sorte: SorteAdresseIp,
        adresse: String,
    }

    let local = AdresseIp {
        sorte: SorteAdresseIp::V4,
        adresse: String::from(&quot;127.0.0.1&quot;),
    };
    
    let rebouclage = AdresseIp {
        sorte: SorteAdresseIp::V6,
        adresse: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">Encart 6-1¬†: Stockage de la donn√©e et de la variante de
<code>SorteAdresseIp</code> d'une adresse IP en utilisant une <code>struct</code></span></p>
<!--
Here, we‚Äôve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first is `home`,
and it has the value `IpAddrKind::V4` as its `kind` with associated address
data of `127.0.0.1`. The second instance is `loopback`. It has the other
variant of `IpAddrKind` as its `kind` value, `V6`, and has address `::1`
associated with it. We‚Äôve used a struct to bundle the `kind` and `address`
values together, so now the variant is associated with the value.
-->
<p>Ainsi, nous avons d√©fini une structure <code>AdresseIp</code> qui a deux champs¬†: un champ
<code>sorte</code> qui est du type <code>SorteAdresseIp</code> (l'√©num√©ration que nous avons d√©finie
pr√©c√©demment) et un champ <code>adresse</code> qui est du type <code>String</code>. Nous avons deux
instances de cette structure. La premi√®re est <code>local</code>, et a la valeur
<code>SorteAdresseIp::V4</code> pour son champ <code>sorte</code>, associ√© √† la donn√©e d'adresse qui
est <code>127.0.0.1</code>. La seconde instance est <code>rebouclage</code>. Elle a comme valeur de
champ <code>sorte</code> l'autre variante de <code>SorteAdresseIp</code>, <code>V6</code>, et a l'adresse<code>::1</code>
qui lui est associ√©e. Nous avons utilis√© une structure pour relier ensemble la
<code>sorte</code> et l'<code>adresse</code>, donc maintenant la variante est li√©e √† la valeur.</p>
<!--
However, representing the same concept using just an enum is more concise:
rather than an enum inside a struct, we can put data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>Cependant, suivre le m√™me principe en utilisant uniquement une √©num√©ration est
plus concis¬†: plut√¥t que d'utiliser une √©num√©ration dans une structure, nous
pouvons ins√©rer directement la donn√©e dans chaque variante de l'√©num√©ration.
Cette nouvelle d√©finition de l'√©num√©ration <code>AdresseIp</code> indique que chacune des
variantes <code>V4</code> et <code>V6</code> auront des valeurs associ√©es de type <code>String</code>¬†:</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(String),
        V6(String),
    }
    
    let local = AdresseIp::V4(String::from(&quot;127.0.0.1&quot;));
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct. Here it‚Äôs also easier to see another detail of how enums work:
the name of each enum variant that we define also becomes a function that
constructs an instance of the enum. That is, `IpAddr::V4()` is a function call
that takes a `String` argument and returns an instance of the `IpAddr` type. We
automatically get this constructor function defined as a result of defining the
enum.
-->
<p>Nous relions les donn√©es de chaque variante directement √† l'√©num√©ration, donc il
n'est pas n√©cessaire d'avoir une structure en plus. Ceci nous permet de voir
plus facilement un d√©tail de fonctionnement des √©num√©rations¬†: le nom de chaque
variante d'√©num√©ration que nous d√©finissons devient aussi une fonction qui
construit une instance de l'√©num√©ration. Ainsi, <code>AdresseIp::V4()</code> est un appel
de fonction qui prend une <code>String</code> en argument et qui retourne une instance du
type <code>AdresseIp</code>. Nous obtenons automatiquement cette fonction de constructeur
qui est d√©finie lorsque nous d√©finissons l'√©num√©ration.</p>
<!--
There‚Äôs another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldn‚Äôt be able to with
a struct. Enums handle this case with ease:
-->
<p>Il y a un autre avantage √† utiliser une √©num√©ration plut√¥t qu'une structure¬†:
chaque variante peut stocker des types diff√©rents, et aussi avoir une quantit√©
diff√©rente de donn√©es associ√©es. Les adresses IP version quatre vont toujours
avoir quatre composantes num√©riques qui auront une valeur entre 0 et 255. Si
nous voulions stocker les adresses <code>V4</code> avec quatre valeurs de type <code>u8</code> mais
continuer √† stocker les adresses <code>V6</code> dans une <code>String</code>, nous ne pourrions pas
le faire avec une structure. Les √©num√©rations permettent de faire cela
facilement¬†:</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    
    let local = AdresseIp::V4(127, 0, 0, 1);
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We‚Äôve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr]<!-- ignore -- > Let‚Äôs look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
we‚Äôve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>Nous avons vu diff√©rentes mani√®res de d√©finir des structures de donn√©es pour
enregistrer des adresses IP en version quatre et version six. Cependant, il
s'av√®re que vouloir stocker des adresses IP et identifier de quelle sorte elles
sont est si fr√©quent que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la biblioth√®que standard a une d√©finition que nous
pouvons utiliser¬†!</a><!-- ignore --> Analysons comment la biblioth√®que
standard a d√©fini <code>IpAddr</code> (l'√©quivalent de notre <code>AdresseIp</code>)¬†: nous retrouvons
la m√™me √©num√©ration et les variantes que nous avons d√©finies et utilis√©es, mais
stocke les donn√©es d'adresse dans des variantes dans deux structures
diff√©rentes, qui sont d√©finies chacune pour chaque variante¬†:</p>
<!--
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // -- code masqu√© ici --
}

struct Ipv6Addr {
    // -- code masqu√© ici --
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>Ce code montre comment vous pouvez ins√©rer n'importe quel type de donn√©es dans
une variante d'√©num√©ration¬†: des cha√Ænes de caract√®res, des nombres ou des
structures, par exemple. Vous pouvez m√™me y int√©grer d'autres √©num√©rations¬†! Par
ailleurs, les types de la biblioth√®que standard ne sont parfois pas plus
compliqu√©s que ce que vous pourriez inventer.</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
haven‚Äôt brought the standard library‚Äôs definition into our scope. We‚Äôll talk
more about bringing types into scope in Chapter 7.
-->
<p>Notez aussi que m√™me si la biblioth√®que standard embarque une d√©finition de
<code>IpAddr</code>, nous pouvons quand m√™me cr√©er et utiliser notre propre d√©finition de
ce type sans avoir de conflit de nom car nous n'avons pas import√© cette
d√©finition de la biblioth√®que standard dans la port√©e. Nous verrons plus en
d√©tail comment importer les types dans la port√©e au chapitre 7.</p>
<!--
Let‚Äôs look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>Analysons un autre exemple d'une √©num√©ration dans l'encart 6-2¬†: celle-ci a une
grande diversit√© de types dans ses variantes.</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">Encart 6-2¬†: Une √©num√©ration <code>Message</code> dont chaque
variante stocke des valeurs de diff√©rents types et en diff√©rentes
quantit√©s</span></p>
<!--
This enum has four variants with different types:
-->
<p>Cette √©num√©ration a quatre variantes avec des types diff√©rents¬†:</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` has named fields like a struct does.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quitter</code> n'a pas du tout de donn√©e associ√©e.</li>
<li><code>Deplacer</code> int√®gre une structure anonyme en son sein.</li>
<li><code>Ecrire</code> int√®gre une seule <code>String</code>.</li>
<li><code>ChangerCouleur</code> int√®gre trois valeurs de type <code>i32</code>.</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn‚Äôt use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>D√©finir une √©num√©ration avec des variantes comme celles dans l'encart 6-2
ressemble √† la d√©finition de diff√©rentes sortes de structures, sauf que
l'√©num√©ration n'utilise pas le mot-cl√© <code>struct</code> et que toutes les variantes sont
regroup√©es ensemble sous le type <code>Message</code>. Les structures suivantes peuvent
stocker les m√™mes donn√©es que celles stock√©es par les variantes pr√©c√©dentes¬†:</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MessageQuitter; // une structure unit√©
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldn‚Äôt as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<p>Mais si nous utilisions les diff√©rentes structures, qui ont chacune leur propre
type, nous ne pourrions pas d√©finir facilement une fonction qui prend en
param√®tre toutes les sortes de messages, tel que nous pourrions le faire avec
l'√©num√©ration <code>Message</code> que nous avons d√©finie dans l'encart 6-2, qui est un
seul type.</p>
<!--
There is one more similarity between enums and structs: just as we‚Äôre able to
define methods on structs using `impl`, we‚Äôre also able to define methods on
enums. Here‚Äôs a method named `call` that we could define on our `Message` enum:
-->
<p>Il y a un autre point commun entre les √©num√©rations et les structures¬†: tout
comme on peut d√©finir des m√©thodes sur les structures en utilisant <code>impl</code>, on
peut aussi d√©finir des m√©thodes sur des √©num√©rations. Voici une m√©thode appel√©e
<code>appeler</code> que nous pouvons d√©finir sur notre √©num√©ration <code>Message</code>¬†:</p>
<!--
```rust
# fn main() {
#     enum Message {
#         Quit,
#         Move { x: i32, y: i32 },
#         Write(String),
#         ChangeColor(i32, i32, i32),
#     }
# 
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quitter,
</span><span class="boring">        Deplacer { x: i32, y: i32 },
</span><span class="boring">        Ecrire(String),
</span><span class="boring">        ChangerCouleur(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn appeler(&amp;self) {
            // le corps de la m√©thode sera d√©fini ici
        }
    }
    
    let m = Message::Ecrire(String::from(&quot;hello&quot;));
    m.appeler();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, we‚Äôve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>Le corps de la m√©thode va utiliser <code>self</code> pour obtenir la valeur sur laquelle
nous avons utilis√© la m√©thode. Dans cet exemple, nous avons cr√©√© une variable
<code>m</code> qui a la valeur <code>Message::Ecrire(String::from(&quot;hello&quot;))</code>, et cela sera ce
que <code>self</code> aura comme valeur dans le corps de la m√©thode <code>appeler</code> quand nous
lancerons <code>m.appeler()</code>.</p>
<!--
Let‚Äôs look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>Regardons maintenant une autre √©num√©ration de la biblioth√®que standard qui est
tr√®s utilis√©e et utile¬†: <code>Option</code>.</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3 id="l√©num√©ration-option-et-ses-avantages-par-rapport-√†-la-valeur-null"><a class="header" href="#l√©num√©ration-option-et-ses-avantages-par-rapport-√†-la-valeur-null">L'√©num√©ration <code>Option</code> et ses avantages par rapport √† la valeur null</a></h3>
<!--
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type encodes the very common scenario in
which a value could be something or it could be nothing. For example, if you
request the first of a list containing items, you would get a value. If you
request the first item of an empty list, you would get nothing. Expressing this
concept in terms of the type system means the compiler can check whether you‚Äôve
handled all the cases you should be handling; this functionality can prevent
bugs that are extremely common in other programming languages.
-->
<p>Cette section √©tudie le cas de <code>Option</code>, qui est une autre √©num√©ration d√©finie
dans la biblioth√®que standard. Le type <code>Option</code> d√©crit un sc√©nario tr√®s courant
o√π une valeur peut √™tre soit quelque chose, soit rien du tout. Par exemple, si
vous demandez le premier √©l√©ment dans une liste non vide, vous devriez obtenir
une valeur. Si vous demandez le premier √©l√©ment d'une liste vide, vous ne
devriez rien obtenir. Exprimer ce concept avec le syst√®me de types implique que
le compilateur peut v√©rifier si vous avez g√©r√© tous les cas que vous pourriez
rencontrer¬†; cette fonctionnalit√© peut √©viter des bogues qui sont tr√®s courants
dans d'autres langages de programmation.</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn‚Äôt have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>La conception d'un langage de programmation est souvent pens√©e en fonction des
fonctionnalit√©s qu'on inclut, mais les fonctionnalit√©s qu'on refuse sont elles
aussi importantes. Rust n'a pas de fonctionnalit√© <em>null</em> qu'ont de nombreux
langages. <em>Null</em> est une valeur qui signifie qu'il n'y a pas de valeur √† cet
endroit. Avec les langages qui utilisent null, les variables peuvent toujours
√™tre dans deux √©tats¬†: null ou non null.</p>
<!--
In his 2009 presentation ‚ÄúNull References: The Billion Dollar Mistake,‚Äù Tony
Hoare, the inventor of null, has this to say:
-->
<p>Dans sa th√®se de 2009 ‚ÄúNull References: The Billion Dollar Mistake‚Äù (les
r√©f√©rences nulles¬†: l'erreur √† un milliard de dollars), Tony Hoare, l'inventeur
de null, a √©crit ceci¬†:</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldn‚Äôt resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>Je l'appelle mon erreur √† un milliard de dollars. √Ä cette √©poque, je concevais
le premier syst√®me de type complet pour des r√©f√©rences dans un langage orient√©
objet. Mon objectif √©tait de garantir que toutes les utilisations des
r√©f√©rences soient totalement s√ªres, et soient v√©rifi√©es automatiquement par le
compilateur. Mais je n'ai pas pu r√©sister √† la tentation d'inclure la
r√©f√©rence nulle, simplement parce que c'√©tait si simple √† impl√©menter. Cela a
conduit √† d'innombrables erreurs, vuln√©rabilit√©s, et pannes syst√®mes, qui ont
probablement caus√© un milliard de dollars de dommages au cours des quarante
derni√®res ann√©es.</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, you‚Äôll get an error of some kind. Because this null or not-null
property is pervasive, it‚Äôs extremely easy to make this kind of error.
-->
<p>Le probl√®me avec les valeurs nulles, c'est que si vous essayez d'utiliser une
valeur nulle comme si elle n'√©tait pas nulle, vous obtiendrez une erreur d'une
fa√ßon ou d'une autre. Comme cette propri√©t√© nulle ou non nulle est omnipr√©sente,
il est tr√®s facile de faire cette erreur.</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>Cependant, le concept que null essaye d'exprimer reste utile¬†: une valeur nulle
est une valeur qui est actuellement invalide ou absente pour une raison ou une
autre.</p>
<!--
The problem isn‚Äôt really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]<!-- ignore -- >
as follows:
-->
<p>Le probl√®me ne vient pas vraiment du concept, mais de son impl√©mentation. C'est
pourquoi Rust n'a pas de valeurs nulles, mais il a une √©num√©ration qui d√©crit le
concept d'une valeur qui peut √™tre soit pr√©sente, soit absente. Cette
√©num√©ration est <code>Option&lt;T&gt;</code>, et elle est <a href="https://doc.rust-lang.org/std/option/enum.Option.html">d√©finie dans la biblioth√®que
standard</a><!-- ignore --> comme ci-dessous¬†:</p>
<!--
```rust
enum Option<T> {
    None,
    Some(T),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that it‚Äôs even included in the prelude; you
don‚Äôt need to bring it into scope explicitly. Its variants are also included in
the prelude: you can use `Some` and `None` directly without the `Option::`
prefix. The `Option<T>` enum is still just a regular enum, and `Some(T)` and
`None` are still variants of type `Option<T>`.
-->
<p>L'√©num√©ration <code>Option&lt;T&gt;</code> est tellement utile qu'elle est int√©gr√©e dans l'√©tape
pr√©liminaire¬†; vous n'avez pas besoin de l'importer explicitement dans la
port√©e. Ses variantes sont aussi int√©gr√©es dans l'√©tape pr√©liminaire¬†: vous
pouvez utiliser directement <code>Some</code> (<em>quelque chose</em>) et <code>None</code> (<em>rien</em>) sans
les pr√©fixer par <code>Option::</code>. L'√©num√©ration <code>Option&lt;T&gt;</code> reste une √©num√©ration
normale, et <code>Some(T)</code> ainsi que <code>None</code> sont toujours des variantes de type
<code>Option&lt;T&gt;</code>.</p>
<!--
The `<T>` syntax is a feature of Rust we haven‚Äôt talked about yet. It‚Äôs a
generic type parameter, and we‚Äôll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type, and that each concrete
type that gets used in place of `T` makes the overall `Option<T>` type a
different type. Here are some examples of using `Option` values to hold number
types and string types:
-->
<p>La syntaxe <code>&lt;T&gt;</code> est une fonctionnalit√© de Rust que nous n'avons pas encore
abord√©e. Il s'agit d'un param√®tre de type g√©n√©rique, et nous verrons la
g√©n√©ricit√© plus en d√©tail au chapitre 10. Pour le moment, dites-vous que ce
<code>&lt;T&gt;</code> signifie que la variante <code>Some</code> de l'√©num√©ration <code>Option</code> peut stocker un
√©l√©ment de donn√©e de n'importe quel type, et que chaque type concret qui est
utilis√© √† la place du <code>T</code> transforme tout le type <code>Option&lt;T&gt;</code> en un type
diff√©rent. Voici quelques exemples d'utilisation de valeurs de <code>Option</code> pour
stocker des types de nombres et des types de cha√Ænes de caract√®res¬†:</p>
<!--
```rust
# fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let un_nombre = Some(5);
    let une_chaine = Some(&quot;une cha√Æne&quot;);

    let nombre_absent: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `some_number` is `Option<i32>`. The type of `some_string` is
`Option<&str>`, which is a different type. Rust can infer these types because
we‚Äôve specified a value inside the `Some` variant. For `absent_number`, Rust
requires us to annotate the overall `Option` type: the compiler can‚Äôt infer the
type that the corresponding `Some` variant will hold by looking only at a
`None` value. Here, we tell Rust that we mean for `absent_number` to be of type
`Option<i32>`.
-->
<p>La variable <code>un_nombre</code> est du type <code>Option&lt;i32&gt;</code>. Mais la variable <code>une_chaine</code>
est du type <code>Option&lt;&amp;str&gt;</code>, qui est un tout autre type. Rust peut d√©duire ces
types car nous avons renseign√© une valeur dans la variante <code>Some</code>. Pour
<code>nombre_absent</code>, Rust n√©cessite que nous annotions le type de tout le <code>Option</code>¬†:
le compilateur ne peut pas d√©duire le type qui devrait √™tre stock√© dans la
variante <code>Some</code> √† partir de la valeur <code>None</code>. Ici, nous avons renseign√© √† Rust
que nous voulions que <code>nombre_absent</code> soit du type <code>Option&lt;i32&gt;</code>.</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we don‚Äôt have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p>Lorsque nous avons une valeur <code>Some</code>, nous savons que la valeur est pr√©sente et
que la valeur est stock√©e dans le <code>Some</code>. Lorsque nous avons une valeur <code>None</code>,
en quelque sorte, cela veut dire la m√™me chose que null¬†: nous n'avons pas une
valeur valide. Donc pourquoi obtenir <code>Option&lt;T&gt;</code> est meilleur que d'avoir null¬†?</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler won‚Äôt let us use an `Option<T>` value as if it were
definitely a valid value. For example, this code won‚Äôt compile because it‚Äôs
trying to add an `i8` to an `Option<i8>`:
-->
<p>En bref, comme <code>Option&lt;T&gt;</code> et <code>T</code> (o√π <code>T</code> repr√©sente n'importe quel type) sont
de types diff√©rents, le compilateur ne va pas nous autoriser √† utiliser une
valeur <code>Option&lt;T&gt;</code> comme si cela √©tait bien une valeur valide. Par exemple, le
code suivant ne se compile pas car il essaye d'additionner un <code>i8</code> et une
<code>Option&lt;i8&gt;</code>¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let somme = x + y;
<span class="boring">}
</span></code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>Si nous lan√ßons ce code, nous aurons un message d'erreur comme celui-ci¬†:</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 -- > src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let somme = x + y;
  |                   ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesn‚Äôt understand how
to add an `i8` and an `Option<i8>`, because they‚Äôre different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value we‚Äôre working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>Intense¬†! Effectivement, ce message d'erreur signifie que Rust ne comprend pas
comment additionner un <code>i8</code> et une <code>Option&lt;i8&gt;</code>, car ils sont de types
diff√©rents. Quand nous avons une valeur d'un type comme <code>i8</code> avec Rust, le
compilateur va s'assurer que nous avons toujours une valeur valide. Nous pouvons
continuer en toute confiance sans avoir √† v√©rifier que cette valeur n'est pas
nulle avant de l'utiliser. Ce n'est que lorsque nous avons une <code>Option&lt;i8&gt;</code> (ou
tout autre type de valeur avec lequel nous travaillons) que nous devons nous
inqui√©ter de ne pas avoir de valeur, et le compilateur va s'assurer que nous
g√©rons ce cas avant d'utiliser la valeur.</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn‚Äôt null when it actually
is.
-->
<p>Autrement dit, vous devez convertir une <code>Option&lt;T&gt;</code> en <code>T</code> pour pouvoir faire
avec elle des op√©rations du type <code>T</code>. G√©n√©ralement, cela permet de r√©soudre l'un
des probl√®mes les plus courants avec null¬†: supposer qu'une valeur n'est pas
nulle alors qu'en r√©alit√©, elle l'est.</p>
<!--
Eliminating the risk of incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn‚Äôt an
`Option<T>`, you *can* safely assume that the value isn‚Äôt null. This was a
deliberate design decision for Rust to limit null‚Äôs pervasiveness and increase
the safety of Rust code.
-->
<p>Eliminer le risque que des valeurs nulles puissent √™tre mal g√©r√©es vous aide √†
√™tre plus confiant en votre code. Pour avoir une valeur qui peut
potentiellement √™tre nulle, vous devez l'indiquer explicitement en d√©clarant
que le type de cette valeur est <code>Option&lt;T&gt;</code>. Ensuite, quand vous utiliserez
cette valeur, il vous faudra g√©rer explicitement le cas o√π cette valeur est
nulle. Si vous utilisez une valeur qui n'est pas une <code>Option&lt;T&gt;</code>, alors vous
<em>pouvez</em> consid√©rer que cette valeur ne sera jamais nulle sans prendre de
risques. Il s'agit d'un choix de conception d√©lib√©r√© de Rust pour limiter
l'omnipr√©sence de null et augmenter la s√©curit√© du code en Rust.</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]<!-- ignore -- >. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>Donc, comment r√©cup√©rer la valeur de type <code>T</code> d'une variante <code>Some</code> quand vous
avez une valeur de type <code>Option&lt;T&gt;</code> afin de l'utiliser¬†? L'√©num√©ration
<code>Option&lt;T&gt;</code> a un large choix de m√©thodes qui sont plus ou moins utiles selon les
cas¬†; vous pouvez les d√©couvrir dans <a href="https://doc.rust-lang.org/std/option/enum.Option.html">sa documentation</a><!-- ignore -->. Se
familiariser avec les m√©thodes de <code>Option&lt;T&gt;</code> peut √™tre tr√®s utile dans votre
aventure avec Rust.</p>
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. You want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. You want some
other code to run if you have a `None` value, and that code doesn‚Äôt have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>De mani√®re g√©n√©rale, pour pouvoir utiliser une valeur de <code>Option&lt;T&gt;</code>, votre code
doit g√©rer chaque variante. On veut que du code soit ex√©cut√© uniquement quand on
a une valeur <code>Some(T)</code>, et que ce code soit autoris√© √† utiliser la valeur de
type <code>T</code> √† l'int√©rieur. On veut aussi qu'un autre code soit ex√©cut√© si on a une
valeur <code>None</code>, et ce code n'aura pas de valeur de type <code>T</code> de disponible.
L'expression <code>match</code> est une structure de contr√¥le qui fait bien ceci
lorsqu'elle est utilis√©e avec les √©num√©rations¬†: elle va ex√©cuter du code
diff√©rent en fonction de quelle variante de l'√©num√©ration elle obtient, et ce
code pourra utiliser la donn√©e pr√©sente dans la valeur correspondante.</p>
<!--
[IpAddr]: ../std/net/enum.IpAddr.html
[option]: ../std/option/enum.Option.html
[docs]: ../std/option/enum.Option.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
<a id="the-match-control-flow-operator"></a>
## The `match` Control Flow Construct
-->
<p><a id="la-structure-de-contr√¥le-match"></a></p>
<h2 id="la-structure-de-contr√¥le-de-flux-match"><a class="header" href="#la-structure-de-contr√¥le-de-flux-match">La structure de contr√¥le de flux <code>match</code></a></h2>
<!--
Rust has an extremely powerful control flow construct called `match` that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rust a une structure de contr√¥le de flux tr√®s puissante appel√©e <code>match</code> qui vous
permet de comparer une valeur avec une s√©rie de motifs et d'ex√©cuter du code en
fonction du motif qui correspond. Les motifs peuvent √™tre constitu√©s de valeurs
litt√©rales, de noms de variables, de jokers, parmi tant d'autres¬†; le
chapitre 18 va couvrir tous les diff√©rents types de motifs et ce qu'ils font. Ce
qui fait la puissance de <code>match</code> est l'expressivit√© des motifs et le fait que le
compilateur v√©rifie que tous les cas possibles sont bien g√©r√©s.</p>
<!--
Think of a `match` expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value ‚Äúfits,‚Äù
the value falls into the associated code block to be used during execution.
Speaking of coins, let‚Äôs use them as an example using `match`! We can write a
function that takes an unknown United States coin and, in a similar way as the
counting machine, determines which coin it is and return its value in cents, as
shown here in Listing 6-3.
-->
<p>Consid√©rez l'expression <code>match</code> comme une machine √† trier les pi√®ces de
monnaie¬†: les pi√®ces descendent le long d'une piste avec des trous de tailles
diff√©rentes, et chaque pi√®ce tombe dans le premier trou √† sa taille qu'elle
rencontre. De mani√®re similaire, les valeurs parcourent tous les motifs dans un
<code>match</code>, et au premier motif auquel la valeur ‚Äúcorrespond‚Äù, la valeur va
descendre dans le bloc de code correspondant afin d'√™tre utilis√©e pendant son
ex√©cution. En parlant des pi√®ces, utilisons-les avec un exemple qui utilise
<code>match</code>¬†! Nous pouvons √©crire une fonction qui prend en param√®tre une pi√®ce
inconnue des √âtats-Unis d'Am√©rique et qui peut, de la m√™me mani√®re qu'une
machine √† trier, d√©terminer quelle pi√®ce c'est et retourner sa valeur en
centimes, comme ci-dessous dans l'encart 6-3.</p>
<!--
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum PieceUs {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; 1,
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns</span>
-->
<p><span class="caption">Encart 6-3¬†: Une √©num√©ration et une expression <code>match</code> qui
trie les variantes de l'√©num√©ration dans ses motifs</span></p>
<!--
Let‚Äôs break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but there‚Äôs a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can return any type. The type of `coin` in this example is the `Coin`
enum that we defined on the first line.
-->
<p>D√©composons le <code>match</code> dans la fonction <code>valeur_en_centimes</code>. En premier lieu,
nous utilisons le mot-cl√© <code>match</code> suivi par une expression, qui dans notre cas
est la valeur de <code>piece</code>. Cela ressemble beaucoup √† une expression utilis√©e avec
<code>if</code>, mais il y a une grosse diff√©rence¬†: avec <code>if</code>, l'expression doit retourner
une valeur bool√©enne, mais ici, elle retourne n'importe quel type. Dans cet
exemple, <code>piece</code> est de type <code>PieceUs</code>, qui est l'√©num√©ration que nous avons
d√©finie √† la premi√®re ligne.</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>Ensuite, nous avons les branches du <code>match</code>. Une branche a deux parties¬†: un
motif et du code. La premi√®re branche a ici pour motif la valeur
<code>PieceUs::Penny</code> et ensuite l'op√©rateur <code>=&gt;</code> qui s√©pare le motif et le code √†
ex√©cuter. Le code dans ce cas est uniquement la valeur <code>1</code>. Chaque branche est
s√©par√©e de la suivante par une virgule.</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn‚Äôt match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>Lorsqu'une expression <code>match</code> est ex√©cut√©e, elle compare la valeur de <code>piece</code>
avec le motif de chaque branche, dans l'ordre. Si un motif correspond √† la
valeur, le code correspondant √† ce motif est alors ex√©cut√©. Si ce motif ne
correspond pas √† la valeur, l'ex√©cution passe √† la prochaine branche, un peu
comme dans une machine de tri de pi√®ces. Nous pouvons avoir autant de branches
que n√©cessaire¬†: dans l'encart 6-3, notre <code>match</code> a quatre branches.</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>Le code correspondant √† chaque branche est une expression, et la valeur qui
r√©sulte de l'expression dans la branche correspondante est la valeur qui sera
retourn√©e par l'expression <code>match</code>.</p>
<!--
We don‚Äôt typically use curly brackets if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you must use curly brackets. For example, the
following code prints ‚ÄúLucky penny!‚Äù every time the method is called with a
`Coin::Penny`, but still returns the last value of the block, `1`:
-->
<p>Habituellement, nous n'utilisons pas les accolades si le code de la branche
correspondante est court, comme c'est le cas dans l'encart 6-3 o√π chaque
branche retourne simplement une valeur. Si vous voulez ex√©cuter plusieurs
lignes de code dans une branche d'un <code>match</code>, vous devez utiliser les
accolades. Par exemple, le code suivant va afficher ‚ÄúUn centime
porte-bonheur¬†!‚Äù √† chaque fois que la m√©thode est appel√©e avec une valeur
<code>PieceUs::Penny</code>, mais va continuer √† retourner la derni√®re valeur du
bloc, <code>1</code>¬†:</p>
<!--
```rust
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter,
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; {
            println!(&quot;Un centime porte-bonheur¬†!&quot;);
            1
        }
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3 id="des-motifs-reli√©s-√†-des-valeurs"><a class="header" href="#des-motifs-reli√©s-√†-des-valeurs">Des motifs reli√©s √† des valeurs</a></h3>
<!--
Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>Une autre fonctionnalit√© int√©ressante des branches de <code>match</code> est qu'elles
peuvent se lier aux valeurs qui correspondent au motif. C'est ainsi que nous
pouvons extraire des valeurs d'une variante d'√©num√©ration.</p>
<!--
As an example, let‚Äôs change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which we‚Äôve done here in Listing 6-4.
-->
<p>En guise d'exemple, changeons une de nos variantes d'√©num√©ration pour stocker
une donn√©e √† l'int√©rieur. Entre 1999 et 2008, les √âtats-Unis d'Am√©rique ont
frapp√© un c√¥t√© des <em>quarters</em> (pi√®ces de 25 centimes) avec des dessins
diff√©rents pour chacun des 50 √âtats. Les autres pi√®ces n'ont pas eu de dessins
d'√âtats, donc seul le <em>quarter</em> a cette valeur en plus. Nous pouvons ajouter
cette information √† notre <code>enum</code> en changeant la variante <code>Quarter</code> pour y
ajouter une valeur <code>EtatUs</code> qui y sera stock√©e √† l'int√©rieur, comme nous
l'avons fait dans l'encart 6-4.</p>
<!--
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // pour pouvoir afficher l'√âtat
enum EtatUs {
    Alabama,
    Alaska,
    // -- partie masqu√©e ici --
}

enum PieceUs {
    Penny,
    Nickel,
    Dime,
    Quarter(EtatUs),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">Encart 6-4¬†: Une √©num√©ration <code>PieceUs</code> dans laquelle la
variante <code>Quarter</code> stocke en plus une valeur de type <code>EtatUs</code></span></p>
<!--
Let‚Äôs imagine that a friend is trying to collect all 50 state quarters. While
we sort our loose change by coin type, we‚Äôll also call out the name of the
state associated with each quarter so if it‚Äôs one our friend doesn‚Äôt have, they
can add it to their collection.
-->
<p>Imaginons qu'un de vos amis essaye de collectionner tous les <em>quarters</em> des 50
√âtats. Pendant que nous trions notre monnaie en vrac par type de pi√®ce, nous
mentionnerons aussi le nom de l'√âtat correspondant √† chaque <em>quarter</em> de sorte
que si notre ami ne l'a pas, il puisse l'ajouter √† sa collection.</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarter‚Äôs state. Then we can use `state` in the code for that arm, like so:
-->
<p>Dans l'expression <code>match</code> de ce code, nous avons ajout√© une variable <code>etat</code> au
motif qui correspond √† la variante <code>PieceUs::Quarter</code>. Quand on aura une
correspondance <code>PieceUs::Quarter</code>, la variable <code>etat</code> sera li√©e √† la valeur de
l'√âtat de cette pi√®ce. Ensuite, nous pourrons utiliser <code>etat</code> dans le code de
cette branche, comme ceci¬†:</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
# 
# fn main() {
#     value_in_cents(Coin::Quarter(UsState::Alaska));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masqu√©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; 1,
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter(etat) =&gt; {
            println!(&quot;Il s'agit d'un quarter de l'√âtat de {:?}¬†!&quot;, etat);
            25
        },
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    valeur_en_centimes(PieceUs::Quarter(EtatUs::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p>Si nous appelons <code>valeur_en_centimes(PieceUs::Quarter(EtatUs::Alaska))</code>, <code>piece</code>
vaudra <code>PieceUs::Quarter(EtatUs::Alaska)</code>. Quand nous comparons cette valeur
avec toutes les branches du <code>match</code>, aucune d'entre elles ne correspondra
jusqu'√† ce qu'on arrive √† <code>PieceUs::Quarter(etat)</code>. √Ä partir de ce moment, la
variable <code>etat</code> aura la valeur <code>EtatUs::Alaska</code>. Nous pouvons alors utiliser
cette variable dans l'expression <code>println!</code>, ce qui nous permet d'afficher la
valeur de l'√âtat √† l'int√©rieur de la variante <code>Quarter</code> de l'√©num√©ration
<code>PieceUs</code>.</p>
<!--
### Matching with `Option<T>`
-->
<h3 id="utiliser-match-avec-optiont"><a class="header" href="#utiliser-match-avec-optiont">Utiliser <code>match</code> avec <code>Option&lt;T&gt;</code></a></h3>
<!--
In the previous section, we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, we‚Äôll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>Dans la section pr√©c√©dente, nous voulions obtenir la valeur interne <code>T</code> dans le
cas de <code>Some</code> lorsqu'on utilisait <code>Option&lt;T&gt;</code>¬†; nous pouvons aussi g√©rer les
<code>Option&lt;T&gt;</code> en utilisant <code>match</code> comme nous l'avons fait avec l'√©num√©ration
<code>PieceUs</code>¬†! Au lieu de comparer des pi√®ces, nous allons comparer les variantes
de <code>Option&lt;T&gt;</code>, mais la fa√ßon d'utiliser l'expression <code>match</code> reste la m√™me.</p>
<!--
Let‚Äôs say we want to write a function that takes an `Option<i32>` and, if
there‚Äôs a value inside, adds 1 to that value. If there isn‚Äôt a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p>Disons que nous voulons √©crire une fonction qui prend une <code>Option&lt;i32&gt;</code> et qui,
s'il y a une valeur √† l'int√©rieur, ajoute 1 √† cette valeur. S'il n'y a pas de
valeur √† l'int√©rieur, la fonction retournera la valeur <code>None</code> et ne va rien
faire de plus.</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p>Cette fonction est tr√®s facile √† √©crire, gr√¢ce √† <code>match</code>, et ressemblera √†
l'encart 6-5.</p>
<!--
```rust
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let cinq = Some(5);
    let six = plus_un(cinq);
    let none = plus_un(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">Encart 6-5¬†: Une fonction qui utilise une expression
<code>match</code> sur une <code>Option&lt;i32&gt;</code></span></p>
<!--
Let‚Äôs examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p>Examinons la premi√®re ex√©cution de <code>plus_un</code> en d√©tail. Lorsque nous appelons
<code>plus_un(cinq)</code>, la variable <code>x</code> dans le corps de <code>plus_un</code> aura la valeur
<code>Some(5)</code>. Ensuite, nous comparons cela √† chaque branche du <code>match</code>.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
The `Some(5)` value doesn‚Äôt match the pattern `None`, so we continue to the
next arm.
-->
<p>La valeur <code>Some(5)</code> ne correspond pas au motif <code>None</code>, donc nous continuons √† la
branche suivante.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
#             None => None,
            Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add 1 to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<p>Est-ce que <code>Some(5)</code> correspond au motif <code>Some(i)</code>¬†? Bien s√ªr¬†! Nous avons la
m√™me variante. Le <code>i</code> va prendre la valeur contenue dans le <code>Some</code>, donc <code>i</code>
prend la valeur <code>5</code>. Le code dans la branche du <code>match</code> est ex√©cut√©, donc nous
ajoutons 1 √† la valeur de <code>i</code> et nous cr√©ons une nouvelle valeur <code>Some</code> avec
notre r√©sultat <code>6</code> √† l'int√©rieur.</p>
<!--
Now let‚Äôs consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>Maintenant, regardons le second appel √† <code>plus_un</code> dans l'encart 6-5, o√π <code>x</code> vaut
<code>None</code>. Nous entrons dans le <code>match</code> et nous le comparons √† la premi√®re branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
It matches! There‚Äôs no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>Cela correspond¬†! Il n'y a pas de valeur √† additionner, donc le programme
s'arr√™te et retourne la valeur <code>None</code> qui est dans le c√¥t√© droit du <code>=&gt;</code>. Comme
la premi√®re branche correspond, les autres branches ne sont pas compar√©es.</p>
<!--
Combining `match` and enums is useful in many situations. You‚Äôll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. It‚Äôs a bit tricky at first, but
once you get used to it, you‚Äôll wish you had it in all languages. It‚Äôs
consistently a user favorite.
-->
<p>La combinaison de <code>match</code> et des √©num√©rations est utile dans de nombreuses
situations. Vous allez revoir de nombreuses fois ce sch√©ma dans du code Rust¬†:
utiliser <code>match</code> sur une √©num√©ration, r√©cup√©rer la valeur qu'elle renferme, et
ex√©cuter du code en fonction de sa valeur. C'est un peu d√©licat au d√©but, mais
une fois que vous vous y √™tes habitu√©, vous regretterez de ne pas l'avoir dans
les autres langages. Cela devient toujours l'outil pr√©f√©r√© de ses utilisateurs.</p>
<!--
### Matches Are Exhaustive
-->
<h3 id="les-match-sont-toujours-exhaustifs"><a class="header" href="#les-match-sont-toujours-exhaustifs">Les <code>match</code> sont toujours exhaustifs</a></h3>
<!--
There‚Äôs one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and won‚Äôt compile:
-->
<p>Il y a un autre point de <code>match</code> que nous devons aborder. Examinez cette version
de notre fonction <code>plus_un</code> qui a un bogue et ne va pas se compiler¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
We didn‚Äôt handle the `None` case, so this code will cause a bug. Luckily, it‚Äôs
a bug Rust knows how to catch. If we try to compile this code, we‚Äôll get this
error:
-->
<p>Nous n'avons pas g√©r√© le cas du <code>None</code>, donc ce code va g√©n√©rer un bogue.
Heureusement, c'est un bogue que Rust sait g√©rer. Si nous essayons de compiler
ce code, nous allons obtenir cette erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   -- > src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<!--
Rust knows that we didn‚Äôt cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier impossible.
-->
<p>Rust sait que nous n'avons pas couvert toutes les possibilit√©s et sait m√™me quel
motif nous avons oubli√©¬†! Les <code>match</code> de Rust sont <em>exhaustifs</em>¬†: nous devons
traiter toutes les possibilit√©s afin que le code soit valide. C'est notamment le
cas avec <code>Option&lt;T&gt;</code>¬†: quand Rust nous emp√™che d'oublier de g√©rer explicitement
le cas de <code>None</code>, il nous prot√®ge d'une situation o√π nous supposons que nous
avons une valeur alors que nous pourrions avoir null, ce qui rend impossible
l'erreur √† un milliard de dollars que nous avons vue pr√©c√©demment.</p>
<!--
### Catch-all Patterns and the `_` Placeholder
-->
<h3 id="les-motifs-g√©n√©riques-et-le-motif-_"><a class="header" href="#les-motifs-g√©n√©riques-et-le-motif-_">Les motifs g√©n√©riques et le motif <code>_</code></a></h3>
<!--
Using enums, we can also take special actions for a few particular values, but
for all other values take one default action. Imagine we‚Äôre implementing a game
where, if you roll a 3 on a dice roll, your player doesn‚Äôt move, but instead
gets a new fancy hat. If you roll a 7, your player loses a fancy hat. For all
other values, your player moves that number of spaces on the game board. Here‚Äôs
a `match` that implements that logic, with the result of the dice roll
hardcoded rather than a random value, and all other logic represented by
functions without bodies because actually implementing them is out of scope for
this example:
-->
<p>En utilisant les √©num√©rations, nous pouvons aussi appliquer des actions
sp√©ciales pour certaines valeurs pr√©cises, mais une action par d√©faut pour
toutes les autres valeurs. Imaginons que nous impl√©mentons un jeu dans lequel,
si vous obtenez une valeur de 3 sur un lanc√© de d√©, votre joueur ne se d√©place
pas, mais √† la place il obtient un nouveau chapeau fataisie. Si vous obtenez
un 7, votre joueur perd son chapeau fantaisie. Pour toutes les autres valeurs,
votre joueur se d√©place de ce nombre de cases sur le plateau du jeu. Voici un
<code>match</code> qui impl√©mente cette logique, avec le r√©sultat du lanc√© de d√© cod√© en
dur plut√¥t qu'issu d'une g√©n√©ration al√©atoire, et toute la logique des autres
fonctions sont des corps vides car leur impl√©mentation n'est pas le sujet de
cet exemple¬†:</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        autre =&gt; deplace_joueur(autre),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
    fn deplace_joueur(nombre_cases: u8) {}
<span class="boring">}
</span></code></pre></pre>
<!--
For the first two arms, the patterns are the literal values 3 and 7. For the
last arm that covers every other possible value, the pattern is the variable
we‚Äôve chosen to name `other`. The code that runs for the `other` arm uses the
variable by passing it to the `move_player` function.
-->
<p>Dans les deux premi√®res branches, les motifs sont les valeurs lit√©rales 3 et 7.
La derni√®re branche couvre toutes les autres valeurs possibles, le motif est la
variable <code>autre</code>. Le code qui s'ex√©cute pour la branche <code>autre</code> utilise la
variable en la passant dans la fonction <code>deplacer_joueur</code>.</p>
<!--
This code compiles, even though we haven‚Äôt listed all the possible values a
`u8` can have, because the last pattern will match all values not specifically
listed. This catch-all pattern meets the requirement that `match` must be
exhaustive. Note that we have to put the catch-all arm last because the
patterns are evaluated in order. Rust will warn us if we add arms after a
catch-all because those later arms would never match!
-->
<p>Ce code se compile, m√™me si nous n'avons pas list√© toutes les valeurs possibles
qu'un <code>u8</code> puisse avoir, car le dernier motif va correspondre √† toutes les
valeurs qui ne sont pas sp√©cifiquement list√©s. Ce motif g√©n√©rique r√©pond √† la
condition qu'un <code>match</code> doive √™tre exhaustif. Notez que nous devons placer la
branche avec le motif g√©n√©rique en tout dernier, car les motifs sont √©valu√©s
dans l'ordre. Rust va nous pr√©venir si nous ajoutons des branches apr√®s un motif
g√©n√©rique car toutes ces autres branches ne seront jamais v√©rifi√©es¬†!</p>
<!--
Rust also has a pattern we can use when we don‚Äôt want to use the value in the
catch-all pattern: `_`, which is a special pattern that matches any value and
does not bind to that value. This tells Rust we aren‚Äôt going to use the value,
so Rust won‚Äôt warn us about an unused variable.
-->
<p>Rust a aussi un motif que nous pouvons utiliser lorsque nous n'avons pas besoin
d'utiliser la valeur dans le motif g√©n√©rique¬†: <code>_</code>, qui est un motif sp√©cial
qui v√©rifie n'importe quelle valeur et ne r√©cup√®re pas cette valeur. Ceci
indique √† Rust que nous n'allons pas utiliser la valeur, donc Rust ne va pas
nous pr√©venir qu'il y a une variable non utilis√©e.</p>
<!--
Let‚Äôs change the rules of the game to be that if you roll anything other than
a 3 or a 7, you must roll again. We don‚Äôt need to use the value in that case,
so we can change our code to use `_` instead of the variable named `other`:
-->
<p>Changeons les r√®gles du jeu pour que si nous obtenions autre chose qu'un 3 ou
un 7, nous jetions √† nouveau le d√©. Nous n'avons pas besoin d'utiliser la valeur
dans ce cas, donc nous pouvons changer notre code pour utiliser <code>_</code> au lieu de
la variable <code>autre</code>¬†:</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        _ =&gt; relancer(),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
    fn relancer() {}
<span class="boring">}
</span></code></pre></pre>
<!--
This example also meets the exhaustiveness requirement because we‚Äôre explicitly
ignoring all other values in the last arm; we haven‚Äôt forgotten anything.
-->
<p>Cet exemple r√©pond bien aux crit√®res d'exhaustivit√© car nous ignorons
explicitement toutes les autres valeurs dans la derni√®re branche¬†; nous n'avons
rien oubli√©.</p>
<!--
If we change the rules of the game one more time, so that nothing else happens
on your turn if you roll anything other than a 3 or a 7, we can express that
by using the unit value (the empty tuple type we mentioned in [‚ÄúThe Tuple
Type‚Äù][tuples]<!-- ignore -- > section) as the code that goes with the `_` arm:
-->
<p>Si nous changeons √† nouveau les r√®gles du jeu, afin que rien se passe si vous
obtenez autre chose qu'un 3 ou un 7, nous pouvons exprimer cela en utilisant la
valeur unit√© (le type tuple vide que nous avons cit√© dans <a href="ch03-02-data-types.html">une section
pr√©c√©dente</a><!-- ignore -->) dans le code de la branche <code>_</code>¬†:</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        _ =&gt; (),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
<span class="boring">}
</span></code></pre></pre>
<!--
Here, we‚Äôre telling Rust explicitly that we aren‚Äôt going to use any other value
that doesn‚Äôt match a pattern in an earlier arm, and we don‚Äôt want to run any
code in this case.
-->
<p>Ici, nous indiquons explicitement √† Rust que nous n'allons pas utiliser d'autres
valeurs qui ne correspondent pas √† un motif des branches ant√©rieures, et nous ne
voulons lancer aucun code dans ce cas.</p>
<!--
There‚Äôs more about patterns and matching that we‚Äôll cover in [Chapter
18][ch18-00-patterns]<!-- ignore -- >. For now, we‚Äôre going to move on to the
`if let` syntax, which can be useful in situations where the `match` expression
is a bit wordy.
-->
<p>Il existe aussi d'autres motifs que nous allons voir dans le
<a href="ch18-00-patterns.html">chapitre 18</a><!-- ignore -->. Pour l'instant, nous allons voir
l'autre syntaxe <code>if let</code>, qui peut se rendre utile dans des cas o√π l'expression
<code>match</code> est trop verbeuse.</p>
<!--
[tuples]: ch03-02-data-types.html#the-tuple-type
[ch18-00-patterns]: ch18-00-patterns.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Concise Control Flow with `if let`
-->
<h2 id="une-structure-de-contr√¥le-concise--if-let"><a class="header" href="#une-structure-de-contr√¥le-concise--if-let">Une structure de contr√¥le concise¬†: <code>if let</code></a></h2>
<!--
The `if let` syntax lets you combine `if` and `let` into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an `Option<u8>` value in the `config_max`
variable but only wants to execute code if the value is the `Some` variant.
-->
<p>La syntaxe <code>if let</code> vous permet de combiner <code>if</code> et <code>let</code> afin de g√©rer les
valeurs qui correspondent √† un motif donn√©, tout en ignorant les autres.
Imaginons le programme dans l'encart 6-6 qui fait un <code>match</code> sur la valeur
<code>Option&lt;u8&gt;</code> de la variable <code>une_valeur_u8</code> mais n'a besoin d'ex√©cuter du code que
si la valeur est la variante <code>Some</code>.</p>
<!--
```rust
# fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = Some(3u8);
    match une_valeur_u8 {
        Some(max) =&gt; println!(&quot;Le maximum est r√©gl√© sur {}&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-6: A `match` that only cares about executing
code when the value is `Some`</span>
-->
<p><span class="caption">Encart 6-6¬†: Un <code>match</code> qui n'ex√©cute du code que si la
valeur est <code>Some</code></span></p>
<!--
If the value is `Some`, we print out the value in the `Some` variant by binding
the value to the variable `max` in the pattern. We don‚Äôt want to do anything
with the `None` value. To satisfy the `match` expression, we have to add `_ =>
()` after processing just one variant, which is annoying boilerplate code to
add.
-->
<p>Si la valeur est un <code>Some</code>, nous affichons la valeur dans la variante <code>Some</code> en
associant la valeur √† la variable <code>max</code> dans le motif. Nous ne voulons rien
faire avec la valeur <code>None</code>. Pour satisfaire l'expression <code>match</code>, nous devons
ajouter <code>_ =&gt; ()</code> apr√®s avoir g√©r√© une seule variante, ce qui est du code
inutile.</p>
<!--
Instead, we could write this in a shorter way using `if let`. The following
code behaves the same as the `match` in Listing 6-6:
-->
<p>√Ä la place, nous pourrions √©crire le m√™me programme de mani√®re plus concise en
utilisant <code>if let</code>. Le code suivant se comporte comme le <code>match</code> de l'encart
6-6¬†:</p>
<!--
```rust
# fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = Some(3u8);
    if let Some(max) = une_valeur_u8 {
        println!(&quot;Le maximum est r√©gl√© sur {}&quot;, max);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
The syntax `if let` takes a pattern and an expression separated by an equal
sign. It works the same way as a `match`, where the expression is given to the
`match` and the pattern is its first arm. In this case, the pattern is
`Some(max)`, and the `max` binds to the value inside the `Some`. We can then
use `max` in the body of the `if let` block in the same way as we used `max` in
the corresponding `match` arm. The code in the `if let` block isn‚Äôt run if the
value doesn‚Äôt match the pattern.
-->
<p>La syntaxe <code>if let</code> prend un motif et une expression s√©par√©s par un signe √©gal.
Elle fonctionne de la m√™me mani√®re qu'un <code>match</code> o√π l'expression est donn√©e au
<code>match</code> et o√π le motif est sa premi√®re branche. Dans ce cas, le motif est
<code>Some(max)</code>, et le <code>max</code> est associ√© √† la valeur dans le <code>Some</code>. Nous pouvons
ensuite utiliser <code>max</code> dans le corps du bloc <code>if let</code> de la m√™me mani√®re que
nous avons utilis√© <code>max</code> dans la branche correspondante au <code>match</code>. Le code dans
le bloc <code>if let</code> n'est pas ex√©cut√© si la valeur ne correspond pas au motif.</p>
<!--
Using `if let` means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that `match` enforces. Choosing
between `match` and `if let` depends on what you‚Äôre doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.
-->
<p>Utiliser <code>if let</code> permet d'√©crire moins de code, et de moins l'indenter.
Cependant, vous perdez la v√©rification de l'exhaustivit√© qu'assure le <code>match</code>.
Choisir entre <code>match</code> et <code>if let</code> d√©pend de la situation¬†: √† vous de choisir
s'il vaut mieux √™tre concis ou appliquer une v√©rification exhaustive.</p>
<!--
In other words, you can think of `if let` as syntax sugar for a `match` that
runs code when the value matches one pattern and then ignores all other values.
-->
<p>Autrement dit, vous pouvez consid√©rer le <code>if let</code> comme du sucre syntaxique pour
un <code>match</code> qui ex√©cute du code uniquement quand la valeur correspond √† un motif
donn√© et ignore toutes les autres valeurs.</p>
<!--
We can include an `else` with an `if let`. The block of code that goes with the
`else` is the same as the block of code that would go with the `_` case in the
`match` expression that is equivalent to the `if let` and `else`. Recall the
`Coin` enum definition in Listing 6-4, where the `Quarter` variant also held a
`UsState` value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a `match`
expression like this:
-->
<p>Nous pouvons joindre un <code>else</code> √† un <code>if let</code>. Le bloc de code qui va dans le
<code>else</code> est le m√™me que le bloc de code qui va dans le cas <code>_</code> avec l'expression
<code>match</code>. Souvenez-vous de la d√©finition de l'√©num√©ration <code>PieceUs</code> de l'encart
6-4, o√π la variante <code>Quarter</code> stockait aussi une valeur <code>EtatUs</code>. Si nous
voulions compter toutes les pi√®ces qui ne sont pas des <em>quarters</em> que nous
voyons passer, tout en affichant l'√âtat des <em>quarters</em>, nous pourrions le faire
avec une expression <code>match</code> comme ceci¬†:</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
# fn main() {
#     let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masqu√©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let piece = PieceUs::Penny;
</span>    let mut compteur = 0;
    match piece {
        PieceUs::Quarter(etat) =&gt; println!(&quot;Il s'agit d'un quarter de l'√âtat de {:?}¬†!&quot;, etat),
        _ =&gt; compteur += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could use an `if let` and `else` expression like this:
-->
<p>Ou nous pourrions utiliser une expression <code>if let</code>/<code>else</code> comme ceci¬†:</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
# fn main() {
#     let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masqu√©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let piece = PieceUs::Penny;
</span>    let mut compteur = 0;
    if let PieceUs::Quarter(etat) = piece {
        println!(&quot;Il s'agit d'un quarter de l'√âtat de {:?}¬†!&quot;, etat);
    } else {
        compteur += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If you have a situation in which your program has logic that is too verbose to
express using a `match`, remember that `if let` is in your Rust toolbox as well.
-->
<p>Si vous trouvez que votre programme est alourdi par l'utilisation d'un <code>match</code>,
souvenez-vous que <code>if let</code> est aussi pr√©sent dans votre boite √† outils Rust.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-5"><a class="header" href="#r√©sum√©-5">R√©sum√©</a></h2>
<!--
We‚Äôve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We‚Äôve shown how the standard library‚Äôs `Option<T>`
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use `match` or `if let` to extract and use those
values, depending on how many cases you need to handle.
-->
<p>Nous avons d√©sormais appris comment utiliser les √©num√©rations pour cr√©er des
types personnalis√©s qui peuvent faire partie d'un jeu de valeurs recens√©es. Nous
avons montr√© comment le type <code>Option&lt;T&gt;</code> de la biblioth√®que standard vous aide
√† utiliser le syst√®me de types pour √©viter les erreurs. Lorsque les valeurs
d'√©num√©ration contiennent des donn√©es, vous pouvez utiliser <code>match</code> ou <code>if let</code>
pour extraire et utiliser ces valeurs, √† choisir en fonction du nombre de cas
que vous voulez g√©rer.</p>
<!--
Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions get only values of the type each
function expects.
-->
<p>Vos programmes Rust peuvent maintenant d√©crire des concepts m√©tier √† l'aide de
structures et d'√©num√©rations. Cr√©er des types personnalis√©s √† utiliser dans
votre API assure la s√©curit√© des types¬†: le compilateur s'assurera que vos
fonctions ne re√ßoivent que des valeurs du type attendu.</p>
<!--
In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let‚Äôs now turn to
Rust‚Äôs modules.
-->
<p>Afin de fournir une API bien organis√©e, simple √† utiliser et qui n'expose que ce
dont vos utilisateurs auront besoin, d√©couvrons maintenant les modules de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Managing Growing Projects with Packages, Crates, and Modules
-->
<h1 id="g√©rer-des-projets-grandissants-avec-les-paquets-crates-et-modules"><a class="header" href="#g√©rer-des-projets-grandissants-avec-les-paquets-crates-et-modules">G√©rer des projets grandissants avec les paquets, crates et modules</a></h1>
<!--
As you write large programs, organizing your code will be important because
keeping track of your entire program in your head will become impossible. By
grouping related functionality and separating code with distinct features,
you‚Äôll clarify where to find code that implements a particular feature and
where to go to change how a feature works.
-->
<p>Lorsque vous commencerez √† √©crire des gros programmes, organiser votre code va
devenir important car vous ne pourrez plus garder en t√™te l'int√©gralit√© de votre
programme. En regroupant des fonctionnalit√©s qui ont des points communs et en
les s√©parant des autres fonctionnalit√©s, vous clarifiez l'endroit o√π trouver le
code qui impl√©mente une fonctionnalit√© sp√©cifique afin de pouvoir le relire ou
le modifier.</p>
<!--
The programs we‚Äôve written so far have been in one module in one file. As a
project grows, you can organize code by splitting it into multiple modules and
then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects of a set of interrelated packages
that evolve together, Cargo provides workspaces, which we‚Äôll cover in the
[‚ÄúCargo Workspaces‚Äù][workspaces]<!-- ignore -- > section in Chapter 14.
-->
<p>Les programmes que nous avons √©crits jusqu'√† pr√©sent √©taient dans un module au
sein d'un seul fichier. √Ä mesure que le projet grandit, vous pouvez organiser
votre code en le d√©coupant en plusieurs modules et ensuite en plusieurs
fichiers. Un paquet peut contenir plusieurs crates binaires et accessoirement
une crate de biblioth√®que. √Ä mesure qu'un paquet grandit, vous pouvez en
extraire des parties dans des crates s√©par√©es qui deviennent des d√©pendances
externes. Ce chapitre va aborder toutes ces techniques. Pour un projet de tr√®s
grande envergure qui a des paquets interconnect√©s qui √©voluent ensemble, Cargo
propose les espaces de travail, que nous d√©couvrirons dans une section du
<a href="ch14-03-cargo-workspaces.html">chapitre 14</a><!-- ignore -->.</p>
<!--
In addition to grouping functionality, encapsulating implementation details
lets you reuse code at a higher level: once you‚Äôve implemented an operation,
other code can call that code via the code‚Äôs public interface without knowing
how the implementation works. The way you write code defines which parts are
public for other code to use and which parts are private implementation details
that you reserve the right to change. This is another way to limit the amount
of detail you have to keep in your head.
-->
<p>En plus de regrouper des fonctionnalit√©s, les modules vous permettent
d'encapsuler les d√©tails de l'impl√©mentation d'une op√©ration¬†: vous pouvez
√©crire du code puis l'utiliser comme une abstraction √† travers l'interface de
programmation publique (API) du code sans se soucier de conna√Ætre les d√©tails de
son impl√©mentation. La fa√ßon dont vous √©crivez votre code d√©finit quelles
parties sont publiques et donc utilisables par un autre code, et quelles parties
sont des d√©tails d'impl√©mentation priv√©s dont vous vous r√©servez le droit de
modifier. C'est un autre moyen de limiter le nombre d'√©l√©ments de l'API pour
celui qui l'utilise.</p>
<!--
A related concept is scope: the nested context in which code is written has a
set of names that are defined as ‚Äúin scope.‚Äù When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can‚Äôt have two items with the
same name in the same scope; tools are available to resolve name conflicts.
-->
<p>Un concept qui lui est associ√© est la port√©e¬†: le contexte dans lequel le code
est √©crit a un jeu de noms qui sont d√©finis comme ‚Äúdans la port√©e‚Äù. Quand ils
lisent, √©crivent et compilent du code, les d√©veloppeurs et les compilateurs ont
besoin de savoir ce que tel nom d√©signe √† tel endroit, et s'il s'agit d'une
variable, d'une fonction, d'une structure, d'une √©num√©ration, d'un module, d'une
constante, etc. Vous pouvez cr√©er des port√©es et d√©cider quels noms sont dans la
port√©e ou non. Vous ne pouvez pas avoir deux entit√©s avec le m√™me nom dans la
m√™me port√©e¬†; cependant, des outils existent pour r√©soudre les conflits de nom.</p>
<!--
Rust has a number of features that allow you to manage your code‚Äôs
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the *module system*, include:
-->
<p>Rust a de nombreuses fonctionnalit√©s qui vous permettent de g√©rer l'organisation
de votre code, gr√¢ce √† ce que la communaut√© Rust appelle le <em>syst√®me de
modules</em>. Ce syst√®me d√©finit quels sont les √©l√©ments qui sont accessibles depuis
l'ext√©rieur de la biblioth√®que (notion de priv√© ou public), ainsi que leur
port√©e. Ces fonctionnalit√©s comprennent¬†:</p>
<!--
* **Packages:** A Cargo feature that lets you build, test, and share crates
* **Crates:** A tree of modules that produces a library or executable
* **Modules** and **use:** Let you control the organization, scope, and
  privacy of paths
* **Paths:** A way of naming an item, such as a struct, function, or module
-->
<ul>
<li><strong>les paquets¬†:</strong> une fonctionnalit√© de Cargo qui vous permet de compiler,
tester, et partager des crates¬†;</li>
<li><strong>les <em>crates</em>¬†:</strong> une arborescence de modules qui fournit une biblioth√®que ou
un ex√©cutable¬†;</li>
<li><strong>les modules</strong>¬†: utilis√©s avec le mot-cl√© <code>use</code>, ils vous permettent de
contr√¥ler l'organisation, la port√©e et la visibilit√© des chemins¬†;</li>
<li><strong>les chemins¬†:</strong> une fa√ßon de nommer un √©l√©ment, comme une structure, une
fonction ou un module.</li>
</ul>
<!--
In this chapter, we‚Äôll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!
-->
<p>Dans ce chapitre, nous allons d√©couvrir ces fonctionnalit√©s, voir comment elles
interagissent, et expliquer comment les utiliser pour g√©rer les port√©es. √Ä
l'issue de ce chapitre, vous aurez de solides connaissances sur le syst√®me de
modules et vous pourrez travailler avec les port√©es comme un pro¬†!</p>
<!--
[workspaces]: ch14-03-cargo-workspaces.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Packages and Crates
-->
<h2 id="les-paquets-et-les-crates"><a class="header" href="#les-paquets-et-les-crates">Les paquets et les crates</a></h2>
<!--
The first parts of the module system we‚Äôll cover are packages and crates. A
crate is a binary or library. The *crate root* is a source file that the Rust
compiler starts from and makes up the root module of your crate (we‚Äôll explain
modules in depth in the [‚ÄúDefining Modules to Control Scope and
Privacy‚Äù][modules]<!-- ignore -- > section). A *package* is one or more crates
that provide a set of functionality. A package contains a *Cargo.toml* file
that describes how to build those crates.
-->
<p>La premi√®re partie du syst√®me de modules que nous allons aborder concerne les
paquets et les <em>crates</em>. Une crate est un binaire ou une biblioth√®que. Pour la
compiler, le compilateur Rust part d'un fichier source, la racine de la <em>crate</em>,
√† partir duquel est alors cr√©√© le <em>module racine</em> de votre <em>crate</em> (nous verrons
les modules plus en d√©tail dans la <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">section suivante</a><!-- ignore -->).
Un <em>paquet</em> se compose d'une ou plusieurs crates qui fournissent un ensemble de
fonctionnalit√©s. Un paquet contient un fichier <em>Cargo.toml</em> qui d√©crit comment
construire ces crates.</p>
<!--
Several rules determine what a package can contain. A package can contain
at most one library crate. It can contain as many binary crates
as you‚Äôd like, but it must contain at least one crate (either library or
binary).
-->
<p>Il y a plusieurs r√®gles qui d√©terminent ce qu'un paquet peut contenir. Il <em>doit</em>
contenir au maximum une seule crate de biblioth√®que. Il peut contenir autant de
crates binaires que vous le souhaitez, mais il doit contenir au moins une crate
(que ce soit une biblioth√®que ou un binaire).</p>
<!--
Let‚Äôs walk through what happens when we create a package. First, we enter the
command `cargo new`:
-->
<p>D√©couvrons ce qui se passe quand nous cr√©ons un paquet. D'abord, nous utilisons
la commande <code>cargo new</code>¬†:</p>
<!--
```console
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```
-->
<pre><code class="language-console">$ cargo new mon-projet
     Created binary (application) `mon-projet` package
$ ls mon-projet
Cargo.toml
src
$ ls mon-projet/src
main.rs
</code></pre>
<!--
When we entered the command, Cargo created a *Cargo.toml* file, giving us a
package. Looking at the contents of *Cargo.toml*, there‚Äôs no mention of
*src/main.rs* because Cargo follows a convention that *src/main.rs* is the
crate root of a binary crate with the same name as the package. Likewise, Cargo
knows that if the package directory contains *src/lib.rs*, the package contains
a library crate with the same name as the package, and *src/lib.rs* is its
crate root. Cargo passes the crate root files to `rustc` to build the library
or binary.
-->
<p>Lorsque nous avons saisi la commande, Cargo a cr√©√© un fichier <em>Cargo.toml</em>, qui
d√©finit un paquet. Si on regarde le contenu de <em>Cargo.toml</em>, le fichier
<em>src/main.rs</em> n'est pas mentionn√© car Cargo ob√©it √† une convention selon
laquelle <em>src/main.rs</em> est la racine de la crate binaire portant le m√™me
nom que le paquet. De la m√™me fa√ßon, Cargo sait que si le dossier du paquet
contient <em>src/lib.rs</em>, alors le paquet contient une crate de biblioth√®que qui a
le m√™me nom que le paquet, et que <em>src/lib.rs</em> est sa racine. Cargo transmet les
fichiers de la crate racine √† <code>rustc</code> pour compiler la biblioth√®que ou le
binaire.</p>
<!--
Here, we have a package that only contains *src/main.rs*, meaning it only
contains a binary crate named `my-project`. If a package contains *src/main.rs*
and *src/lib.rs*, it has two crates: a binary and a library, both with the same
name as the package. A package can have multiple binary crates by placing files
in the *src/bin* directory: each file will be a separate binary crate.
-->
<p>Dans notre cas, nous avons un paquet qui contient uniquement <em>src/main.rs</em>, ce
qui veut dire qu'il contient uniquement une crate binaire qui s'appelle
<code>mon-projet</code>. Si un paquet contient <em>src/main.rs</em> et <em>src/lib.rs</em>, il a deux
crates¬†: une binaire et une biblioth√®que, chacune avec le m√™me nom que le
paquet. Un paquet peut avoir plusieurs crates binaires en ajoutant des fichiers
dans le r√©pertoire <em>src/bin</em>¬†: chaque fichier sera une crate s√©par√©e.</p>
<!--
A crate will group related functionality together in a scope so the
functionality is easy to share between multiple projects. For example, the
`rand` crate we used in [Chapter 2][rand]<!-- ignore -- > provides functionality
that generates random numbers. We can use that functionality in our own
projects by bringing the `rand` crate into our project‚Äôs scope. All the
functionality provided by the `rand` crate is accessible through the crate‚Äôs
name, `rand`.
-->
<p>Une crate regroupe plusieurs fonctionnalit√©s associ√©es ensemble dans une port√©e
afin que les fonctionnalit√©s soient faciles √† partager entre plusieurs projets.
Par exemple, la crate <code>rand</code> que nous avons utilis√©e dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">le chapitre 2</a><!-- ignore --> nous permet de g√©n√©rer des nombres
al√©atoires. Nous pouvons utiliser cette fonctionnalit√© dans notre propre projet
en important la crate <code>rand</code> dans la port√©e de notre projet. Toutes les
fonctionnalit√©s fournies par la crate <code>rand</code> sont accessibles via le nom de la
crate, <code>rand</code>.</p>
<!--
Keeping a crate‚Äôs functionality in its own scope clarifies whether particular
functionality is defined in our crate or the `rand` crate and prevents
potential conflicts. For example, the `rand` crate provides a trait named
`Rng`. We can also define a `struct` named `Rng` in our own crate. Because a
crate‚Äôs functionality is namespaced in its own scope, when we add `rand` as a
dependency, the compiler isn‚Äôt confused about what the name `Rng` refers to. In
our crate, it refers to the `struct Rng` that we defined. We would access the
`Rng` trait from the `rand` crate as `rand::Rng`.
-->
<p>Ranger une fonctionnalit√© d'une crate dans sa propre port√©e clarifie si une
fonctionnalit√© pr√©cise est d√©finie dans notre crate ou dans la crate <code>rand</code> et
√©vite ainsi de potentiels conflits. Par exemple, la crate <code>rand</code> fournit un
<em>trait</em> qui s'appelle <code>Rng</code>. Nous pouvons nous aussi d√©finir une structure qui
s'appelle <code>Rng</code> dans notre propre crate. Comme les fonctionnalit√©s des crates
sont dans la port√©e de leur propre espace de nom, quand nous ajoutons <code>rand</code> en
d√©pendance, il n'y a pas d'ambigu√Øt√© pour le compilateur sur le nom <code>Rng</code>. Dans
notre crate, il se r√©f√®re au <code>struct Rng</code> que nous avons d√©fini. Nous acc√©dons
au <em>trait</em> <code>Rng</code> de la crate <code>rand</code> via <code>rand::Rng</code>.</p>
<!--
Let‚Äôs move on and talk about the module system!
-->
<p>Poursuivons et parlons maintenant du syst√®me de modules¬†!</p>
<!--
[modules]: ch07-02-defining-modules-to-control-scope-and-privacy.html
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining Modules to Control Scope and Privacy
-->
<h2 id="d√©finir-des-modules-pour-g√©rer-la-port√©e-et-la-visibilit√©"><a class="header" href="#d√©finir-des-modules-pour-g√©rer-la-port√©e-et-la-visibilit√©">D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></h2>
<!--
In this section, we‚Äôll talk about modules and other parts of the module system,
namely *paths* that allow you to name items; the `use` keyword that brings a
path into scope; and the `pub` keyword to make items public. We‚Äôll also discuss
the `as` keyword, external packages, and the glob operator. For now, let‚Äôs
focus on modules!
-->
<p>Dans cette section, nous allons aborder les modules et les autres outils du
syst√®me de modules, √† savoir les <em>chemins</em> qui nous permettent de nommer les
√©l√©ments¬†; l'utilisation du mot-cl√© <code>use</code> qui importe un chemin dans la port√©e¬†;
et le mot-cl√© <code>pub</code> qui rend publics les √©l√©ments. Nous verrons aussi le mot-cl√©
<code>as</code>, les paquets externes, et l'op√©rateur glob. Pour commencer, penchons-nous
sur les modules¬†!</p>
<!--
*Modules* let us organize code within a crate into groups for readability and
easy reuse. Modules also control the *privacy* of items, which is whether an
item can be used by outside code (*public*) or is an internal implementation
detail and not available for outside use (*private*).
-->
<p>Les <em>modules</em> nous permettent de regrouper le code d'une crate pour une
meilleure lisibilit√© et pour la facilit√© de r√©utilisation. Les modules
permettent aussi de g√©rer la <em>visibilit√©</em> des √©l√©ments, qui pr√©cise si un
√©l√©ment peut √™tre utilis√© √† l'ext√©rieur du module (<em>c'est public</em>) ou s'il est
un constituant interne et n'est pas disponible pour une utilisation externe
(<em>c'est priv√©</em>).</p>
<!--
As an example, let‚Äôs write a library crate that provides the functionality of a
restaurant. We‚Äôll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than actually
implement a restaurant in code.
-->
<p>Voici un exemple¬†: √©crivons une crate de biblioth√®que qui permet de simuler un
restaurant. Nous allons d√©finir les signatures des fonctions mais nous allons
laisser leurs corps vides pour nous concentrer sur l'organisation du code,
plut√¥t que de coder pour de vrai un restaurant.</p>
<!--
In the restaurant industry, some parts of a restaurant are referred to as
*front of house* and others as *back of house*. Front of house is where
customers are; this is where hosts seat customers, servers take orders and
payment, and bartenders make drinks. Back of house is where the chefs and cooks
work in the kitchen, dishwashers clean up, and managers do administrative work.
-->
<p>Dans le secteur de la restauration, certaines parties d'un restaurant sont
assimil√©es √† la <em>salle √† manger</em> et d'autres <em>aux cuisines</em>. La partie salle √†
manger est l'endroit o√π se trouvent les clients¬†; c'est l'endroit o√π les h√¥tes
installent les clients, o√π les serveurs prennent les commandes et encaissent les
clients, et o√π les barmans pr√©parent des boissons. Dans la partie cuisines, nous
retrouvons les chefs et les cuisiniers qui travaillent dans la cuisine, mais
aussi les plongeurs qui nettoient la vaisselle et les gestionnaires qui
s'occupent des t√¢ches administratives.</p>
<!--
To structure our crate in the same way that a real restaurant works, we can
organize the functions into nested modules. Create a new library named
`restaurant` by running `cargo new --lib restaurant`; then put the code in
Listing 7-1 into *src/lib.rs* to define some modules and function signatures.
-->
<p>Pour organiser notre crate de la m√™me mani√®re qu'un vrai restaurant, nous
pouvons organiser les fonctions avec des modules imbriqu√©s. Cr√©ez une nouvelle
biblioth√®que qui s'appelle <code>restaurant</code> en utilisant
<code>cargo new --lib restaurant</code>¬†; puis √©crivez le code de l'encart 7-1 dans
<em>src/lib.rs</em> afin de d√©finir quelques modules et quelques signatures de
fonctions.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```
-->
<pre><code class="language-rust noplayground">mod salle_a_manger {
    mod accueil {
        fn ajouter_a_la_liste_attente() {}

        fn installer_a_une_table() {}
    }

    mod service {
        fn prendre_commande() {}

        fn servir_commande() {}

        fn encaisser() {}
    }
}
</code></pre>
<!--
<span class="caption">Listing 7-1: A `front_of_house` module containing other
modules that then contain functions</span>
-->
<p><span class="caption">Encart 7-1¬†: Un module <code>salle_a_manger</code> qui contient
d'autres modules qui contiennent eux-m√™mes des fonctions</span></p>
<!--
We define a module by starting with the `mod` keyword and then specify the
name of the module (in this case, `front_of_house`) and place curly brackets
around the body of the module. Inside modules, we can have other modules, as in
this case with the modules `hosting` and `serving`. Modules can also hold
definitions for other items, such as structs, enums, constants, traits, or‚Äîas
in Listing 7-1‚Äîfunctions.
-->
<p>Nous d√©finissons un module en commen√ßant avec le mot-cl√© <code>mod</code> et nous pr√©cisons
ensuite le nom du module (dans notre cas, <code>salle_a_manger</code>) et nous ajoutons des
accolades autour du corps du module. Dans les modules, nous pouvons avoir
d'autres modules, comme dans notre cas avec les modules <code>accueil</code> et <code>service</code>.
Les modules peuvent aussi contenir des d√©finitions pour d'autres √©l√©ments, comme
des structures, des √©num√©rations, des constantes, des traits, ou des fonctions
(comme c'est le cas dans l'encart 7-1).</p>
<!--
By using modules, we can group related definitions together and name why
they‚Äôre related. Programmers using this code would have an easier time finding
the definitions they wanted to use because they could navigate the code based
on the groups rather than having to read through all the definitions.
Programmers adding new functionality to this code would know where to place the
code to keep the program organized.
-->
<p>Gr√¢ce aux modules, nous pouvons regrouper ensemble des d√©finitions qui sont
li√©es et donner un nom √† ce lien. Les d√©veloppeurs qui utiliseront ce code
pourront plus facilement trouver les d√©finitions dont ils ont besoin car ils
peuvent parcourir le code en fonction des groupes plut√¥t que d'avoir √† lire
toutes les d√©finitions. Les d√©veloppeurs qui veulent rajouter des nouvelles
fonctionnalit√©s √† ce code sauront maintenant o√π placer le code tout en gardant
le programme organis√©.</p>
<!--
Earlier, we mentioned that *src/main.rs* and *src/lib.rs* are called crate
roots. The reason for their name is that the contents of either of these two
files form a module named `crate` at the root of the crate‚Äôs module structure,
known as the *module tree*.
-->
<p>Pr√©c√©demment, nous avons dit que <em>src/main.rs</em> et <em>src/lib.rs</em> √©taient des
racines de crates. Nous les appelons ainsi car le contenu de chacun de ces
deux fichiers constituent un module qui s'appelle <code>crate</code> √† la racine de
<em>l'arborescence du module</em>.</p>
<!--
Listing 7-2 shows the module tree for the structure in Listing 7-1.
-->
<p>L'encart 7-2 pr√©sente l'arborescence du module pour la structure de
l'encart 7-1.</p>
<!--
```text
crate
 ‚îî‚îÄ‚îÄ front_of_house
     ‚îú‚îÄ‚îÄ hosting
     ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
     ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
     ‚îî‚îÄ‚îÄ serving
         ‚îú‚îÄ‚îÄ take_order
         ‚îú‚îÄ‚îÄ serve_order
         ‚îî‚îÄ‚îÄ take_payment
```
-->
<pre><code class="language-text">crate
 ‚îî‚îÄ‚îÄ salle_a_manger
     ‚îú‚îÄ‚îÄ accueil
     ‚îÇ   ‚îú‚îÄ‚îÄ ajouter_a_la_liste_attente
     ‚îÇ   ‚îî‚îÄ‚îÄ installer_a_une_table
     ‚îî‚îÄ‚îÄ service
         ‚îú‚îÄ‚îÄ prendre_commande
         ‚îú‚îÄ‚îÄ servir_commande
         ‚îî‚îÄ‚îÄ encaisser
</code></pre>
<!--
<span class="caption">Listing 7-2: The module tree for the code in Listing
7-1</span>
-->
<p><span class="caption">Encart 7-2¬†: L'arborescence des modules pour le code de
l'encart 7-1</span></p>
<!--
This tree shows how some of the modules nest inside one another (for example,
`hosting` nests inside `front_of_house`). The tree also shows that some modules
are *siblings* to each other, meaning they‚Äôre defined in the same module
(`hosting` and `serving` are defined within `front_of_house`). To continue the
family metaphor, if module A is contained inside module B, we say that module A
is the *child* of module B and that module B is the *parent* of module A.
Notice that the entire module tree is rooted under the implicit module named
`crate`.
-->
<p>Cette arborescence montre comment les modules sont imbriqu√©s entre eux (par
exemple, <code>accueil</code> est imbriqu√© dans <code>salle_a_manger</code>). L'arborescence montre
aussi que certains modules sont les <em>fr√®res</em> d'autres modules, ce qui veut dire
qu'ils sont d√©finis dans le m√™me module (<code>accueil</code> et <code>service</code> sont d√©finis
dans <code>salle_a_manger</code>). Pour prolonger la m√©taphore familiale, si le module A
est contenu dans le module B, on dit que le module A est <em>l'enfant</em> du module B
et que ce module B est le <em>parent</em> du module A. Notez aussi que le module
implicite nomm√© <code>crate</code> est le parent de toute cette arborescence.</p>
<!--
The module tree might remind you of the filesystem‚Äôs directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.
-->
<p>L'arborescence des modules peut rappeler les dossiers du syst√®me de fichiers de
votre ordinateur¬†; et c'est une excellente comparaison¬†! Comme les dossiers dans
un syst√®me de fichiers, vous utilisez les modules pour organiser votre code. Et
comme pour les fichiers dans un dossier, nous avons besoin d'un moyen de trouver
nos modules.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Paths for Referring to an Item in the Module Tree
-->
<h2 id="d√©signer-un-√©l√©ment-dans-larborescence-de-modules"><a class="header" href="#d√©signer-un-√©l√©ment-dans-larborescence-de-modules">D√©signer un √©l√©ment dans l'arborescence de modules</a></h2>
<!--
To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. If we want to call a function,
we need to know its path.
-->
<p>Pour indiquer √† Rust o√π trouver un √©l√©ment dans l'arborescence de modules, nous
utilisons un chemin √† l'instar des chemins que nous utilisons lorsque nous
naviguons dans un syst√®me de fichiers. Si nous voulons appeler une fonction,
nous avons besoin de conna√Ætre son chemin.</p>
<!--
A path can take two forms:
-->
<p>Il existe deux types de chemins¬†:</p>
<!--
* An *absolute path* starts from a crate root by using a crate name or a
  literal `crate`.
* A *relative path* starts from the current module and uses `self`, `super`, or
  an identifier in the current module.
-->
<ul>
<li>Un <em>chemin absolu</em> qui commence √† partir de la racine de la crate en utilisant
le nom d'une crate, ou le mot <code>crate</code>.</li>
<li>Un <em>chemin relatif</em> qui commence √† partir du module courant et qui utilise
<code>self</code>, <code>super</code>, ou un identificateur √† l'int√©rieur du module.</li>
</ul>
<!--
Both absolute and relative paths are followed by one or more identifiers
separated by double colons (`::`).
-->
<p>Les chemins absolus et relatifs sont suivis par un ou plusieurs identificateurs
s√©par√©s par <code>::</code>.</p>
<!--
Let‚Äôs return to the example in Listing 7-1. How do we call the
`add_to_waitlist` function? This is the same as asking, what‚Äôs the path of the
`add_to_waitlist` function? In Listing 7-3, we simplified our code a bit by
removing some of the modules and functions. We‚Äôll show two ways to call the
`add_to_waitlist` function from a new function `eat_at_restaurant` defined in
the crate root. The `eat_at_restaurant` function is part of our library crate‚Äôs
public API, so we mark it with the `pub` keyword. In the [‚ÄùExposing Paths with
the `pub` Keyword‚Äù][pub]<!-- ignore -- > section, we‚Äôll go into more detail
about `pub`. Note that this example won‚Äôt compile just yet; we‚Äôll explain why
in a bit.
-->
<p>Reprenons notre exemple de l'encart 7-1. Comment pouvons-nous appeler la
fonction <code>ajouter_a_la_liste_attente</code>¬†? Cela revient √† se demander¬†: quel est le
chemin de la fonction <code>ajouter_a_la_liste_attente</code>¬†? Dans l'encart 7-3, nous
avons un peu simplifi√© notre code en enlevant quelques modules et quelques
fonctions. Nous allons voir deux fa√ßons d'appeler la fonction
<code>ajouter_a_la_liste_attente</code> √† partir d'une nouvelle fonction
<code>manger_au_restaurant</code> d√©finie √† la racine de la crate. La fonction
<code>manger_au_restaurant</code> fait partie de l'API publique de notre crate de
biblioth√®que, donc nous la marquons avec le mot-cl√© <code>pub</code>. Dans la section
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposer-des-chemins-avec-le-mot-cl%C3%A9-pub">‚ÄùExposer les chemins avec le mot-cl√© <code>pub</code>‚Äù</a><!-- ignore -->, nous en
apprendrons plus sur <code>pub</code>. Notez que cet exemple ne se compile pas pour le
moment¬†; nous allons l'expliquer un peu plus tard.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">mod salle_a_manger {
    mod accueil {
        fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-3: Calling the `add_to_waitlist` function using
absolute and relative paths</span>
-->
<p><span class="caption">Encart 7-3¬†: appel √† la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant un chemin absolu et relatif</span></p>
<!--
The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,
we use an absolute path. The `add_to_waitlist` function is defined in the same
crate as `eat_at_restaurant`, which means we can use the `crate` keyword to
start an absolute path.
-->
<p>Au premier appel de la fonction <code>ajouter_a_la_liste_attente</code> dans
<code>manger_au_restaurant</code>, nous utilisons un chemin absolu. La fonction
<code>ajouter_a_la_liste_attente</code> est d√©finie dans la m√™me crate que
<code>manger_au_restaurant</code>, ce qui veut dire que nous pouvons utiliser le mot-cl√©
<code>crate</code> pour d√©marrer un chemin absolu.</p>
<!--
After `crate`, we include each of the successive modules until we make our way
to `add_to_waitlist`. You can imagine a filesystem with the same structure, and
we‚Äôd specify the path `/front_of_house/hosting/add_to_waitlist` to run the
`add_to_waitlist` program; using the `crate` name to start from the crate root
is like using `/` to start from the filesystem root in your shell.
-->
<p>Apr√®s <code>crate</code>, nous ajoutons chacun des modules successifs jusqu'√†
<code>ajouter_a_la_liste_attente</code>. Nous pouvons faire l'analogie avec un syst√®me de
fichiers qui aurait la m√™me structure, o√π nous pourrions utiliser le chemin
<code>/salle_a_manger/accueil/ajouter_a_la_liste_attente</code> pour lancer le programme
<code>ajouter_a_la_liste_attente</code>¬†; utiliser le nom <code>crate</code> pour partir de la racine
de la crate revient √† utiliser <code>/</code> pour partir de la racine de votre syst√®me de
fichiers dans votre invite de commande.</p>
<!--
The second time we call `add_to_waitlist` in `eat_at_restaurant`, we use a
relative path. The path starts with `front_of_house`, the name of the module
defined at the same level of the module tree as `eat_at_restaurant`. Here the
filesystem equivalent would be using the path
`front_of_house/hosting/add_to_waitlist`. Starting with a name means that the
path is relative.
-->
<p>Lors du second appel √† <code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>,
nous utilisons un chemin relatif. Le chemin commence par <code>salle_a_manger</code>, le
nom du module qui est d√©fini au m√™me niveau que <code>manger_au_restaurant</code> dans
l'arborescence de modules. Ici, l'√©quivalent en terme de syst√®me de fichier
serait le chemin <code>salle_a_manger/accueil/ajouter_a_la_liste_attente</code>. Commencer
par un nom signifie que le chemin est relatif.</p>
<!--
Choosing whether to use a relative or absolute path is a decision you‚Äôll make
based on your project. The decision should depend on whether you‚Äôre more likely
to move item definition code separately from or together with the code that
uses the item. For example, if we move the `front_of_house` module and the
`eat_at_restaurant` function into a module named `customer_experience`, we‚Äôd
need to update the absolute path to `add_to_waitlist`, but the relative path
would still be valid. However, if we moved the `eat_at_restaurant` function
separately into a module named `dining`, the absolute path to the
`add_to_waitlist` call would stay the same, but the relative path would need to
be updated. Our preference is to specify absolute paths because it‚Äôs more
likely to move code definitions and item calls independently of each other.
-->
<p>Choisir entre utiliser un chemin relatif ou absolu sera une d√©cision que vous
ferez en fonction de votre projet. Le choix se fera en fonction de si vous √™tes
susceptible de d√©placer la d√©finition de l'√©l√©ment souhait√© s√©par√©ment ou en
m√™me temps que le code qui l'utilise. Par exemple, si nous d√©pla√ßons le module
<code>salle_a_manger</code> ainsi que la fonction <code>manger_au_restaurant</code> dans un module qui
s'appelle <code>experience_client</code>, nous aurons besoin de mettre √† jour le chemin
absolu vers <code>ajouter_a_la_liste_attente</code>, mais le chemin relatif restera valide.
Cependant, si nous avions d√©plac√© uniquement la fonction <code>manger_au_restaurant</code>
dans un module <code>repas</code> s√©par√©, le chemin absolu de l'appel √†
<code>ajouter_a_la_liste_attente</code> restera le m√™me, mais le chemin relatif aura besoin
d'√™tre mis √† jour. Notre pr√©f√©rence est d'utiliser un chemin absolu car il est
plus facile de d√©placer les d√©finitions de code et les appels aux √©l√©ments
ind√©pendamment les uns des autres.</p>
<!--
Let‚Äôs try to compile Listing 7-3 and find out why it won‚Äôt compile yet! The
error we get is shown in Listing 7-4.
-->
<p>Essayons de compiler l'encart 7-3 et essayons de comprendre pourquoi il ne se
compile pas pour le moment¬†! L'erreur que nous obtenons est affich√©e dans
l'encart 7-4.</p>
<!--
```console
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 -- > src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 -- > src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  -- > src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  -- > src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `accueil` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();
  |                            ^^^^^^^ private module
  |
note: the module `accueil` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod accueil {
  |     ^^^^^^^^^^^

error[E0603]: module `accueil` is private
  --&gt; src/lib.rs:12:21
   |
12 |     salle_a_manger::accueil::ajouter_a_la_liste_attente();
   |                     ^^^^^^^ private module
   |
note: the module `accueil` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod accueil {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<!--
<span class="caption">Listing 7-4: Compiler errors from building the code in
Listing 7-3</span>
-->
<p><span class="caption">Encart 7-4¬†: les erreurs de compilation du code de
l'encart 7-3</span></p>
<!--
The error messages say that module `hosting` is private. In other words, we
have the correct paths for the `hosting` module and the `add_to_waitlist`
function, but Rust won‚Äôt let us use them because it doesn‚Äôt have access to the
private sections.
-->
<p>Le message d'erreur nous rappelle que ce module <code>accueil</code> est priv√©. Autrement
dit, nous avons des chemins corrects pour le module <code>accueil</code> et pour la
fonction <code>ajouter_a_la_liste_attente</code>, mais Rust ne nous laisse pas les utiliser
car il n'a pas acc√®s aux sections priv√©es.</p>
<!--
Modules aren‚Äôt useful only for organizing your code. They also define Rust‚Äôs
*privacy boundary*: the line that encapsulates the implementation details
external code isn‚Äôt allowed to know about, call, or rely on. So, if you want to
make an item like a function or struct private, you put it in a module.
-->
<p>Les modules ne servent pas uniquement √† organiser votre code. Ils d√©finissent
aussi les <em>limites de visibilit√©</em> de Rust¬†: le code externe n'est pas autoris√©
√† conna√Ætre, √† appeler ou √† se fier √† des √©l√©ments internes au module. Donc, si
vous voulez rendre un √©l√©ment priv√© comme une fonction ou une structure, vous
devez le placer dans un module.</p>
<!--
The way privacy works in Rust is that all items (functions, methods, structs,
enums, modules, and constants) are private by default. Items in a parent module
can‚Äôt use the private items inside child modules, but items in child modules
can use the items in their ancestor modules. The reason is that child modules
wrap and hide their implementation details, but the child modules can see the
context in which they‚Äôre defined. To continue with the restaurant metaphor,
think of the privacy rules as being like the back office of a restaurant: what
goes on in there is private to restaurant customers, but office managers can
see and do everything in the restaurant in which they operate.
-->
<p>La visibilit√© en Rust fait en sorte que tous les √©l√©ments (fonctions,
m√©thodes, structures, √©num√©rations, modules et constantes) sont priv√©s par
d√©faut. Les √©l√©ments dans un module parent ne peuvent pas utiliser les √©l√©ments
priv√©s dans les modules enfants, mais les √©l√©ments dans les modules enfants
peuvent utiliser les √©l√©ments dans les modules parents. C'est parce que les
modules enfants englobent et cachent les d√©tails de leur impl√©mentation, mais
les modules enfants peuvent voir dans quel contexte ils sont d√©finis. Pour
continuer la m√©taphore du restaurant, consid√©rez que les r√®gles de visibilit√© de
Rust fonctionnent comme les cuisines d'un restaurant¬†: ce qui s'y passe n'est
pas connu des clients, mais les gestionnaires peuvent tout voir et tout faire
dans le restaurant dans lequel ils travaillent.</p>
<!--
Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. But you can expose inner
parts of child modules‚Äô code to outer ancestor modules by using the `pub`
keyword to make an item public.
-->
<p>Rust a d√©cid√© de faire fonctionner le syst√®me de modules de fa√ßon √† ce que les
d√©tails d'impl√©mentation interne sont cach√©s par d√©faut. Ainsi, vous savez
quelles parties du code interne vous pouvez changer sans casser le code externe.
Mais vous pouvez exposer aux parents des parties internes des modules enfants en
utilisant le mot-cl√© <code>pub</code> afin de les rendre publiques.</p>
<!--
### Exposing Paths with the `pub` Keyword
-->
<h3 id="exposer-des-chemins-avec-le-mot-cl√©-pub"><a class="header" href="#exposer-des-chemins-avec-le-mot-cl√©-pub">Exposer des chemins avec le mot-cl√© <code>pub</code></a></h3>
<!--
Let‚Äôs return to the error in Listing 7-4 that told us the `hosting` module is
private. We want the `eat_at_restaurant` function in the parent module to have
access to the `add_to_waitlist` function in the child module, so we mark the
`hosting` module with the `pub` keyword, as shown in Listing 7-5.
-->
<p>Retournons √† l'erreur de l'encart 7-4 qui nous informe que le module <code>accueil</code>
est priv√©. Nous voulons que la fonction <code>manger_au_restaurant</code> du module parent
ait acc√®s √† la fonction <code>ajouter_a_la_liste_attente</code> du module enfant, donc nous
utilisons le mot-cl√© <code>pub</code> sur le module <code>accueil</code>, comme dans l'encart 7-5.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">mod salle_a_manger {
    pub mod accueil {
        fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-5: Declaring the `hosting` module as `pub` to
use it from `eat_at_restaurant`</span>
-->
<p><span class="caption">Encart 7-5¬†: utiliser <code>pub</code> sur le module <code>accueil</code> permet
de l'utiliser dans <code>manger_au_restaurant</code></span></p>
<!--
Unfortunately, the code in Listing 7-5 still results in an error, as shown in
Listing 7-6.
-->
<p>Malheureusement, il reste une erreur dans le code de l'encart 7-5, la voici dans
l'encart 7-6.</p>
<!--
```console
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 -- > src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 -- > src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  -- > src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  -- > src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `ajouter_a_la_liste_attente` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ private function
  |
note: the function `ajouter_a_la_liste_attente` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn ajouter_a_la_liste_attente() {}
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `ajouter_a_la_liste_attente` is private
  --&gt; src/lib.rs:12:30
   |
12 |     salle_a_manger::accueil::ajouter_a_la_liste_attente();
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ private function
   |
note: the function `ajouter_a_la_liste_attente` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn ajouter_a_la_liste_attente() {}
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<!--
<span class="caption">Listing 7-6: Compiler errors from building the code in
Listing 7-5</span>
-->
<p><span class="caption">Encart 7-6¬†: erreurs de compilation du code de l'encart
7-5</span></p>
<!--
What happened? Adding the `pub` keyword in front of `mod hosting` makes the
module public. With this change, if we can access `front_of_house`, we can
access `hosting`. But the *contents* of `hosting` are still private; making the
module public doesn‚Äôt make its contents public. The `pub` keyword on a module
only lets code in its ancestor modules refer to it.
-->
<p>Que s'est-il pass√©¬†? Ajouter le mot-cl√© <code>pub</code> devant <code>mod accueil</code> rend public
le module. Avec cette modification, si nous pouvons acc√©der √† <code>salle_a_manger</code>,
alors nous pouvons acc√©der √† <code>accueil</code>. Mais le <em>contenu</em> de <code>accueil</code> reste
priv√©¬†; rendre le module public ne rend pas son contenu public. Le mot-cl√© <code>pub</code>
sur un module permet uniquement au code de ses parents d'y faire r√©f√©rence.</p>
<!--
The errors in Listing 7-6 say that the `add_to_waitlist` function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.
-->
<p>Les erreurs dans l'encart 7-6 nous informent que la fonction
<code>ajouter_a_la_liste_attente</code> est priv√©e. Les r√®gles de visibilit√© s'appliquent
aussi bien aux modules qu'aux structures, √©num√©rations, fonctions et m√©thodes.</p>
<!--
Let‚Äôs also make the `add_to_waitlist` function public by adding the `pub`
keyword before its definition, as in Listing 7-7.
-->
<p>Rendons publique la fonction <code>ajouter_a_la_liste_attente</code>, en ajoutant le
mot-cl√© <code>pub</code> devant sa d√©finition, comme dans l'encart 7-7.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-7: Adding the `pub` keyword to `mod hosting`
and `fn add_to_waitlist` lets us call the function from
`eat_at_restaurant`</span>
-->
<p><span class="caption">Encart 7-7¬†: ajout du mot-cl√© <code>pub</code> devant <code>mod accueil</code>
et <code>fn ajouter_a_la_liste_attente</code> pour nous permettre d'appeler la fonction √†
partir de <code>manger_au_restaurant</code></span></p>
<!--
Now the code will compile! Let‚Äôs look at the absolute and the relative path and
double-check why adding the `pub` keyword lets us use these paths in
`add_to_waitlist` with respect to the privacy rules.
-->
<p>Maintenant, le code va compiler¬†! Analysons les chemins relatif et absolu et
v√©rifions pourquoi l'ajout du mot-cl√© <code>pub</code> nous permet d'utiliser ces chemins
dans <code>ajouter_a_la_liste_attente</code> tout en respectant les r√®gles de visibilit√©.</p>
<!--
In the absolute path, we start with `crate`, the root of our crate‚Äôs module
tree. Then the `front_of_house` module is defined in the crate root. The
`front_of_house` module isn‚Äôt public, but because the `eat_at_restaurant`
function is defined in the same module as `front_of_house` (that is,
`eat_at_restaurant` and `front_of_house` are siblings), we can refer to
`front_of_house` from `eat_at_restaurant`. Next is the `hosting` module marked
with `pub`. We can access the parent module of `hosting`, so we can access
`hosting`. Finally, the `add_to_waitlist` function is marked with `pub` and we
can access its parent module, so this function call works!
-->
<p>Dans le chemin absolu, nous commen√ßons avec <code>crate</code>, la racine de l'arborescence
de modules de notre crate. Ensuite, le module <code>salle_a_manger</code> est d√©fini √† la
racine de la crate. Le module <code>salle_a_manger</code> n'est pas public, mais comme la
fonction <code>manger_au_restaurant</code> est d√©finie dans le m√™me module que
<code>salle_a_manger</code> (car <code>manger_au_restaurant</code> et <code>salle_a_manger</code> sont fr√®res),
nous pouvons utiliser <code>salle_a_manger</code> √† partir de <code>manger_au_restaurant</code>.
Ensuite, nous avons le module <code>accueil</code>, d√©fini avec <code>pub</code>. Nous pouvons acc√©der
au module parent de <code>accueil</code>, donc nous pouvons acc√©der √† <code>accueil</code>. Enfin, la
fonction <code>ajouter_a_la_liste_attente</code> est elle aussi d√©finie avec <code>pub</code> et nous
pouvons acc√©der √† son module parent, donc au final cet appel √† la fonction
fonctionne bien¬†!</p>
<!--
In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
`front_of_house`. The `front_of_house` module is defined within the same module
as `eat_at_restaurant`, so the relative path starting from the module in which
`eat_at_restaurant` is defined works. Then, because `hosting` and
`add_to_waitlist` are marked with `pub`, the rest of the path works, and this
function call is valid!
-->
<p>Dans le chemin relatif, le fonctionnement est le m√™me que le chemin absolu sauf
pour la premi√®re √©tape¬†: plut√¥t que de d√©marrer de la racine de la crate, le
chemin commence √† partir de <code>salle_a_manger</code>. Le module <code>salle_a_manger</code> est
d√©fini dans le m√™me module que <code>manger_au_restaurant</code>, donc le chemin relatif
qui commence √† partir du module o√π est d√©fini <code>manger_au_restaurant</code> fonctionne
bien. Ensuite, comme <code>accueil</code> et <code>ajouter_a_la_liste_attente</code> sont d√©finis avec
<code>pub</code>, le reste du chemin fonctionne, et cet appel √† la fonction est donc
valide¬†!</p>
<!--
### Starting Relative Paths with `super`
-->
<h3 id="commencer-les-chemins-relatifs-avec-super"><a class="header" href="#commencer-les-chemins-relatifs-avec-super">Commencer les chemins relatifs avec <code>super</code></a></h3>
<!--
We can also construct relative paths that begin in the parent module by using
`super` at the start of the path. This is like starting a filesystem path with
the `..` syntax. Why would we want to do this?
-->
<p>Nous pouvons aussi cr√©er des chemins relatifs qui commencent √† partir du module
parent en utilisant <code>super</code> au d√©but du chemin. C'est comme d√©buter un chemin
dans un syst√®me de fichiers avec la syntaxe <code>..</code>. Mais pourquoi voudrions-nous
faire cela¬†?</p>
<!--
Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function `fix_incorrect_order` calls the function `serve_order` by specifying
the path to `serve_order` starting with `super`:
-->
<p>Imaginons le code dans l'encart 7-8 qui repr√©sente le cas o√π le chef corrige une
commande erron√©e et l'apporte personnellement au client pour s'excuser. La
fonction <code>corriger_commande_erronee</code> appelle la fonction <code>servir_commande</code> en
commen√ßant le chemin de <code>servir_commande</code> avec <code>super</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
```
-->
<pre><code class="language-rust noplayground test_harness">fn servir_commande() {}

mod cuisines {
    fn corriger_commande_erronee() {
        cuisiner_commande();
        super::servir_commande();
    }

    fn cuisiner_commande() {}
}
</code></pre>
<!--
<span class="caption">Listing 7-8: Calling a function using a relative path
starting with `super`</span>
-->
<p><span class="caption">Encart 7-8¬†: appel d'une fonction en utilisant un chemin
relatif qui commence par <code>super</code></span></p>
<!--
The `fix_incorrect_order` function is in the `back_of_house` module, so we can
use `super` to go to the parent module of `back_of_house`, which in this case
is `crate`, the root. From there, we look for `serve_order` and find it.
Success! We think the `back_of_house` module and the `serve_order` function are
likely to stay in the same relationship to each other and get moved together
should we decide to reorganize the crate‚Äôs module tree. Therefore, we used
`super` so we‚Äôll have fewer places to update code in the future if this code
gets moved to a different module.
-->
<p>La fonction <code>corriger_commande_erronee</code> est dans le module <code>cuisines</code>, donc nous
pouvons utiliser <code>super</code> pour nous rendre au module parent de <code>cuisines</code>, qui
dans notre cas est <code>crate</code>, la racine. De l√†, nous cherchons <code>servir_commande</code>
et nous la trouvons. Avec succ√®s¬†! Nous pensons que le module <code>cuisines</code> et la
fonction <code>servir_commande</code> vont toujours garder la m√™me relation et devrons √™tre
d√©plac√©s ensemble si nous r√©organisons l'arborescence de modules de la crate.
Ainsi, nous avons utilis√© <code>super</code> pour avoir moins de code √† mettre √† jour √†
l'avenir si ce code est d√©plac√© dans un module diff√©rent.</p>
<!--
### Making Structs and Enums Public
-->
<h3 id="rendre-publiques-des-structures-et-des-√©num√©rations"><a class="header" href="#rendre-publiques-des-structures-et-des-√©num√©rations">Rendre publiques des structures et des √©num√©rations</a></h3>
<!--
We can also use `pub` to designate structs and enums as public, but there are a
few extra details. If we use `pub` before a struct definition, we make the
struct public, but the struct‚Äôs fields will still be private. We can make each
field public or not on a case-by-case basis. In Listing 7-9, we‚Äôve defined a
public `back_of_house::Breakfast` struct with a public `toast` field but a
private `seasonal_fruit` field. This models the case in a restaurant where the
customer can pick the type of bread that comes with a meal, but the chef
decides which fruit accompanies the meal based on what‚Äôs in season and in
stock. The available fruit changes quickly, so customers can‚Äôt choose the fruit
or even see which fruit they‚Äôll get.
-->
<p>Nous pouvons aussi utiliser <code>pub</code> pour d√©clarer des structures et des
√©num√©rations publiquement, mais il y a d'autres points √† prendre en compte. Si
nous utilisons <code>pub</code> avant la d√©finition d'une structure, nous rendons la
structure publique, mais les champs de la structure restent priv√©s. Nous pouvons
rendre chaque champ public ou non au cas par cas. Dans l'encart 7-9, nous avons
d√©fini une structure publique <code>cuisines::PetitDejeuner</code> avec un champ public
<code>tartine_grillee</code> mais avec un champ priv√© <code>fruit_de_saison</code>. Cela simule un
restaurant o√π le client peut choisir le type de pain qui accompagne le repas,
mais le chef d√©cide des fruits qui accompagnent le repas en fonction de la
saison et ce qu'il y a en stock. Les fruits disponibles changent rapidement,
donc les clients ne peuvent pas choisir le fruit ou m√™me voir quel fruit ils
obtiendront.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```
-->
<pre><code class="language-rust noplayground">mod cuisines {
    pub struct PetitDejeuner {
        pub tartine_grillee: String,
        fruit_de_saison: String,
    }

    impl PetitDejeuner {
        pub fn en_ete(tartine_grillee: &amp;str) -&gt; PetitDejeuner {
            PetitDejeuner {
                tartine_grillee: String::from(tartine_grillee),
                fruit_de_saison: String::from(&quot;p√™ches&quot;),
            }
        }
    }
}

pub fn manger_au_restaurant() {
    // On commande un petit-d√©jeuner en √©t√© avec tartine grill√©e au seigle
    let mut repas = cuisines::PetitDejeuner::en_ete(&quot;seigle&quot;);
    // On change d'avis sur le pain que nous souhaitons
    repas.tartine_grillee = String::from(&quot;bl√©&quot;);
    println!( &quot;Je voudrais une tartine grill√©e au {}, s'il vous pla√Æt.&quot;,
              repas.tartine_grillee);

    // La prochaine ligne ne va pas se compiler si nous ne la commentons pas,
    // car nous ne sommes pas autoris√©s √† voir ou modifier le fruit de saison
    // qui accompagne le repas.

    // repas.fruit_de_saison = String::from(&quot;myrtilles&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 7-9: A struct with some public fields and some
private fields</span>
-->
<p><span class="caption">Encart 7-9¬†: une structure avec certains champs publics et
d'autres priv√©s</span></p>
<!--
Because the `toast` field in the `back_of_house::Breakfast` struct is public,
in `eat_at_restaurant` we can write and read to the `toast` field using dot
notation. Notice that we can‚Äôt use the `seasonal_fruit` field in
`eat_at_restaurant` because `seasonal_fruit` is private. Try uncommenting the
line modifying the `seasonal_fruit` field value to see what error you get!
-->
<p>Comme le champ <code>tartine_grillee</code> est public dans la structure
<code>cuisines::PetitDejeuner</code>, nous pouvons lire et √©crire dans le champ
<code>tartine_grillee</code> √† partir de <code>manger_au_restaurant</code> en utilisant <code>.</code>. Notez
aussi que nous ne pouvons pas utiliser le champ <code>fruit_de_saison</code> dans
<code>manger_au_restaurant</code> car <code>fruit_de_saison</code> est priv√©. Essayez de d√©-commenter
la ligne qui tente de modifier la valeur du champ <code>fruit_de_saison</code> et voyez
l'erreur que vous obtenez¬†!</p>
<!--
Also, note that because `back_of_house::Breakfast` has a private field, the
struct needs to provide a public associated function that constructs an
instance of `Breakfast` (we‚Äôve named it `summer` here). If `Breakfast` didn‚Äôt
have such a function, we couldn‚Äôt create an instance of `Breakfast` in
`eat_at_restaurant` because we couldn‚Äôt set the value of the private
`seasonal_fruit` field in `eat_at_restaurant`.
-->
<p>Aussi, remarquez que comme <code>cuisines::PetitDejeuner</code> a un champ priv√©, la
structure a besoin de fournir une fonction associ√©e publique qui construit une
instance de <code>PetitDejeuner</code> (que nous avons nomm√©e <code>en_ete</code> ici). Si
<code>PetitDejeuner</code> n'avait pas une fonction comme celle-ci, nous ne pourrions pas
cr√©er une instance de <code>PetitDejeuner</code> dans <code>manger_au_restaurant</code> car nous ne
pourrions pas donner une valeur au champ priv√© <code>fruit_de_saison</code> dans
<code>manger_au_restaurant</code>.</p>
<!--
In contrast, if we make an enum public, all of its variants are then public. We
only need the `pub` before the `enum` keyword, as shown in Listing 7-10.
-->
<p>Par contre, si nous rendons publique une √©num√©ration, toutes ses variantes
seront publiques. Nous avons simplement besoin d'un <code>pub</code> devant le mot-cl√©
<code>enum</code>, comme dans l'encart 7-10.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```
-->
<pre><code class="language-rust noplayground">mod cuisines {
    pub enum AmuseBouche {
        Soupe,
        Salade,
    }
}

pub fn manger_au_restaurant() {
    let commande1 = cuisines::AmuseBouche::Soupe;
    let commande2 = cuisines::AmuseBouche::Salade;
}
</code></pre>
<!--
<span class="caption">Listing 7-10: Designating an enum as public makes all its
variants public</span>
-->
<p><span class="caption">Encart 7-10¬†: on rend publique une √©num√©ration et cela
rend aussi toutes ses variantes publiques</span></p>
<!--
Because we made the `Appetizer` enum public, we can use the `Soup` and `Salad`
variants in `eat_at_restaurant`. Enums aren‚Äôt very useful unless their variants
are public; it would be annoying to have to annotate all enum variants with
`pub` in every case, so the default for enum variants is to be public. Structs
are often useful without their fields being public, so struct fields follow the
general rule of everything being private by default unless annotated with `pub`.
-->
<p>Comme nous rendons l'√©num√©ration <code>AmuseBouche</code> publique, nous pouvons utiliser
les variantes <code>Soupe</code> et <code>Salade</code> dans <code>manger_au_restaurant</code>. Les √©num√©rations
ne sont pas tr√®s utiles si elles n'ont pas leurs variantes publiques¬†; et cela
serait p√©nible d'avoir √† marquer toutes les variantes de l'√©num√©ration avec
<code>pub</code>, donc par d√©faut les variantes d'√©num√©rations sont publiques. Les
structures sont souvent utiles sans avoir de champs publics, donc les champs des
structures sont tous priv√©s par d√©faut, sauf si ces √©l√©ments sont marqu√©s d'un
<code>pub</code>.</p>
<!--
There‚Äôs one more situation involving `pub` that we haven‚Äôt covered, and that is
our last module system feature: the `use` keyword. We‚Äôll cover `use` by itself
first, and then we‚Äôll show how to combine `pub` and `use`.
-->
<p>Il y a encore une chose que nous n'avons pas abord√©e concernant <code>pub</code>, et c'est
la derni√®re fonctionnalit√© du syst√®me de modules¬†: le mot-cl√© <code>use</code>. Nous
commencerons par parler de l'utilisation de <code>use</code> de mani√®re g√©n√©rale, puis nous
verrons comment combiner <code>pub</code> et <code>use</code>.</p>
<!--
[pub]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Bringing Paths into Scope with the `use` Keyword
-->
<h2 id="importer-des-chemins-dans-la-port√©e-via-le-mot-cl√©-use"><a class="header" href="#importer-des-chemins-dans-la-port√©e-via-le-mot-cl√©-use">Importer des chemins dans la port√©e via le mot-cl√© <code>use</code></a></h2>
<!--
It might seem like the paths we‚Äôve written to call functions so far are
inconveniently long and repetitive. For example, in Listing 7-7, whether we
chose the absolute or relative path to the `add_to_waitlist` function, every
time we wanted to call `add_to_waitlist` we had to specify `front_of_house` and
`hosting` too. Fortunately, there‚Äôs a way to simplify this process. We can
bring a path into a scope once and then call the items in that path as if
they‚Äôre local items with the `use` keyword.
-->
<p>Les chemins que nous avons √©crits jusqu'ici peuvent para√Ætre p√©nibles car trop
longs et r√©p√©titifs. Par exemple, dans l'encart 7-7, que nous ayons choisi
d'utiliser le chemin absolu ou relatif pour la fonction
<code>ajouter_a_la_liste_attente</code>, nous aurions d√ª aussi √©crire <code>salle_a_manger</code> et
<code>accueil</code> √† chaque fois que nous voulions appeler <code>ajouter_a_la_liste_attente</code>.
Heureusement, il existe une solution pour simplifier ce cheminement.
Nous pouvons importer un chemin dans la port√©e et appeler ensuite les √©l√©ments
de ce chemin comme s'ils √©taient locaux gr√¢ce au mot-cl√© <code>use</code>.</p>
<!--
In Listing 7-11, we bring the `crate::front_of_house::hosting` module into the
scope of the `eat_at_restaurant` function so we only have to specify
`hosting::add_to_waitlist` to call the `add_to_waitlist` function in
`eat_at_restaurant`.
-->
<p>Dans l'encart 7-11, nous importons le module <code>crate::salle_a_manger::accueil</code>
dans la port√©e de la fonction <code>manger_au_restaurant</code> afin que nous n'ayons plus
qu'√† utiliser <code>accueil::ajouter_a_la_liste_attente</code> pour appeler la fonction
<code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-11: Bringing a module into scope with
`use`</span>
-->
<p><span class="caption">Encart 7-11¬†: importer un module dans la port√©e via <code>use</code>
</span></p>
<!--
Adding `use` and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding `use crate::front_of_house::hosting` in the crate
root, `hosting` is now a valid name in that scope, just as though the `hosting`
module had been defined in the crate root. Paths brought into scope with `use`
also check privacy, like any other paths.
-->
<p>Dans une port√©e, utiliser un <code>use</code> et un chemin s'apparente √† cr√©er un lien
symbolique dans le syst√®me de fichier. Gr√¢ce √† l'ajout de
<code>use crate::salle_a_manger::accueil</code> √† la racine de la crate, <code>accueil</code> est
maintenant un nom valide dans cette port√©e, comme si le module <code>accueil</code> avait
√©t√© d√©fini √† la racine de la crate. Les chemins import√©s dans la port√©e via
<code>use</code> doivent respecter les r√®gles de visibilit√©, tout comme les autres chemins.</p>
<!--
You can also bring an item into scope with `use` and a relative path. Listing
7-12 shows how to specify a relative path to get the same behavior as in
Listing 7-11.
-->
<p>Vous pouvez aussi importer un √©l√©ment dans la port√©e avec <code>use</code> et un chemin
relatif. L'encart 7-12 nous montre comment utiliser un chemin relatif pour
obtenir le m√™me r√©sultat que l'encart 7-11.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-12: Bringing a module into scope with `use` and
a relative path</span>
-->
<p><span class="caption">Encart 7-12¬†: importer un module dans la port√©e avec <code>use</code>
et un chemin relatif</span></p>
<!--
### Creating Idiomatic `use` Paths
-->
<h3 id="cr√©er-des-chemins-id√©aux-pour-use"><a class="header" href="#cr√©er-des-chemins-id√©aux-pour-use">Cr√©er des chemins id√©aux pour <code>use</code></a></h3>
<!--
In Listing 7-11, you might have wondered why we specified `use
crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` in
`eat_at_restaurant` rather than specifying the `use` path all the way out to
the `add_to_waitlist` function to achieve the same result, as in Listing 7-13.
-->
<p>Dans l'encart 7-11, vous vous √™tes peut-√™tre demand√© pourquoi nous avions
utilis√© <code>use crate::salle_a_manger::accueil</code> et appel√© ensuite
<code>accueil::ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code> plut√¥t que
d'√©crire le chemin du <code>use</code> jusqu'√† la fonction <code>ajouter_a_la_liste_attente</code>
pour avoir le m√™me r√©sultat, comme dans l'encart 7-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil::ajouter_a_la_liste_attente;

pub fn manger_au_restaurant() {
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-13: Bringing the `add_to_waitlist` function
into scope with `use`, which is unidiomatic</span>
-->
<p><span class="caption">Encart 7-13¬†: importer la fonction
<code>ajouter_a_la_liste_attente</code> dans la port√©e avec <code>use</code>, ce qui n'est pas id√©al
</span></p>
<!--
Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with `use`. Bringing the
function‚Äôs parent module into scope with `use` means we have to specify the
parent module when calling the function. Specifying the parent module when
calling the function makes it clear that the function isn‚Äôt locally defined
while still minimizing repetition of the full path. The code in Listing 7-13 is
unclear as to where `add_to_waitlist` is defined.
-->
<p>Bien que l'encart 7-11 et 7-13 accomplissent la m√™me t√¢che, l'encart 7-11 est la
fa√ßon id√©ale d'importer une fonction dans la port√©e via <code>use</code>. L'import du
module parent de la fonction dans notre port√©e avec <code>use</code> n√©cessite que nous
ayons √† pr√©ciser le module parent quand nous appelons la fonction. Renseigner le
module parent lorsque nous appelons la fonction pr√©cise clairement que la
fonction n'est pas d√©finie localement, tout en minimisant la r√©p√©tition du
chemin complet. Nous ne pouvons pas rep√©rer facilement l√† o√π est d√©fini
<code>ajouter_a_la_liste_attente</code> dans l'encart 7-13.</p>
<!--
On the other hand, when bringing in structs, enums, and other items with `use`,
it‚Äôs idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library‚Äôs `HashMap` struct into the scope of a binary
crate.
-->
<p>Cela dit, lorsque nous importons des structures, des √©num√©rations, et d'autres
√©l√©ments avec <code>use</code>, il est id√©al de pr√©ciser le chemin complet. L'encart 7-14
montre la mani√®re id√©ale d'importer la structure <code>HashMap</code> de la biblioth√®que
standard dans la port√©e d'une crate binaire.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<!--
<span class="caption">Listing 7-14: Bringing `HashMap` into scope in an
idiomatic way</span>
-->
<p><span class="caption">Encart 7-14¬†: import de <code>HashMap</code> dans la port√©e de
mani√®re id√©ale</span></p>
<!--
There‚Äôs no strong reason behind this idiom: it‚Äôs just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.
-->
<p>Il n'y a pas de forte justification √† cette pratique¬†: c'est simplement une
convention qui a germ√©, et les gens se sont habitu√©s √† lire et √©crire du code
Rust de cette fa√ßon.</p>
<!--
The exception to this idiom is if we‚Äôre bringing two items with the same name
into scope with `use` statements, because Rust doesn‚Äôt allow that. Listing 7-15
shows how to bring two `Result` types into scope that have the same name but
different parent modules and how to refer to them.
-->
<p>Il y a une exception √† cette pratique¬†: nous ne pouvons pas utiliser
l'instruction <code>use</code> pour importer deux √©l√©ments avec le m√™me nom dans la port√©e,
car Rust ne l'autorise pas. L'encart 7-15 nous montre comment importer puis
utiliser deux types <code>Result</code> ayant le m√™me nom mais dont les modules parents
sont distincts.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
#     Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn fonction1() -&gt; fmt::Result {
    // -- partie masqu√©e ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; io::Result&lt;()&gt; {
    // -- partie masqu√©e ici --
<span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span>
-->
<p><span class="caption">Encart 7-15¬†: l'import de deux types ayant le m√™me nom
dans la m√™me port√©e n√©cessite d'utiliser leurs modules parents.</span></p>
<!--
As you can see, using the parent modules distinguishes the two `Result` types.
If instead we specified `use std::fmt::Result` and `use std::io::Result`, we‚Äôd
have two `Result` types in the same scope and Rust wouldn‚Äôt know which one we
meant when we used `Result`.
-->
<p>Comme vous pouvez le constater, l'utilisation des modules parents permet de
distinguer les deux types <code>Result</code>. Si nous avions utilis√©
<code>use std::fmt::Result</code> et <code>use std::io::Result</code>, nous aurions deux types nomm√©s
<code>Result</code> dans la m√™me port√©e et donc Rust ne pourrait pas comprendre lequel nous
voudrions utiliser en demandant <code>Result</code>.</p>
<!--
### Providing New Names with the `as` Keyword
-->
<h3 id="renommer-des-√©l√©ments-avec-le-mot-cl√©-as"><a class="header" href="#renommer-des-√©l√©ments-avec-le-mot-cl√©-as">Renommer des √©l√©ments avec le mot-cl√© <code>as</code></a></h3>
<!--
There‚Äôs another solution to the problem of bringing two types of the same name
into the same scope with `use`: after the path, we can specify `as` and a new
local name, or alias, for the type. Listing 7-16 shows another way to write the
code in Listing 7-15 by renaming one of the two `Result` types using `as`.
-->
<p>Il y a une autre solution au fait d'avoir deux types du m√™me nom dans la m√™me
port√©e √† cause de <code>use</code>¬†: apr√®s le chemin, nous pouvons rajouter <code>as</code> suivi d'un
nouveau nom local, ou alias, sur le type. L'encart 7-16 nous montre une autre
fa√ßon d'√©crire le code de l'encart 7-15 en utilisant <code>as</code> pour renommer un des
deux types <code>Result</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
#     Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn fonction1() -&gt; Result {
    // -- partie masqu√©e ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; IoResult&lt;()&gt; {
    // -- partie masqu√©e ici --
<span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 7-16: Renaming a type when it‚Äôs brought into
scope with the `as` keyword</span>
-->
<p><span class="caption">Encart 7-16¬†: renommer un type lorsqu'il est import√© dans
la port√©e, avec le mot-cl√© <code>as</code></span></p>
<!--
In the second `use` statement, we chose the new name `IoResult` for the
`std::io::Result` type, which won‚Äôt conflict with the `Result` from `std::fmt`
that we‚Äôve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!
-->
<p>Dans la seconde instruction <code>use</code>, nous avons choisi <code>IoResult</code> comme nouveau
nom du type <code>std::io::Result</code>, qui n'est plus en conflit avec le <code>Result</code> de
<code>std::fmt</code> que nous avons aussi import√© dans la port√©e. Les encarts 7-15 et 7-16
sont id√©aux, donc le choix vous revient¬†!</p>
<!--
### Re-exporting Names with `pub use`
-->
<h3 id="r√©exporter-des-√©l√©ments-avec-pub-use"><a class="header" href="#r√©exporter-des-√©l√©ments-avec-pub-use">R√©exporter des √©l√©ments avec <code>pub use</code></a></h3>
<!--
When we bring a name into scope with the `use` keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code‚Äôs scope, we can combine `pub`
and `use`. This technique is called *re-exporting* because we‚Äôre bringing
an item into scope but also making that item available for others to bring into
their scope.
-->
<p>Lorsque nous importons un √©l√©ment dans la port√©e avec le mot-cl√© <code>use</code>, son nom
dans la nouvelle port√©e est priv√©. Pour permettre au code appelant d'utiliser ce
nom comme s'il √©tait d√©fini dans cette port√©e, nous pouvons associer <code>pub</code> et
<code>use</code>. Cette technique est appel√©e <em>r√©exporter</em> car nous importons un √©l√©ment
dans la port√©e, mais nous rendons aussi cet √©l√©ment disponible aux port√©es des
autres.</p>
<!--
Listing 7-17 shows the code in Listing 7-11 with `use` in the root module
changed to `pub use`.
-->
<p>L'encart 7-17 nous montre le code de l'encart 7-11 o√π le <code>use</code> du module racine
a √©t√© remplac√© par <code>pub use</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with `pub use`</span>
-->
<p><span class="caption">Encart 7-17¬†: rendre un √©l√©ment disponible pour n'importe
quel code qui l'importera dans sa port√©e, avec <code>pub use</code></span></p>
<!--
By using `pub use`, external code can now call the `add_to_waitlist` function
using `hosting::add_to_waitlist`. If we hadn‚Äôt specified `pub use`, the
`eat_at_restaurant` function could call `hosting::add_to_waitlist` in its
scope, but external code couldn‚Äôt take advantage of this new path.
-->
<p>Gr√¢ce √† <code>pub use</code>, le code externe peut maintenant appeler la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant <code>accueil::ajouter_a_la_liste_attente</code>.
Si nous n'avions pas utilis√© <code>pub use</code>, la fonction <code>manger_au_restaurant</code>
aurait pu appeler <code>accueil::ajouter_a_la_liste_attente</code> dans sa port√©e, mais le
code externe n'aurait pas pu profiter de ce nouveau chemin.</p>
<!--
Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about ‚Äúfront of house‚Äù and ‚Äúback of house.‚Äù But customers visiting a restaurant
probably won‚Äôt think about the parts of the restaurant in those terms. With
`pub use`, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.
-->
<p>R√©exporter est utile quand la structure interne de votre code est diff√©rente de
la fa√ßon dont les d√©veloppeurs qui utilisent votre code se la repr√©sentent. Par
exemple, dans cette m√©taphore du restaurant, les personnes qui font fonctionner
le restaurant se structurent en fonction de la ‚Äúsalle √† manger‚Äù et des
‚Äúcuisines‚Äù. Mais les clients qui utilisent le restaurant ne vont probablement
pas voir les choses ainsi. Avec <code>pub use</code>, nous pouvons √©crire notre code selon
une certaine organisation, mais l'exposer avec une organisation diff√©rente. En
faisant ainsi, la biblioth√®que est bien organis√©e autant pour les d√©veloppeurs
qui travaillent sur la biblioth√®que que pour les d√©veloppeurs qui utilisent la
biblioth√®que.</p>
<!--
### Using External Packages
-->
<h3 id="utiliser-des-paquets-externes"><a class="header" href="#utiliser-des-paquets-externes">Utiliser des paquets externes</a></h3>
<!--
In Chapter 2, we programmed a guessing game project that used an external
package called `rand` to get random numbers. To use `rand` in our project, we
added this line to *Cargo.toml*:
-->
<p>Dans le chapitre 2, nous avions d√©velopp√© un projet de jeu du plus ou du moins
qui utilisait le paquet externe <code>rand</code> afin d'obtenir des nombres al√©atoires.
Pour pouvoir utiliser <code>rand</code> dans notre projet, nous avions ajout√© cette ligne
dans <em>Cargo.toml</em>¬†:</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
rand = "0.8.3"
```
-->
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<!--
Adding `rand` as a dependency in *Cargo.toml* tells Cargo to download the
`rand` package and any dependencies from [crates.io](https://crates.io/) and
make `rand` available to our project.
-->
<p>L'ajout de <code>rand</code> comme d√©pendance dans <em>Cargo.toml</em> demande √† Cargo de
t√©l√©charger le paquet <code>rand</code> et toutes ses d√©pendances √† partir de
<a href="https://crates.io/">crates.io</a> et rend disponible <code>rand</code> pour notre projet.</p>
<!--
Then, to bring `rand` definitions into the scope of our package, we added a
`use` line starting with the name of the crate, `rand`, and listed the items
we wanted to bring into scope. Recall that in the [‚ÄúGenerating a Random
Number‚Äù][rand]<!-- ignore -- > section in Chapter 2, we brought the `Rng` trait
into scope and called the `rand::thread_rng` function:
-->
<p>Ensuite, pour importer les d√©finitions de <code>rand</code> dans la port√©e de notre paquet,
nous avions ajout√© une ligne <code>use</code> qui commence avec le nom de la crate, <code>rand</code>,
et nous avions list√© les √©l√©ments que nous voulions importer dans notre port√©e.
Dans la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">‚ÄúG√©n√©rer le nombre secret‚Äù</a><!-- ignore --> du chapitre 2,
nous avions import√© le trait <code>Rng</code> dans la port√©e, puis nous avions appel√© la
fonction <code>rand::thread_rng</code>¬†:</p>
<!--
```rust,ignore
# use std::io;
use rand::Rng;

fn main() {
#     println!("Guess the number!");
# 
    let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span>    let nombre_secret = rand::thread_rng().gen_range(1..101);
<span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span>}
</code></pre>
<!--
Members of the Rust community have made many packages available at
[crates.io](https://crates.io/), and pulling any of them into your package
involves these same steps: listing them in your package‚Äôs *Cargo.toml* file and
using `use` to bring items from their crates into scope.
-->
<p>Les membres de la communaut√© Rust ont mis √† disposition de nombreux paquets sur
<a href="https://crates.io/">crates.io</a>, et utiliser l'un d'entre eux dans votre paquet
implique toujours ces m√™mes √©tapes¬†: les lister dans le fichier <em>Cargo.toml</em> de
votre paquet et utiliser <code>use</code> pour importer certains √©l√©ments de ces crates
dans la port√©e.</p>
<!--
Note that the standard library (`std`) is also a crate that‚Äôs external to our
package. Because the standard library is shipped with the Rust language, we
don‚Äôt need to change *Cargo.toml* to include `std`. But we do need to refer to
it with `use` to bring items from there into our package‚Äôs scope. For example,
with `HashMap` we would use this line:
-->
<p>Notez que la biblioth√®que standard (<code>std</code>) est aussi une crate qui est externe √†
notre paquet. Comme la biblioth√®que standard est livr√©e avec le langage Rust,
nous n'avons pas √† modifier le <em>Cargo.toml</em> pour y inclure <code>std</code>. Mais nous
devons utiliser <code>use</code> pour importer les √©l√©ments qui se trouvent dans la port√©e
de notre paquet. Par exemple, pour <code>HashMap</code>, nous pourrions utiliser cette
ligne¬†:</p>
<!--
```rust
use std::collections::HashMap;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<!--
This is an absolute path starting with `std`, the name of the standard library
crate.
-->
<p>C'est un chemin absolu qui commence par <code>std</code>, le nom de la crate de la
biblioth√®que standard.</p>
<!--
### Using Nested Paths to Clean Up Large `use` Lists
-->
<h3 id="utiliser-des-chemins-imbriqu√©s-pour-simplifier-les-grandes-listes-de-use"><a class="header" href="#utiliser-des-chemins-imbriqu√©s-pour-simplifier-les-grandes-listes-de-use">Utiliser des chemins imbriqu√©s pour simplifier les grandes listes de <code>use</code></a></h3>
<!--
If we‚Äôre using multiple items defined in the same crate or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two `use` statements we had in the Guessing Game in
Listing 2-4 bring items from `std` into scope:
-->
<p>Si vous utilisez de nombreux √©l√©ments d√©finis dans une m√™me crate ou dans un
m√™me module, lister chaque √©l√©ment sur sa propre ligne prendra beaucoup d'espace
vertical dans vos fichiers. Par exemple, ces deux instructions <code>use</code>, que nous
avions dans le jeu du plus ou du moins dans l'encart 2-4, importaient des
√©l√©ments de <code>std</code> dans la port√©e¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masqu√©e ici --
use std::cmp::Ordering;
use std::io;
// -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagn√©¬†!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.
-->
<p>√Ä la place, nous pouvons utiliser des chemins imbriqu√©s afin d'importer ces
m√™mes √©l√©ments dans la port√©e en une seule ligne. Nous pouvons faire cela en
indiquant la partie commune du chemin, suivi d'un double deux-points, puis
d'accolades autour d'une liste des √©l√©ments qui diff√®rent entre les chemins,
comme dans l'encart 7-18¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masqu√©e ici --
use std::{cmp::Ordering, io};
// -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez saisir un nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagn√©¬†!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span>
-->
<p><span class="caption">Encart 7-18¬†: utiliser un chemin imbriqu√© pour importer
plusieurs √©l√©ments avec le m√™me pr√©fixe dans la port√©e</span></p>
<!--
In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate `use` statements
needed by a lot!
-->
<p>Pour des programmes plus gros, importer plusieurs √©l√©ments dans la port√©e depuis
la m√™me crate ou module en utilisant des chemins imbriqu√©s peut r√©duire
consid√©rablement le nombre de <code>use</code> utilis√©s¬†!</p>
<!--
We can use a nested path at any level in a path, which is useful when combining
two `use` statements that share a subpath. For example, Listing 7-19 shows two
`use` statements: one that brings `std::io` into scope and one that brings
`std::io::Write` into scope.
-->
<p>Nous pouvons utiliser un chemin imbriqu√© √† tous les niveaux d'un chemin, ce qui
peut √™tre utile lorsqu'on utilise deux instructions <code>use</code> qui partagent un
sous-chemin. Par exemple, l'encart 7-19 nous montre deux instructions <code>use</code>¬†:
une qui importe <code>std::io</code> dans la port√©e et une autre qui importe
<code>std::io::Write</code> dans la port√©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::io;
use std::io::Write;
```
-->
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;
</code></pre>
<!--
<span class="caption">Listing 7-19: Two `use` statements where one is a subpath
of the other</span>
-->
<p><span class="caption">Encart 7-19¬†: deux instructions <code>use</code> o√π l'une est un
sous-chemin de l'autre</span></p>
<!--
The common part of these two paths is `std::io`, and that‚Äôs the complete first
path. To merge these two paths into one `use` statement, we can use `self` in
the nested path, as shown in Listing 7-20.
-->
<p>La partie commune entre ces deux chemins est <code>std::io</code>, et c'est le premier
chemin complet. Pour imbriquer ces deux chemins en une seule instruction <code>use</code>,
nous pouvons utiliser <code>self</code> dans le chemin imbriqu√©, comme dans l'encart 7-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::io::{self, Write};
```
-->
<pre><code class="language-rust noplayground">use std::io::{self, Write};
</code></pre>
<!--
<span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one `use` statement</span>
-->
<p><span class="caption">Encart 7-20¬†: imbrication des chemins de l'encart 7-19
dans une seule instruction <code>use</code></span></p>
<!--
This line brings `std::io` and `std::io::Write` into scope.
-->
<p>Cette ligne importe <code>std::io</code> et <code>std::io::Write</code> dans la port√©e.</p>
<!--
### The Glob Operator
-->
<h3 id="lop√©rateur-global"><a class="header" href="#lop√©rateur-global">L'op√©rateur global</a></h3>
<!--
If we want to bring *all* public items defined in a path into scope, we can
specify that path followed by `*`, the glob operator:
-->
<p>Si nous voulons importer, dans la port√©e, <em>tous</em> les √©l√©ments publics d√©finis
dans un chemin, nous pouvons indiquer ce chemin suivi par <code>*</code>, l'op√©rateur
global¬†:</p>
<!--
```rust
use std::collections::*;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This `use` statement brings all public items defined in `std::collections` into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.
-->
<p>Cette instruction <code>use</code> va importer tous les √©l√©ments publics d√©finis dans
<code>std::collections</code> dans la port√©e courante. Mais soyez prudent quand vous
utilisez l'op√©rateur global¬†! L'op√©rateur global rend difficile √† dire quels
√©l√©ments sont dans la port√©e et l√† o√π un √©l√©ment utilis√© dans notre programme a
√©t√© d√©fini.</p>
<!--
The glob operator is often used when testing to bring everything under test
into the `tests` module; we‚Äôll talk about that in the [‚ÄúHow to Write
Tests‚Äù][writing-tests]<!-- ignore -- > section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see [the standard
library documentation](../std/prelude/index.html#other-preludes)<!-- ignore -- >
for more information on that pattern.
-->
<p>L'op√©rateur global est souvent utilis√© lorsque nous √©crivons des tests, pour
importer tout ce qu'il y a √† tester dans le module <code>tests</code>¬†; nous verrons cela
dans une section du <a href="ch11-01-writing-tests.html">chapitre 11</a>. L'op√©rateur global est parfois
aussi utilis√© pour l'√©tape pr√©liminaire¬†: rendez-vous dans <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">la documentation de
la biblioth√®que
standard</a><!--
ignore --> pour plus d'informations sur cela.</p>
<!--
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
[writing-tests]: ch11-01-writing-tests.html#how-to-write-tests
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Separating Modules into Different Files
-->
<h2 id="s√©parer-les-modules-dans-diff√©rents-fichiers"><a class="header" href="#s√©parer-les-modules-dans-diff√©rents-fichiers">S√©parer les modules dans diff√©rents fichiers</a></h2>
<!--
So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.
-->
<p>Jusqu'√† pr√©sent, tous les exemples de ce chapitre ont d√©fini plusieurs modules
dans un seul fichier. Quand les modules vont grossir, vous allez probablement
vouloir d√©placer leurs d√©finitions dans un fichier s√©par√© pour faciliter le
parcours de votre code.</p>
<!--
For example, let‚Äôs start from the code in Listing 7-17 and move the
`front_of_house` module to its own file *src/front_of_house.rs* by changing the
crate root file so it contains the code shown in Listing 7-21. In this case,
the crate root file is *src/lib.rs*, but this procedure also works with binary
crates whose crate root file is *src/main.rs*.
-->
<p>Prenons par exemple le code de l'encart 7-17 et d√©pla√ßons le module
<code>salle_a_manger</code> dans son propre fichier <em>src/salle_a_manger.rs</em> en changeant le
fichier √† la racine de la crate afin qu'il corresponde au code de l'encart 7-21.
Dans notre cas, le fichier √† la racine de la crate est <em>src/lib.rs</em>, mais cette
proc√©dure fonctionne aussi avec les crates binaires dans lesquelles le fichier √†
la racine de la crate est <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore">mod salle_a_manger;

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-21: Declaring the `front_of_house` module whose
body will be in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Encart 7-21¬†: D√©claration du module <code>salle_a_manger</code> dont
le corps sera dans <em>src/salle_a_manger.rs</em></span></p>
<!--
And *src/front_of_house.rs* gets the definitions from the body of the
`front_of_house` module, as shown in Listing 7-22.
-->
<p>Et <em>src/salle_a_manger.rs</em> contiendra la d√©finition du corps du module
<code>salle_a_manger</code>, comme dans l'encart 7-22.</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">Fichier¬†: src/salle_a_manger.rs</span></p>
<!--
```rust,ignore
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```
-->
<pre><code class="language-rust ignore">pub mod accueil {
    pub fn ajouter_a_la_liste_attente() {}
}
</code></pre>
<!--
<span class="caption">Listing 7-22: Definitions inside the `front_of_house`
module in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Encart 7-22¬†: Les d√©finitions √† l'int√©rieur du module
<code>salle_a_manger</code> dans <em>src/salle_a_manger.rs</em></span></p>
<!--
Using a semicolon after `mod front_of_house` rather than using a block tells
Rust to load the contents of the module from another file with the same name as
the module. To continue with our example and extract the `hosting` module to
its own file as well, we change *src/front_of_house.rs* to contain only the
declaration of the `hosting` module:
-->
<p>Utiliser un point-virgule apr√®s <code>mod salle_a_manger</code> plut√¥t que de cr√©er un bloc
indique √† Rust de charger le contenu du module √† partir d'un autre fichier qui
porte le m√™me nom que le module. Pour continuer avec notre exemple et d√©placer
√©galement le module <code>accueil</code> dans son propre fichier, nous modifions
<em>src/salle_a_manger.rs</em> pour avoir uniquement la d√©claration du module
<code>accueil</code>¬†:</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">Fichier¬†: src/salle_a_manger.rs</span></p>
<!--
```rust,ignore
pub mod hosting;
```
-->
<pre><code class="language-rust ignore">pub mod accueil;
</code></pre>
<!--
Then we create a *src/front_of_house* directory and a file
*src/front_of_house/hosting.rs* to contain the definitions made in the
`hosting` module:
-->
<p>Ensuite, nous cr√©ons un dossier <em>src/salle_a_manger</em> et un fichier
<em>src/salle_a_manger/accueil.rs</em> qui contiendra les d√©finitions du module
<code>accueil</code>¬†:</p>
<!--
<span class="filename">Filename: src/front_of_house/hosting.rs</span>
-->
<p><span class="filename">Fichier¬†: src/salle_a_manger/accueil.rs</span></p>
<!--
```rust
pub fn add_to_waitlist() {}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_a_la_liste_attente() {}
<span class="boring">}
</span></code></pre></pre>
<!--
The module tree remains the same, and the function calls in `eat_at_restaurant`
will work without any modification, even though the definitions live in
different files. This technique lets you move modules to new files as they grow
in size.
-->
<p>L'arborescence des modules reste identique, et les appels aux fonctions de
<code>manger_au_restaurant</code> vont continuer √† fonctionner sans aucune modification,
m√™me si les d√©finitions se retrouvent dans des fichiers diff√©rents. Cette
technique vous permet de d√©placer des modules dans de nouveaux fichiers au fur
et √† mesure qu'ils s'agrandissent.</p>
<!--
Note that the `pub use crate::front_of_house::hosting` statement in
*src/lib.rs* also hasn‚Äôt changed, nor does `use` have any impact on what files
are compiled as part of the crate. The `mod` keyword declares modules, and Rust
looks in a file with the same name as the module for the code that goes into
that module.
-->
<p>Remarquez que l'instruction <code>pub use crate::salle_a_manger::accueil</code> dans
<em>src/lib.rs</em> n'a pas chang√©, et que <code>use</code> n'a aucun impact sur quels fichiers
sont compil√©s pour constituer la crate. Le mot-cl√© <code>mod</code> d√©clare un module, et
Rust recherche un fichier de code qui porte le nom dudit module.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-6"><a class="header" href="#r√©sum√©-6">R√©sum√©</a></h2>
<!--
Rust lets you split a package into multiple crates and a crate into modules
so you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a `use` statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is private by default, but you can make
definitions public by adding the `pub` keyword.
-->
<p>Rust vous permet de d√©couper un paquet en plusieurs crates et une crate en
modules afin que vous puissiez r√©utiliser vos √©l√©ments d'un module √† un autre.
Vous pouvez faire cela en utilisant des chemins absolus ou relatifs. Ces chemins
peuvent √™tre import√©s dans la port√©e avec l'instruction <code>use</code> pour pouvoir
utiliser l'√©l√©ment plusieurs fois dans la port√©e avec un chemin plus court. Le
code du module est priv√© par d√©faut, mais vous pouvez rendre publiques des
d√©finitions en ajoutant le mot-cl√© <code>pub</code>.</p>
<!--
In the next chapter, we‚Äôll look at some collection data structures in the
standard library that you can use in your neatly organized code.
-->
<p>Au prochain chapitre, nous allons nous int√©resser √† quelques collections de
structures de donn√©es de la biblioth√®que standard que vous pourrez utiliser dans
votre code soigneusement organis√©.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Common Collections
-->
<h1 id="les-collections-standard"><a class="header" href="#les-collections-standard">Les collections standard</a></h1>
<!--
Rust‚Äôs standard library includes a number of very useful data structures called
*collections*. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data these collections point to is stored on the heap, which means
the amount of data does not need to be known at compile time and can grow or
shrink as the program runs. Each kind of collection has different capabilities
and costs, and choosing an appropriate one for your current situation is a
skill you‚Äôll develop over time. In this chapter, we‚Äôll discuss three
collections that are used very often in Rust programs:
-->
<p>La biblioth√®que standard de Rust apporte quelques structures de donn√©es tr√®s
utiles appel√©es <em>collections</em>. La plupart des autres types de donn√©es
repr√©sentent une seule valeur pr√©cise, mais les collections peuvent contenir
plusieurs valeurs. Contrairement aux tableaux et aux tuples, les donn√©es que ces
collections contiennent sont stock√©es sur le tas, ce qui veut dire que la
quantit√© de donn√©es n'a pas √† √™tre connue au moment de la compilation et peut
augmenter ou diminuer pendant l'ex√©cution du programme. Chaque type de
collection a ses avantages et ses inconv√©nients, et en choisir un qui r√©pond √†
votre besoin sur le moment est une aptitude que vous allez d√©velopper avec le
temps. Dans ce chapitre, nous allons d√©couvrir trois collections qui sont tr√®s
utilis√©es dans les programmes Rust¬†:</p>
<!--
* A *vector* allows you to store a variable number of values next to each other.
* A *string* is a collection of characters. We‚Äôve mentioned the `String` type
  previously, but in this chapter we‚Äôll talk about it in depth.
* A *hash map* allows you to associate a value with a particular key. It‚Äôs a
  particular implementation of the more general data structure called a *map*.
-->
<ul>
<li>Le <em>vecteur</em> qui vous permet de stocker un nombre variable de valeurs les unes
√† c√¥t√© des autres.</li>
<li>La <em>String</em>, qui est une collection de caract√®res. Nous avons d√©j√† aper√ßu le
type <code>String</code> pr√©c√©demment, mais dans ce chapitre, nous allons l'√©tudier en
d√©tail.</li>
<li>La <em>table de hachage</em> qui vous permet d'associer une valeur √† une cl√© pr√©cise.
C'est une impl√©mentation sp√©cifique d'une structure de donn√©es plus
g√©n√©rique : le <em>tableau associatif</em>.</li>
</ul>
<!--
To learn about the other kinds of collections provided by the standard library,
see [the documentation][collections].
-->
<p>Pour en savoir plus sur les autres types de collections fournies par la
biblioth√®que standard, allez voir <a href="https://doc.rust-lang.org/std/collections/index.html">la documentation</a>.</p>
<!--
We‚Äôll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.
-->
<p>Nous allons voir comment cr√©er et modifier les vecteurs, les Strings et les
tables de hachage, et √©tudier leurs diff√©rences.</p>
<!--
[collections]: ../std/collections/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing Lists of Values with Vectors
-->
<h2 id="stocker-des-listes-de-valeurs-avec-des-vecteurs"><a class="header" href="#stocker-des-listes-de-valeurs-avec-des-vecteurs">Stocker des listes de valeurs avec des vecteurs</a></h2>
<!--
The first collection type we‚Äôll look at is `Vec<T>`, also known as a *vector*.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.
-->
<p>Le premier type de collection que nous allons voir est <code>Vec&lt;T&gt;</code>, aussi appel√©
<em>vecteur</em>. Les vecteurs vous permettent de stocker plus d'une valeur dans une
seule structure de donn√©es qui stocke les valeurs les unes √† c√¥t√© des autres
dans la m√©moire. Les vecteurs peuvent stocker uniquement des valeurs du m√™me
type. Ils sont utiles lorsque vous avez une liste d'√©l√©ments, tels que les
lignes de texte provenant d'un fichier ou les prix des articles d'un panier
d'achat.</p>
<!--
### Creating a New Vector
-->
<h3 id="cr√©er-un-nouveau-vecteur"><a class="header" href="#cr√©er-un-nouveau-vecteur">Cr√©er un nouveau vecteur</a></h3>
<!--
To create a new empty vector, we call the `Vec::new` function, as shown in
Listing 8-1.
-->
<p>Pour cr√©er un nouveau vecteur vide, nous appelons la fonction <code>Vec::new</code>, comme
dans l'encart 8-1.</p>
<!--
```rust
# fn main() {
    let v: Vec<i32> = Vec::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-1: Creating a new, empty vector to hold values
of type `i32`</span>
-->
<p><span class="caption">Encart 8-1¬†: cr√©ation d'un nouveau vecteur vide pour y
stocker des valeurs de type <code>i32</code></span></p>
<!--
Note that we added a type annotation here. Because we aren‚Äôt inserting any
values into this vector, Rust doesn‚Äôt know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we‚Äôll cover how to use generics with your own types in Chapter 10. For now,
know that the `Vec<T>` type provided by the standard library can hold any type.
When we create a vector to hold a specific type, we can specify the type within
angle brackets. In Listing 8-1, we‚Äôve told Rust that the `Vec<T>` in `v` will
hold elements of the `i32` type.
-->
<p>Remarquez que nous avons ajout√© ici une annotation de type. Comme nous
n'ajoutons pas de valeurs dans ce vecteur, Rust ne sait pas quel type d'√©l√©ments
nous souhaitons stocker. C'est une information importante. Les vecteurs sont
impl√©ment√©s avec la g√©n√©ricit√©¬†; nous verrons comment utiliser la g√©n√©ricit√© sur
vos propres types au chapitre 10. Pour l'instant, sachez que le type <code>Vec&lt;T&gt;</code>
qui est fourni par la biblioth√®que standard peut stocker n'importe quel type.
Lorsque nous cr√©ons un vecteur pour stocker un type pr√©cis, nous pouvons
renseigner ce type entre des chevrons. Dans l'encart 8-1, nous pr√©cisons √† Rust
que le <code>Vec&lt;T&gt;</code> dans <code>v</code> va stocker des √©l√©ments de type <code>i32</code>.</p>
<!--
More often, you‚Äôll create a `Vec<T>` with initial values and Rust will infer
the type of value you want to store, so you rarely need to do this type
annotation. Rust conveniently provides the `vec!` macro, which will create a
new vector that holds the values you give it. Listing 8-2 creates a new
`Vec<i32>` that holds the values `1`, `2`, and `3`. The integer type is `i32`
because that‚Äôs the default integer type, as we discussed in the [‚ÄúData
Types‚Äù][data-types]<!-- ignore -- > section of Chapter 3.
-->
<p>Le plus souvent, vous allez cr√©er un <code>Vec&lt;T&gt;</code> avec des valeurs initiales et
Rust va deviner le type de la valeur que vous souhaitez stocker, donc vous
n'aurez pas souvent besoin de faire cette annotation de type. Rust propose la
macro tr√®s pratique <code>vec!</code>, qui va cr√©er un nouveau vecteur qui stockera les
valeurs que vous lui donnerez. L'encart 8-2 cr√©e un nouveau <code>Vec&lt;i32&gt;</code> qui
stocke les valeurs <code>1</code>, <code>2</code> et <code>3</code>. Le type d'entier est <code>i32</code> car c'est le
type d'entier par d√©faut, comme nous l'avons √©voqu√© dans la section <a href="ch03-02-data-types.html">‚ÄúLes types
de donn√©es‚Äù</a><!-- ignore --> du chapitre 3.</p>
<!--
```rust
# fn main() {
    let v = vec![1, 2, 3];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-2: Creating a new vector containing
values</span>
-->
<p><span class="caption">Encart 8-2¬†: cr√©ation d'un nouveau vecteur qui contient
des valeurs</span></p>
<!--
Because we‚Äôve given initial `i32` values, Rust can infer that the type of `v`
is `Vec<i32>`, and the type annotation isn‚Äôt necessary. Next, we‚Äôll look at how
to modify a vector.
-->
<p>Comme nous avons donn√© des valeurs initiales <code>i32</code>, Rust peut en d√©duire que le
type de <code>v</code> est <code>Vec&lt;i32&gt;</code>, et l'annotation de type n'est plus n√©cessaire.
Maintenant, nous allons voir comment modifier un vecteur.</p>
<!--
### Updating a Vector
-->
<h3 id="modifier-un-vecteur"><a class="header" href="#modifier-un-vecteur">Modifier un vecteur</a></h3>
<!--
To create a vector and then add elements to it, we can use the `push` method,
as shown in Listing 8-3.
-->
<p>Pour cr√©er un vecteur et ensuite lui ajouter des √©l√©ments, nous pouvons utiliser
la m√©thode <code>push</code>, comme dans l'encart 8-3.</p>
<!--
```rust
# fn main() {
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-3: Using the `push` method to add values to a
vector</span>
-->
<p><span class="caption">Encart 8-3¬†: utilisation de la m√©thode <code>push</code> pour ajouter
des valeurs √† un vecteur</span></p>
<!--
As with any variable, if we want to be able to change its value, we need to
make it mutable using the `mut` keyword, as discussed in Chapter 3. The numbers
we place inside are all of type `i32`, and Rust infers this from the data, so
we don‚Äôt need the `Vec<i32>` annotation.
-->
<p>Comme pour toute variable, si nous voulons pouvoir modifier sa valeur, nous
devons la rendre mutable en utilisant le mot-cl√© <code>mut</code>, comme nous l'avons vu
au chapitre 3. Les nombres que nous ajoutons dedans sont tous du type <code>i32</code>, et
Rust le devine √† partir des donn√©es, donc nous n'avons pas besoin de
l'annotation <code>Vec&lt;i32&gt;</code>.</p>
<!--
### Dropping a Vector Drops Its Elements
-->
<h3 id="lib√©rer-un-vecteur-lib√®re-aussi-ses-√©l√©ments"><a class="header" href="#lib√©rer-un-vecteur-lib√®re-aussi-ses-√©l√©ments">Lib√©rer un vecteur lib√®re aussi ses √©l√©ments</a></h3>
<!--
Like any other `struct`, a vector is freed when it goes out of scope, as
annotated in Listing 8-4.
-->
<p>Comme toutes les autres structures, un vecteur est lib√©r√© quand il sort de la
port√©e, comme pr√©cis√© dans l'encart 8-4.</p>
<!--
```rust
# fn main() {
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];
    
        // on fait des choses avec v
    
    } // &lt;- v sort de la port√©e et est lib√©r√© ici
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-4: Showing where the vector and its elements
are dropped</span>
-->
<p><span class="caption">Encart 8-4¬†: mise en √©vidence de l√† o√π le vecteur et ses
√©l√©ments sont lib√©r√©s</span></p>
<!--
When the vector gets dropped, all of its contents are also dropped, meaning
those integers it holds will be cleaned up. This may seem like a
straightforward point but it can get complicated when you start to introduce
references to the elements of the vector. Let‚Äôs tackle that next!
-->
<p>Lorsque le vecteur est lib√©r√©, tout son contenu est aussi lib√©r√©, ce qui veut
dire que les nombres entiers qu'il stocke vont √™tre effac√©s de la m√©moire. Cela
semble tr√®s simple mais cela peut devenir plus compliqu√© quand vous commencez √†
utiliser des r√©f√©rences vers les √©l√©ments du vecteur. Voyons ceci d√®s √†
pr√©sent¬†!</p>
<!--
### Reading Elements of Vectors
-->
<h3 id="lire-les-√©l√©ments-des-vecteurs"><a class="header" href="#lire-les-√©l√©ments-des-vecteurs">Lire les √©l√©ments des vecteurs</a></h3>
<!--
There are two ways to reference a value stored in a vector: via indexing or
using the `get` method. In the following examples, we‚Äôve annotated the types of
the values that are returned from these functions for extra clarity.
-->
<p>Il existe deux fa√ßons de d√©signer une valeur enregistr√©e dans un vecteur¬†: via
les indices ou en utilisant la m√©thode <code>get</code>. Dans les exemples suivants, nous
avons pr√©cis√© les types des valeurs qui sont retourn√©es par ces fonctions pour
plus de clart√©.</p>
<!--
Listing 8-5 shows both methods of accessing a value in a vector, with indexing
syntax and the `get` method.
-->
<p>L'encart 8-5 nous montre les deux fa√ßons d'acc√©der √† une valeur d'un vecteur,
via la syntaxe d'indexation et avec la m√©thode <code>get</code>.</p>
<!--
```rust
# fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    match v.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let troisieme: &amp;i32 = &amp;v[2];
    println!(&quot;Le troisi√®me √©l√©ment est {}&quot;, troisieme);

    match v.get(2) {
        Some(troisieme) =&gt; println!(&quot;Le troisi√®me √©l√©ment est {}&quot;, troisieme),
        None =&gt; println!(&quot;Il n'y a pas de troisi√®me √©l√©ment.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-5: Using indexing syntax or the `get` method to
access an item in a vector</span>
-->
<p><span class="caption">Encart 8-5¬†: utilisation de la syntaxe d'indexation ainsi
que la m√©thode <code>get</code> pour acc√©der √† un √©l√©ment d'un vecteur</span></p>
<!--
Note two details here. First, we use the index value of `2` to get the third
element because vectors are indexed by number, starting at zero. Second, we get
the third element by either using `&` and `[]`, which gives us a reference, or
using the `get` method with the index passed as an argument, which gives us an
`Option<&T>`.
-->
<p>Il y a deux d√©tails √† remarquer ici. Premi√®rement, nous avons utilis√© l'indice
<code>2</code> pour obtenir le troisi√®me √©l√©ment car les vecteurs sont index√©s par des
nombres, qui commencent √† partir de z√©ro. Deuxi√®mement, nous obtenons le
troisi√®me √©l√©ment soit en utilisant <code>&amp;</code> et <code>[]</code>, ce qui nous donne une
r√©f√©rence, soit en utilisant la m√©thode <code>get</code> avec l'indice en argument, ce qui
nous fournit une <code>Option&lt;&amp;T&gt;</code>.</p>
<!--
The reason Rust provides these two ways to reference an element is so you can
choose how the program behaves when you try to use an index value outside the
range of existing elements. As an example, let‚Äôs see what happens when we have
a vector of five elements and then we try to access an element at index 100
with each technique, as shown in Listing 8-6.
-->
<p>La raison pour laquelle Rust offre ces deux mani√®res d'obtenir une r√©f√©rence
vers un √©lement est de vous permettre de choisir le comportement du programme
lorsque vous essayez d'utiliser une valeur dont l'indice est √† l'ext√©rieur de
la plage des √©l√©ments existants. Par exemple, voyons dans l'encart 8-6 ce qui
se passe lorsque nous avons un vecteur de cinq √©l√©ments et qu'ensuite nous
essayons d'acc√©der √† un √©l√©ment √† l'indice 100 avec chaque technique.</p>
<!--
```rust,should_panic,panics
# fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
# }
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let existe_pas = &amp;v[100];
    let existe_pas = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-6: Attempting to access the element at index
100 in a vector containing five elements</span>
-->
<p><span class="caption">Encart 8-6¬†: tentative d'acc√®s √† l'√©l√©ment √† l'indice 100
dans un vecteur qui contient cinq √©l√©ments</span></p>
<!--
When we run this code, the first `[]` method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if there‚Äôs an attempt to access an element past the
end of the vector.
-->
<p>Lorsque nous ex√©cutons ce code, la premi√®re m√©thode <code>[]</code> va faire paniquer le
programme car il demande un √©l√©ment non existant. Cette m√©thode doit √™tre
favoris√©e lorsque vous souhaitez que votre programme plante s'il y a une
tentative d'acc√©der √† un √©l√©ment apr√®s la fin du vecteur.</p>
<!--
When the `get` method is passed an index that is outside the vector, it returns
`None` without panicking. You would use this method if accessing an element
beyond the range of the vector may happen occasionally under normal
circumstances. Your code will then have logic to handle having either
`Some(&element)` or `None`, as discussed in Chapter 6. For example, the index
could be coming from a person entering a number. If they accidentally enter a
number that‚Äôs too large and the program gets a `None` value, you could tell the
user how many items are in the current vector and give them another chance to
enter a valid value. That would be more user-friendly than crashing the program
due to a typo!
-->
<p>Lorsque nous passons un indice en dehors de l'intervalle du vecteur √† la
m√©thode <code>get</code>, elle retourne <code>None</code> sans paniquer. Vous devriez utiliser cette
m√©thode s'il peut arriver occasionnellement de vouloir acc√©der √† un √©l√©ment en
dehors de l'intervalle du vecteur en temps normal. Votre code va ensuite devoir
g√©rer les deux valeurs <code>Some(&amp;element)</code> ou <code>None</code>, comme nous l'avons vu au
chapitre 6. Par exemple, l'indice peut provenir d'une saisie utilisateur. Si
par accident il saisit un nombre qui est trop grand et que le programme obtient
une valeur <code>None</code>, vous pouvez alors dire √† l'utilisateur combien il y a
d'√©l√©ments dans le vecteur courant et lui donner une nouvelle chance de saisir
une valeur valide. Cela sera plus convivial que de faire planter le programme √†
cause d'une faute de frappe¬†!</p>
<!--
When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you can‚Äôt have mutable and immutable references in the same
scope. That rule applies in Listing 8-7, where we hold an immutable reference
to the first element in a vector and try to add an element to the end. This
program won‚Äôt work if we also try to refer to that element later in the
function:
-->
<p>Lorsque le programme obtient une r√©f√©rence valide, le v√©rificateur d'emprunt va
faire appliquer les r√®gles de possession et d'emprunt (que nous avons vues au
chapitre 4) pour s'assurer que cette r√©f√©rence ainsi que toutes les autres
r√©f√©rences au contenu de ce vecteur restent valides. Souvenez-vous de la r√®gle
qui dit que vous ne pouvez pas avoir des r√©f√©rences mutables et immuables dans
la m√™me port√©e. Cette r√®gle s'applique √† l'encart 8-7, o√π nous obtenons une
r√©f√©rence immuable vers le premier √©l√©ment d'un vecteur et nous essayons
d'ajouter un √©l√©ment √† la fin. Ce programme ne fonctionnera pas si nous
essayons aussi d'utiliser cet √©l√©ment plus tard dans la fonction¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {}", first);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let premier = &amp;v[0];

    v.push(6);

    println!(&quot;Le premier √©l√©ment est¬†: {}&quot;, premier);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-7: Attempting to add an element to a vector
while holding a reference to an item</span>
-->
<p><span class="caption">Encart 8-7¬†: tentative d'ajout d'un √©l√©ment √† un vecteur
alors que nous utilisons une r√©f√©rence √† un √©l√©ment</span></p>
<!--
Compiling this code will result in this error:
-->
<p>Compiler ce code va nous mener √† cette erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("The first element is: {}", first);
  |                                          ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let premier = &amp;v[0];
  |                    - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;Le premier √©l√©ment est¬†: {}&quot;, premier);
  |                                             ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<!--
The code in Listing 8-7 might look like it should work: why should a reference
to the first element care about changes at the end of the vector? This error is
due to the way vectors work: because vectors put the values next to each other
in memory, adding a new element onto the end of the vector might require
allocating new memory and copying the old elements to the new space, if there
isn‚Äôt enough room to put all the elements next to each other where the vector
is currently stored. In that case, the reference to the first element would be
pointing to deallocated memory. The borrowing rules prevent programs from
ending up in that situation.
-->
<p>Le code dans l'encart 8-7 semble pourtant marcher¬†: pourquoi une r√©f√©rence au
premier √©l√©ment devrait se soucier de ce qui se passe √† la fin du vecteur¬†?
Cette erreur s'explique par la fa√ßon dont les vecteurs fonctionnent¬†: comme les
vecteurs ajoutent les valeurs les unes √† c√¥t√© des autres dans la m√©moire,
l'ajout d'un nouvel √©l√©ment √† la fin du vecteur peut n√©cessiter d'allouer un
nouvel espace m√©moire et copier tous les anciens √©l√©ments dans ce nouvel
espace, s'il n'y a pas assez de place pour placer tous les √©l√©ments les uns √†
c√¥t√© des autres dans la m√©moire l√† o√π est actuellement stock√© le vecteur. Dans
ce cas, la r√©f√©rence au premier √©l√©ment pointerait vers de la m√©moire
d√©sallou√©e. Les r√®gles d'emprunt √©vitent aux programmes de se retrouver dans
cette situation.</p>
<!--
> Note: For more on the implementation details of the `Vec<T>` type, see [‚ÄúThe
> Rustonomicon‚Äù][nomicon].
-->
<blockquote>
<p>Remarque¬†: pour plus de d√©tails sur l'impl√©mentation du type <code>Vec&lt;T&gt;</code>,
consultez <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">le ‚ÄúRustonomicon‚Äù</a>.</p>
</blockquote>
<!--
### Iterating over the Values in a Vector
-->
<h3 id="it√©rer-sur-les-valeurs-dun-vecteur"><a class="header" href="#it√©rer-sur-les-valeurs-dun-vecteur">It√©rer sur les valeurs d'un vecteur</a></h3>
<!--
To access each element in a vector in turn, we would iterate through all of the
elements rather than use indices to access one at a time. Listing 8-8 shows how
to use a `for` loop to get immutable references to each element in a vector of
`i32` values and print them.
-->
<p>Pour acc√©der √† chaque √©l√©ment d'un vecteur chacun son tour, nous devrions
it√©rer sur tous les √©l√©ments plut√¥t que d'utiliser individuellement les
indices. L'encart 8-8 nous montre comment utiliser une boucle <code>for</code> pour
obtenir des r√©f√©rences immuables pour chacun des √©l√©ments dans un vecteur de
<code>i32</code>, et les afficher.</p>
<!--
```rust
# fn main() {
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{}", i);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-8: Printing each element in a vector by
iterating over the elements using a `for` loop</span>
-->
<p><span class="caption">Encart 8-8¬†: affichage de chaque √©l√©ment d'un vecteur en
it√©rant sur les √©l√©ments en utilisant une boucle <code>for</code></span></p>
<!--
We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The `for` loop in Listing 8-9
will add `50` to each element.
-->
<p>Nous pouvons aussi it√©rer avec des r√©f√©rences mutables pour chacun des √©l√©ments
d'un vecteur mutable afin de modifier tous les √©l√©ments. La boucle <code>for</code> de
l'encart 8-9 va ajouter <code>50</code> √† chacun des √©l√©ments.</p>
<!--
```rust
# fn main() {
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-9: Iterating over mutable references to
elements in a vector</span>
-->
<p><span class="caption">Encart 8-9¬†: it√©rations sur des r√©f√©rences mutables vers
des √©l√©ments d'un vecteur</span></p>
<!--
To change the value that the mutable reference refers to, we have to use the
`*` dereference operator to get to the value in `i` before we can use the
`+=` operator. We‚Äôll talk more about the dereference operator in the
[‚ÄúFollowing the Pointer to the Value with the Dereference Operator‚Äù][deref]<!-- ignore -- >
section of Chapter 15.
-->
<p>Afin de changer la valeur vers laquelle pointe la r√©f√©rence mutable, nous devons
utiliser l'op√©rateur de d√©r√©f√©rencement <code>*</code> pour obtenir la valeur dans <code>i</code>
avant que nous puissions utiliser l'op√©rateur <code>+=</code>. Nous verrons plus en d√©tail
l'op√©rateur de d√©r√©f√©rencement dans une section du
<a href="ch15-02-deref.html">chapitre 15</a><!-- ignore -->.</p>
<!--
### Using an Enum to Store Multiple Types
-->
<h3 id="utiliser-une-√©num√©ration-pour-stocker-diff√©rents-types"><a class="header" href="#utiliser-une-√©num√©ration-pour-stocker-diff√©rents-types">Utiliser une √©num√©ration pour stocker diff√©rents types</a></h3>
<!--
Vectors can only store values that are the same type. This can be inconvenient;
there are definitely use cases for needing to store a list of items of
different types. Fortunately, the variants of an enum are defined under the
same enum type, so when we need one type to represent elements of different
types, we can define and use an enum!
-->
<p>Les vecteurs ne peuvent stocker que des valeurs du m√™me type. Cela peut √™tre un
probl√®me¬†; il y a forc√©ment des cas o√π on a besoin de stocker une liste
d'√©l√©ments de types diff√©rents. Heureusement, les variantes d'une √©num√©ration
sont d√©finies sous le m√™me type d'√©num√©ration, donc lorsque nous avons besoin
d'un type pour repr√©senter les √©l√©ments de types diff√©rents, nous pouvons
d√©finir et utiliser une √©num√©ration¬†!</p>
<!--
For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and all the enum variants will be considered the same type: that
of the enum. Then we can create a vector to hold that enum and so, ultimately,
holds different types. We‚Äôve demonstrated this in Listing 8-10.
-->
<p>Par exemple, imaginons que nous voulions obtenir les valeurs d'une ligne d'une
feuille de calcul dans laquelle quelques colonnes sont des entiers, d'autres
des nombres √† virgule flottante, et quelques cha√Ænes de caract√®res. Nous
pouvons d√©finir une √©num√©ration dont les variantes vont avoir les diff√©rents
types, et toutes les variantes de l'√©num√©ration seront du m√™me type¬†: celui de
l'√©num√©ration. Ensuite, nous pouvons cr√©er un vecteur pour stocker cette
√©num√©ration et ainsi, au final, qui stocke diff√©rents types. La d√©monstration
de cette technique est dans l'encart 8-10.</p>
<!--
```rust
# fn main() {
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Cellule {
        Int(i32),
        Float(f64),
        Text(String),
    }
    
    let ligne = vec![
        Cellule::Int(3),
        Cellule::Text(String::from(&quot;bleu&quot;)),
        Cellule::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-10: Defining an `enum` to store values of
different types in one vector</span>
-->
<p><span class="caption">Encart 8-10¬†: d√©finition d'une <code>enum</code> pour stocker des
valeurs de diff√©rents types dans un seul vecteur</span></p>
<!--
Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. We
must also be explicit about what types are allowed in this vector. If Rust
allowed a vector to hold any type, there would be a chance that one or more of
the types would cause errors with the operations performed on the elements of
the vector. Using an enum plus a `match` expression means that Rust will ensure
at compile time that every possible case is handled, as discussed in Chapter 6.
-->
<p>Rust a besoin de savoir quel type de donn√©e sera stock√© dans le vecteur au
moment de la compilation afin de conna√Ætre la quantit√© de m√©moire n√©cessaire
pour stocker chaque √©l√©ment sur le tas. Nous devons √™tre pr√©cis sur les types
autoris√©s dans ce vecteur. Si Rust avait permis qu'un vecteur stocke n'importe
quel type, il y aurait pu avoir un risque qu'un ou plusieurs des types
provoquent une erreur avec les manipulations effectu√©es sur les √©l√©ments du
vecteur. L'utilisation d'une √©num√©ration ainsi qu'une expression <code>match</code> permet
√† Rust de garantir au moment de la compilation que tous les cas possibles sont
trait√©s, comme nous l'avons appris au chapitre 6.</p>
<!--
If you don‚Äôt know the exhaustive set of types a program will get at runtime to
store in a vector, the enum technique won‚Äôt work. Instead, you can use a trait
object, which we‚Äôll cover in Chapter 17.
-->
<p>Si vous n'avez pas une liste exhaustive des types que votre programme va
stocker dans un vecteur, la technique de l'√©num√©ration ne va pas fonctionner. √Ä
la place, vous pouvez utiliser un objet trait, que nous verrons au chapitre 17.</p>
<!--
Now that we‚Äôve discussed some of the most common ways to use vectors, be sure
to review [the API documentation][vec-api]<!-- ignore -- > for all the many
useful methods defined on `Vec<T>` by the standard library. For example, in
addition to `push`, a `pop` method removes and returns the last element. Let‚Äôs
move on to the next collection type: `String`!
-->
<p>Maintenant que nous avons vu les mani√®res les plus courantes d'utiliser les
vecteurs, prenez le temps de consulter <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">la documentation de
l'API</a><!-- ignore --> pour d√©couvrir toutes les m√©thodes tr√®s utiles
d√©finies dans la biblioth√®que standard pour <code>Vec&lt;T&gt;</code>. Par exemple, en plus de
<code>push</code>, nous avons une m√©thode <code>pop</code> qui retire et retourne le dernier √©l√©ment.
Int√©ressons-nous maintenant au prochain type de collection¬†: la <code>String</code>¬†!</p>
<!--
[data-types]: ch03-02-data-types.html#data-types
[nomicon]: ../nomicon/vec/vec.html
[vec-api]: ../std/vec/struct.Vec.html
[deref]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing UTF-8 Encoded Text with Strings
-->
<h2 id="stocker-du-texte-encod√©-en-utf-8-avec-les-strings"><a class="header" href="#stocker-du-texte-encod√©-en-utf-8-avec-les-strings">Stocker du texte encod√© en UTF-8 avec les Strings</a></h2>
<!--
We talked about strings in Chapter 4, but we‚Äôll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rust‚Äôs propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when you‚Äôre
coming from other programming languages.
-->
<p>Nous avons d√©j√† parl√© des cha√Ænes de caract√®res dans le chapitre 4, mais nous
allons √† pr√©sent les analyser plus en d√©tail. Les nouveaux Rustac√©s bloquent
souvent avec les cha√Ænes de caract√®res pour trois raisons¬†: la tendance de Rust
√† pr√©venir les erreurs, le fait que les cha√Ænes de caract√®res sont des
structures de donn√©es plus compliqu√©es que ne le pensent la plupart des
d√©veloppeurs, et l'UTF-8. Ces raisons cumul√©es rendent les choses compliqu√©es
lorsque vous venez d'un autre langage de programmation.</p>
<!--
We discuss strings in the context of collections because strings are
implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we‚Äôll
talk about the operations on `String` that every collection type has, such as
creating, updating, and reading. We‚Äôll also discuss the ways in which `String`
is different from the other collections, namely how indexing into a `String` is
complicated by the differences between how people and computers interpret
`String` data.
-->
<p>Nous avons pr√©sent√© les cha√Ænes de caract√®res comme des collections car les
cha√Ænes de caract√®res sont en r√©alit√© des suites d'octets, avec quelques
m√©thodes suppl√©mentaires qui sont utiles lorsque ces octets sont consid√©r√©s
comme du texte. Dans cette section, nous allons voir les points communs entre
le fonctionnement des <code>String</code> et celui des autres collections, comme la
cr√©ation, la modification et la lecture. Nous verrons les raisons pour
lesquelles les <code>String</code> sont diff√©rentes des autres collections, en particulier
pourquoi l'indexation d'une <code>String</code> est compliqu√©e √† cause des diff√©rences
entre la fa√ßon dont les gens et les ordinateurs interpr√®tent les donn√©es d'une
<code>String</code>.</p>
<!--
### What Is a String?
-->
<h3 id="quest-ce-quune-cha√Æne-de-caract√®res-"><a class="header" href="#quest-ce-quune-cha√Æne-de-caract√®res-">Qu'est-ce qu'une cha√Æne de caract√®res¬†?</a></h3>
<!--
We‚Äôll first define what we mean by the term *string*. Rust has only one string
type in the core language, which is the string slice `str` that is usually seen
in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the program‚Äôs binary and are therefore
string slices.
-->
<p>Nous allons d'abord d√©finir ce que nous entendons par le terme <em>cha√Æne de
caract√®res</em>. Rust a un seul type de cha√Ænes de caract√®res dans le noyau du
langage, qui est la slice de cha√Æne de caract√®res <code>str</code> qui est habituellement
utilis√©e sous sa forme emprunt√©e, <code>&amp;str</code>. Dans le chapitre 4, nous avons abord√©
les <em>slices de cha√Ænes de caract√®res</em>, qui sont des r√©f√©rences √† des donn√©es
d'une cha√Æne de caract√®res encod√©e en UTF-8 qui sont stock√©es autre part. Les
litt√©raux de cha√Ænes de caract√®res, par exemple, sont stock√©s dans le binaire du
programme et sont des slices de cha√Ænes de caract√®res.</p>
<!--
The `String` type, which is provided by Rust‚Äôs standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to ‚Äústrings‚Äù in Rust, they might be
referring to either the `String` or the string slice `&str` types, not just one
of those types. Although this section is largely about `String`, both types are
used heavily in Rust‚Äôs standard library, and both `String` and string slices
are UTF-8 encoded.
-->
<p>Le type <code>String</code>, qui est fourni par la biblioth√®que standard de Rust plut√¥t que
d'√™tre int√©gr√© au noyau du langage, est un type de cha√Æne de caract√®res encod√©
en UTF-8 qui peut s'agrandir, √™tre mutable, et √™tre poss√©d√©. Lorsque les
Rustac√©s parlent de ‚Äúcha√Ænes de caract√®res‚Äù en Rust, ils entendent soit le type
<code>String</code>, soit le type de slice de cha√Ænes de caract√®res <code>&amp;str</code>, et non pas un
seul de ces types. Bien que cette section traite essentiellement de <code>String</code>,
ces deux types sont utilis√©s massivement dans la biblioth√®que standard de Rust,
et tous les deux sont encod√©s en UTF-8.</p>
<!--
Rust‚Äôs standard library also includes a number of other string types, such as
`OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even
more options for storing string data. See how those names all end in `String`
or `Str`? They refer to owned and borrowed variants, just like the `String` and
`str` types you‚Äôve seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We won‚Äôt discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.
-->
<p>La biblioth√®que standard de Rust apporte aussi un certain nombre d'autres types
de cha√Ænes de caract√®res, comme <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, et <code>CStr</code>. Les
crates de biblioth√®que peuvent fournir encore plus de solutions pour stocker des
cha√Ænes de caract√®res. Avez-vous remarqu√© que ces noms finissent tous par
<code>String</code> ou <code>Str</code>¬†? Cela fait r√©f√©rence aux variantes poss√©d√©es et emprunt√©es,
comme les types <code>String</code> et <code>str</code> que nous avons vus pr√©c√©demment. Ces types de
cha√Ænes de caract√®res peuvent stocker leur texte dans de diff√©rents encodages,
ou le stocker en m√©moire de mani√®re diff√©rente, par exemple. Nous n'allons pas
traiter de ces autres types de cha√Ænes de caract√®res dans ce chapitre¬†;
r√©f√©rez-vous √† la documentation de leur API pour en savoir plus sur leur
utilisation et leur utilit√©.</p>
<!--
### Creating a New String
-->
<h3 id="cr√©er-une-nouvelle-string"><a class="header" href="#cr√©er-une-nouvelle-string">Cr√©er une nouvelle String</a></h3>
<!--
Many of the same operations available with `Vec<T>` are available with `String`
as well, starting with the `new` function to create a string, shown in Listing
8-11.
-->
<p>De nombreuses op√©rations disponibles avec <code>Vec&lt;T&gt;</code> sont aussi disponibles avec
<code>String</code>, en commen√ßant par la fonction <code>new</code> pour cr√©er une <code>String</code>, utilis√©e
dans l'encart 8-11.</p>
<!--
```rust
# fn main() {
    let mut s = String::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-11: Creating a new, empty `String`</span>
-->
<p><span class="caption">Encart 8-11¬†: Cr√©ation d'une nouvelle <code>String</code> vide</span></p>
<!--
This line creates a new empty string called `s`, which we can then load data
into. Often, we‚Äôll have some initial data that we want to start the string
with. For that, we use the `to_string` method, which is available on any type
that implements the `Display` trait, as string literals do. Listing 8-12 shows
two examples.
-->
<p>Cette ligne cr√©e une nouvelle <code>String</code> vide qui s'appelle <code>s</code>, dans laquelle
nous pouvons ensuite charger des donn√©es. Souvent, nous aurons quelques donn√©es
initiales que nous voudrions ajouter dans la <code>String</code>. Pour cela, nous utilisons
la m√©thode <code>to_string</code>, qui est disponible sur tous les types qui impl√©mentent
le trait <code>Display</code>, comme le font les litt√©raux de cha√Ænes de caract√®res.
L'encart 8-12 nous montre deux exemples.</p>
<!--
```rust
# fn main() {
    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let donnee = &quot;contenu initial&quot;;

    let s = donnee.to_string();

    // cette m√©thode fonctionne aussi directement sur un
    // litt√©ral de cha√Æne de caract√®res¬†:
    let s = &quot;contenu initial&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-12: Using the `to_string` method to create a
`String` from a string literal</span>
-->
<p><span class="caption">Encart 8-12¬†: Utilisation de la m√©thode <code>to_string</code> pour
cr√©er une <code>String</code> √† partir d'un litt√©ral de cha√Æne</span></p>
<!--
This code creates a string containing `initial contents`.
-->
<p>Ce code cr√©e une <code>String</code> qui contient <code>contenu initial</code>.</p>
<!--
We can also use the function `String::from` to create a `String` from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses `to_string`.
-->
<p>Nous pouvons aussi utiliser la fonction <code>String::from</code> pour cr√©er une <code>String</code>
√† partir d'un litt√©ral de cha√Æne. Le code dans l'encart 8-13 est √©quivalent au
code dans l'encart 8-12 qui utilisait <code>to_string</code>.</p>
<!--
```rust
# fn main() {
    let s = String::from("initial contents");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;contenu initial&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-13: Using the `String::from` function to create
a `String` from a string literal</span>
-->
<p><span class="caption">Encart 8-13¬†: Utilisation de la fonction <code>String::from</code>
afin de cr√©er une <code>String</code> √† partir d'un litt√©ral de cha√Æne</span></p>
<!--
Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, `String::from` and
`to_string` do the same thing, so which you choose is a matter of style and
readability.
-->
<p>Comme les cha√Ænes de caract√®res sont utilis√©es pour de nombreuses choses, nous
pouvons utiliser beaucoup d'API g√©n√©riques pour les cha√Ænes de caract√®res.
Certaines d'entre elles peuvent para√Ætre redondantes, mais elles ont toutes
leur place¬†! Dans notre cas, <code>String::from</code> et <code>to_string</code> font la m√™me chose,
donc votre choix est une question de go√ªt et de lisibilit√©.</p>
<!--
Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.
-->
<p>Souvenez-vous que les cha√Ænes de caract√®res sont encod√©es en UTF-8, donc nous
pouvons y int√©grer n'importe quelle donn√©e valide, comme nous le voyons dans
l'encart 8-14.</p>
<!--
```rust
# fn main() {
    let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
    let hello = String::from("Dobr√Ω den");
    let hello = String::from("Hello");
    let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
    let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
    let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
    let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
    let hello = String::from("‰Ω†Â•Ω");
    let hello = String::from("Ol√°");
    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let bonjour = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
    let bonjour = String::from(&quot;Dobr√Ω den&quot;);
    let bonjour = String::from(&quot;Hello&quot;);
    let bonjour = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
    let bonjour = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
    let bonjour = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
    let bonjour = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
    let bonjour = String::from(&quot;‰Ω†Â•Ω&quot;);
    let bonjour = String::from(&quot;Ol√°&quot;);
    let bonjour = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
    let bonjour = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span>
-->
<p><span class="caption">Encart 8-14¬†: Stockage de salutations dans diff√©rentes
langues dans des cha√Ænes de caract√®res</span></p>
<!--
All of these are valid `String` values.
-->
<p>Toutes ces cha√Ænes sont des valeurs <code>String</code> valides.</p>
<!--
### Updating a String
-->
<h3 id="modifier-une-string"><a class="header" href="#modifier-une-string">Modifier une <code>String</code></a></h3>
<!--
A `String` can grow in size and its contents can change, just like the contents
of a `Vec<T>`, if you push more data into it. In addition, you can conveniently
use the `+` operator or the `format!` macro to concatenate `String` values.
-->
<p>Une <code>String</code> peut s'agrandir et son contenu peut changer, exactement comme le
contenu d'un <code>Vec&lt;T&gt;</code>, si on y ajoute des donn√©es. De plus, vous pouvez ais√©ment
utiliser l'op√©rateur <code>+</code> ou la macro <code>format!</code> pour concat√©ner des valeurs
<code>String</code>.</p>
<!--
#### Appending to a String with `push_str` and `push`
-->
<h4 id="ajouter-du-texte-√†-une-cha√Æne-avec-push_str-et-push"><a class="header" href="#ajouter-du-texte-√†-une-cha√Æne-avec-push_str-et-push">Ajouter du texte √† une cha√Æne avec <code>push_str</code> et <code>push</code></a></h4>
<!--
We can grow a `String` by using the `push_str` method to append a string slice,
as shown in Listing 8-15.
-->
<p>Nous pouvons agrandir une <code>String</code> en utilisant la m√©thode <code>push_str</code> pour
ajouter une slice de cha√Æne de caract√®res, comme dans l'encart 8-15.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-15: Appending a string slice to a `String`
using the `push_str` method</span>
-->
<p><span class="caption">Encart 8-15¬†: Ajout d'une slice de cha√Æne de caract√®res
dans une <code>String</code> en utilisant la m√©thode <code>push_str</code></span></p>
<!--
After these two lines, `s` will contain `foobar`. The `push_str` method takes a
string slice because we don‚Äôt necessarily want to take ownership of the
parameter. For example, in the code in Listing 8-16, we want to able to use
`s2` after appending its contents to `s1`.
-->
<p>√Ä l'issue de ces deux lignes, <code>s</code> va contenir <code>foobar</code>. La m√©thode <code>push_str</code>
prend une slice de cha√Æne de caract√®res car nous ne souhaitons pas forc√©ment
prendre possession du param√®tre. Par exemple, dans le code de l'encart 8-16,
nous voulons pouvoir utiliser <code>s2</code> apr√®s avoir ajout√© son contenu dans <code>s1</code>.</p>
<!--
```rust
# fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 est {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-16: Using a string slice after appending its
contents to a `String`</span>
-->
<p><span class="caption">Encart 8-16¬†: Utilisation d'une slice de cha√Æne de
caract√®res apr√®s avoir ajout√© son contenu dans une <code>String</code></span></p>
<!--
If the `push_str` method took ownership of `s2`, we wouldn‚Äôt be able to print
its value on the last line. However, this code works as we‚Äôd expect!
-->
<p>Si la m√©thode <code>push_str</code> prenait possession de <code>s2</code>, √† la derni√®re ligne, nous
ne pourrions pas afficher sa valeur. Cependant, ce code fonctionne comme nous
l'esp√©rions¬†!</p>
<!--
The `push` method takes a single character as a parameter and adds it to the
`String`. Listing 8-17 adds the letter ‚Äúl‚Äù to a `String` using the `push`
method.
-->
<p>La m√©thode <code>push</code> prend un seul caract√®re en param√®tre et l'ajoute √† la
<code>String</code>. L'encart 8-17 ajoute la lettre ‚Äúl‚Äù √† une <code>String</code> en utilisant la
m√©thode <code>push</code>.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("lo");
    s.push('l');
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-17: Adding one character to a `String` value
using `push`</span>
-->
<p><span class="caption">Encart 8-17¬†: Ajout d'un unique caract√®re √† la valeur
d'une <code>String</code> en utilisant <code>push</code></span></p>
<!--
As a result, `s` will contain `lol`.
-->
<p>Apr√®s l'ex√©cution, <code>s</code> contiendra <code>lol</code>.</p>
<!--
#### Concatenation with the `+` Operator or the `format!` Macro
-->
<h4 id="concat√©nation-avec-lop√©rateur--ou-la-macro-format"><a class="header" href="#concat√©nation-avec-lop√©rateur--ou-la-macro-format">Concat√©nation avec l'op√©rateur <code>+</code> ou la macro <code>format!</code></a></h4>
<!--
Often, you‚Äôll want to combine two existing strings. One way to do so is to use
the `+` operator, as shown in Listing 8-18.
-->
<p>Souvent, vous aurez besoin de combiner deux cha√Ænes de caract√®res existantes.
Une fa√ßon de faire cela est d'utiliser l'op√©rateur <code>+</code>, comme dans l'encart
8-18.</p>
<!--
```rust
# fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // notez que s1 a √©t√© d√©plac√© ici
                       // et ne pourra plus √™tre utilis√©
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-18: Using the `+` operator to combine two
`String` values into a new `String` value</span>
-->
<p><span class="caption">Encart 8-18¬†: Utilisation de l'op√©rateur <code>+</code> pour combiner
deux valeurs de <code>String</code></span></p>
<!--
The string `s3` will contain `Hello, world!`. The reason `s1` is no longer
valid after the addition, and the reason we used a reference to `s2`, has to do
with the signature of the method that‚Äôs called when we use the `+` operator.
The `+` operator uses the `add` method, whose signature looks something like
this:
-->
<p>La cha√Æne de caract√®res <code>s3</code> va contenir <code>Hello, world!</code>. La raison pour
laquelle <code>s1</code> n'est plus utilisable apr√®s avoir √©t√© ajout√©, et pour laquelle
nous utilisons une r√©f√©rence vers <code>s2</code>, est la signature de la m√©thode qui est
appel√©e lorsque nous utilisons l'op√©rateur <code>+</code>. L'op√©rateur <code>+</code> utilise la
m√©thode <code>add</code>, dont la signature ressemble √† ceci¬†:</p>
<!--
```rust,ignore
fn add(self, s: &str) -> String {
```
-->
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!--
In the standard library, you‚Äôll see `add` defined using generics. Here, we‚Äôve
substituted in concrete types for the generic ones, which is what happens when
we call this method with `String` values. We‚Äôll discuss generics in Chapter 10.
This signature gives us the clues we need to understand the tricky bits of the
`+` operator.
-->
<p>Dans la biblioth√®que standard, vous pouvez constater que <code>add</code> est d√©fini en
utilisant des g√©n√©riques. Ici, nous avons remplac√© par des types concrets √† la
place des g√©n√©riques, ce qui se passe lorsque nous utilisons cette m√©thode avec
des valeurs de type <code>String</code>. Nous verrons la g√©n√©ricit√© au chapitre 10. Cette
signature nous donne les √©l√©ments dont nous avons besoin pour comprendre les
subtilit√©s de l'op√©rateur <code>+</code>.</p>
<!--
First, `s2` has an `&`, meaning that we‚Äôre adding a *reference* of the second
string to the first string. This is because of the `s` parameter in the `add`
function: we can only add a `&str` to a `String`; we can‚Äôt add two `String`
values together. But wait‚Äîthe type of `&s2` is `&String`, not `&str`, as
specified in the second parameter to `add`. So why does Listing 8-18 compile?
-->
<p>Premi√®rement, <code>s2</code> a un <code>&amp;</code>, ce qui veut dire que nous ajoutons une <em>r√©f√©rence</em>
vers la seconde cha√Æne de caract√®res √† la premi√®re cha√Æne. C'est √† cause du
param√®tre <code>s</code> de la fonction <code>add</code>¬†: nous pouvons seulement ajouter un <code>&amp;str</code> √†
une <code>String</code>¬†; nous ne pouvons pas ajouter deux valeurs de type <code>String</code>
ensemble. Mais attendez ‚Äî le type de <code>&amp;s2</code> est <code>&amp;String</code>, et non pas <code>&amp;str</code>,
comme c'est √©crit dans le second param√®tre de <code>add</code>. Alors pourquoi est-ce que
le code de l'encart 8-18 se compile¬†?</p>
<!--
The reason we‚Äôre able to use `&s2` in the call to `add` is that the compiler
can *coerce* the `&String` argument into a `&str`. When we call the `add`
method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`.
We‚Äôll discuss deref coercion in more depth in Chapter 15. Because `add` does
not take ownership of the `s` parameter, `s2` will still be a valid `String`
after this operation.
-->
<p>La raison pour laquelle nous pouvons utiliser <code>&amp;s2</code> dans l'appel √† <code>add</code> est que
le compilateur peut <em>extrapoler</em> l'argument <code>&amp;String</code> en un <code>&amp;str</code>. Lorsque nous
appelons la m√©thode <code>add</code>, Rust va utiliser une <em>extrapolation de
d√©r√©f√©rencement</em>, qui transforme ici <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Nous verrons plus en
d√©tail l'extrapolation de d√©r√©f√©rencement au chapitre 15. Comme <code>add</code> ne prend
pas possession du param√®tre <code>s</code>, <code>s2</code> sera toujours une <code>String</code> valide apr√®s
cette op√©ration.</p>
<!--
Second, we can see in the signature that `add` takes ownership of `self`,
because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be
moved into the `add` call and will no longer be valid after that. So although
`let s3 = s1 + &s2;` looks like it will copy both strings and create a new one,
this statement actually takes ownership of `s1`, appends a copy of the contents
of `s2`, and then returns ownership of the result. In other words, it looks
like it‚Äôs making a lot of copies but isn‚Äôt; the implementation is more
efficient than copying.
-->
<p>Ensuite, nous pouvons constater que la signature de <code>add</code> prend possession de
<code>self</code>, car <code>self</code> n'a <em>pas</em> de <code>&amp;</code>. Cela signifie que <code>s1</code> dans l'encart 8-18
va √™tre d√©plac√© dans l'appel √† <code>add</code> et ne sera plus en vigueur apr√®s cela. Donc
bien que <code>let s3 = s1 + &amp;s2</code> semble copier les deux cha√Ænes de caract√®res pour
en cr√©er une nouvelle, cette instruction va en r√©alit√© prendre possession de
<code>s1</code>, y ajouter une copie du contenu de <code>s2</code> et nous redonner la possession du
r√©sultat. Autrement dit, cela semble faire beaucoup de copies mais en r√©alit√©
non¬†; son impl√©mentation est plus efficace que la copie.</p>
<!--
If we need to concatenate multiple strings, the behavior of the `+` operator
gets unwieldy:
-->
<p>Si nous avons besoin de concat√©ner plusieurs cha√Ænes de caract√®res, le
comportement de l'op√©rateur <code>+</code> devient difficile √† utiliser¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<!--
At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"`
characters, it‚Äôs difficult to see what‚Äôs going on. For more complicated string
combining, we can instead use the `format!` macro:
-->
<p>Au final, <code>s</code> vaudra <code>tic-tac-toe</code>. Avec tous les caract√®res <code>+</code> et <code>&quot;</code>, il est
difficile de visualiser ce qui se passe. Pour une combinaison de cha√Ænes de
caract√®res plus complexe, nous pouvons utiliser √† la place la macro <code>format!</code>¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<!--
This code also sets `s` to `tic-tac-toe`. The `format!` macro works like
`println!`, but instead of printing the output to the screen, it returns a
`String` with the contents. The version of the code using `format!` is much
easier to read, and the code generated by the `format!` macro uses references
so that this call doesn‚Äôt take ownership of any of its parameters.
-->
<p>Ce code assigne lui aussi √† <code>s</code> la valeur <code>tic-tac-toe</code>. La macro <code>format!</code>
fonctionne comme <code>println!</code>, mais au lieu d'afficher son r√©sultat √† l'√©cran,
elle retourne une <code>String</code> avec son contenu. La version du code qui utilise
<code>format!</code> est plus facile √† lire, et le code g√©n√©r√© par la macro <code>format!</code>
utilise des r√©f√©rences afin qu'il ne prenne pas possession de ses param√®tres.</p>
<!--
### Indexing into Strings
-->
<h3 id="lindexation-des-strings"><a class="header" href="#lindexation-des-strings">L'indexation des Strings</a></h3>
<!--
In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a `String` using indexing syntax in Rust, you‚Äôll
get an error. Consider the invalid code in Listing 8-19.
-->
<p>Dans de nombreux autres langages de programmation, l'acc√®s individuel aux
caract√®res d'une cha√Æne de caract√®res en utilisant leur indice est une op√©ration
valide et courante. Cependant, si vous essayez d'acc√©der √† des √©l√©ments d'une
<code>String</code> en utilisant la syntaxe d'indexation avec Rust, vous allez avoir une
erreur. Nous tentons cela dans le code invalide de l'encart 8-19.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span>
-->
<p><span class="caption">Encart 8-19¬†: Tentative d'utilisation de la syntaxe
d'indexation avec une <code>String</code></span></p>
<!--
This code will result in the following error:
-->
<p>Ce code va produire l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 -- > src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<!--
The error and the note tell the story: Rust strings don‚Äôt support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.
-->
<p>L'erreur et la remarque nous expliquent le probl√®me¬†: les <code>String</code> de Rust
n'acceptent pas l'utilisation des indices. Mais pourquoi¬†? Pour r√©pondre √† cette
question, nous avons besoin de savoir comment Rust enregistre les cha√Ænes de
caract√®res dans la m√©moire.</p>
<!--
#### Internal Representation
-->
<h4 id="repr√©sentation-interne"><a class="header" href="#repr√©sentation-interne">Repr√©sentation interne</a></h4>
<!--
A `String` is a wrapper over a `Vec<u8>`. Let‚Äôs look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:
-->
<p>Une <code>String</code> est une surcouche de <code>Vec&lt;u8&gt;</code>. Revenons sur certains exemples de
cha√Ænes de caract√®res correctement encod√©es en UTF-8 que nous avions dans
l'encart 8-14. Premi√®rement, celle-ci¬†:</p>
<!--
```rust
# fn main() {
#     let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
#     let hello = String::from("Dobr√Ω den");
#     let hello = String::from("Hello");
#     let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
#     let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
#     let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
#     let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
#     let hello = String::from("‰Ω†Â•Ω");
#     let hello = String::from("Ol√°");
#     let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let bonjour = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Hello&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Ol√°&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
</span>    let bonjour = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
In this case, `len` will be 4, which means the vector storing the string ‚ÄúHola‚Äù
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. The
following line, however, may surprise you. (Note that this string begins with
the capital Cyrillic letter Ze, not the Arabic number 3.)
-->
<p>Dans ce cas-ci, <code>len</code> vaudra 4, ce qui veut dire que le vecteur qui stocke la
cha√Æne ‚ÄúHola‚Äù a une taille de 4 octets. Chacune des lettres prend 1 octet
lorsqu'elles sont encod√©es en UTF-8. Cependant, la ligne suivante peut
surprendre. (Notez que cette cha√Æne de caract√®res commence avec la lettre
majuscule cyrillique Z√©, et non pas le chiffre arabe 3.)</p>
<!--
```rust
# fn main() {
#     let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
#     let hello = String::from("Dobr√Ω den");
#     let hello = String::from("Hello");
#     let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
#     let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
#     let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
#     let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
#     let hello = String::from("‰Ω†Â•Ω");
#     let hello = String::from("Ol√°");
    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
#     let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let bonjour = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Hello&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Ol√°&quot;);
</span>    let bonjour = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
<span class="boring">    let bonjour = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Asked how long the string is, you might say 12. In fact, Rust‚Äôs answer is 24:
that‚Äôs the number of bytes it takes to encode ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù in UTF-8, because
each Unicode scalar value in that string takes 2 bytes of storage. Therefore,
an index into the string‚Äôs bytes will not always correlate to a valid Unicode
scalar value. To demonstrate, consider this invalid Rust code:
-->
<p>Si on vous demandait la longueur de la cha√Æne de caract√®res, vous r√©pondriez
probablement 12. En r√©alit√©, la r√©ponse de Rust sera 24¬†: c'est le nombre
d'octets n√©cessaires pour encoder ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù en UTF-8, car chaque valeur
scalaire Unicode dans cette cha√Æne de caract√®res prend 2 octets en m√©moire.
Par cons√©quent, un indice dans les octets de la cha√Æne de caract√®res ne
correspondra pas forc√©ment √† une valeur scalaire Unicode valide. Pour d√©montrer
cela, utilisons ce code Rust invalide¬†:</p>
<!--
```rust,ignore,does_not_compile
let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";
let answer = &hello[0];
```
-->
<pre><code class="language-rust ignore does_not_compile">let bonjour = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let reponse = &amp;bonjour[0];
</code></pre>
<!--
You already know that `answer` will not be `–ó`, the first letter. When encoded
in UTF-8, the first byte of `–ó` is `208` and the second is `151`, so it would
seem that `answer` should in fact be `208`, but `208` is not a valid character
on its own. Returning `208` is likely not what a user would want if they asked
for the first letter of this string; however, that‚Äôs the only data that Rust
has at byte index 0. Users generally don‚Äôt want the byte value returned, even
if the string contains only Latin letters: if `&"hello"[0]` were valid code
that returned the byte value, it would return `104`, not `h`.
-->
<p>Vous savez d√©j√† que <code>reponse</code> ne vaudra pas <code>–ó</code>, la premi√®re lettre. Lorsqu'il
est encod√© en UTF-8, le premier octet de <code>–ó</code> est <code>208</code> et le second est <code>151</code>,
donc on dirait que <code>reponse</code> vaudrait <code>208</code>, mais <code>208</code> n'est pas un caract√®re
valide √† lui seul. Retourner <code>208</code> n'est pas ce qu'un utilisateur attend s'il
demande la premi√®re lettre de cette cha√Æne de caract√®res¬†; cependant, c'est la
seule valeur que Rust a √† l'indice 0 des octets. Les utilisateurs ne souhaitent
g√©n√©ralement pas obtenir la valeur d'un octet, m√™me si la cha√Æne de caract√®res
contient uniquement des lettres latines¬†: si <code>&amp;&quot;hello&quot;[0]</code> √©tait un code valide
qui retournait la valeur de l'octet, il retournerait <code>104</code> et non pas <code>h</code>.</p>
<!--
The answer, then, is that to avoid returning an unexpected value and causing
bugs that might not be discovered immediately, Rust doesn‚Äôt compile this code
at all and prevents misunderstandings early in the development process.
-->
<p>La solution est donc, pour √©viter de retourner une valeur inattendue et g√©n√©rer
des bogues qui ne seraient pas d√©couverts imm√©diatement, que Rust ne va pas
compiler ce code et va ainsi √©viter des erreurs d√®s le d√©but du processus de
d√©veloppement.</p>
<!--
#### Bytes and Scalar Values and Grapheme Clusters! Oh My!
-->
<h4 id="des-octets-des-valeurs-scalaires-et-des-groupes-de-graph√®mes--oh-mon-dieu-"><a class="header" href="#des-octets-des-valeurs-scalaires-et-des-groupes-de-graph√®mes--oh-mon-dieu-">Des octets, des valeurs scalaires et des groupes de graph√®mes¬†!? Oh mon Dieu¬†!</a></h4>
<!--
Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust‚Äôs perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call *letters*).
-->
<p>Un autre probl√®me avec l'UTF-8 est qu'il a en fait trois mani√®res pertinentes
de consid√©rer les cha√Ænes de caract√®res avec Rust¬†: comme des octets, comme
des valeurs scalaires ou comme des groupes de graph√®mes (ce qui se rapproche le
plus de ce que nous pourrions appeler des <em>lettres</em>).</p>
<!--
If we look at the Hindi word ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:
-->
<p>Si l'on consid√®re le mot hindi ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù √©crit en √©criture devanagari, il est
stock√© comme un vecteur de valeurs <code>u8</code> qui sont les suivantes¬†:</p>
<!--
```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```
-->
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!--
That‚Äôs 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust‚Äôs `char` type is, those
bytes look like this:
-->
<p>Cela fait 18 octets et c'est ainsi que les ordinateurs stockeront cette donn√©e.
Si nous les voyons comme des valeurs scalaires Unicode, ce qu'est le type <code>char</code>
de Rust, ces octets seront les suivants¬†:</p>
<!--
```text
['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
```
-->
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<!--
There are six `char` values here, but the fourth and sixth are not letters:
they‚Äôre diacritics that don‚Äôt make sense on their own. Finally, if we look at
them as grapheme clusters, we‚Äôd get what a person would call the four letters
that make up the Hindi word:
-->
<p>Nous avons six valeurs <code>char</code> ici, mais les quatri√®me et sixi√®me valeurs ne sont
pas des lettres¬†: ce sont des signes diacritiques qui n'ont pas de sens employ√©s
seuls. Enfin, si nous les voyons comme des groupes de graph√®mes, on obtient ce
qu'on pourrait appeler les quatre lettres qui constituent le mot hindi¬†:</p>
<!--
```text
["‡§®", "‡§Æ", "‡§∏‡•ç", "‡§§‡•á"]
```
-->
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<!--
Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.
-->
<p>Rust fournit diff√©rentes mani√®res d'interpr√©ter les donn√©es brutes des cha√Ænes
de caract√®res que les ordinateurs stockent afin que chaque programme puisse
choisir l'interpr√©tation dont il a besoin, peu importe la langue dans laquelle
sont les donn√©es.</p>
<!--
A final reason Rust doesn‚Äôt allow us to index into a `String` to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn‚Äôt possible to guarantee that performance with a `String`,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.
-->
<p>Une derni√®re raison pour laquelle Rust ne nous autorise pas √† indexer une
<code>String</code> pour r√©cup√©rer un caract√®re est que les op√©rations d'indexation sont
cens√©es prendre un temps constant (O(1)). Mais il n'est pas possible de garantir
cette performance avec une <code>String</code>, car Rust devrait parcourir le contenu
depuis le d√©but jusqu'√† l'indice pour d√©terminer combien il y a de caract√®res
valides.</p>
<!--
### Slicing Strings
-->
<h3 id="les-slices-de-cha√Ænes-de-caract√®res-1"><a class="header" href="#les-slices-de-cha√Ænes-de-caract√®res-1">Les slices de cha√Ænes de caract√®res</a></h3>
<!--
Indexing into a string is often a bad idea because it‚Äôs not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. If you really need to use
indices to create string slices, therefore, Rust asks you to be more specific.
-->
<p>L'indexation sur une cha√Æne de caract√®res est souvent une mauvaise id√©e car le
type de retour de l'op√©ration n'est pas toujours √©vident¬†: un octet, un
caract√®re, un groupe de graph√®mes ou une slice de cha√Æne de caract√®res¬†? Si
vous avez vraiment besoin d'utiliser des indices pour cr√©er des slices de
cha√Ænes, Rust vous demande plus de pr√©cisions.</p>
<!--
Rather than indexing using `[]` with a single number, you can use `[]` with a
range to create a string slice containing particular bytes:
-->
<p>Plut√¥t que d'utiliser <code>[]</code> avec un nombre seul, vous pouvez utiliser <code>[]</code> avec
un intervalle d'indices pour cr√©er une slice de cha√Æne contenant des octets
bien pr√©cis, plut√¥t que d'utiliser <code>[]</code> avec un seul nombre¬†:</p>
<!--
```rust
let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";

let s = &hello[0..4];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bonjour = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;bonjour[0..4];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `s` will be a `&str` that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
`s` will be `–ó–¥`.
-->
<p>Ici, <code>s</code> sera un <code>&amp;str</code> qui contiendra les 4 premiers octets de la cha√Æne de
caract√®res. Pr√©c√©demment, nous avions mentionn√© que chacun de ces caract√®res
√©tait encod√© sur 2 octets, ce qui veut dire que <code>s</code> vaudra <code>–ó–¥</code>.</p>
<!--
If we were to try to slice only part of a character‚Äôs bytes with something like
`&hello[0..1]`, Rust would panic at runtime in the same way as if an invalid
index were accessed in a vector:
-->
<p>Si vous essayons de produire une slice d'une partie des octets d'un caract√®re
avec quelquechose comme <code>&amp;bonjour[0..1]</code>, Rust va paniquer au moment de
l'ex√©cution de la m√™me fa√ßon que si nous utilisions un indice invalide pour
acc√©der √† un √©l√©ment d'un vecteur¬†:</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
You should use ranges to create string slices with caution, because doing so
can crash your program.
-->
<p>Vous devriez utiliser les intervalles pour cr√©er des slices avec prudence, car
cela peut provoquer un plantage de votre programme.</p>
<!--
### Methods for Iterating Over Strings
-->
<h3 id="les-m√©thodes-pour-parcourir-les-cha√Ænes-de-caract√®res"><a class="header" href="#les-m√©thodes-pour-parcourir-les-cha√Ænes-de-caract√®res">Les m√©thodes pour parcourir les cha√Ænes de caract√®res</a></h3>
<!--
The best way to operate on pieces of strings is to be explicit about whether
you want characters or bytes. For individual Unicode scalar values, use the
`chars` method. Calling `chars` on ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù separates out and returns six values
of type `char`, and you can iterate over the result to access each element:
-->
<p>La meilleure mani√®re de travailler sur des parties de cha√Ænes de caract√®res est
d'exprimer clairement si vous voulez travailler avec des caract√®res ou des
octets. Pour les valeurs scalaires Unicode une par une, utilisez la m√©thode
<code>chars</code>. Appeler <code>chars</code> sur ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù s√©pare et retourne six valeurs de type
<code>char</code>, et vous pouvez it√©rer sur le r√©sultat pour acc√©der √† chaque √©l√©ment¬†:</p>
<!--
```rust
for c in "‡§®‡§Æ‡§∏‡•ç‡§§‡•á".chars() {
    println!("{}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the following:
-->
<p>Ce code va afficher ceci¬†:</p>
<!--
```text
‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
```
-->
<pre><code class="language-text">‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
</code></pre>
<!--
Alternatively, the `bytes` method returns each raw byte, which might be
appropriate for your domain:
-->
<p>Aussi, la m√©thode <code>bytes</code> va retourner chaque octet brut, ce qui sera peut-√™tre
plus utile selon ce que vous voulez faire¬†:</p>
<!--
```rust
for b in "‡§®‡§Æ‡§∏‡•ç‡§§‡•á".bytes() {
    println!("{}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the 18 bytes that make up this `String`:
-->
<p>Ce code va afficher les 18 octets qui constituent cette <code>String</code>¬†:</p>
<!--
```text
224
164
// --snip--
165
135
```
-->
<pre><code class="language-text">224
164
// -- √©l√©ments masqu√©s ici --
165
135
</code></pre>
<!--
But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.
-->
<p>Rappelez-vous bien que des valeurs scalaires Unicode peuvent √™tre constitu√©es de
plus d'un octet.</p>
<!--
Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
[crates.io](https://crates.io/)<!-- ignore -- > if this is the functionality you
need.
-->
<p>L'obtention des groupes de graph√®mes √† partir de cha√Ænes de caract√®res est
complexe, donc cette fonctionnalit√© n'est pas fournie par la biblioth√®que
standard. Des crates sont disponibles sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> si c'est la fonctionnalit√© dont
vous avez besoin.</p>
<!--
### Strings Are Not So Simple
-->
<h3 id="les-cha√Ænes-de-caract√®res-ne-sont-pas-si-simples"><a class="header" href="#les-cha√Ænes-de-caract√®res-ne-sont-pas-si-simples">Les cha√Ænes de caract√®res ne sont pas si simples</a></h3>
<!--
To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of `String` data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.
-->
<p>Pour r√©sumer, les cha√Ænes de caract√®res sont complexes. Les diff√©rents langages
de programmation ont fait diff√©rents choix sur la fa√ßon de pr√©senter cette
complexit√© aux d√©veloppeurs. Rust a choisi d'appliquer par d√©faut la gestion
rigoureuse des donn√©es de <code>String</code> pour tous les programmes Rust, ce qui veut
dire que les d√©veloppeurs doivent r√©fl√©chir davantage √† la gestion des donn√©es
UTF-8. Ce compromis r√©v√®le davantage la complexit√© des cha√Ænes de caract√®res par
rapport √† ce que les autres langages de programmation laissent para√Ætre, mais
vous √©vite d'avoir √† g√©rer plus tard dans votre cycle de d√©veloppement des
erreurs √† cause de caract√®res non ASCII.</p>
<!--
Let‚Äôs switch to something a bit less complex: hash maps!
-->
<p>Passons maintenant √† quelque chose de moins complexe¬†: les tables de hachage¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing Keys with Associated Values in Hash Maps
-->
<h2 id="stocker-des-cl√©s-associ√©es-√†-des-valeurs-dans-des-tables-de-hachage"><a class="header" href="#stocker-des-cl√©s-associ√©es-√†-des-valeurs-dans-des-tables-de-hachage">Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></h2>
<!--
The last of our common collections is the *hash map*. The type `HashMap<K, V>`
stores a mapping of keys of type `K` to values of type `V` using a
*hashing function*, which determines how it places these keys and values into
memory. Many programming languages support this kind of data structure, but
they often use a different name, such as hash, map, object, hash table,
dictionary, or associative array, just to name a few.
-->
<p>La derni√®re des collections les plus courantes est la <em>table de hachage (hash
map)</em>. Le type <code>HashMap&lt;K, V&gt;</code> stocke une association de cl√©s de type <code>K</code> √† des
valeurs de type <code>V</code> en utilisant une <em>fonction de hachage</em>, qui d√©termine
comment elle va ranger ces cl√©s et valeurs dans la m√©moire. De nombreux
langages de programmation prennent en charge ce genre de structure de donn√©es,
mais elles ont souvent un nom diff√©rent, tel que hash, map, objet, table
d'association, dictionnaire ou tableau associatif, pour n'en nommer que
quelques-uns.</p>
<!--
Hash maps are useful when you want to look up data not by using an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each team‚Äôs score in a hash map in which
each key is a team‚Äôs name and the values are each team‚Äôs score. Given a team
name, you can retrieve its score.
-->
<p>Les tables de hachage sont utiles lorsque vous voulez rechercher des donn√©es non
pas en utilisant des indices, comme vous pouvez le faire avec les vecteurs, mais
en utilisant une cl√© qui peut √™tre de n'importe quel type. Par exemple, dans un
jeu, vous pouvez consigner le score de chaque √©quipe dans une table de hachage
dans laquelle chaque cl√© est le nom d'une √©quipe et la valeur est le score de
l'√©quipe. Si vous avez le nom d'une √©quipe, vous pouvez r√©cup√©rer son score.</p>
<!--
We‚Äôll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on `HashMap<K, V>` by the standard library.
As always, check the standard library documentation for more information.
-->
<p>Nous allons passer en revue l'API de base des tables de hachage dans cette
section, mais bien d'autres fonctionnalit√©s se cachent dans les fonctions
d√©finies sur <code>HashMap&lt;K, V&gt;</code> par la biblioth√®que standard. Comme d'habitude,
consultez la documentation de la biblioth√®que standard pour plus d'informations.</p>
<!--
### Creating a New Hash Map
-->
<h3 id="cr√©er-une-nouvelle-table-de-hachage"><a class="header" href="#cr√©er-une-nouvelle-table-de-hachage">Cr√©er une nouvelle table de hachage</a></h3>
<!--
One way to create an empty hash map is using `new` and adding elements with
`insert`. In Listing 8-20, we‚Äôre keeping track of the scores of two teams whose
names are *Blue* and *Yellow*. The Blue team starts with 10 points, and the
Yellow team starts with 50.
-->
<p>Une fa√ßon de cr√©er une table de hachage vide est d'utiliser <code>new</code> et d'ajouter
des √©l√©ments avec <code>insert</code>. Dans l'encart 8-20, nous consignons les scores de
deux √©quipes qui s'appellent <em>Bleu</em> et <em>Jaune</em>. L'√©quipe Bleu commence avec 10
points, et l'√©quipe Jaune commence avec 50.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Jaune"), 50);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Jaune&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-20: Creating a new hash map and inserting some
keys and values</span>
-->
<p><span class="caption">Encart 8-20¬†: cr√©ation d'une nouvelle table de hachage et
insertion de quelques cl√©s et valeurs</span></p>
<!--
Note that we need to first `use` the `HashMap` from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it‚Äôs not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there‚Äôs no built-in macro to construct them, for example.
-->
<p>Notez que nous devons d'abord importer <code>HashMap</code> via <code>use</code> depuis la partie des
collections de la biblioth√®que standard. De nos trois collections courantes,
cette derni√®re est la moins utilis√©e, donc elle n'est pas pr√©sente dans les
fonctionnalit√©s import√©es automatiquement dans la port√©e par l'√©tape
pr√©liminaire. Les tables de hachage sont aussi moins g√©r√©es par la biblioth√®que
standard¬†; il n'y a pas de macro int√©gr√©e pour les construire, par exemple.</p>
<!--
Just like vectors, hash maps store their data on the heap. This `HashMap` has
keys of type `String` and values of type `i32`. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.
-->
<p>Exactement comme les vecteurs, les tables de hachage stockent leurs donn√©es sur
le tas. Cette <code>HashMap</code> a des cl√©s de type <code>String</code> et des valeurs de type
<code>i32</code>. Et comme les vecteurs, les tables de hachage sont homog√®nes¬†: toutes les
cl√©s doivent √™tre du m√™me type, et toutes les valeurs doivent aussi √™tre du
m√™me type.</p>
<!--
Another way of constructing a hash map is by using iterators and the `collect`
method on a vector of tuples, where each tuple consists of a key and its value.
We‚Äôll be going into more detail about iterators and their associated methods in
the [‚ÄùProcessing a Series of Items with Iterators‚Äù section of Chapter
13][iterators]<!-- ignore -- >. The `collect` method gathers data into a number
of collection types, including `HashMap`. For example, if we had the team names
and initial scores in two separate vectors, we could use the `zip` method to
create an iterator of tuples where ‚ÄúBlue‚Äù is paired with 10, and so forth. Then
we could use the `collect` method to turn that iterator of tuples into a hash
map, as shown in Listing 8-21.
-->
<p>Une autre fa√ßon de construire une table de hachage est d'utiliser les it√©rateurs
et la m√©thode <code>collect</code> sur un vecteur de tuples, o√π chaque tuple repr√©sente une
cl√© et sa valeur. Nous aborderons en d√©tail les it√©rateurs et leurs m√©thodes
associ√©es dans <a href="ch13-02-iterators.html">une section du chapitre 13</a><!-- ignore -->. La
m√©thode <code>collect</code> regroupe les donn√©es dans quelques types de collections, dont
<code>HashMap</code>. Par exemple, si nous avions les noms des √©quipes et les scores
initiaux dans deux vecteurs s√©par√©s, nous pourrions utiliser la m√©thode <code>zip</code>
pour cr√©er un it√©rateur de tuples o√π ‚ÄúBleu‚Äù est associ√© √† 10, et ainsi de suite.
Ensuite, nous pourrions utiliser la m√©thode <code>collect</code> pour transformer cet
it√©rateur de tuples en table de hachage, comme dans l'encart 8-21.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let equipes = vec![String::from("Bleu"), String::from("Jaune")];
    let scores_initiaux = vec![10, 50];

    let mut scores: HashMap<_, _> =
        equipes.into_iter().zip(scores_initiaux.into_iter()).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let equipes = vec![String::from(&quot;Bleu&quot;), String::from(&quot;Jaune&quot;)];
    let scores_initiaux = vec![10, 50];

    let mut scores: HashMap&lt;_, _&gt; =
        equipes.into_iter().zip(scores_initiaux.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-21: Creating a hash map from a list of teams
and a list of scores</span>
-->
<p><span class="caption">Encart 8-21¬†: cr√©ation d'une table de hachage √† partir
d'une liste d'√©quipes et d'une liste de scores</span></p>
<!--
The type annotation `HashMap<_, _>` is needed here because it‚Äôs possible to
`collect` into many different data structures and Rust doesn‚Äôt know which you
want unless you specify. For the parameters for the key and value types,
however, we use underscores, and Rust can infer the types that the hash map
contains based on the types of the data in the vectors. In Listing 8-21, the
key type will be `String` and the value type will be `i32`, just as in Listing
8-20.
-->
<p>L'annotation de type <code>HashMap&lt;_, _&gt;</code> est n√©cessaire ici car <code>collect</code> peut
g√©n√©rer plusieurs types de structures de donn√©es et Rust ne sait pas laquelle
vous souhaitez si vous ne le pr√©cisez pas. Mais pour les param√®tres qui
correspondent aux types de cl√© et de valeur, nous utilisons des tirets bas, et
Rust peut d√©duire les types que la table de hachage contient en fonction des
types des donn√©es pr√©sentes dans les vecteurs. Dans l'encart 8-21, le type des
cl√©s sera <code>String</code> et le type des valeurs sera <code>i32</code>, comme dans l'encart 8-20.</p>
<!--
### Hash Maps and Ownership
-->
<h3 id="les-tables-de-hachage-et-la-possession"><a class="header" href="#les-tables-de-hachage-et-la-possession">Les tables de hachage et la possession</a></h3>
<!--
For types that implement the `Copy` trait, like `i32`, the values are copied
into the hash map. For owned values like `String`, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.
-->
<p>Pour les types qui impl√©mentent le trait <code>Copy</code>, comme <code>i32</code>, les valeurs sont
copi√©es dans la table de hachage. Pour les valeurs qui sont poss√©d√©es comme
<code>String</code>, les valeurs seront d√©plac√©es et la table de hachage sera la
propri√©taire de ces valeurs, comme d√©montr√© dans l'encart 8-22.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let nom_champ = String::from("Couleur favorite");
    let valeur_champ = String::from("Bleu");

    let mut table = HashMap::new();
    table.insert(nom_champ, valeur_champ);
    // nom_champ et valeur_champ ne sont plus en vigueur √† partir d'ici,
    // essayez de les utiliser et vous verrez l'erreur du compilateur que
    // vous obtiendrez¬†!
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let nom_champ = String::from(&quot;Couleur favorite&quot;);
    let valeur_champ = String::from(&quot;Bleu&quot;);

    let mut table = HashMap::new();
    table.insert(nom_champ, valeur_champ);
    // nom_champ et valeur_champ ne sont plus en vigueur √† partir d'ici,
    // essayez de les utiliser et vous verrez l'erreur du compilateur que
    // vous obtiendrez¬†!
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-22: Showing that keys and values are owned by
the hash map once they‚Äôre inserted</span>
-->
<p><span class="caption">Encart 8-22¬†: d√©monstration que les cl√©s et les valeurs
sont poss√©d√©es par la table de hachage une fois qu'elles sont ins√©r√©es</span></p>
<!--
We aren‚Äôt able to use the variables `field_name` and `field_value` after
they‚Äôve been moved into the hash map with the call to `insert`.
-->
<p>Nous ne pouvons plus utiliser les variables <code>nom_champ</code> et <code>valeur_champ</code> apr√®s
qu'elles ont √©t√© d√©plac√©es dans la table de hachage lors de l'appel √† <code>insert</code>.</p>
<!--
If we insert references to values into the hash map, the values won‚Äôt be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We‚Äôll talk more about these issues in
the [‚ÄúValidating References with
Lifetimes‚Äù][validating-references-with-lifetimes]<!-- ignore -- > section in
Chapter 10.
-->
<p>Si nous ins√©rons dans la table de hachage des r√©f√©rences vers des valeurs, ces
valeurs ne seront pas d√©plac√©es dans la table de hachage. Les valeurs vers
lesquelles les r√©f√©rences pointent doivent rester en vigueur au moins aussi
longtemps que la table de hachage. Nous verrons ces probl√©matiques dans <a href="ch10-03-lifetime-syntax.html">une
section du chapitre 10</a><!-- ignore -->.</p>
<!--
### Accessing Values in a Hash Map
-->
<h3 id="acc√©der-aux-valeurs-dans-une-table-de-hachage"><a class="header" href="#acc√©der-aux-valeurs-dans-une-table-de-hachage">Acc√©der aux valeurs dans une table de hachage</a></h3>
<!--
We can get a value out of the hash map by providing its key to the `get`
method, as shown in Listing 8-23.
-->
<p>Nous pouvons obtenir une valeur d'une table de hachage en passant sa cl√© √† la
m√©thode <code>get</code>, comme dans l'encart 8-23.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Jaune"), 50);

    let nom_equipe = String::from("Bleu");
    let score = scores.get(&nom_equipe);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Jaune&quot;), 50);

    let nom_equipe = String::from(&quot;Bleu&quot;);
    let score = scores.get(&amp;nom_equipe);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-23: Accessing the score for the Blue team
stored in the hash map</span>
-->
<p><span class="caption">Encart 8-23¬†: r√©cup√©ration du score de l'√©quipe <code>Bleu</code>,
stock√© dans la table de hachage</span></p>
<!--
Here, `score` will have the value that‚Äôs associated with the Blue team, and the
result will be `Some(&10)`. The result is wrapped in `Some` because `get`
returns an `Option<&V>`; if there‚Äôs no value for that key in the hash map,
`get` will return `None`. The program will need to handle the `Option` in one
of the ways that we covered in Chapter 6.
-->
<p>Dans notre cas, <code>score</code> aura la valeur qui est associ√©e √† l'√©quipe <code>Bleu</code>, et le
r√©sultat sera <code>Some(&amp;10)</code>. Le r√©sultat est encapsul√© dans un <code>Some</code> car <code>get</code>
retourne une <code>Option&lt;&amp;V&gt;</code>¬†: s'il n'y a pas de valeur pour cette cl√© dans la
table de hachage, <code>get</code> va retourner <code>None</code>. Le programme doit g√©rer cette
<code>Option</code> d'une des mani√®res dont nous avons parl√© au chapitre 6.</p>
<!--
We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a `for` loop:
-->
<p>Nous pouvons it√©rer sur chaque paire de cl√©/valeur dans une table de hachage de
la m√™me mani√®re que nous le faisons avec les vecteurs, en utilisant une boucle
<code>for</code>¬†:</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Jaune"), 50);

    for (cle, valeur) in &scores {
        println!("{}¬†: {}", cle, valeur);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Jaune&quot;), 50);

    for (cle, valeur) in &amp;scores {
        println!(&quot;{}¬†: {}&quot;, cle, valeur);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print each pair in an arbitrary order:
-->
<p>Ce code va afficher chaque paire dans un ordre arbitraire¬†:</p>
<!--
```text
Yellow: 50
Blue: 10
```
-->
<pre><code class="language-text">Jaune¬†: 50
Bleu¬†: 10
</code></pre>
<!--
### Updating a Hash Map
-->
<h3 id="modifier-une-table-de-hachage"><a class="header" href="#modifier-une-table-de-hachage">Modifier une table de hachage</a></h3>
<!--
Although the number of key and value pairs is growable, each key can only have
one value associated with it at a time. When you want to change the data in a
hash map, you have to decide how to handle the case when a key already has a
value assigned. You could replace the old value with the new value, completely
disregarding the old value. You could keep the old value and ignore the new
value, only adding the new value if the key *doesn‚Äôt* already have a value. Or
you could combine the old value and the new value. Let‚Äôs look at how to do each
of these!
-->
<p>Bien que le nombre de paires de cl√©-valeur puisse augmenter, chaque cl√© ne peut
√™tre associ√©e qu'√† une seule valeur √† la fois. Lorsque vous souhaitez modifier
les donn√©es d'une table de hachage, vous devez choisir comment g√©rer le cas o√π
une cl√© a d√©j√† une valeur qui lui est associ√©e. Vous pouvez remplacer l'ancienne
valeur avec la nouvelle valeur, en ignorant compl√®tement l'ancienne valeur. Vous
pouvez garder l'ancienne valeur et ignorer la nouvelle valeur, en ins√©rant la
nouvelle valeur uniquement si la cl√© <em>n'a pas</em> d√©j√† une valeur. Ou vous pouvez
fusionner l'ancienne valeur et la nouvelle. D√©couvrons d√®s maintenant comment
faire chacune de ces actions¬†!</p>
<!--
#### Overwriting a Value
-->
<h4 id="r√©√©crire-une-valeur"><a class="header" href="#r√©√©crire-une-valeur">R√©√©crire une valeur</a></h4>
<!--
If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-24 calls `insert` twice, the hash map will
only contain one key/value pair because we‚Äôre inserting the value for the Blue
team‚Äôs key both times.
-->
<p>Si nous ajoutons une cl√© et une valeur dans une table de hachage et que nous
ajoutons √† nouveau la m√™me cl√© avec une valeur diff√©rente, la valeur associ√©e
√† cette cl√© sera remplac√©e. M√™me si le code dans l'encart 8-24 appelle deux
fois <code>insert</code>, la table de hachage contiendra une seule paire de cl√©/valeur car
nous ajoutons la valeur pour l'√©quipe <code>Bleu</code> √† deux reprises.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Bleu"), 25);

    println!("{:?}", scores);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Bleu&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-24: Replacing a value stored with a particular
key</span>
-->
<p><span class="caption">Encart 8-24¬†: remplacement d'une valeur stock√©e sous une
cl√© sp√©cifique</span></p>
<!--
This code will print `{"Blue": 25}`. The original value of `10` has been
overwritten.
-->
<p>Ce code va afficher <code>{&quot;Bleu&quot;: 25}</code>. La valeur initiale <code>10</code> a √©t√© remplac√©e.</p>
<!--
#### Only Inserting a Value If the Key Has No Value
-->
<h4 id="ajouter-une-valeur-seulement-si-la-cl√©-na-pas-d√©j√†-de-valeur"><a class="header" href="#ajouter-une-valeur-seulement-si-la-cl√©-na-pas-d√©j√†-de-valeur">Ajouter une valeur seulement si la cl√© n'a pas d√©j√† de valeur</a></h4>
<!--
It‚Äôs common to check whether a particular key has a value and, if it doesn‚Äôt,
insert a value for it. Hash maps have a special API for this called `entry`
that takes the key you want to check as a parameter. The return value of the
`entry` method is an enum called `Entry` that represents a value that might or
might not exist. Let‚Äôs say we want to check whether the key for the Yellow team
has a value associated with it. If it doesn‚Äôt, we want to insert the value 50,
and the same for the Blue team. Using the `entry` API, the code looks like
Listing 8-25.
-->
<p>Il est courant de v√©rifier si une cl√© sp√©cifique a d√©j√† une valeur, et si ce
n'est pas le cas, de lui associer une valeur. Les tables de hachage ont une API
sp√©cifique pour ce cas-l√† qui s'appelle <code>entry</code> et qui prend en param√®tre la
cl√© que vous voulez v√©rifier. La valeur de retour de la m√©thode <code>entry</code> est une
√©num√©ration qui s'appelle <code>Entry</code> qui repr√©sente une valeur qui existe ou non.
Imaginons que nous souhaitons v√©rifier si la cl√© pour l'√©quipe <code>Jaune</code> a une
valeur qui lui est associ√©e. Si ce n'est pas le cas, nous voulons lui associer
la valeur 50, et faire de m√™me pour l'√©quipe <code>Bleu</code>. En utilisant l'API <code>entry</code>,
ce code va ressembler √† l'encart 8-25.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Bleu"), 10);

    scores.entry(String::from("Jaune")).or_insert(50);
    scores.entry(String::from("Bleu")).or_insert(50);

    println!("{:?}", scores);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Bleu&quot;), 10);

    scores.entry(String::from(&quot;Jaune&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Bleu&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-25: Using the `entry` method to only insert if
the key does not already have a value</span>
-->
<p><span class="caption">Encart 8-25¬†: utilisation de la m√©thode <code>entry</code> pour
ajouter la cl√© uniquement si elle n'a pas d√©j√† de valeur associ√©e</span></p>
<!--
The `or_insert` method on `Entry` is defined to return a mutable reference to
the value for the corresponding `Entry` key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.
-->
<p>La m√©thode <code>or_insert</code> sur <code>Entry</code> est con√ßue pour retourner une r√©f√©rence
mutable vers la valeur correspondant √† la cl√© du <code>Entry</code> si cette cl√© existe,
et sinon, d'ajouter son param√®tre comme nouvelle valeur pour cette cl√© et
retourner une r√©f√©rence mutable vers la nouvelle valeur. Cette technique est
plus propre que d'√©crire la logique nous-m√™mes et, de plus, elle fonctionne
mieux avec le v√©rificateur d'emprunt.</p>
<!--
Running the code in Listing 8-25 will print `{"Yellow": 50, "Blue": 10}`. The
first call to `entry` will insert the key for the Yellow team with the value
50 because the Yellow team doesn‚Äôt have a value already. The second call to
`entry` will not change the hash map because the Blue team already has the
value 10.
-->
<p>L'ex√©cution du code de l'encart 8-25 va afficher <code>{&quot;Jaune&quot;: 50, &quot;Bleu&quot;: 10}</code>.
Le premier appel √† <code>entry</code> va ajouter la cl√© pour l'√©quipe <code>Jaune</code> avec la
valeur <code>50</code> car l'√©quipe <code>Jaune</code> n'a pas encore de valeur. Le second appel √†
<code>entry</code> ne va pas changer la table de hachage car l'√©quipe <code>Bleu</code> a d√©j√† la
valeur <code>10</code>.</p>
<!--
#### Updating a Value Based on the Old Value
-->
<h4 id="modifier-une-valeur-en-fonction-de-lancienne-valeur"><a class="header" href="#modifier-une-valeur-en-fonction-de-lancienne-valeur">Modifier une valeur en fonction de l'ancienne valeur</a></h4>
<!--
Another common use case for hash maps is to look up a key‚Äôs value and then
update it based on the old value. For instance, Listing 8-26 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we‚Äôve
seen that word. If it‚Äôs the first time we‚Äôve seen a word, we‚Äôll first insert
the value 0.
-->
<p>Une autre utilisation courante avec les tables de hachage est de regarder la
valeur d'une cl√© et ensuite la modifier en fonction de l'ancienne valeur. Par
exemple, l'encart 8-26 contient du code qui compte combien de fois chaque mot
appara√Æt dans du texte. Nous utilisons une table de hachage avec les mots comme
cl√©s et nous incr√©mentons la valeur pour compter combien de fois nous avons vu
ce mot. Si c'est la premi√®re fois que nous voyons un mot, nous allons d'abord
ins√©rer la valeur <code>0</code>.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let texte = "bonjour le monde magnifique monde";

    let mut table = HashMap::new();

    for mot in texte.split_whitespace() {
        let compteur = table.entry(mot).or_insert(0);
        *compteur += 1;
    }

    println!("{:?}", table);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let texte = &quot;bonjour le monde magnifique monde&quot;;

    let mut table = HashMap::new();

    for mot in texte.split_whitespace() {
        let compteur = table.entry(mot).or_insert(0);
        *compteur += 1;
    }

    println!(&quot;{:?}&quot;, table);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-26: Counting occurrences of words using a hash
map that stores words and counts</span>
-->
<p><span class="caption">Encart 8-26¬†: comptage des occurrences des mots en
utilisant une table de hachage qui stocke les mots et leur quantit√©</span></p>
<!--
This code will print `{"world": 2, "hello": 1, "wonderful": 1}`. The
`split_whitespace` method iterates over sub-slices, separated by whitespace, of
the value in `text`. The `or_insert` method returns a mutable reference (`&mut
V`) to the value for the specified key. Here we store that mutable reference in
the `count` variable, so in order to assign to that value, we must first
dereference `count` using the asterisk (`*`). The mutable reference goes out of
scope at the end of the `for` loop, so all of these changes are safe and
allowed by the borrowing rules.
-->
<p>Ce code va afficher <code>{&quot;monde&quot;: 2, &quot;bonjour&quot;: 1, &quot;magnifique&quot;: 1, &quot;le&quot;: 1}</code>. La
m√©thode <code>split_whitespace</code> va it√©rer sur les sous-slices, s√©par√©es par des
espaces vides, sur la valeur dans <code>texte</code>. La m√©thode <code>or_insert</code> retourne une
r√©f√©rence mutable (<code>&amp;mut V</code>) vers la valeur de la cl√© sp√©cifi√©e. Nous stockons
ici la r√©f√©rence mutable dans la variable <code>compteur</code>, donc pour affecter une
valeur, nous devons d'abord d√©r√©f√©rencer <code>compteur</code> en utilisant l'ast√©risque
(<code>*</code>). La r√©f√©rence mutable sort de la port√©e √† la fin de la boucle <code>for</code>, donc
tous ces changements sont s√ªrs et autoris√©s par les r√®gles d'emprunt.</p>
<!--
### Hashing Functions
-->
<h3 id="fonctions-de-hachage"><a class="header" href="#fonctions-de-hachage">Fonctions de hachage</a></h3>
<!--
By default, `HashMap` uses a hashing function called *SipHash* that can provide
resistance to Denial of Service (DoS) attacks involving hash
tables[^siphash]<!-- ignore -- >. This is not the fastest hashing algorithm
available, but the trade-off for better security that comes with the drop in
performance is worth it. If you profile your code and find that the default
hash function is too slow for your purposes, you can switch to another function
by specifying a different hasher. A *hasher* is a type that implements the
`BuildHasher` trait. We‚Äôll talk about traits and how to implement them in
Chapter 10. You don‚Äôt necessarily have to implement your own hasher from
scratch; [crates.io](https://crates.io/)<!-- ignore -- > has libraries shared by
other Rust users that provide hashers implementing many common hashing
algorithms.
-->
<p>Par d√©faut, <code>HashMap</code> utilise une fonction de hachage nomm√©e SipHash qui r√©siste
aux attaques par d√©ni de service (DoS) envers les tables de hachage<sup class="footnote-reference"><a href="#siphash">1</a></sup>.
Ce n'est pas l'algorithme de hachage le plus rapide qui existe, mais le
compromis entre une meilleure s√©curit√© et la baisse de performances en vaut la
peine. Si vous analysez la performance de votre code et que vous vous rendez
compte que la fonction de hachage par d√©faut est trop lente pour vos besoins,
vous pouvez la remplacer par une autre fonction en sp√©cifiant un hacheur
diff√©rent. Un <em>hacheur</em> est un type qui impl√©mente le trait <code>BuildHasher</code>. Nous
verrons les traits et comment les impl√©menter au chapitre 10. Vous n'avez pas
forc√©ment besoin d'impl√©menter votre propre hacheur √† partir de z√©ro¬†;
<a href="https://crates.io/">crates.io</a> h√©berge des biblioth√®ques partag√©es par d'autres
utilisateurs de Rust qui fournissent de nombreux algorithmes de hachage
r√©pandus.</p>
<!--
[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)
-->
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<!--
## Summary
-->
<h2 id="r√©sum√©-7"><a class="header" href="#r√©sum√©-7">R√©sum√©</a></h2>
<!--
Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:
-->
<p>Les vecteurs, Strings, et tables de hachage vont vous apporter de nombreuses
fonctionnalit√©s n√©cessaires √† vos programmes lorsque vous aurez besoin de
stocker, acc√©der, et modifier des donn√©es. Voici quelques exercices que vous
devriez maintenant √™tre en mesure de r√©soudre¬†:</p>
<!--
* Given a list of integers, use a vector and return the median (when sorted,
  the value in the middle position) and mode (the value that occurs most often;
  a hash map will be helpful here) of the list.
* Convert strings to pig latin. The first consonant of each word is moved to
  the end of the word and ‚Äúay‚Äù is added, so ‚Äúfirst‚Äù becomes ‚Äúirst-fay.‚Äù Words
  that start with a vowel have ‚Äúhay‚Äù added to the end instead (‚Äúapple‚Äù becomes
  ‚Äúapple-hay‚Äù). Keep in mind the details about UTF-8 encoding!
* Using a hash map and vectors, create a text interface to allow a user to add
  employee names to a department in a company. For example, ‚ÄúAdd Sally to
  Engineering‚Äù or ‚ÄúAdd Amir to Sales.‚Äù Then let the user retrieve a list of all
  people in a department or all people in the company by department, sorted
  alphabetically.
-->
<ul>
<li>√Ä partir d'une liste d'entiers, utiliser un vecteur et retourner la m√©diane
(la valeur au milieu lorsque la liste est tri√©e) et le mode (la valeur qui
appara√Æt le plus souvent¬†; une table de hachage sera utile dans ce cas) de la
liste.</li>
<li>Convertir des cha√Ænes de caract√®res dans une variante du louch√©bem.
La consonne initiale de chaque mot est remplac√©e par la lettre <code>l</code> et est
r√©tablie √† la fin du mot suivie du suffixe argotique ‚Äúem‚Äù¬†; ainsi, ‚Äúbonjour‚Äù
devient ‚Äú<em>l</em>onjour<em>bem</em>‚Äù. Si le mot commence par une voyelle, ajouter un <code>l</code>
au d√©but du mot et ajouter √† la fin le suffixe ‚Äúmuche‚Äù. Et gardez en t√™te les
d√©tails √† propos de l'encodage UTF-8¬†!</li>
<li>En utilisant une table de hachage et des vecteurs, cr√©ez une interface
textuelle pour permettre √† un utilisateur d'ajouter des noms d'employ√©s dans
un d√©partement d'une entreprise. Par exemple, ‚ÄúAjouter Sally au bureau
d'√©tudes‚Äù ou ‚ÄúAjouter Amir au service commercial‚Äù. Ensuite, donnez la
possibilit√© √† l'utilisateur de r√©cup√©rer une liste de toutes les personnes
dans un d√©partement, ou tout le monde dans l'entreprise tri√© par d√©partement,
et class√©s dans l'ordre alphab√©tique dans tous les cas.</li>
</ul>
<!--
The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!
-->
<p>La documentation de l'API de la biblioth√®que standard d√©crit les m√©thodes qu'ont
les vecteurs, cha√Ænes de caract√®res et tables de hachage, ce qui vous sera bien
utile pour mener √† bien ces exercices¬†!</p>
<!--
We‚Äôre getting into more complex programs in which operations can fail, so, it‚Äôs
a perfect time to discuss error handling. We‚Äôll do that next!
-->
<p>Nous nous lan√ßons dans des programmes de plus en plus complexes dans lesquels
les op√©rations peuvent √©chouer, c'est donc le moment id√©al pour voir comment
bien g√©rer les erreurs. C'est ce que nous allons faire au prochain chapitre¬†!</p>
<!--
[iterators]: ch13-02-iterators.html
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Error Handling
-->
<h1 id="la-gestion-des-erreurs"><a class="header" href="#la-gestion-des-erreurs">La gestion des erreurs</a></h1>
<!--
Errors are a fact of life in software, so Rust has a number of features for
handling situations in which something goes wrong. In many cases, Rust requires
you to acknowledge the possibility of an error and take some action before your
code will compile. This requirement makes your program more robust by ensuring
that you‚Äôll discover errors and handle them appropriately before you‚Äôve
deployed your code to production!
-->
<p>Les erreurs font partie de la vie des programmes informatiques, c'est pourquoi
Rust a des fonctionnalit√©s pour g√©rer les situations dans lesquelles quelque
chose d√©rape. Dans de nombreux cas, Rust exige que vous anticipiez les erreurs
possibles et que vous preniez des dispositions avant de pouvoir compiler votre
code. Cette exigence rend votre programme plus r√©siliant en s'assurant que vous
d√©tectez et g√©rez les erreurs correctement avant m√™me que vous ne d√©ployiez
votre code en production¬†!</p>
<!--
Rust groups errors into two major categories: *recoverable* and *unrecoverable*
errors. For a recoverable error, such as a *file not found* error, we most
likely just want to report the problem to the user and retry the operation.
Unrecoverable errors are always symptoms of bugs, like trying to access a
location beyond the end of an array, and so we want to immediately stop the
program.
-->
<p>Rust classe les erreurs dans deux cat√©gories principales¬†: les erreurs
<em>r√©cup√©rables</em> et <em>irr√©cup√©rables</em>. Pour les erreurs r√©cup√©rables, comme
l'erreur <em>le fichier n'a pas √©t√© trouv√©</em>, nous pr√©f√©rons probablement signaler
le probl√®me √† l'utilisateur et relancer l'op√©ration. Les erreurs irr√©cup√©rables
sont toujours des sympt√¥mes de bogues, comme par exemple essayer d'acc√©der √† un
√©l√©ment en dehors de l'intervalle de donn√©es d'un tableau, et alors dans ce cas
nous voulons arr√™ter imm√©diatement l'ex√©cution du programme.</p>
<!--
Most languages don‚Äôt distinguish between these two kinds of errors and handle
both in the same way, using mechanisms such as exceptions. Rust doesn‚Äôt have
exceptions. Instead, it has the type `Result<T, E>` for recoverable errors and
the `panic!` macro that stops execution when the program encounters an
unrecoverable error. This chapter covers calling `panic!` first and then talks
about returning `Result<T, E>` values. Additionally, we‚Äôll explore
considerations when deciding whether to try to recover from an error or to stop
execution.
-->
<p>La plupart des langages de programmation ne font pas de distinction entre ces
deux types d'erreurs et les g√®rent de la m√™me mani√®re, en utilisant des
fonctionnalit√©s comme les exceptions. Rust n'a pas d'exception. √Ä la place, il
a les types <code>Result&lt;T, E&gt;</code> pour les erreurs r√©cup√©rables, et la macro <code>panic!</code>
qui arr√™te l'ex√©cution quand le programme se heurte √† des erreurs
irr√©cup√©rables. Nous allons commencer ce chapitre par expliquer l'utilisation de
<code>panic!</code>, puis nous allons voir les valeurs de retour <code>Result&lt;T, E&gt;</code>. Enfin,
nous allons voir les √©l√©ments √† prendre en compte pour d√©cider si nous devons
essayer de rattraper une erreur ou alors arr√™ter l'ex√©cution.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Unrecoverable Errors with `panic!`
-->
<h2 id="les-erreurs-irr√©cup√©rables-avec-panic"><a class="header" href="#les-erreurs-irr√©cup√©rables-avec-panic">Les erreurs irr√©cup√©rables avec <code>panic!</code></a></h2>
<!--
Sometimes, bad things happen in your code, and there‚Äôs nothing you can do about
it. In these cases, Rust has the `panic!` macro. When the `panic!` macro
executes, your program will print a failure message, unwind and clean up the
stack, and then quit. We‚Äôll commonly invoke a panic when a bug of some kind has
been detected and it‚Äôs not clear how to handle the problem at the time we‚Äôre
writing our program.
-->
<p>Parfois, des choses se passent mal dans votre code, et vous ne pouvez rien y
faire. Pour ces cas-l√†, Rust a la macro <code>panic!</code>. Quand la macro <code>panic!</code>
s'ex√©cute, votre programme va afficher un message d'erreur, d√©rouler et
nettoyer la pile, et ensuite fermer le programme. Nous allons souvent faire
paniquer le programme lorsqu'un bogue a √©t√© d√©tect√©, et qu&quot;on ne sait comment
g√©rer cette erreur au moment de l'√©criture de notre programme.</p>
<!--
> ### Unwinding the Stack or Aborting in Response to a Panic
>
> By default, when a panic occurs, the program starts *unwinding*, which
> means Rust walks back up the stack and cleans up the data from each function
> it encounters. However, this walking back and cleanup is a lot of work. Rust,
> therefore, allows you to choose the alternative of immediately *aborting*,
> which ends the program without cleaning up. Memory that the program was using
> will then need to be cleaned up by the operating system. If in your project
> you need to make the resulting binary as small as possible, you can switch
> from unwinding to aborting upon a panic by adding `panic = 'abort'` to the
> appropriate `[profile]` sections in your *Cargo.toml* file. For example, if
> you want to abort on panic in release mode, add this:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```
-->
<blockquote>
<h3 id="d√©rouler-la-pile-ou-abandonner-suite-√†-un-panic"><a class="header" href="#d√©rouler-la-pile-ou-abandonner-suite-√†-un-panic">D√©rouler la pile ou abandonner suite √† un <code>panic!</code></a></h3>
<p>Par d√©faut, quand un <em>panic</em> se produit, le programme se met √† <em>d√©rouler</em>, ce
qui veut dire que Rust retourne en arri√®re dans la pile et nettoie les
donn√©es de chaque fonction qu'il rencontre sur son passage. Cependant, cette
marche arri√®re et le nettoyage demandent beaucoup de travail. Toutefois, Rust
vous permet de choisir l'alternative <em>d'abandonner</em> imm√©diatement, ce qui
arr√™te le programme sans nettoyage. La m√©moire qu'utilisait le programme
devra ensuite √™tre nettoy√©e par le syst√®me d'exploitation. Si dans votre
projet vous avez besoin de construire un ex√©cutable le plus petit possible,
vous pouvez passer du d√©roulage √† l'abandon lors d'un panic en ajoutant
<code>panic = 'abort'</code> aux sections <code>[profile]</code> appropri√©es dans votre fichier
<em>Cargo.toml</em>. Par exemple, si vous souhaitez abandonner lors d'un panic en
mode publication <em>(release)</em>, ajoutez ceci¬†:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<!--
Let‚Äôs try calling `panic!` in a simple program:
-->
<p>Essayons d'appeler <code>panic!</code> dans un programme simple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,panics
fn main() {
    panic!("crash and burn");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<!--
When you run the program, you‚Äôll see something like this:
-->
<p>Lorsque vous lancez le programme, vous allez voir quelque chose comme ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The call to `panic!` causes the error message contained in the last two lines.
The first line shows our panic message and the place in our source code where
the panic occurred: *src/main.rs:2:5* indicates that it‚Äôs the second line,
fifth character of our *src/main.rs* file.
-->
<p>L'appel √† <code>panic!</code> d√©clenche le message d'erreur pr√©sent dans les deux derni√®res
lignes. La premi√®re ligne affiche notre message associ√© au panic et
l'emplacement dans notre code source o√π se produit le panic¬†: <em>src/main.rs:2:5</em>
indique que c'est √† la seconde ligne et au cinqui√®me caract√®re de notre fichier
<em>src/main.rs</em>.</p>
<!--
In this case, the line indicated is part of our code, and if we go to that
line, we see the `panic!` macro call. In other cases, the `panic!` call might
be in code that our code calls, and the filename and line number reported by
the error message will be someone else‚Äôs code where the `panic!` macro is
called, not the line of our code that eventually led to the `panic!` call. We
can use the backtrace of the functions the `panic!` call came from to figure
out the part of our code that is causing the problem. We‚Äôll discuss backtraces
in more detail next.
-->
<p>Dans cet exemple, la ligne indiqu√©e fait partie de notre code, et si nous
allons voir cette ligne, nous verrons l'appel √† la macro <code>panic!</code>. Dans d'autres
cas, l'appel de <code>panic!</code> pourrait se produire dans du code que notre code
utilise. Le nom du fichier et la ligne indiqu√©e par le message d'erreur seront
alors ceux du code de quelqu'un d'autre o√π la macro <code>panic!</code> est appel√©e, et non
pas la ligne de notre code qui nous a men√© √† cet appel de <code>panic!</code>. Nous pouvons
utiliser le retra√ßage des fonctions qui ont appel√© <code>panic!</code> pour rep√©rer la
partie de notre code qui pose probl√®me. Nous allons maintenant parler plus en
d√©tail du retra√ßage.</p>
<!--
### Using a `panic!` Backtrace
-->
<h3 id="utiliser-le-retra√ßage-de-panic"><a class="header" href="#utiliser-le-retra√ßage-de-panic">Utiliser le retra√ßage de <code>panic!</code></a></h3>
<!--
Let‚Äôs look at another example to see what it‚Äôs like when a `panic!` call comes
from a library because of a bug in our code instead of from our code calling
the macro directly. Listing 9-1 has some code that attempts to access an
index in a vector beyond the range of valid indexes.
-->
<p>Analysons un autre exemple pour voir ce qui se passe lors d'un appel de <code>panic!</code>
qui se produit dans une biblioth√®que √† cause d'un bogue dans notre code plut√¥t
qu'un appel √† la macro directement. L'encart 9-1 montre du code qui essaye
d'acc√©der √† un indice d'un vecteur en dehors de l'intervalle des indices
valides.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,panics
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-1: Attempting to access an element beyond the
end of a vector, which will cause a call to `panic!`</span>
-->
<p><span class="caption">Encart 9-1¬†: tentative d'acc√®s √† un √©l√©ment qui d√©passe de
l'intervalle d'un vecteur, ce qui provoque un <code>panic!</code></span></p>
<!--
Here, we‚Äôre attempting to access the 100th element of our vector (which is at
index 99 because indexing starts at zero), but the vector has only 3 elements.
In this situation, Rust will panic. Using `[]` is supposed to return an
element, but if you pass an invalid index, there‚Äôs no element that Rust could
return here that would be correct.
-->
<p>Ici, nous essayons d'acc√©der au centi√®me √©l√©ment de notre vecteur (qui est √†
l'indice 99 car l'indexation commence √† z√©ro), mais le vecteur a seulement
trois √©l√©ments. Dans ce cas, Rust va paniquer. Utiliser <code>[]</code> est cens√©
retourner un √©l√©ment, mais si vous lui donnez un indice invalide, Rust ne
pourra pas retourner un √©l√©ment acceptable dans ce cas.</p>
<!--
In C, attempting to read beyond the end of a data structure is undefined
behavior. You might get whatever is at the location in memory that would
correspond to that element in the data structure, even though the memory
doesn‚Äôt belong to that structure. This is called a *buffer overread* and can
lead to security vulnerabilities if an attacker is able to manipulate the index
in such a way as to read data they shouldn‚Äôt be allowed to that is stored after
the data structure.
-->
<p>En C, tenter de lire au-del√† de la fin d'une structure de donn√©es suit un
comportement ind√©fini. Vous pourriez r√©cup√©rer la valeur √† l'emplacement m√©moire
qui correspondrait √† l'√©l√©ment demand√© de la structure de donn√©es, m√™me si cette
partie de la m√©moire n'appartient pas √† cette structure de donn√©es. C'est ce
qu'on appelle une <em>lecture hors limites</em> et cela peut mener √† des failles de
s√©curit√© si un attaquant a la possibilit√© de contr√¥ler l'indice de telle mani√®re
qu'il puisse lire les donn√©es qui ne devraient pas √™tre lisibles en dehors de la
structure de donn√©es.</p>
<!--
To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesn‚Äôt exist, Rust will stop execution and refuse to
continue. Let‚Äôs try it and see:
-->
<p>Afin de prot√©ger votre programme de ce genre de vuln√©rabilit√©, si vous essayez
de lire un √©l√©ment √† un indice qui n'existe pas, Rust va arr√™ter l'ex√©cution et
refuser de continuer. Essayez et vous verrez¬†:</p>
<!--
```console
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
This error points at line 4 of our `main.rs` where we attempt to access index
99. The next note line tells us that we can set the `RUST_BACKTRACE`
environment variable to get a backtrace of exactly what happened to cause the
error. A *backtrace* is a list of all the functions that have been called to
get to this point. Backtraces in Rust work as they do in other languages: the
key to reading the backtrace is to start from the top and read until you see
files you wrote. That‚Äôs the spot where the problem originated. The lines above
that spot are code that your code has called; the lines below are code that
called your code. These before-and-after lines might include core Rust code,
standard library code, or crates that you‚Äôre using. Let‚Äôs try getting a
backtrace by setting the `RUST_BACKTRACE` environment variable to any value
except 0. Listing 9-2 shows output similar to what you‚Äôll see.
-->
<p>Cette erreur mentionne la ligne 4 de notre fichier <em>main.rs</em> o√π on essaie
d'acc√©der √† l'indice 99. La ligne suivante nous informe que nous pouvons r√©gler
la variable d'environnement <code>RUST_BACKTRACE</code> pour obtenir le retra√ßage de ce qui
s'est exactement pass√© pour mener √† cette erreur. Un <em>retra√ßage</em> consiste √†
lister toutes les fonctions qui ont √©t√© appel√©es pour arriver jusqu'√† ce point.
En Rust, le retra√ßage fonctionne comme dans d'autres langages¬†: le secret pour
lire le retra√ßage est de commencer d'en haut et lire jusqu'√† ce que vous voyiez
les fichiers que vous avez √©crits. C'est l'endroit o√π s'est produit le probl√®me.
Les lignes avant cet endroit est du code qui a √©t√© appel√© par votre propre
code¬†; les lignes qui suivent repr√©sentent le code qui a appel√© votre code. Ces
lignes &quot;avant et apr√®s&quot; peuvent √™tre du code du c≈ìur de Rust, du code de la
biblioth√®que standard, ou des crates que vous utilisez. Essayons d'obtenir un
retra√ßage en r√©glant la variable d'environnement <code>RUST_BACKTRACE</code> √† n'importe
quelle valeur autre que 0. L'encart 9-2 nous montre un retour similaire √† ce
que vous devriez voir¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-- >
-->
<!--
```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: <alloc::vec::Vec<T> as core::ops::index::Index<I>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<!--
<span class="caption">Listing 9-2: The backtrace generated by a call to
`panic!` displayed when the environment variable `RUST_BACKTRACE` is set</span>
-->
<p><span class="caption">Encart 9-2¬†: le retra√ßage g√©n√©r√© par l'appel de <code>panic!</code>
qui s'affiche quand la variable d'environnement <code>RUST_BACKTRACE</code> est d√©finie
</span></p>
<!--
That‚Äôs a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using `cargo build` or `cargo run` without the `--release` flag,
as we have here.
-->
<p>Cela fait beaucoup de contenu¬†! Ce que vous voyez sur votre machine peut √™tre
diff√©rent en fonction de votre syst√®me d'exploitation et de votre version de
Rust. Pour avoir le retra√ßage avec ces informations, les symboles de d√©bogage
doivent √™tre activ√©s. Les symboles de d√©bogage sont activ√©s par d√©faut quand on
utilise <code>cargo build</code> ou <code>cargo run</code> sans le drapeau <code>--release</code>, comme c'est le
cas ici.</p>
<!--
In the output in Listing 9-2, line 6 of the backtrace points to the line in our
project that‚Äôs causing the problem: line 4 of *src/main.rs*. If we don‚Äôt want
our program to panic, we should start our investigation at the location pointed
to by the first line mentioning a file we wrote. In Listing 9-1, where we
deliberately wrote code that would panic, the way to fix the panic is to not
request an element beyond the range of the vector indexes. When your code
panics in the future, you‚Äôll need to figure out what action the code is taking
with what values to cause the panic and what the code should do instead.
-->
<p>Dans l'encart 9-2, la ligne 6 du retra√ßage nous montre la ligne de notre projet
qui provoque le probl√®me¬†: la ligne 4 de <em>src/main.rs</em>. Si nous ne voulons pas
que notre programme panique, le premier endroit que nous devrions inspecter est
l'emplacement cit√© par la premi√®re ligne qui mentionne du code que nous avons
√©crit. Dans l'encart 9-1, o√π nous avons d√©lib√©r√©ment √©crit du code qui panique,
la solution pour ne pas paniquer est de ne pas demander un √©l√©ment en dehors de
l'intervalle des indices du vecteur. √Ä l'avenir, quand votre code paniquera,
vous aurez besoin de prendre des dispositions dans votre code pour les valeurs
qui font paniquer et de coder quoi faire lorsque cela se produit.</p>
<!--
We‚Äôll come back to `panic!` and when we should and should not use `panic!` to
handle error conditions in the [‚ÄúTo `panic!` or Not to
`panic!`‚Äù][to-panic-or-not-to-panic]<!-- ignore -- > section later in this
chapter. Next, we‚Äôll look at how to recover from an error using `Result`.
-->
<p>Nous reviendrons sur le cas du <code>panic!</code> et sur les cas o√π nous devrions et ne
devrions pas utiliser <code>panic!</code> pour g√©rer les conditions d'erreur plus tard
√† <a href="ch09-03-to-panic-or-not-to-panic.html">la fin de ce chapitre</a><!-- ignore -->. Pour le
moment, nous allons voir comment g√©rer une erreur en utilisant <code>Result</code>.</p>
<!--
[to-panic-or-not-to-panic]:
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Recoverable Errors with `Result`
-->
<h2 id="des-erreurs-r√©cup√©rables-avec-result"><a class="header" href="#des-erreurs-r√©cup√©rables-avec-result">Des erreurs r√©cup√©rables avec <code>Result</code></a></h2>
<!--
Most errors aren‚Äôt serious enough to require the program to stop entirely.
Sometimes, when a function fails, it‚Äôs for a reason that you can easily
interpret and respond to. For example, if you try to open a file and that
operation fails because the file doesn‚Äôt exist, you might want to create the
file instead of terminating the process.
-->
<p>La plupart des erreurs ne sont pas assez graves au point d'arr√™ter compl√®tement
le programme. Parfois, lorsqu'une fonction √©choue, c'est pour une raison que
vous pouvez facilement comprendre et pour laquelle vous pouvez agir en
cons√©quence. Par exemple, si vous essayez d'ouvrir un fichier et que l'op√©ration
√©choue parce que le fichier n'existe pas, vous pourriez vouloir cr√©er le fichier
plut√¥t que d'arr√™ter le processus.</p>
<!--
Recall from [‚ÄúHandling Potential Failure with the `Result`
Type‚Äù][handle_failure]<!-- ignore -- > in Chapter 2 that the `Result` enum is
defined as having two variants, `Ok` and `Err`, as follows:
-->
<p>Souvenez-vous de la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">‚ÄúG√©rer les erreurs potentielles avec le type
<code>Result</code>‚Äù</a><!-- ignore --> du chapitre 2 que l'√©num√©ration
<code>Result</code> poss√®de deux variantes, <code>Ok</code> et <code>Err</code>, comme ci-dessous¬†:</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `T` and `E` are generic type parameters: we‚Äôll discuss generics in more
detail in Chapter 10. What you need to know right now is that `T` represents
the type of the value that will be returned in a success case within the `Ok`
variant, and `E` represents the type of the error that will be returned in a
failure case within the `Err` variant. Because `Result` has these generic type
parameters, we can use the `Result` type and the functions defined on it in
many different situations where the successful value and error value we want to
return may differ.
-->
<p>Le <code>T</code> et le <code>E</code> sont des param√®tres de type g√©n√©riques¬†: nous parlerons plus en
d√©tail de la g√©n√©ricit√© au chapitre 10. Tout ce que vous avez besoin de savoir
pour le moment, c'est que <code>T</code> repr√©sente le type de valeur imbriqu√©e dans la
variante <code>Ok</code> qui sera retourn√©e dans le cas d'un succ√®s, et <code>E</code> repr√©sente le
type d'erreur imbriqu√©e dans la variante <code>Err</code> qui sera retourn√©e dans le cas
d'un √©chec. Comme <code>Result</code> a ces param√®tres de type g√©n√©riques, nous pouvons
utiliser le type <code>Result</code> et les fonctions associ√©es dans diff√©rentes
situations o√π la valeur de succ√®s et la valeur d'erreur peuvent varier.</p>
<!--
Let‚Äôs call a function that returns a `Result` value because the function could
fail. In Listing 9-3 we try to open a file.
-->
<p>Utilisons une fonction qui retourne une valeur de type <code>Result</code> car la fonction
peut √©chouer. Dans l'encart 9-3, nous essayons d'ouvrir un fichier¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-3: Opening a file</span>
-->
<p><span class="caption">Encart 9-3¬†: ouverture d'un fichier</span></p>
<!--
How do we know `File::open` returns a `Result`? We could look at the [standard
library API documentation](../std/index.html)<!-- ignore -- >, or we could ask
the compiler! If we give `f` a type annotation that we know is *not* the return
type of the function and then try to compile the code, the compiler will tell
us that the types don‚Äôt match. The error message will then tell us what the
type of `f` *is*. Let‚Äôs try it! We know that the return type of `File::open`
isn‚Äôt of type `u32`, so let‚Äôs change the `let f` statement to this:
-->
<p>Comment savons-nous que <code>File::open</code> retourne un <code>Result</code>¬†? Nous pouvons
consulter la <a href="https://doc.rust-lang.org/std/index.html">documentation de l'API de la biblioth√®que
standard</a><!-- ignore -->, ou nous
pouvons demander au compilateur¬†! Si nous appliquons √† <code>f</code> une annotation de
type dont nous savons qu'elle n'est <em>pas</em> le type de retour de la fonction et
que nous essayons ensuite de compiler le code, le compilateur va nous dire que
les types ne correspondent pas. Le message d'erreur va ensuite nous dire <em>quel
est le type</em> de <code>f</code>. Essayons cela¬†! Nous savons que le type de retour de
<code>File::open</code> n'est pas <code>u32</code>, alors essayons de changer l'instruction <code>let f</code>
par ceci¬†:</p>
<!--
```rust,ignore,does_not_compile
# use std::fs::File;
# 
# fn main() {
    let f: u32 = File::open("hello.txt");
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre>
<!--
Attempting to compile now gives us the following output:
-->
<p>Tenter de compiler ce code nous donne maintenant le r√©sultat suivant¬†:</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 -- > src/main.rs:4:18
  |
4 |     let f: u32 = File::open("hello.txt");
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `Result<File, std::io::Error>`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `Result&lt;File, std::io::Error&gt;`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling` due to previous error
</code></pre>
<!--
This tells us the return type of the `File::open` function is a `Result<T, E>`.
The generic parameter `T` has been filled in here with the type of the success
value, `std::fs::File`, which is a file handle. The type of `E` used in the
error value is `std::io::Error`.
-->
<p>Cela nous dit que le type de retour de la fonction <code>File::open</code> est de la forme
<code>Result&lt;T, E&gt;</code>. Le param√®tre g√©n√©rique <code>T</code> a √©t√© remplac√© dans ce cas par le
type en cas de succ√®s, <code>std::fs::File</code>, qui permet d'interagir avec le fichier.
Le <code>E</code> utilis√© pour la valeur d'erreur est du type <code>std::io::Error</code>.</p>
<!--
This return type means the call to `File::open` might succeed and return a file
handle that we can read from or write to. The function call also might fail:
for example, the file might not exist, or we might not have permission to
access the file. The `File::open` function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the `Result` enum
conveys.
-->
<p>Ce type de retour veut dire que l'appel √† <code>File::open</code> peut r√©ussir et nous
retourner un manipulateur de fichier qui peut nous permettre de le lire ou d'y
√©crire. L'utilisation de cette fonction peut aussi √©chouer¬†: par exemple, si le
fichier n'existe pas, ou si nous n'avons pas le droit d'acc√©der au fichier. La
fonction <code>File::open</code> doit avoir un moyen de nous dire si son utilisation a
r√©ussi ou √©chou√© et en m√™me temps nous fournir soit le manipulateur de fichier,
soit des informations sur l'erreur. C'est exactement ces informations que
l'√©num√©ration <code>Result</code> se charge de nous transmettre.</p>
<!--
In the case where `File::open` succeeds, the value in the variable `f` will be
an instance of `Ok` that contains a file handle. In the case where it fails,
the value in `f` will be an instance of `Err` that contains more information
about the kind of error that happened.
-->
<p>Dans le cas o√π <code>File::open</code> r√©ussit, la valeur que nous obtiendrons dans la
variable <code>f</code> sera une instance de <code>Ok</code> qui contiendra un manipulateur de
fichier. Dans le cas o√π cela √©choue, la valeur dans <code>f</code> sera une instance de
<code>Err</code> qui contiendra plus d'information sur le type d'erreur qui a eu lieu.</p>
<!--
We need to add to the code in Listing 9-3 to take different actions depending
on the value `File::open` returns. Listing 9-4 shows one way to handle the
`Result` using a basic tool, the `match` expression that we discussed in
Chapter 6.
-->
<p>Nous avons besoin d'ajouter diff√©rentes actions dans le code de l'encart 9-3 en
fonction de la valeur que <code>File::open</code> retourne. L'encart 9-4 montre une fa√ßon
de g√©rer le <code>Result</code> en utilisant un outil basique, l'expression <code>match</code> que
nous avons vue au chapitre 6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; panic!(&quot;Erreur d'ouverture du fichier¬†: {:?}&quot;, erreur),
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-4: Using a `match` expression to handle the
`Result` variants that might be returned</span>
-->
<p><span class="caption">Encart 9-4¬†: utilisation de l'expression <code>match</code> pour
g√©rer les variantes de <code>Result</code> qui peuvent √™tre retourn√©es</span></p>
<!--
Note that, like the `Option` enum, the `Result` enum and its variants have been
brought into scope by the prelude, so we don‚Äôt need to specify `Result::`
before the `Ok` and `Err` variants in the `match` arms.
-->
<p>Remarquez que, tout comme l'√©num√©ration <code>Option</code>, l'√©num√©ration <code>Result</code> et ses
variantes ont √©t√© import√©es par l'√©tape pr√©liminaire, donc vous n'avez pas
besoin de pr√©ciser <code>Result::</code> devant les variantes <code>Ok</code> et <code>Err</code> dans les
branches du <code>match</code>.</p>
<!--
When the result is `Ok`, this code will return the inner `file` value out of
the `Ok` variant, and we then assign that file handle value to the variable
`f`. After the `match`, we can use the file handle for reading or writing.
-->
<p>Lorsque le r√©sultat est <code>Ok</code>, ce code va retourner la valeur <code>fichier</code> contenue
dans la variante <code>Ok</code>, et nous assignons ensuite cette valeur √† la variable
<code>f</code>. Apr√®s le <code>match</code>, nous pourrons ensuite utiliser le manipulateur de
fichier pour lire ou √©crire.</p>
<!--
The other arm of the `match` handles the case where we get an `Err` value from
`File::open`. In this example, we‚Äôve chosen to call the `panic!` macro. If
there‚Äôs no file named *hello.txt* in our current directory and we run this
code, we‚Äôll see the following output from the `panic!` macro:
-->
<p>L'autre branche du bloc <code>match</code> g√®re le cas o√π nous obtenons un <code>Err</code> √† l'appel
de <code>File::open</code>. Dans cet exemple, nous avons choisi de faire appel √† la macro
<code>panic!</code>. S'il n'y a pas de fichier qui s'appelle <em>hello.txt</em> dans notre
r√©pertoire actuel et que nous ex√©cutons ce code, nous allons voir la sortie
suivante suite √† l'appel de la macro <code>panic!</code>¬†:</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Erreur d'ouverture du fichier : Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:24
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
As usual, this output tells us exactly what has gone wrong.
-->
<p>Comme d'habitude, cette sortie nous explique avec pr√©cision ce qui s'est mal
pass√©.</p>
<!--
### Matching on Different Errors
-->
<h3 id="g√©rer-les-diff√©rentes-erreurs"><a class="header" href="#g√©rer-les-diff√©rentes-erreurs">G√©rer les diff√©rentes erreurs</a></h3>
<!--
The code in Listing 9-4 will `panic!` no matter why `File::open` failed.
However, we want to take different actions for different failure reasons: if
`File::open` failed because the file doesn‚Äôt exist, we want to create the file
and return the handle to the new file. If `File::open` failed for any other
reason‚Äîfor example, because we didn‚Äôt have permission to open the file‚Äîwe still
want the code to `panic!` in the same way as it did in Listing 9-4. For this we
add an inner `match` expression, shown in Listing 9-5.
-->
<p>Le code dans l'encart 9-4 va faire un <code>panic!</code> peu importe la raison de l'√©chec
de <code>File::open</code>. Cependant, nous voulons r√©agir diff√©remment en fonction de
diff√©rents cas d'erreurs¬†: si <code>File::open</code> a √©chou√© parce que le
fichier n'existe pas, nous voulons cr√©er le fichier et retourner le manipulateur
de fichier pour ce nouveau fichier. Si <code>File::open</code> √©choue pour toute autre
raison, par exemple si nous n'avons pas l'autorisation d'ouvrir le fichier,
nous voulons quand m√™me que le code lance un <code>panic!</code> de la m√™me mani√®re qu'il
l'a fait dans l'encart 9-4. C'est pourquoi nous avons ajout√© dans l'encart 9-5
une expression <code>match</code> imbriqu√©e¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -- >
-->
<!--
```rust,ignore
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}
```
-->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; match erreur.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Erreur de cr√©ation du fichier¬†: {:?}&quot;, e),
            },
            autre_erreur =&gt; {
                panic!(&quot;Erreur d'ouverture du fichier¬†: {:?}&quot;, autre_erreur)
            }
        },
    };
}
</code></pre>
<!--
<span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span>
-->
<p><span class="caption">Encart 9-5¬†: gestion des diff√©rents cas d'erreurs avec des
actions diff√©rentes</span></p>
<!--
The type of the value that `File::open` returns inside the `Err` variant is
`io::Error`, which is a struct provided by the standard library. This struct
has a method `kind` that we can call to get an `io::ErrorKind` value. The enum
`io::ErrorKind` is provided by the standard library and has variants
representing the different kinds of errors that might result from an `io`
operation. The variant we want to use is `ErrorKind::NotFound`, which indicates
the file we‚Äôre trying to open doesn‚Äôt exist yet. So we match on `f`, but we
also have an inner match on `error.kind()`.
-->
<p>La valeur de retour de <code>File::open</code> log√©e dans la variante <code>Err</code> est de type
<code>io::Error</code>, qui est une structure fournie par la biblioth√®que standard. Cette
structure a une m√©thode <code>kind</code> que nous pouvons appeler pour obtenir une valeur
de type <code>io::ErrorKind</code>. L'√©num√©ration <code>io::ErrorKind</code> est fournie elle aussi
par la biblioth√®que standard et a des variantes qui repr√©sentent les diff√©rents
types d'erreurs qui pourraient r√©sulter d'une op√©ration provenant du module
<code>io</code>. La variante que nous voulons utiliser est <code>ErrorKind::NotFound</code>, qui
indique que le fichier que nous essayons d'ouvrir n'existe pas encore. Donc nous
utilisons <code>match</code> sur <code>f</code>, mais nous avons dans celle-ci un autre <code>match</code> sur
<code>erreur.kind()</code>.</p>
<!--
The condition we want to check in the inner match is whether the value returned
by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is,
we try to create the file with `File::create`. However, because `File::create`
could also fail, we need a second arm in the inner `match` expression. When the
file can‚Äôt be created, a different error message is printed. The second arm of
the outer `match` stays the same, so the program panics on any error besides
the missing file error.
-->
<p>Nous souhaitons v√©rifier dans le <code>match</code> interne si la valeur de retour de
<code>error.kind()</code> est la variante <code>NotFound</code> de l'√©num√©ration <code>ErrorKind</code>. Si c'est
le cas, nous essayons de cr√©er le fichier avec <code>File::create</code>. Cependant, comme
<code>File::create</code> peut aussi √©chouer, nous avons besoin d'une seconde branche dans
le <code>match</code> interne. Lorsque le fichier ne peut pas √™tre cr√©√©, un message
d'erreur diff√©rent est affich√©. La seconde branche du <code>match</code> principal reste
inchang√©e, donc le programme panique lorsqu'on rencontre une autre erreur que
l'absence de fichier.</p>
<!--
> ### Alternatives to Using `match` with `Result<T, E>`
>
> That‚Äôs a lot of `match`! The `match` expression is very useful but also very
> much a primitive. In Chapter 13, you‚Äôll learn about closures, which are used
> with many of the methods defined on `Result<T, E>`. These methods can be more
> concise than using `match` when handling `Result<T, E>` values in your code.
>
> For example, here‚Äôs another way to write the same logic as shown in Listing
> 9-5 but using closures and the `unwrap_or_else` method:
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -- >
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let f = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {:?}", error);
>             })
>         } else {
>             panic!("Problem opening the file: {:?}", error);
>         }
>     });
> }
> ```
>
> Although this code has the same behavior as Listing 9-5, it doesn‚Äôt contain
> any `match` expressions and is cleaner to read. Come back to this example
> after you‚Äôve read Chapter 13, and look up the `unwrap_or_else` method in the
> standard library documentation. Many more of these methods can clean up huge
> nested `match` expressions when you‚Äôre dealing with errors.
-->
<blockquote>
<h3 id="dautres-solutions-pour-utiliser-match-avec-resultt-e"><a class="header" href="#dautres-solutions-pour-utiliser-match-avec-resultt-e">D'autres solutions pour utiliser <code>match</code> avec <code>Result&lt;T, E&gt;</code></a></h3>
<p>Cela commence √† faire beaucoup de <code>match</code>¬†! L'expression <code>match</code> est tr√®s
utile mais elle est aussi assez rudimentaire. Dans le chapitre 13, vous en
apprendrez plus sur les fermetures, qui sont utilis√©es avec de nombreuses
m√©thodes d√©finies sur <code>Result&lt;T, E&gt;</code>. Ces m√©thodes peuvent s'av√©rer √™tre plus
concises que l'utilisation de <code>match</code> lorsque vous travaillez avec des
valeurs <code>Result&lt;T, E&gt;</code> dans votre code.</p>
<p>Par exemple, voici une autre mani√®re d'√©crire la m√™me logique que celle dans
l'encart 9-5 mais en utilisant les fermetures et la m√©thode
<code>unwrap_or_else</code>¬†:</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
        if erreur.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
                panic!(&quot;Erreur de cr√©ation du fichier¬†: {:?}&quot;, erreur);
            })
        } else {
            panic!(&quot;Erreur d'ouverture du fichier¬†: {:?}&quot;, erreur);
        }
    });
}
</code></pre>
<p>Bien que ce code ait le m√™me comportement que celui de l'encart 9-5, il ne
contient aucune expression <code>match</code> et est plus facile √† lire. Revenez sur cet
exemple apr√®s avoir lu le chapitre 13, et renseignez-vous sur la m√©thode
<code>unwrap_or_else</code> dans la documentation de la biblioth√®que standard. De
nombreuses m√©thodes de ce type peuvent clarifier de grosses expressions
<code>match</code> imbriqu√©es lorsque vous traitez les erreurs.</p>
</blockquote>
<!--
### Shortcuts for Panic on Error: `unwrap` and `expect`
-->
<h3 id="raccourcis-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect"><a class="header" href="#raccourcis-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect">Raccourcis pour faire un panic lors d'une erreur¬†: <code>unwrap</code> et <code>expect</code></a></h3>
<!--
Using `match` works well enough, but it can be a bit verbose and doesn‚Äôt always
communicate intent well. The `Result<T, E>` type has many helper methods
defined on it to do various, more specific tasks. The `unwrap` method is a
shortcut method implemented just like the `match` expression we wrote in
Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return
the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will
call the `panic!` macro for us. Here is an example of `unwrap` in action:
-->
<p>L'utilisation de <code>match</code> fonctionne assez bien, mais elle peut √™tre un peu
verbeuse et ne communique pas forc√©ment bien son intention. Le type
<code>Result&lt;T, E&gt;</code> a de nombreuses m√©thodes qui lui ont √©t√© d√©finies pour
diff√©rents cas. La m√©thode <code>unwrap</code> est une m√©thode de raccourci impl√©ment√©e
comme l'expression <code>match</code> que nous avons √©crite dans l'encart 9-4. Si la
valeur de <code>Result</code> est la variante <code>Ok</code>, <code>unwrap</code> va retourner la valeur
contenue dans le <code>Ok</code>. Si le <code>Result</code> est la variante <code>Err</code>, <code>unwrap</code> va
appeler la macro <code>panic!</code> pour nous. Voici un exemple de <code>unwrap</code> en action¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<!--
If we run this code without a *hello.txt* file, we‚Äôll see an error message from
the `panic!` call that the `unwrap` method makes:
-->
<p>Si nous ex√©cutons ce code alors qu'il n'y a pas de fichier <em>hello.txt</em>, nous
allons voir un message d'erreur suite √† l'appel √† <code>panic!</code> que la m√©thode
<code>unwrap</code> a fait¬†:</p>
<!--
```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: "No such file or directory" } }',
src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<!--
Similarly, the `expect` method lets us also choose the `panic!` error message.
Using `expect` instead of `unwrap` and providing good error messages can convey
your intent and make tracking down the source of a panic easier. The syntax of
`expect` looks like this:
-->
<p>De la m√™me mani√®re, la m√©thode <code>expect</code> nous donne la possibilit√© de d√©finir le
message d'erreur du <code>panic!</code>. Utiliser <code>expect</code> plut√¥t que <code>unwrap</code> et lui
fournir un bon message d'erreur permet de mieux exprimer le probl√®me et
faciliter la recherche de la source d'un panic. La syntaxe de <code>expect</code> est la
suivante¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;√âchec √† l'ouverture de hello.txt&quot;);
}
</code></pre></pre>
<!--
We use `expect` in the same way as `unwrap`: to return the file handle or call
the `panic!` macro. The error message used by `expect` in its call to `panic!`
will be the parameter that we pass to `expect`, rather than the default
`panic!` message that `unwrap` uses. Here‚Äôs what it looks like:
-->
<p>Nous utilisons <code>expect</code> de la m√™me mani√®re que <code>unwrap</code>¬†: pour retourner le
manipulateur de fichier ou appeler la macro <code>panic!</code>. Le message d'erreur
utilis√© par <code>expect</code> lors de son appel √† <code>panic!</code> sera le param√®tre que nous
avons pass√© √† <code>expect</code>, plut√¥t que le message par d√©faut de <code>panic!</code> qu'utilise
<code>unwrap</code>. Voici ce que cela donne¬†:</p>
<!--
```text
thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: "No such file or directory" } }', src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at '√âchec √† l'ouverture de hello.txt: Error { repr: Os {
code: 2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<!--
Because this error message starts with the text we specified, `Failed to open
hello.txt`, it will be easier to find where in the code this error message is
coming from. If we use `unwrap` in multiple places, it can take more time to
figure out exactly which `unwrap` is causing the panic because all `unwrap`
calls that panic print the same message.
-->
<p>Comme ce message d'erreur commence par le texte que nous avons pr√©cis√©, <code>√âchec √† l'ouverture de hello.txt</code>, ce sera plus facile de trouver l√† d'o√π provient ce
message d'erreur dans le code. Si nous utilisons <code>unwrap</code> √† plusieurs endroits,
cela peut prendre plus de temps de comprendre exactement quel <code>unwrap</code> a caus√©
le panic, car tous les appels √† <code>unwrap</code> vont afficher le m√™me message.</p>
<!--
### Propagating Errors
-->
<h3 id="propager-les-erreurs"><a class="header" href="#propager-les-erreurs">Propager les erreurs</a></h3>
<!--
When a function‚Äôs implementation calls something that might fail, instead of
handling the error within the function itself, you can return the error to the
calling code so that it can decide what to do. This is known as *propagating*
the error and gives more control to the calling code, where there might be more
information or logic that dictates how the error should be handled than what
you have available in the context of your code.
-->
<p>Lorsqu'une fonction dont l'impl√©mentation utilise quelque chose qui peut
√©chouer, au lieu de g√©rer l'erreur directement dans cette fonction, vous pouvez
retourner cette erreur au code qui l'appelle pour qu'il d√©cide quoi faire.
C'est ce que l'on appelle <em>propager</em> l'erreur et donne ainsi plus de contr√¥le
au code qui appelle la fonction, dans lequel il peut y avoir plus
d'informations ou d'instructions pour traiter l'erreur que dans le contexte de
votre code.</p>
<!--
For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn‚Äôt exist or can‚Äôt be read, this function will return those errors
to the code that called the function.
-->
<p>Par exemple, l'encart 9-6 montre une fonction qui lit un pseudo √† partir d'un
fichier. Si ce fichier n'existe pas ou ne peut pas √™tre lu, cette fonction va
retourner ces erreurs au code qui a appel√© la fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(fichier) =&gt; fichier,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-6: A function that returns errors to the
calling code using `match`</span>
-->
<p><span class="caption">Encart 9-6¬†: une fonction qui retourne les erreurs au code
qui l'appelle en utilisant <code>match</code></span></p>
<!--
This function can be written in a much shorter way, but we‚Äôre going to start by
doing a lot of it manually in order to explore error handling; at the end,
we‚Äôll show the shorter way. Let‚Äôs look at the return type of the function
first: `Result<String, io::Error>`. This means the function is returning a
value of the type `Result<T, E>` where the generic parameter `T` has been
filled in with the concrete type `String`, and the generic type `E` has been
filled in with the concrete type `io::Error`. If this function succeeds without
any problems, the code that calls this function will receive an `Ok` value that
holds a `String`‚Äîthe username that this function read from the file. If this
function encounters any problems, the calling code will receive an `Err` value
that holds an instance of `io::Error` that contains more information about what
the problems were. We chose `io::Error` as the return type of this function
because that happens to be the type of the error value returned from both of
the operations we‚Äôre calling in this function‚Äôs body that might fail: the
`File::open` function and the `read_to_string` method.
-->
<p>Cette fonction peut √™tre √©crite de fa√ßon plus concise, mais nous avons d√©cid√© de
commencer par faire un maximum de choses manuellement pour d√©couvrir la gestion
d'erreurs¬†; mais √† la fin, nous verrons comment raccourcir le code. Commen√ßons
par regarder le type de retour de la fonction¬†: <code>Result&lt;String, io::Error&gt;</code>.
Cela signifie que la fonction retourne une valeur de type <code>Result&lt;T, E&gt;</code> o√π le
param√®tre g√©n√©rique <code>T</code> a √©t√© remplac√© par le type <code>String</code> et le param√®tre
g√©n√©rique <code>E</code> a √©t√© remplac√© par le type <code>io::Error</code>. Si cette fonction r√©ussit
sans probl√®me, le code qui appellant va obtenir une valeur <code>Ok</code> qui contient
une <code>String</code>, le pseudo que cette fonction lit dans le fichier. Si cette
fonction rencontre un probl√®me, le code qui appelle cette fonction va obtenir
une valeur <code>Err</code> qui contient une instance de <code>io::Error</code> qui donne plus
d'informations sur la raison du probl√®me. Nous avons choisi <code>io::Error</code> comme
type de retour de cette fonction parce qu'il se trouve que c'est le type
d'erreur de retour pour les deux op√©rations qui peuvent √©chouer que l'on utilise
dans le corps de cette fonction¬†: la fonction <code>File::open</code> et la m√©thode
<code>read_to_string</code>.</p>
<!--
The body of the function starts by calling the `File::open` function. Then we
handle the `Result` value with a `match` similar to the `match` in Listing 9-4.
If `File::open` succeeds, the file handle in the pattern variable `file`
becomes the value in the mutable variable `f` and the function continues. In
the `Err` case, instead of calling `panic!`, we use the `return` keyword to
return early out of the function entirely and pass the error value from
`File::open`, now in the pattern variable `e`, back to the calling code as this
function‚Äôs error value.
-->
<p>Le corps de la fonction commence par appeler la fonction <code>File::open</code>. Ensuite,
nous g√©rons la valeur du <code>Result</code> avec un <code>match</code> similaire au <code>match</code> de
l'encart 9-4. Si le <code>File::open</code> est un succ√®s, le manipulateur de fichier dans
la variable <code>fichier</code> du motif devient la valeur dans la variable mutable <code>f</code>
et la fonction continue son d√©roulement. Dans le cas d'un <code>Err</code>, au lieu
d'appeler <code>panic!</code>, nous utilisons <code>return</code> pour sortir pr√©matur√©ment de toute
la fonction et en passant la valeur du <code>File::open</code>, d√©sormais dans la variable
<code>e</code>, au code appelant comme valeur de retour de cette fonction.</p>
<!--
So if we have a file handle in `f`, the function then creates a new `String` in
variable `s` and calls the `read_to_string` method on the file handle in `f` to
read the contents of the file into `s`. The `read_to_string` method also
returns a `Result` because it might fail, even though `File::open` succeeded.
So we need another `match` to handle that `Result`: if `read_to_string`
succeeds, then our function has succeeded, and we return the username from the
file that‚Äôs now in `s` wrapped in an `Ok`. If `read_to_string` fails, we return
the error value in the same way that we returned the error value in the `match`
that handled the return value of `File::open`. However, we don‚Äôt need to
explicitly say `return`, because this is the last expression in the function.
-->
<p>Donc si nous avons un manipulateur de fichier dans <code>f</code>, la fonction cr√©e
ensuite une nouvelle <code>String</code> dans la variable <code>s</code> et nous appelons la m√©thode
<code>read_to_string</code> sur le manipulateur de fichier <code>f</code> pour extraire le contenu du
fichier dans <code>s</code>. La m√©thode <code>read_to_string</code> retourne aussi un <code>Result</code> car
elle peut √©chouer, m√™me si <code>File::open</code> a r√©ussi. Nous avons donc besoin d'un
nouveau <code>match</code> pour g√©rer ce <code>Result</code>¬†: si <code>read_to_string</code> r√©ussit, alors
notre fonction a r√©ussi, et nous retournons le pseudo que nous avons extrait du
fichier qui est maintenant int√©gr√© dans un <code>Ok</code>, lui-m√™me stock√© dans <code>s</code>. Si
<code>read_to_string</code> √©choue, nous retournons la valeur d'erreur de la m√™me fa√ßon
que nous avons retourn√© la valeur d'erreur dans le <code>match</code> qui g√©rait la valeur
de retour de <code>File::open</code>. Cependant, nous n'avons pas besoin d'√©crire
explicitement <code>return</code>, car c'est la derni√®re expression de la fonction.</p>
<!--
The code that calls this code will then handle getting either an `Ok` value
that contains a username or an `Err` value that contains an `io::Error`. It‚Äôs
up to the calling code to decide what to do with those values. If the calling
code gets an `Err` value, it could call `panic!` and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don‚Äôt have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.
-->
<p>Le code qui appelle ce code va devoir ensuite g√©rer les cas o√π il r√©cup√®re une
valeur <code>Ok</code> qui contient un pseudo, ou une valeur <code>Err</code> qui contient une
<code>io::Error</code>. Il revient au code appelant de d√©cider quoi faire avec ces
valeurs. Si le code appelant obtient une valeur <code>Err</code>, il peut appeler <code>panic!</code>
et faire planter le programme, utiliser un pseudo par d√©faut, ou chercher le
pseudo autre part que dans ce fichier, par exemple. Nous n'avons pas assez
d'informations sur ce que le code appelant a l'intention de faire, donc nous
remontons toutes les informations de succ√®s ou d'erreur pour qu'elles soient
g√©r√©es correctement.</p>
<!--
This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator `?` to make this easier.
-->
<p>Cette fa√ßon de propager les erreurs est si courante en Rust que Rust fournit
l'op√©rateur point d'interrogation <code>?</code> pour faciliter ceci.</p>
<!--
#### A Shortcut for Propagating Errors: the `?` Operator
-->
<h4 id="un-raccourci-pour-propager-les-erreurs--lop√©rateur-"><a class="header" href="#un-raccourci-pour-propager-les-erreurs--lop√©rateur-">Un raccourci pour propager les erreurs¬†: l'op√©rateur <code>?</code></a></h4>
<!--
Listing 9-7 shows an implementation of `read_username_from_file` that has the
same functionality as in Listing 9-6, but this implementation uses the
`?` operator.
-->
<p>L'encart 9-7 montre une impl√©mentation de <code>lire_pseudo_depuis_fichier</code> qui a
les m√™mes fonctionnalit√©s que dans l'encart 9-6, mais cette impl√©mentation
utilise l'op√©rateur point d'interrogation <code>?</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-7: A function that returns errors to the
calling code using the `?` operator</span>
-->
<p><span class="caption">Encart 9-7¬†: une fonction qui retourne les erreurs au code
appelant en utilisant l'op√©rateur <code>?</code></span></p>
<!--
The `?` placed after a `Result` value is defined to work in almost the same way
as the `match` expressions we defined to handle the `Result` values in Listing
9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will
get returned from this expression, and the program will continue. If the value
is an `Err`, the `Err` will be returned from the whole function as if we had
used the `return` keyword so the error value gets propagated to the calling
code.
-->
<p>Le <code>?</code> plac√© apr√®s une valeur <code>Result</code> est con√ßu pour fonctionner presque de la
m√™me mani√®re que les expressions <code>match</code> que nous avons d√©finies pour g√©rer les
valeurs <code>Result</code> dans l'encart 9-6. Si la valeur du <code>Result</code> est un <code>Ok</code>, la
valeur dans le <code>Ok</code> sera retourn√©e par cette expression et le programme
continuera. Si la valeur est un <code>Err</code>, le <code>Err</code> sera retourn√© par la fonction
comme si nous avions utilis√© le mot-cl√© <code>return</code> afin que la valeur d'erreur
soit propag√©e au code appelant.</p>
<!--
There is a difference between what the `match` expression from Listing 9-6 does
and what the `?` operator does: error values that have the `?` operator called
on them go through the `from` function, defined in the `From` trait in the
standard library, which is used to convert errors from one type into another.
When the `?` operator calls the `from` function, the error type received is
converted into the error type defined in the return type of the current
function. This is useful when a function returns one error type to represent
all the ways a function might fail, even if parts might fail for many different
reasons. As long as there‚Äôs an `impl From<OtherError> for ReturnedError` to
define the conversion in the trait‚Äôs `from` function, the `?` operator takes
care of calling the `from` function automatically.
-->
<p>Il y a une diff√©rence entre ce que fait l'expression <code>match</code> de l'encart 9-6 et
ce que fait l'op√©rateur <code>?</code>¬†: les valeurs d'erreurs sur lesquelles est utilis√©
l'op√©rateur <code>?</code> passent par la fonction <code>from</code>, d√©finie dans le trait <code>From</code> de
la biblioth√®que standard, qui est utilis√©e pour convertir les erreurs d'un type
√† un autre. Lorsque l'op√©rateur <code>?</code> appelle la fonction <code>from</code>, le type d'erreur
re√ßu est converti dans le type d'erreur d√©clar√© dans le type de retour de la
fonction concern√©e. C'est utile lorsqu'une fonction retourne un type d'erreur
qui peut couvrir tous les cas d'√©chec de la fonction, m√™me si certaines de ses
parties peuvent √©chouer pour diff√©rentes raisons. √Ä partir du moment qu'il y a
un <code>impl From&lt;AutreErreur&gt;</code> sur <code>ErreurRetournee</code> pour expliquer la conversion
dans la fonction <code>from</code> du trait, l'op√©rateur <code>?</code> se charge d'appeler la
fonction <code>from</code> automatiquement.</p>
<!--
In the context of Listing 9-7, the `?` at the end of the `File::open` call will
return the value inside an `Ok` to the variable `f`. If an error occurs, the
`?` operator will return early out of the whole function and give any `Err`
value to the calling code. The same thing applies to the `?` at the end of the
`read_to_string` call.
-->
<p>Dans le cas de l'encart 9-7, le <code>?</code> √† la fin de l'appel √† <code>File::open</code> va
retourner la valeur √† l'int√©rieur d'un <code>Ok</code> √† la variable <code>f</code>. Si une erreur se
produit, l'op√©rateur <code>?</code> va quitter pr√©matur√©ment la fonction et retourner une
valeur <code>Err</code> au code appelant. La m√™me chose se produira au <code>?</code> √† la fin de
l'appel √† <code>read_to_string</code>.</p>
<!--
The `?` operator eliminates a lot of boilerplate and makes this function‚Äôs
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the `?`, as shown in Listing 9-8.
-->
<p>L'op√©rateur <code>?</code> all√®ge l'√©criture de code et facilite l'impl√©mentation de la
fonction. Nous pouvons m√™me encore plus r√©duire ce code en encha√Ænant
imm√©diatement les appels aux m√©thodes apr√®s le <code>?</code> comme dans l'encart 9-8¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-8: Chaining method calls after the `?`
operator</span>
-->
<p><span class="caption">Encart 9-8¬†: encha√Ænement des appels aux m√©thodes apr√®s
l'op√©rateur <code>?</code></span></p>
<!--
We‚Äôve moved the creation of the new `String` in `s` to the beginning of the
function; that part hasn‚Äôt changed. Instead of creating a variable `f`, we‚Äôve
chained the call to `read_to_string` directly onto the result of
`File::open("hello.txt")?`. We still have a `?` at the end of the
`read_to_string` call, and we still return an `Ok` value containing the
username in `s` when both `File::open` and `read_to_string` succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.
-->
<p>Nous avons d√©plac√© la cr√©ation de la nouvelle <code>String</code> dans <code>s</code> au d√©but de la
fonction¬†; cette partie n'a pas chang√©. Au lieu de cr√©er la variable <code>f</code>, nous
encha√Ænons directement l'appel √† <code>read_to_string</code> sur le r√©sultat de
<code>File::open(&quot;hello.txt&quot;)?</code>. Nous avons toujours le <code>?</code> √† la fin de l'appel √†
<code>read_to_string</code>, et nous retournons toujours une valeur <code>Ok</code> contenant le
pseudo dans <code>s</code> lorsque <code>File::open</code> et <code>read_to_string</code> r√©ussissent toutes les
deux plut√¥t que de retourner des erreurs. Cette fonctionnalit√© est toujours la
m√™me que dans l'encart 9-6 et l'encart 9-7¬†; c'est juste une fa√ßon diff√©rente et
plus ergonomique de l'√©crire.</p>
<!--
Listing 9-9 shows a way to make this even shorter using `fs::read_to_string`.
-->
<p>L'encart 9-9 nous montre comment encore plus raccourcir tout ceci en utilisant
<code>fs::read_to_string</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-9: Using `fs::read_to_string` instead of
opening and then reading the file</span>
-->
<p><span class="caption">Encart 9-9¬†: utilisation de <code>fs::read_to_string</code> plut√¥t
que d'ouvrir puis lire le fichier</span></p>
<!--
Reading a file into a string is a fairly common operation, so the standard
library provides the convenient `fs::read_to_string` function that opens the
file, creates a new `String`, reads the contents of the file, puts the contents
into that `String`, and returns it. Of course, using `fs::read_to_string`
doesn‚Äôt give us the opportunity to explain all the error handling, so we did it
the longer way first.
-->
<p>R√©cup√©rer le contenu d'un fichier dans une <code>String</code> est une op√©ration assez
courante, donc la biblioth√®que standard fournit la fonction assez pratique
<code>fs::read_to_string</code>, qui ouvre le fichier, cr√©e une nouvelle <code>String</code>, lit le
contenu du fichier, ins√®re ce contenu dans cette <code>String</code>, et la retourne.
√âvidemment, l'utilisation de <code>fs:read_to_string</code> ne nous offre pas l'occasion
d'expliquer toute la gestion des erreurs, donc nous avons d'abord utilis√© la
mani√®re la plus longue.</p>
<!--
#### Where The `?` Operator Can Be Used
-->
<h4 id="o√π-lop√©rateur--peut-√™tre-utilis√©"><a class="header" href="#o√π-lop√©rateur--peut-√™tre-utilis√©">O√π l'op√©rateur <code>?</code> peut √™tre utilis√©</a></h4>
<!--
The `?` operator can only be used in functions whose return type is compatible
with the value the `?` is used on. This is because the `?` operator is defined
to perform an early return of a value out of the function, in the same manner
as the `match` expression we defined in Listing 9-6. In Listing 9-6, the
`match` was using a `Result` value, and the early return arm returned an
`Err(e)` value. The return type of the function has to be a `Result` so that
it‚Äôs compatible with this `return`.
-->
<p>L'op√©rateur <code>?</code> ne peut √™tre utilis√© uniquement que dans des fonctions dont le
type de retour compatible avec ce sur quoi le <code>?</code> est utilis√©. C'est parce que
l'op√©rateur <code>?</code> est con√ßu pour retourner pr√©matur√©mment une valeur de la
fonction, de la m√™me mani√®re que le faisait l'expression <code>match</code> que nous avons
d√©finie dans l'encart 9-6. Dans l'encart 9-6, le <code>match</code> utilisait une valeur
de type <code>Result</code>, et la branche de retour pr√©matur√© retournait une valeur de
type <code>Err(e)</code>. Le type de retour de cette fonction doit √™tre un <code>Result</code> afin
d'√™tre compatible avec ce <code>return</code>.</p>
<!--
In Listing 9-10, let‚Äôs look at the error we‚Äôll get if we use the `?` operator
in a `main` function with a return type incompatible with the type of the value
we use `?` on:
-->
<p>Dans l'encart 9-10, d√©couvrons l'erreur que nous allons obtenir si nous
utilisons l'op√©rateur <code>?</code> dans une fonction <code>main</code> qui a un type de retour
incompatible avec le type de valeur sur laquelle nous utilisons <code>?</code>¬†:</p>
<!--
```rust,ignore,does_not_compile
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!--
<span class="caption">Listing 9-10: Attempting to use the `?` in the `main`
function that returns `()` won‚Äôt compile</span>
-->
<p><span class="caption">Encart 9-10¬†: tentative d'utilisation du <code>?</code> dans la
fonction <code>main</code> qui retourne un <code>()</code>, qui ne devrait pas pouvoir se
compiler</span></p>
<!--
This code opens a file, which might fail. The `?` operator follows the `Result`
value returned by `File::open`, but this `main` function has the return type of
`()`, not `Result`. When we compile this code, we get the following error
message:
-->
<p>Ce code ouvre un fichier, ce qui devrait √©chouer. L'op√©rateur <code>?</code> est plac√©e
derri√®re la valeur de type <code>Result</code> retourn√©e par <code>File::open</code>, mais cette
fonction <code>main</code> a un type de retour <code>()</code> et non pas <code>Result</code>. Lorsque nous
compilons ce code, nous obtenons le message d'erreur suivant¬†:</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 -- > src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open("hello.txt")?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<!--
This error points out that we‚Äôre only allowed to use the `?` operator in a
function that returns `Result`, `Option`, or another type that implements
`FromResidual`. To fix the error, you have two choices. One choice is to change
the return type of your function to be compatible with the value you‚Äôre using
the `?` operator on as long as you have no restrictions preventing that. The
other technique is to use a `match` or one of the `Result<T, E>` methods to
handle the `Result<T, E>` in whatever way is appropriate.
-->
<p>Cette erreur explique que nous sommes autoris√©s √† utiliser l'op√©rateur <code>?</code>
uniquement dans une fonction qui retourne <code>Result</code>, <code>Option</code>, ou un autre type
qui impl√©mente <code>FromResidual</code>. Pour corriger l'erreur, vous avez deux choix. Le
premier est de changer le type de retour de votre fonction pour √™tre compatible
avec la valeur avec lequel vous utilisez l'op√©rateur <code>?</code>, si vous pouvez le
faire. L'autre solution est d'utiliser un <code>match</code> ou une des m√©thodes de
<code>Result&lt;T, E&gt;</code> pour g√©rer le <code>Result&lt;T, E&gt;</code> de la mani√®re la plus appropri√©e.</p>
<!--
The error message also mentioned that `?` can be used with `Option<T>` values
as well. As with using `?` on `Result`, you can only use `?` on `Option` in a
function that returns an `Option`. The behavior of the `?` operator when called
on an `Option<T>` is similar to its behavior when called on a `Result<T, E>`:
if the value is `None`, the `None` will be returned early from the function at
that point. If the value is `Some`, the value inside the `Some` is the
resulting value of the expression and the function continues. Listing 9-11 has
an example of a function that finds the last character of the first line in the
given text:
-->
<p>Le message d'erreur indique √©galement que <code>?</code> peut aussi √™tre utilis√© avec des
valeurs de type <code>Option&lt;T&gt;</code>. Comme pour pouvoir utiliser <code>?</code> sur un <code>Result</code>,
vous devez utiliser <code>?</code> sur <code>Option</code> uniquement dans une fonction qui retourne
une <code>Option</code>. Le comportement de l'op√©rateur <code>?</code> sur une <code>Option&lt;T&gt;</code> est
identique au comportement sur un <code>Result&lt;T, E&gt;</code>¬†: si la valeur est <code>None</code>, le
<code>None</code> sera retourn√© pr√©matur√©mment √† la fonction dans laquelle il est utilis√©.
Si la valeur est <code>Some</code>, la valeur dans le <code>Some</code> sera la valeur r√©sultante de
l'expression et la fonction continuera son d√©roulement. L'encart 9-11 est un
exemple de fonction qui trouve le dernier caract√®re de la premi√®re ligne dans
le texte qu'on lui fournit¬†:</p>
<!--
```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
# 
# fn main() {
#     assert_eq!(
#         last_char_of_first_line("Hello, world\nHow are you today?"),
#         Some('d')
#     );
# 
#     assert_eq!(last_char_of_first_line(""), None);
#     assert_eq!(last_char_of_first_line("\nhi"), None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn dernier_caractere_de_la_premiere_ligne(texte: &amp;str) -&gt; Option&lt;char&gt; {
    texte.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dernier_caractere_de_la_premiere_ligne(&quot;Et bonjour\nComment ca va, aujourd'hui ?&quot;),
</span><span class="boring">        Some('r')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(dernier_caractere_de_la_premiere_ligne(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(dernier_caractere_de_la_premiere_ligne(&quot;\nsalut&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-11: Using the `?` operator on an `Option<T>`
value</span>
-->
<p><span class="caption">Encart 9-11¬†: utilisation de l'op√©rateur <code>?</code> sur une
valeur du type <code>Option&lt;T&gt;</code></span></p>
<!--
This function returns `Option<char>` because it‚Äôs possible that there is a
character there, but it‚Äôs also possible that there isn‚Äôt. This code takes the
`text` string slice argument and calls the `lines` method on it, which returns
an iterator over the lines in the string. Because this function wants to
examine the first line, it calls `next` on the iterator to get the first value
from the iterator. If `text` is the empty string, this call to `next` will
return `None`, in which case we use `?` to stop and return `None` from
`last_char_of_first_line`. If `text` is not the empty string, `next` will
return a `Some` value containing a string slice of the first line in `text`.
-->
<p>Cette fonction retourne un type <code>Option&lt;char&gt;</code> car il est possible qu'il y ait
un caract√®re √† cet endroit, mais il est aussi possible qu'il n'y soit pas. Ce
code prends l'argument <code>texte</code> slice de cha√Æne de caract√®re et appelle sur elle
la m√©thode <code>lines</code>, qui retourne un it√©rateur des lignes dans la cha√Æne. Comme
cette fonction veut traiter la premi√®re ligne, elle appelle <code>next</code> sur
l'it√©rateur afin d'obtenir la premi√®re valeur de cet it√©rateur. Si <code>texte</code> est
une cha√Æne vide, cet appel √† <code>next</code> va retourner <code>None</code>, et dans ce cas nous
utilisons <code>?</code> pour arr√™ter le d√©roulement de la fonction et retourner <code>None</code>.
Si <code>texte</code> n'est pas une cha√Æne vide, <code>next</code> va retourner une valeur de type
<code>Some</code> contenant une slice de cha√Æne de caract√®res de la premi√®re ligne de
<code>texte</code>.</p>
<!--
The `?` extracts the string slice, and we can call `chars` on that string slice
to get an iterator of its characters. We‚Äôre interested in the last character in
this first line, so we call `last` to return the last item in the iterator.
This is an `Option` because it‚Äôs possible that the first line is the empty
string, for example if `text` starts with a blank line but has characters on
other lines, as in `"\nhi"`. However, if there is a last character on the first
line, it will be returned in the `Some` variant. The `?` operator in the middle
gives us a concise way to express this logic, allowing us to implement the
function in one line. If we couldn‚Äôt use the `?` operator on `Option`, we‚Äôd
have to implement this logic using more method calls or a `match` expression.
-->
<p>Le <code>?</code> extrait la slice de la cha√Æne de caract√®res, et nous pouvons ainsi
appeller <code>chars</code> sur cette slice de cha√Æne de caract√®res afin d'obtenir un
it√©rateur de ses caract√®res. Nous nous int√©ressons au dernier caract√®re de
cette premi√®re ligne, donc nous appelons <code>last</code> pour retourner le dernier
√©l√©ment dans l'it√©rateur. C'est une <code>Option</code> car il est possible que la
premi√®re ligne soit une cha√Æne de caract√®res vide, par exemple si <code>texte</code>
commence par une ligne vide mais a des caract√®res sur les autres lignes, comme
par exemple <code>&quot;\nhi&quot;</code>. Cependant, si il y a un caract√®re √† la fin de la premi√®re
ligne, il sera retourn√© dans la variante <code>Some</code>. L'op√©rateur <code>?</code> au millieu
nous donne un moyen concret d'exprimer cette logique, nous permettant
d'impl√©menter la fonction en une ligne. Si nous n'avions pas pu utiliser
l'op√©rateur <code>?</code> sur <code>Option</code>, nous aurions d√ª impl√©menter cette logique en
utilisant plus d'appels √† des m√©thodes ou des expressions <code>match</code>.</p>
<!--
Note that you can use the `?` operator on a `Result` in a function that returns
`Result`, and you can use the `?` operator on an `Option` in a function that
returns `Option`, but you can‚Äôt mix and match. The `?` operator won‚Äôt
automatically convert a `Result` to an `Option` or vice versa; in those cases,
you can use methods like the `ok` method on `Result` or the `ok_or` method on
`Option` to do the conversion explicitly.
-->
<p>Notez bien que vous pouvez utiliser l'op√©rateur <code>?</code> sur un <code>Result</code> dans une
fonction qui retourne <code>Result</code>, et vous pouvez utiliser l'op√©rateur <code>?</code> sur une
<code>Option</code> dans une fonction qui retourne une <code>Option</code>, mais vous ne pouvez pas
m√©langer les deux. L'op√©rateur <code>?</code> ne va pas convertir un <code>Result</code> en <code>Option</code>
et vice-versa¬†; dans ce cas, vous pouvez utiliser des m√©thodes comme la m√©thode
<code>ok</code> sur <code>Result</code> ou la m√©thode <code>ok_or</code> sur <code>Option</code> pour faire explicitement
la conversion.</p>
<!--
So far, all the `main` functions we‚Äôve used return `()`. The `main` function is
special because it‚Äôs the entry and exit point of executable programs, and there
are restrictions on what its return type can be for the programs to behave as
expected.
-->
<p>Jusqu'ici, toutes les fonctions <code>main</code> que nous avons utilis√© retournent <code>()</code>.
La fonction <code>main</code> est sp√©ciale car c'est le point d'entr√©e et de sortie des
programmes ex√©cutables, et il y a quelques limitations sur ce que peut √™tre
le type de retour pour que les programmes se comportent correctement.</p>
<!--
Luckily, `main` can also return a `Result<(), E>`. Listing 9-12 has the
code from Listing 9-10 but we‚Äôve changed the return type of `main` to be
`Result<(), Box<dyn Error>>` and added a return value `Ok(())` to the end. This
code will now compile:
-->
<p>Heureusement, <code>main</code> peut aussi retourner un <code>Result&lt;(), E&gt;</code>. L'encart 9-12
reprend le code de l'encart 9-10 mais nous avons chang√© le type de retour du
<code>main</code> pour √™tre <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> et nous avons ajout√© la valeur de
retour <code>Ok(())</code> √† la fin. Ce code devrait maintenant pouvoir se compiler¬†:</p>
<!--
```rust,ignore
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<!--
<span class="caption">Listing 9-12: Changing `main` to return `Result<(), E>`
allows the use of the `?` operator on `Result` values</span>
-->
<p><span class="caption">Encart 9-12¬†: changement du <code>main</code> pour qu'elle retourne
un <code>Result&lt;(), E&gt;</code> permettant d'utiliser l'op√©rateur <code>?</code> sur des valeurs de type
<code>Result</code></span></p>
<!--
The `Box<dyn Error>` type is a *trait object*, which we‚Äôll talk about in the
[‚ÄúUsing Trait Objects that Allow for Values of Different
Types‚Äù][trait-objects]<!-- ignore -- > section in Chapter 17. For now, you can
read `Box<dyn Error>` to mean ‚Äúany kind of error.‚Äù Using `?` on a `Result`
value in a `main` function with the error type `Box<dyn Error>` is allowed,
because it allows any `Err` value to be returned early.
-->
<p>Le type <code>Box&lt;dyn Error&gt;</code> est un <em>objet trait</em>, que nous verrons dans une
section du <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore -->. Pour l'instant, vous
pouvez interpr√©ter <code>Box&lt;dyn Error&gt;</code> en ‚Äútout type d'erreur‚Äù. L'utilisation de
<code>?</code> sur une valeur type <code>Result</code> dans la fonction <code>main</code> avec le type
<code>Box&lt;dyn Error&gt;</code> est donc permise, car cela permet √† n'importe quelle une
valeur de type <code>Err</code> d'√™tre retourn√©e pr√©matur√©ment.</p>
<!--
When a `main` function returns a `Result<(), E>`, the executable will
exit with a value of `0` if `main` returns `Ok(())` and will exit with a
nonzero value if `main` returns an `Err` value. Executables written in C return
integers when they exit: programs that exit successfully return the integer
`0`, and programs that error return some integer other than `0`. Rust also
returns integers from executables to be compatible with this convention.
-->
<p>Lorsqu'une fonction <code>main</code> retourne un <code>Result&lt;(), E&gt;</code>, l'ex√©cutable va
terminer son ex√©cution avec une valeur de <code>0</code> si le <code>main</code> retourne <code>Ok(())</code> et
va se terminer avec une valeur diff√©rente de z√©ro si <code>main</code> retourne une valeur
<code>Err</code>. Les ex√©cutables √©crits en C retournent des entiers lorsqu'ils se
terminent¬†: les programmes qui se terminent avec succ√®s retournent l'entier
<code>0</code>, et les programmes qui sont en erreur retournent un entier autre que <code>0</code>.
Rust retourne √©galement des entiers avec des ex√©cutables pour √™tre compatible
avec cette convention.</p>
<!--
The `main` function may return any types that implement [the
`std::process::Termination` trait][termination]<!-- ignore -- >. As of this
writing, the `Termination` trait is an unstable feature only available in
Nightly Rust, so you can‚Äôt yet implement it for your own types in Stable Rust,
but you might be able to someday!
-->
<p>La fonction <code>main</code> peut retourner n'importe quel type qui impl√©mente <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">le trait
<code>std::process::Termination</code></a><!-- ignore -->. Au moment de
l'√©criture de ces mots, le trait <code>Termination</code> est une fonctionnalit√© instable
seulement disponible avec la version exp√©rimentale de Rust, donc vous ne pouvez
pas l'impl√©menter sur vos propres types avec la version stable de Rust, mais
vous pourrez peut-√™tre le faire un jour¬†!</p>
<!--
Now that we‚Äôve discussed the details of calling `panic!` or returning `Result`,
let‚Äôs return to the topic of how to decide which is appropriate to use in which
cases.
-->
<p>Maintenant que nous avons vu les d√©tails pour utiliser <code>panic!</code> ou retourner
<code>Result</code>, voyons maintenant comment choisir ce qu'il faut faire en fonction des
cas.</p>
<!--
[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[termination]: ../std/process/trait.Termination.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## To `panic!` or Not to `panic!`
-->
<h2 id="paniquer-ou-ne-pas-paniquer-telle-est-la-question"><a class="header" href="#paniquer-ou-ne-pas-paniquer-telle-est-la-question">Paniquer ou ne pas paniquer, telle est la question</a></h2>
<!--
So how do you decide when you should call `panic!` and when you should return
`Result`? When code panics, there‚Äôs no way to recover. You could call `panic!`
for any error situation, whether there‚Äôs a possible way to recover or not, but
then you‚Äôre making the decision that a situation is unrecoverable on behalf of
the calling code. When you choose to return a `Result` value, you give the
calling code options. The calling code could choose to attempt to recover in a
way that‚Äôs appropriate for its situation, or it could decide that an `Err`
value in this case is unrecoverable, so it can call `panic!` and turn your
recoverable error into an unrecoverable one. Therefore, returning `Result` is a
good default choice when you‚Äôre defining a function that might fail.
-->
<p>Comment d√©cider si vous devez utiliser <code>panic!</code> ou si vous devez retourner un
<code>Result</code>¬†? Quand un code panique, il n'y a pas de moyen de r√©cup√©rer la
situation. Vous pourriez utiliser <code>panic!</code> pour n'importe quelle situation
d'erreur, peu importe s'il est possible de r√©cup√©rer la situation ou non, mais
vous prenez alors la d√©cision de tout arr√™ter √† la place du code appellant.
Lorsque vous choisissez de retourner une valeur <code>Result</code>, vous donnez le choix
au code appelant. Le code appelant peut choisir d'essayer de r√©cup√©rer l'erreur
de mani√®re appropri√©e √† la situation, ou il peut d√©cider que dans ce cas une
valeur <code>Err</code> est irr√©cup√©rable, et va donc utiliser <code>panic!</code> et transformer
votre erreur r√©cup√©rable en erreur irr√©cup√©rable. Ainsi, retourner <code>Result</code> est
un bon choix par d√©faut lorsque vous d√©finissez une fonction qui peut √©chouer.</p>
<!--
In situations such as examples, prototype code, and tests, it‚Äôs more
appropriate to write code that panics instead of returning a `Result`. Let‚Äôs
explore why, then discuss situations in which the compiler can‚Äôt tell that
failure is impossible, but you as a human can. The chapter will conclude with
some general guidelines on how to decide whether to panic in library code.
-->
<p>Dans certains cas comme les exemples, les prototypes, et les tests, il est plus
appropri√© d'√©crire du code qui panique plut√¥t que de retourner un <code>Result</code>.
Nous allons voir pourquoi, puis nous verrons des situations dans lesquelles
vous savez en tant qu'humain qu'un code ne peut pas √©chouer, mais que le
compilateur ne peut pas le d√©duire par lui-m√™me. Enfin, nous allons conclure le
chapitre par quelques lignes directrices g√©n√©rales pour d√©cider s'il faut
paniquer dans le code d'une biblioth√®que.</p>
<!--
### Examples, Prototype Code, and Tests
-->
<h3 id="les-exemples-les-prototypes-et-les-tests"><a class="header" href="#les-exemples-les-prototypes-et-les-tests">Les exemples, les prototypes et les tests</a></h3>
<!--
When you‚Äôre writing an example to illustrate some concept, also including robust
error-handling code can make the example less clear. In
examples, it‚Äôs understood that a call to a method like `unwrap` that could
panic is meant as a placeholder for the way you‚Äôd want your application to
handle errors, which can differ based on what the rest of your code is doing.
-->
<p>Lorsque vous √©crivez un exemple pour illustrer un concept, y rajouter un code
de gestion des erreurs tr√®s r√©silient peut nuire √† la clart√© de l'exemple. Dans
les exemples, il est courant d'utiliser une m√©thode comme <code>unwrap</code> (qui peut
faire un panic) pour remplacer le code de gestion de l'erreur que vous
utiliseriez en temps normal dans votre application, et qui peut changer en
fonction de ce que le reste de votre code va faire.</p>
<!--
Similarly, the `unwrap` and `expect` methods are very handy when prototyping,
before you‚Äôre ready to decide how to handle errors. They leave clear markers in
your code for when you‚Äôre ready to make your program more robust.
-->
<p>De la m√™me mani√®re, les m√©thodes <code>unwrap</code> et <code>expect</code> sont tr√®s pratiques pour
coder des prototypes, avant m√™me de d√©cider comment g√©rer les erreurs. Ce sont
des indicateurs clairs dans votre code pour plus tard quand vous serez pr√™t √†
rendre votre code plus r√©silient aux √©checs.</p>
<!--
If a method call fails in a test, you‚Äôd want the whole test to fail, even if
that method isn‚Äôt the functionality under test. Because `panic!` is how a test
is marked as a failure, calling `unwrap` or `expect` is exactly what should
happen.
-->
<p>Si l'appel √† une m√©thode √©choue dans un test, nous voulons que tout le test
√©choue, m√™me si cette m√©thode n'est pas la fonctionnalit√© que nous testons.
Puisque c'est <code>panic!</code> qui indique qu'un test a √©chou√©, utiliser <code>unwrap</code> ou
<code>expect</code> est exactement ce qu'il faut faire.</p>
<!--
### Cases in Which You Have More Information Than the Compiler
-->
<h3 id="les-cas-o√π-vous-avez-plus-dinformations-que-le-compilateur"><a class="header" href="#les-cas-o√π-vous-avez-plus-dinformations-que-le-compilateur">Les cas o√π vous avez plus d'informations que le compilateur</a></h3>
<!--
It would also be appropriate to call `unwrap` when you have some other logic
that ensures the `Result` will have an `Ok` value, but the logic isn‚Äôt
something the compiler understands. You‚Äôll still have a `Result` value that you
need to handle: whatever operation you‚Äôre calling still has the possibility of
failing in general, even though it‚Äôs logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you‚Äôll never
have an `Err` variant, it‚Äôs perfectly acceptable to call `unwrap`. Here‚Äôs an
example:
-->
<p>Vous pouvez utiliser <code>unwrap</code> lorsque vous avez une certaine logique qui
garantit que le <code>Result</code> sera toujours une valeur <code>Ok</code>, mais que ce n'est pas le
genre de logique que le compilateur arrive √† comprendre. Vous aurez quand m√™me
une valeur <code>Result</code> √† g√©rer¬†: l'op√©ration que vous utilisez peut √©chouer de
mani√®re g√©n√©rale, m√™me si dans votre cas c'est logiquement impossible. Si en
inspectant manuellement le code vous vous rendez compte que vous n'aurez jamais
une variante <code>Err</code>, vous pouvez tout √† fait utiliser <code>unwrap</code>. Voici un
exemple¬†:</p>
<!--
```rust
# fn main() {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1".parse().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<!--
We‚Äôre creating an `IpAddr` instance by parsing a hardcoded string. We can see
that `127.0.0.1` is a valid IP address, so it‚Äôs acceptable to use `unwrap`
here. However, having a hardcoded, valid string doesn‚Äôt change the return type
of the `parse` method: we still get a `Result` value, and the compiler will
still make us handle the `Result` as if the `Err` variant is a possibility
because the compiler isn‚Äôt smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore *did* have a possibility of failure,
we‚Äôd definitely want to handle the `Result` in a more robust way instead.
-->
<p>Nous cr√©ons une instance de <code>IpAddr</code> en interpr√©tant une cha√Æne de caract√®res
cod√©e en dur dans le code. Nous savons que <code>127.0.0.1</code> est une adresse IP
valide, donc il est acceptable d'utiliser <code>unwrap</code> ici. Toutefois, avoir une
cha√Æne de caract√®res valide et cod√©e en dur ne change pas le type de retour de
la m√©thode <code>parse</code>¬†: nous obtenons toujours une valeur de type <code>Result</code> et le
compilateur va nous demander de g√©rer le <code>Result</code> comme si on pouvait obtenir la
variante <code>Err</code>, car le compilateur n'est pas suffisamment intelligent pour
comprendre que cette cha√Æne de caract√®res est toujours une adresse IP valide. Si
le texte de l'adresse IP provient de l'utilisateur au lieu d'√™tre cod√© en dur
dans le programme et donc qu'il y a d√©sormais une possibilit√© d'erreur, alors
nous devrions vouloir g√©rer le <code>Result</code> d'une mani√®re plus r√©siliente.</p>
<!--
### Guidelines for Error Handling
-->
<h3 id="recommandations-pour-g√©rer-les-erreurs"><a class="header" href="#recommandations-pour-g√©rer-les-erreurs">Recommandations pour g√©rer les erreurs</a></h3>
<!--
It‚Äôs advisable to have your code panic when it‚Äôs possible that your code
could end up in a bad state. In this context, a *bad state* is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
code‚Äîplus one or more of the following:
-->
<p>Il est recommand√© de faire paniquer votre code d√®s qu'il risque d'aboutir √† un
√©tat invalide. Dans ce contexte, un <em>√©tat invalide</em> est lorsqu'un postulat, une
garantie, un contrat ou un invariant a √©t√© rompu, comme des valeurs invalides,
contradictoires ou manquantes qui sont fournies √† votre code, ainsi qu'un ou
plusieurs des √©l√©ments suivants¬†:</p>
<!--
* The bad state is something that is unexpected, as opposed to something that
  will likely happen occasionally, like a user entering data in the wrong
  format.
* Your code after this point needs to rely on not being in this bad state,
  rather than checking for the problem at every step.
* There‚Äôs not a good way to encode this information in the types you use. We‚Äôll
  work through an example of what we mean in the [‚ÄúEncoding States and Behavior
  as Types‚Äù][encoding]<!-- ignore -- > section of Chapter 17.
-->
<ul>
<li>L'√©tat invalide est quelque chose qui est inattendu, contrairement √† quelque
chose qui devrait arriver occasionnellement, comme par exemple un utilisateur
qui saisit une donn√©e dans un mauvais format.</li>
<li>Apr√®s cette instruction, votre code a besoin de ne pas √™tre dans cet √©tat
invalide, plut√¥t que d'avoir √† v√©rifier le probl√®me √† chaque √©tape.</li>
<li>Il n'y a pas de bonne fa√ßon d'encoder cette information dans les types que
vous utilisez. Nous allons pratiquer ceci via un exemple dans <a href="ch17-03-oo-design-patterns.html">une section du
chapitre 17</a><!-- ignore -->.</li>
</ul>
<!--
If someone calls your code and passes in values that don‚Äôt make sense, the best
choice might be to call `panic!` and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, `panic!` is
often appropriate if you‚Äôre calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.
-->
<p>Si une personne utilise votre biblioth√®que et lui fournit des valeurs qui n'ont
pas de sens, la meilleure des choses √† faire est d'utiliser <code>panic!</code> et
d'avertir cette personne du bogue dans son code afin qu'elle le r√®gle pendant la
phase de d√©veloppement. De la m√™me mani√®re, <code>panic!</code> est parfois appropri√© si
vous appelez du code externe sur lequel vous n'avez pas la main, et qu'il
retourne un √©tat invalide que vous ne pouvez pas corriger.</p>
<!--
However, when failure is expected, it‚Äôs more appropriate to return a `Result`
than to make a `panic!` call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a `Result` indicates that failure is an
expected possibility that the calling code must decide how to handle.
-->
<p>Cependant, si l'on s'attend √† rencontrer des √©checs, il est plus appropri√© de
retourner un <code>Result</code> plut√¥t que de faire appel √† <code>panic!</code>. Il peut s'agir par
exemple d'un interpr√©teur qui re√ßoit des donn√©es erron√©es, ou une requ√™te HTTP
qui retourne un statut qui indique que vous avez atteint une limite de d√©bit.
Dans ces cas-l√†, vous devriez indiquer qu'il est possible que cela puisse
√©chouer en retournant un <code>Result</code> afin que le code appelant puisse d√©cider quoi
faire pour g√©rer le probl√®me.</p>
<!--
When your code performs operations on values, your code should verify the
values are valid first and panic if the values aren‚Äôt valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
`panic!` if you attempt an out-of-bounds memory access: trying to access memory
that doesn‚Äôt belong to the current data structure is a common security problem.
Functions often have *contracts*: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug and
it‚Äôs not a kind of error you want the calling code to have to explicitly
handle. In fact, there‚Äôs no reasonable way for calling code to recover; the
calling *programmers* need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.
-->
<p>Lorsque votre code effectue des op√©rations sur des valeurs, votre code devrait
d'abord v√©rifier que ces valeurs sont valides, et faire un panic si les valeurs
ne sont pas correctes. C'est essentiellement pour des raisons de s√©curit√©¬†:
tenter de travailler avec des donn√©es invalides peut exposer votre code √† des
vuln√©rabilit√©s. C'est la principale raison pour laquelle la biblioth√®que
standard va appeler <code>panic!</code> si vous essayez d'acc√©der √† la m√©moire hors
limite¬†: essayer d'acc√©der √† de la m√©moire qui n'appartient pas √† la structure
de donn√©es actuelle est un probl√®me de s√©curit√© fr√©quent. Les fonctions ont
souvent des <em>contrats</em>¬†: leur comportement est garanti uniquement si les donn√©es
d'entr√©e remplissent des conditions particuli√®res. Paniquer lorsque le contrat
est viol√© est justifi√©, car une violation de contrat signifie toujours un bogue
du c√¥t√© de l'appelant, et ce n'est pas le genre d'erreur que vous voulez que le
code appelant g√®re explicitement. En fait, il n'y a aucun moyen rationnel pour
que le code appelant se corrige¬†: le <em>d√©veloppeur</em> du code appelant doit
corriger le code. Les contrats d'une fonction, en particulier lorsqu'une
violation va causer un panic, doivent √™tre expliqu√©s dans la documentation de
l'API de ladite fonction.</p>
<!--
However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust‚Äôs type system (and thus the type
checking done by the compiler) to do many of the checks for you. If your
function has a particular type as a parameter, you can proceed with your code‚Äôs
logic knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an `Option`, your program expects to
have *something* rather than *nothing*. Your code then doesn‚Äôt have to handle
two cases for the `Some` and `None` variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won‚Äôt
even compile, so your function doesn‚Äôt have to check for that case at runtime.
Another example is using an unsigned integer type such as `u32`, which ensures
the parameter is never negative.
-->
<p>Cependant, avoir beaucoup de v√©rifications d'erreurs dans toutes vos fonctions
serait verbeux et p√©nible. Heureusement, vous pouvez utiliser le syst√®me de
types de Rust (et donc la v√©rification de type que fait le compilateur) pour
assurer une partie des v√©rifications √† votre place. Si votre fonction a un
param√®tre d'un type pr√©cis, vous pouvez continuer √† √©crire votre code en
sachant que le compilateur s'est d√©j√† assur√© que vous avez une valeur valide.
Par exemple, si vous obtenez un type de valeur plut√¥t qu'une <code>Option</code>, votre
programme s'attend √† obtenir <em>quelque chose</em> plut√¥t que <em>rien</em>. Votre code n'a
donc pas √† g√©rer les deux cas de variantes <code>Some</code> et <code>None</code>¬†: la seule
possibilit√© est qu'il y a une valeur. Du code qui essaye de ne rien fournir √†
votre fonction ne compilera m√™me pas, donc votre fonction n'a pas besoin de
v√©rifier ce cas-l√† lors de l'ex√©cution. Un autre exemple est d'utiliser un type
d'entier non sign√© comme <code>u32</code>, qui garantit que le param√®tre n'est jamais
strictement n√©gatif.</p>
<!--
### Creating Custom Types for Validation
-->
<h3 id="cr√©er-des-types-personnalis√©s-pour-la-v√©rification"><a class="header" href="#cr√©er-des-types-personnalis√©s-pour-la-v√©rification">Cr√©er des types personnalis√©s pour la v√©rification</a></h3>
<!--
Let‚Äôs take the idea of using Rust‚Äôs type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user‚Äôs guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of ‚ÄúToo high‚Äù or ‚ÄúToo low‚Äù would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number that‚Äôs out of range versus when a user
types, for example, letters instead.
-->
<p>Allons plus loin dans l'id√©e d'utiliser le syst√®me de types de Rust pour
s'assurer d'avoir une valeur valide en cr√©ant un type personnalis√© pour la
v√©rification. Souvenez-vous du jeu du plus ou du moins du chapitre 2 dans lequel
notre code demandait √† l'utilisateur de deviner un nombre entre 1 et 100. Nous
n'avons jamais valid√© que le nombre saisi par l'utilisateur √©tait entre ces
nombres avant de le comparer √† notre nombre secret¬†; nous avons seulement
v√©rifi√© que le nombre √©tait positif. Dans ce cas, les cons√©quences ne sont pas
tr√®s graves¬†: notre r√©sultat ‚ÄúC'est plus¬†!‚Äù ou ‚ÄúC'est moins¬†!‚Äù sera toujours
correct. Mais ce serait une am√©lioration utile pour aider l'utilisateur √† faire
des suppositions valides et pour avoir un comportement diff√©rent selon qu'un
utilisateur propose un nombre en dehors des limites ou qu'il saisit, par
exemple, des lettres √† la place.</p>
<!--
One way to do this would be to parse the guess as an `i32` instead of only a
`u32` to allow potentially negative numbers, and then add a check for the
number being in range, like so:
-->
<p>Une fa√ßon de faire cela serait de stocker le nombre saisi dans un <code>i32</code> plut√¥t
que dans un <code>u32</code> afin de permettre d'obtenir potentiellement des nombres
n√©gatifs, et ensuite v√©rifier que le nombre est dans la plage autoris√©e, comme
ceci¬†:</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Devinez le nombre¬†!");
# 
#     let nombre_secret = rand::thread_rng().gen_range(1..101);
# 
    loop {
        // -- partie masqu√©e ici --

#         println!("Veuillez saisir un nombre.");
# 
#         let mut supposition = String::new();
# 
#         io::stdin()
#             .read_line(&mut supposition)
#             .expect("√âchec de la lecture de la saisie");
# 
        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) => nombre,
            Err(_) => continue,
        };

        if supposition < 1 || supposition > 100 {
            println!("Le nombre secret est entre 1 et 100.");
            continue;
        }

        match supposition.cmp(&nombre_secret) {
            // -- partie masqu√©e ici --
#             Ordering::Less => println!("C'est plus¬†!"),
#             Ordering::Greater => println!("C'est moins¬†!"),
#             Ordering::Equal => {
#                 println!("Gagn√©¬†!");
#                 break;
#             }
#         }
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    loop {
        // -- partie masqu√©e ici --

<span class="boring">        println!(&quot;Veuillez saisir un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;√âchec de la lecture de la saisie&quot;);
</span><span class="boring">
</span>        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        if supposition &lt; 1 || supposition &gt; 100 {
            println!(&quot;Le nombre secret est entre 1 et 100.&quot;);
            continue;
        }

        match supposition.cmp(&amp;nombre_secret) {
            // -- partie masqu√©e ici --
<span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Gagn√©¬†!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<!--
The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.
-->
<p>L'expression <code>if</code> v√©rifie si la valeur est en dehors des limites et informe
l'utilisateur du probl√®me le cas √©ch√©ant, puis utilise <code>continue</code> pour passer √†
la prochaine it√©ration de la boucle et ainsi demander de saisir une nouvelle
supposition. Apr√®s l'expression <code>if</code>, nous pouvons continuer avec la comparaison
entre <code>supposition</code> et le nombre secret tout en sachant que <code>supposition</code> est
entre 1 et 100.</p>
<!--
However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).
-->
<p>Cependant, ce n'est pas une solution id√©ale¬†: si c'√©tait absolument critique
que le programme ne travaille qu'avec des valeurs entre 1 et 100 et qu'il aurait
de nombreuses fonctions qui reposent sur cette condition, cela pourrait √™tre
fastidieux (et cela impacterait potentiellement la performance) de faire une
v√©rification comme celle-ci dans chacune de ces fonctions.</p>
<!--
Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, it‚Äôs safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-13 shows one way to define a
`Guess` type that will only create an instance of `Guess` if the `new` function
receives a value between 1 and 100.
-->
<p>√Ä la place, nous pourrions construire un nouveau type et int√©grer les
v√©rifications dans la fonction de cr√©ation d'une instance de ce type plut√¥t que
de r√©p√©ter partout les v√©rifications. Il est ainsi plus s√ªr pour les fonctions
d'utiliser ce nouveau type dans leurs signatures et d'utiliser avec confiance
les valeurs qu'elles re√ßoivent. L'encart 9-13 montre une fa√ßon de d√©finir un
type <code>Supposition</code> qui ne cr√©era une instance de <code>Supposition</code> que si la
fonction <code>new</code> re√ßoit une valeur entre 1 et 100¬†:</p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -- >
-->
<!--
```rust
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("Supposition valeur must be between 1 and 100, got {}.", valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&self) -> i32 {
        self.valeur
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;Supposition valeur must be between 1 and 100, got {}.&quot;, valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&amp;self) -&gt; i32 {
        self.valeur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-13: A `Guess` type that will only continue with
values between 1 and 100</span>
-->
<p><span class="caption">Encart 9-13¬†: un type <code>Supposition</code> qui ne va continuer
que si la valeur est entre 1 et 100</span></p>
<!--
First, we define a struct named `Guess` that has a field named `value` that
holds an `i32`. This is where the number will be stored.
-->
<p>D'abord, nous d√©finissons une structure qui s'appelle <code>Supposition</code> qui a un
champ <code>valeur</code> qui stocke un <code>i32</code>. C'est dans ce dernier que le nombre sera
stock√©.</p>
<!--
Then we implement an associated function named `new` on `Guess` that creates
instances of `Guess` values. The `new` function is defined to have one
parameter named `value` of type `i32` and to return a `Guess`. The code in the
body of the `new` function tests `value` to make sure it‚Äôs between 1 and 100.
If `value` doesn‚Äôt pass this test, we make a `panic!` call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a `Guess` with a `value` outside this range would
violate the contract that `Guess::new` is relying on. The conditions in which
`Guess::new` might panic should be discussed in its public-facing API
documentation; we‚Äôll cover documentation conventions indicating the possibility
of a `panic!` in the API documentation that you create in Chapter 14. If
`value` does pass the test, we create a new `Guess` with its `value` field set
to the `value` parameter and return the `Guess`.
-->
<p>Ensuite, nous impl√©mentons une fonction associ√©e <code>new</code> sur <code>Supposition</code> qui
cr√©e des instances de <code>Supposition</code>. La fonction <code>new</code> est con√ßue pour recevoir
un param√®tre <code>valeur</code> de type <code>i32</code> et retourner une <code>Supposition</code>. Le code dans
le corps de la fonction <code>new</code> teste <code>valeur</code> pour s'assurer qu'elle est bien
entre 1 et 100. Si <code>valeur</code> √©choue √† ce test, nous faisons appel √† <code>panic!</code>, qui
alertera le d√©veloppeur qui √©crit le code appelant qu'il a un bogue qu'il doit
r√©gler, car cr√©er une <code>Supposition</code> avec <code>valeur</code> en dehors de cette plage va
violer le contrat sur lequel s'appuie <code>Supposition::new</code>. Les conditions dans
lesquelles <code>Supposition::new</code> va paniquer devraient √™tre expliqu√©es dans la
documentation publique de l'API¬†; nous verrons les conventions pour indiquer
l'√©ventualit√© d'un <code>panic!</code> dans la documentation de l'API que vous cr√©erez
au chapitre 14. Si <code>valeur</code> passe le test, nous cr√©ons une nouvelle
<code>Supposition</code> avec son champ <code>valeur</code> qui prend la valeur du param√®tre <code>valeur</code>
et retourne cette <code>Supposition</code>.</p>
<!--
Next, we implement a method named `value` that borrows `self`, doesn‚Äôt have any
other parameters, and returns an `i32`. This kind of method is sometimes called
a *getter*, because its purpose is to get some data from its fields and return
it. This public method is necessary because the `value` field of the `Guess`
struct is private. It‚Äôs important that the `value` field be private so code
using the `Guess` struct is not allowed to set `value` directly: code outside
the module *must* use the `Guess::new` function to create an instance of
`Guess`, thereby ensuring there‚Äôs no way for a `Guess` to have a `value` that
hasn‚Äôt been checked by the conditions in the `Guess::new` function.
-->
<p>Enfin, nous impl√©mentons une m√©thode <code>valeur</code> qui emprunte <code>self</code>, n'a aucun
autre param√®tre, et retourne un <code>i32</code>. Ce genre de m√©thode est parfois appel√© un
<em>accesseur</em>, car son r√¥le est d'acc√©der aux donn√©es des champs et de les
retourner. Cette m√©thode publique est n√©cessaire car le champ <code>valeur</code> de la
structure <code>Supposition</code> est priv√©. Il est important que le champ <code>valeur</code> soit
priv√© pour que le code qui utilise la structure <code>Supposition</code> ne puisse pas
directement assigner une valeur √† <code>valeur</code>¬†: le code en dehors du module <em>doit</em>
utiliser la fonction <code>Supposition::new</code> pour cr√©er une instance de
<code>Supposition</code>, ce qui permet d'emp√™cher la cr√©ation d'une <code>Supposition</code> avec un
champ <code>valeur</code> qui n'a pas √©t√© v√©rifi√© par les conditions dans la fonction
<code>Supposition:new</code>.</p>
<!--
A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a `Guess` rather than an
`i32` and wouldn‚Äôt need to do any additional checks in its body.
-->
<p>Une fonction qui prend en param√®tre ou qui retourne des nombres uniquement entre
1 et 100 peut ensuite d√©clarer dans sa signature qu'elle prend en param√®tre ou
qu'elle retourne une <code>Supposition</code> plut√¥t qu'un <code>i32</code> et n'aura pas besoin de
faire de v√©rifications suppl√©mentaires dans son corps.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-8"><a class="header" href="#r√©sum√©-8">R√©sum√©</a></h2>
<!--
Rust‚Äôs error handling features are designed to help you write more robust code.
The `panic!` macro signals that your program is in a state it can‚Äôt handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The `Result` enum uses Rust‚Äôs type system to indicate that
operations might fail in a way that your code could recover from. You can use
`Result` to tell code that calls your code that it needs to handle potential
success or failure as well. Using `panic!` and `Result` in the appropriate
situations will make your code more reliable in the face of inevitable problems.
-->
<p>Les fonctionnalit√©s de gestion d'erreurs de Rust sont con√ßues pour vous aider √†
√©crire du code plus r√©silient. La macro <code>panic!</code> signale que votre programme
est dans un √©tat qu'il ne peut pas g√©rer et vous permet de dire au processus de
s'arr√™ter au lieu d'essayer de continuer avec des valeurs invalides ou
incorrectes. L'√©num√©ration <code>Result</code> utilise le syst√®me de types de Rust pour
signaler que des op√©rations peuvent √©chouer de telle fa√ßon que votre code puisse
rattraper l'erreur. Vous pouvez utiliser <code>Result</code> pour dire au code qui appelle
votre code qu'il a besoin de g√©rer le r√©sultat et aussi les potentielles
erreurs. Utiliser <code>panic!</code> et <code>Result</code> de mani√®re appropri√©e rendra votre code
plus fiable face √† des probl√®mes in√©vitables.</p>
<!--
Now that you‚Äôve seen useful ways that the standard library uses generics with
the `Option` and `Result` enums, we‚Äôll talk about how generics work and how you
can use them in your code.
-->
<p>Maintenant que vous avez vu la fa√ßon dont la biblioth√®que standard tire parti de
la g√©n√©ricit√© avec les √©num√©rations <code>Option</code> et <code>Result</code>, nous allons voir
comment la g√©n√©ricit√© fonctionne et comment vous pouvez l'utiliser dans votre code.</p>
<!--
[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Generic Types, Traits, and Lifetimes
-->
<h1 id="les-types-g√©n√©riques-les-traits-et-les-dur√©es-de-vie"><a class="header" href="#les-types-g√©n√©riques-les-traits-et-les-dur√©es-de-vie">Les types g√©n√©riques, les traits et les dur√©es de vie</a></h1>
<!--
Every programming language has tools for effectively handling the duplication
of concepts. In Rust, one such tool is *generics*. Generics are abstract
stand-ins for concrete types or other properties. When we‚Äôre writing code, we
can express the behavior of generics or how they relate to other generics
without knowing what will be in their place when compiling and running the code.
-->
<p>Tous les langages de programmation ont des outils pour g√©rer la duplication des
concepts. En Rust, un de ces outils est la <em>g√©n√©ricit√©</em>. La g√©n√©ricit√© permet
de remplacer des types concrets ou d'autres propri√©t√©s par des param√®tres
abstraits appel√©s <em>g√©n√©riques</em>. Lorsque nous √©crivons du code, nous pouvons
exprimer le comportement des g√©n√©riques, ou comment ils interagissent avec
d'autres g√©n√©riques, sans savoir ce qu'il y aura √† leur place lors de la
compilation et de l'ex√©cution du code.</p>
<!--
Similar to the way a function takes parameters with unknown values to run the
same code on multiple concrete values, functions can take parameters of some
generic type instead of a concrete type, like `i32` or `String`. In fact, we‚Äôve
already used generics in Chapter 6 with `Option<T>`, Chapter 8 with `Vec<T>`
and `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, you‚Äôll
explore how to define your own types, functions, and methods with generics!
-->
<p>De la m√™me mani√®re qu'une fonction prend des param√®tres avec des valeurs
inconnues pour ex√©cuter le m√™me code sur plusieurs valeurs concr√®tes, les
fonctions peuvent prendre des param√®tres d'un type g√©n√©rique plut√¥t que d'un
type concret comme <code>i32</code> ou <code>String</code>. En fait, nous avons d√©j√† utilis√© des types
g√©n√©riques au chapitre 6 avec <code>Option&lt;T&gt;</code>, au chapitre 8 avec <code>Vec&lt;T&gt;</code> et
<code>HashMap&lt;K, V&gt;</code>, et au chapitre 9 avec <code>Result&lt;T, E&gt;</code>. Dans ce chapitre, nous
allons voir comment d√©finir nos propres types, fonctions et m√©thodes utilisant
des types g√©n√©riques¬†!</p>
<!--
First, we‚Äôll review how to extract a function to reduce code duplication. Next,
we‚Äôll use the same technique to make a generic function from two functions that
differ only in the types of their parameters. We‚Äôll also explain how to use
generic types in struct and enum definitions.
-->
<p>Pour commencer, nous allons examiner comment construire une fonction pour
r√©duire la duplication de code. Ensuite, nous utiliserons la m√™me technique pour
construire une fonction g√©n√©rique √† partir de deux fonctions qui se distinguent
uniquement par le type de leurs param√®tres. Nous expliquerons aussi comment
utiliser les types g√©n√©riques dans les d√©finitions de structures et
d'√©num√©rations.</p>
<!--
Then you‚Äôll learn how to use *traits* to define behavior in a generic way. You
can combine traits with generic types to constrain a generic type to only
those types that have a particular behavior, as opposed to just any type.
-->
<p>Ensuite, vous apprendrez comment utiliser les <em>traits</em> pour d√©finir un
comportement de mani√®re g√©n√©rique. Vous pouvez combiner les traits avec des
types g√©n√©riques pour contraindre un type g√©n√©rique uniquement √† des types qui
ont un comportement particulier, et non pas accepter n'importe quel type.</p>
<!--
Finally, we‚Äôll discuss *lifetimes*, a variety of generics that give the
compiler information about how references relate to each other. Lifetimes allow
us to borrow values in many situations while still enabling the compiler to
check that the references are valid.
-->
<p>Enfin, nous verrons les <em>dur√©es de vie</em>, un genre de g√©n√©rique qui indique au
compilateur comment les r√©f√©rences s'articulent entre elles. Les dur√©es de vie
nous permettent d'emprunter des valeurs dans diff√©rentes situations tout en
donnant les √©l√©ments au compilateur pour v√©rifier que les r√©f√©rences sont
toujours valides.</p>
<!--
## Removing Duplication by Extracting a Function
-->
<h2 id="supprimer-les-doublons-en-construisant-une-fonction"><a class="header" href="#supprimer-les-doublons-en-construisant-une-fonction">Supprimer les doublons en construisant une fonction</a></h2>
<!--
Before diving into generics syntax, let‚Äôs first look at how to remove
duplication that doesn‚Äôt involve generic types by extracting a function. Then
we‚Äôll apply this technique to extract a generic function! In the same way that
you recognize duplicated code to extract into a function, you‚Äôll start to
recognize duplicated code that can use generics.
-->
<p>Avant de plonger dans la syntaxe des g√©n√©riques, nous allons regarder comment
supprimer les doublons, sans utiliser de types g√©n√©riques, en construisant une
fonction. Ensuite, nous allons appliquer cette technique pour construire une
fonction g√©n√©rique¬†! De la m√™me mani√®re que vous d√©tectez du code dupliqu√© pour
l'extraire dans une fonction, vous allez commencer √† reconna√Ætre du code
dupliqu√© qui peut utiliser la g√©n√©ricit√©.</p>
<!--
Consider a short program that finds the largest number in a list, as shown in
Listing 10-1.
-->
<p>Imaginons un petit programme qui trouve le nombre le plus grand dans une liste,
comme dans l'encart 10-1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);
#     assert_eq!(le_plus_grand, 100);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);
<span class="boring">    assert_eq!(le_plus_grand, 100);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span>
-->
<p><span class="caption">Encart 10-1¬†: le code pour trouver le nombre le plus grand
dans une liste de nombres</span></p>
<!--
This code stores a list of integers in the variable `number_list` and places
the first number in the list in a variable named `largest`. Then it iterates
through all the numbers in the list, and if the current number is greater than
the number stored in `largest`, it replaces the number in that variable.
However, if the current number is less than or equal to the largest number seen
so far, the variable doesn‚Äôt change, and the code moves on to the next number
in the list. After considering all the numbers in the list, `largest` should
hold the largest number, which in this case is 100.
-->
<p>Ce code stocke une liste de nombres entiers dans la variable <code>liste_de_nombres</code>
et place le premier nombre de la liste dans une variable qui s'appelle
<code>le_plus_grand</code>. Ensuite, il parcourt tous les nombres dans la liste, et si le
nombre courant est plus grand que le nombre stock√© dans <code>le_plus_grand</code>, il
remplace le nombre dans cette variable. Cependant, si le nombre courant est
plus petit ou √©gal au nombre le plus grand trouv√© pr√©c√©demment, la variable ne
change pas, et le code passe au nombre suivant de la liste. Apr√®s avoir parcouru
tous les nombres de la liste, <code>le_plus_grand</code> devrait stocker le plus grand
nombre, qui est 100 dans notre cas.</p>
<!--
To find the largest number in two different lists of numbers, we can duplicate
the code in Listing 10-1 and use the same logic at two different places in the
program, as shown in Listing 10-2.
-->
<p>Pour trouver le nombre le plus grand dans deux listes de nombres diff√©rentes,
nous pourrions dupliquer le code de l'encart 10-1 et suivre la m√™me logique √†
deux endroits diff√©rents du programme, comme dans l'encart 10-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-2: Code to find the largest number in *two*
lists of numbers</span>
-->
<p><span class="caption">Encart 10-2¬†: le code pour trouver le plus grand nombre
dans <em>deux</em> listes de nombres</span></p>
<!--
Although this code works, duplicating code is tedious and error prone. We also
have to update the code in multiple places when we want to change it.
-->
<p>Bien que ce code fonctionne, la duplication de code est fastidieuse et source
d'erreurs. Nous devons aussi mettre √† jour le code √† plusieurs endroits si nous
souhaitons le modifier.</p>
<!--
To eliminate this duplication, we can create an abstraction by defining a
function that operates on any list of integers given to it in a parameter. This
solution makes our code clearer and lets us express the concept of finding the
largest number in a list abstractly.
-->
<p>Pour √©viter cette duplication, nous pouvons cr√©er un niveau d'abstraction en
d√©finissant une fonction qui travaille avec n'importe quelle liste de nombres
entiers qu'on lui donne en param√®tre. Cette solution rend notre code plus clair
et nous permet d'exprimer le concept de trouver le nombre le plus grand dans une
liste de mani√®re abstraite.</p>
<!--
In Listing 10-3, we extracted the code that finds the largest number into a
function named `largest`. Unlike the code in Listing 10-1, which can find the
largest number in only one particular list, this program can find the largest
number in two different lists.
-->
<p>Dans l'encart 10-3, nous avons extrait le code qui trouve le nombre le plus
grand dans une fonction qui s'appelle <code>le_plus_grand</code>. Contrairement au code de
l'encart 10-1, qui pouvait trouver le nombre le plus grand dans une seule liste
en particulier, ce programme peut trouver le nombre le plus grand dans deux
listes diff√©rentes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn le_plus_grand(liste: &[i32]) -> i32 {
    let mut le_plus_grand = liste[0];

    for &element in liste {
        if element > le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);
#     assert_eq!(resultat, 100);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);
#     assert_eq!(resultat, 6000);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 6000);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span>
-->
<p><span class="caption">Encart 10-3¬†: du code abstrait qui trouve le plus grand
nombre dans deux listes</span></p>
<!--
The `largest` function has a parameter called `list`, which represents any
concrete slice of `i32` values that we might pass into the function. As a
result, when we call the function, the code runs on the specific values that we
pass in. Don‚Äôt worry about the syntax of the `for` loop for now. We aren‚Äôt
referencing a reference to an `i32` here; we‚Äôre pattern matching and
destructuring each `&i32` that the `for` loop gets so that `item` will be an
`i32` inside the loop body. We‚Äôll cover pattern matching in detail in [Chapter
18][ch18]<!-- ignore -- >.
-->
<p>La fonction <code>le_plus_grand</code> a un param√®tre qui s'appelle <code>liste</code>, qui repr√©sente
n'importe quelle slice concr√®te de valeurs <code>i32</code> que nous pouvons passer √† la
fonction. Au final, lorsque nous appelons la fonction, le code s'ex√©cute sur les
valeurs pr√©cises que nous lui avons fournies. Mais ne nous pr√©occupons pas de
la syntaxe de la boucle <code>for</code> pour l'instant. Ici, nous n'utilisons pas une
r√©f√©rence vers un <code>i32</code>, nous destructurons via le filtrage par motif chaque
<code>&amp;i32</code> afin que la boucle <code>for</code> utilise cet <code>element</code> en tant que <code>i32</code> dans le
corps de la boucle. Nous parlerons plus en d√©tails du filtrage par motif au
<a href="ch18-00-patterns.html">chapitre 18</a><!-- ignore -->.</p>
<!--
In sum, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:
-->
<p>En r√©sum√©, voici les √©tapes que nous avons suivies pour changer le code de
l'encart 10-2 pour obtenir celui de l'encart 10-3¬†:</p>
<!--
1. Identify duplicate code.
2. Extract the duplicate code into the body of the function and specify the
   inputs and return values of that code in the function signature.
3. Update the two instances of duplicated code to call the function instead.
-->
<ol>
<li>Identification du code dupliqu√©.</li>
<li>Extraction du code dupliqu√© dans le corps de la fonction et ajout de
pr√©cisions sur les entr√©es et les valeurs de retour de ce code dans la
signature de la fonction.</li>
<li>Remplacement des deux instances du code dupliqu√© par des appels √† la
fonction.</li>
</ol>
<!--
Next, we‚Äôll use these same steps with generics to reduce code duplication in
different ways. In the same way that the function body can operate on an
abstract `list` instead of specific values, generics allow code to operate on
abstract types.
-->
<p>Ensuite, nous allons utiliser les m√™mes √©tapes avec la g√©n√©ricit√© pour r√©duire
la duplication de code de diff√©rentes fa√ßons. De la m√™me mani√®re que le corps
d'une fonction peut op√©rer sur une <code>liste</code> abstraite plut√¥t que sur des valeurs
sp√©cifiques, la g√©n√©ricit√© permet de travailler sur des types abstraits.</p>
<!--
For example, say we had two functions: one that finds the largest item in a
slice of `i32` values and one that finds the largest item in a slice of `char`
values. How would we eliminate that duplication? Let‚Äôs find out!
-->
<p>Par exemple, imaginons que nous ayons deux fonctions¬†: une qui trouve l'√©l√©ment
le plus grand dans une slice de valeurs <code>i32</code> et une qui trouve l'√©l√©ment le
plus grand dans une slice de valeurs <code>char</code>. Comment pourrions-nous √©viter la
duplication¬†? Voyons cela d√®s maintenant¬†!</p>
<!--
[ch18]: ch18-00-patterns.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Generic Data Types
-->
<h2 id="les-types-de-donn√©es-g√©n√©riques"><a class="header" href="#les-types-de-donn√©es-g√©n√©riques">Les types de donn√©es g√©n√©riques</a></h2>
<!--
We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let‚Äôs
first look at how to define functions, structs, enums, and methods using
generics. Then we‚Äôll discuss how generics affect code performance.
-->
<p>Nous pouvons utiliser la g√©n√©ricit√© pour cr√©er des d√©finitions pour des √©l√©ments
comme les signatures de fonctions ou les structures, que nous pouvons ensuite
utiliser sur de nombreux types de donn√©es concrets. Commen√ßons par regarder
comment d√©finir des fonctions, des structures, des √©num√©rations, et des m√©thodes
en utilisant la g√©n√©ricit√©. Ensuite nous verrons comment la g√©n√©ricit√© impacte
la performance du code.</p>
<!--
### In Function Definitions
-->
<h3 id="dans-la-d√©finition-dune-fonction"><a class="header" href="#dans-la-d√©finition-dune-fonction">Dans la d√©finition d'une fonction</a></h3>
<!--
When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.
-->
<p>Lorsque nous d√©finissons une fonction en utilisant la g√©n√©ricit√©, nous utilisons
des types g√©n√©riques dans la signature de la fonction l√† o√π nous pr√©cisons
habituellement
les types de donn√©es des param√®tres et de la valeur de retour. Faire ainsi rend
notre code plus flexible et apporte plus de fonctionnalit√©s au code appelant
notre fonction, tout en √©vitant la duplication de code.</p>
<!--
Continuing with our `largest` function, Listing 10-4 shows two functions that
both find the largest value in a slice.
-->
<p>Pour continuer avec notre fonction <code>le_plus_grand</code>, l'encart 10-4 nous montre
deux fonctions qui trouvent toutes les deux la valeur la plus grande dans une
slice.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
#     assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
#     assert_eq!(result, 'y');
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand_i32(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn le_plus_grand_caractere(liste: &amp;[char]) -&gt; char {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand_i32(&amp;liste_de_nombres);
    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand_caractere(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caract√®re est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 'y');
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span>
-->
<p><span class="caption">Encart 10-4¬†: deux fonctions qui se distinguent seulement
par leur nom et le type dans leur signature</span></p>
<!--
The `largest_i32` function is the one we extracted in Listing 10-3 that finds
the largest `i32` in a slice. The `largest_char` function finds the largest
`char` in a slice. The function bodies have the same code, so let‚Äôs eliminate
the duplication by introducing a generic type parameter in a single function.
-->
<p>La fonction <code>le_plus_grand_i32</code> est celle que nous avons construite √† l'encart 10-3
lorsqu'elle trouvait le plus grand <code>i32</code> dans une slice. La fonction
<code>le_plus_grand_caractere</code> recherche le plus grand <code>char</code> dans une slice. Les
corps des fonctions ont le m√™me code, donc essayons d'√©viter cette duplication
en utilisant un param√®tre de type g√©n√©rique dans une seule et unique fonction.</p>
<!--
To parameterize the types in the new function we‚Äôll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But we‚Äôll use `T` because, by
convention, parameter names in Rust are short, often just a letter, and Rust‚Äôs
type-naming convention is CamelCase. Short for ‚Äútype,‚Äù `T` is the default
choice of most Rust programmers.
-->
<p>Pour param√©trer les types dans la nouvelle fonction que nous allons d√©finir,
nous avons besoin de donner un nom au param√®tre de type, comme nous l'avons
fait pour les param√®tres de valeur des fonctions. Vous pouvez utiliser
n'importe quel identificateur pour nommer le param√®tre de type. Mais ici nous allons
utiliser <code>T</code> car, par convention, les noms de param√®tres en Rust sont courts,
souvent m√™me une seule lettre, et la convention de nommage des types en Rust est
d'utiliser le CamelCase. Et puisque la version courte de ‚Äútype‚Äù est <code>T</code>, c'est
le choix par d√©faut de nombreux d√©veloppeurs Rust.</p>
<!--
When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
`largest` function, place type name declarations inside angle brackets, `<>`,
between the name of the function and the parameter list, like this:
-->
<p>Lorsqu'on utilise un param√®tre dans le corps de la fonction, nous devons
d√©clarer le nom du param√®tre dans la signature afin que le compilateur puisse
savoir √† quoi r√©f√®re ce nom. De la m√™me mani√®re, lorsqu'on utilise un nom de
param√®tre de type dans la signature d'une fonction, nous devons d√©clarer le nom
du param√®tre de type avant de pouvoir l'utiliser. Pour d√©clarer la fonction
g√©n√©rique <code>le_plus_grand</code>, il faut placer la d√©claration du nom du type entre
des chevrons <code>&lt;&gt;</code>, le tout entre le nom de la fonction et la liste des
param√®tres, comme ceci¬†:</p>
<!--
```rust,ignore
fn largest<T>(list: &[T]) -> T {
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; T {
</code></pre>
<!--
We read this definition as: the function `largest` is generic over some type
`T`. This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a value of the
same type `T`.
-->
<p>Cette d√©finition se lit comme ceci¬†: la fonction <code>le_plus_grand</code> est g√©n√©rique
en fonction du type <code>T</code>. Cette fonction a un param√®tre qui s'appelle <code>liste</code>,
qui est une slice de valeurs de type <code>T</code>. Cette fonction <code>le_plus_grand</code> va
retourner une valeur du m√™me type <code>T</code>.</p>
<!--
Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code won‚Äôt
compile yet, but we‚Äôll fix it later in this chapter.
-->
<p>L'encart 10-5 nous montre la combinaison de la d√©finition de la fonction
<code>le_plus_grand</code> avec le type de donn√©es g√©n√©rique pr√©sent dans sa signature.
L'encart montre aussi que nous pouvons appeler la fonction avec une slice soit
de valeurs <code>i32</code>, soit de valeurs <code>char</code>. Notez que ce code ne se compile pas
encore, mais nous allons y rem√©dier plus tard dans ce chapitre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caract√®re est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-5: A definition of the `largest` function that
uses generic type parameters but doesn‚Äôt compile yet</span>
-->
<p><span class="caption">Encart 10-5¬†: une d√©finition de la fonction
<code>le_plus_grand</code> qui utilise des param√®tres de type g√©n√©riques, mais qui ne
compile pas encore</span></p>
<!--
If we compile this code right now, we‚Äôll get this error:
-->
<p>Si nous essayons de compiler ce code d√®s maintenant, nous aurons l'erreur
suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                   ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The note mentions `std::cmp::PartialOrd`, which is a *trait*. We‚Äôll talk about
traits in the next section. For now, this error states that the body of
`largest` won‚Äôt work for all possible types that `T` could be. Because we want
to compare values of type `T` in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
`std::cmp::PartialOrd` trait that you can implement on types (see Appendix C
for more on this trait). You‚Äôll learn how to specify that a generic type has a
particular trait in the [‚ÄúTraits as Parameters‚Äù][traits-as-parameters]<!--
ignore -- > section, but let‚Äôs first explore other ways of using generic type
parameters.
-->
<p>La note cite <code>std::cmp::PartialOrd</code>, qui est un <em>trait</em>. Nous allons voir les
traits dans la prochaine section. Pour le moment, cette erreur nous informe que
le corps de <code>le_plus_grand</code> ne va pas fonctionner pour tous les types possibles
que <code>T</code> peut repr√©senter. Comme nous voulons comparer des valeurs de type <code>T</code>
dans le corps, nous pouvons utiliser uniquement des types dont les valeurs
peuvent √™tre tri√©es dans l'ordre. Pour effectuer des comparaisons, la biblioth√®que
standard propose le trait <code>std::cmp::PartialOrd</code> que vous pouvez impl√©menter sur
des types (voir l'annexe C pour en savoir plus sur ce trait). Vous allez
apprendre √† indiquer qu'un type g√©n√©rique a un trait sp√©cifique dans la section
<a href="ch10-02-traits.html#des-traits-en-param%C3%A8tres">‚ÄúDes traits en param√®tres‚Äù</a><!-- ignore -->, mais d'abord
nous allons explorer d'autres mani√®res d'utiliser les param√®tres de types
g√©n√©riques.</p>
<!--
### In Struct Definitions
-->
<h3 id="dans-la-d√©finition-des-structures"><a class="header" href="#dans-la-d√©finition-des-structures">Dans la d√©finition des structures</a></h3>
<!--
We can also define structs to use a generic type parameter in one or more
fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>`
struct to hold `x` and `y` coordinate values of any type.
-->
<p>Nous pouvons aussi d√©finir des structures en utilisant des param√®tres de type
g√©n√©riques dans un ou plusieurs champs en utilisant la syntaxe <code>&lt;&gt;</code>. L'encart
10-6 nous montre comment d√©finir une structure <code>Point&lt;T&gt;</code> pour stocker des
valeurs de coordonn√©es <code>x</code> et <code>y</code> de n'importe quel type.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let entiers = Point { x: 5, y: 10 };
    let flottants = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y`
values of type `T`</span>
-->
<p><span class="caption">Encart 10-6¬†: une structure <code>Point&lt;T&gt;</code> qui stocke les
valeurs <code>x</code> et <code>y</code> de type <code>T</code></span></p>
<!--
The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.
-->
<p>La syntaxe pour l'utilisation des g√©n√©riques dans les d√©finitions de structures
est similaire √† celle utilis√©e dans les d√©finitions de fonctions. D'abord, on
d√©clare le nom du param√®tre de type entre des chevrons juste apr√®s le nom de la
structure. Ensuite, on peut utiliser le type g√©n√©rique dans la d√©finition de la
structure l√† o√π on indiquerait en temps normal des types de donn√©es concrets.</p>
<!--
Note that because we‚Äôve used only one generic type to define `Point<T>`, this
definition says that the `Point<T>` struct is generic over some type `T`, and
the fields `x` and `y` are *both* that same type, whatever that type may be. If
we create an instance of a `Point<T>` that has values of different types, as in
Listing 10-7, our code won‚Äôt compile.
-->
<p>Notez que comme nous n'avons utilis√© qu'un seul type g√©n√©rique pour d√©finir
<code>Point&lt;T&gt;</code>, cette d√©finition dit que la structure <code>Point&lt;T&gt;</code> est g√©n√©rique en
fonction d'un type <code>T</code>, et les champs <code>x</code> et <code>y</code> sont <em>tous les deux</em> de ce m√™me
type, quel qu'il soit. Si nous cr√©ons une instance de <code>Point&lt;T&gt;</code> qui a des
valeurs de types diff√©rents, comme dans l'encart 10-7, notre code ne va pas se
compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
}
</code></pre>
<!--
<span class="caption">Listing 10-7: The fields `x` and `y` must be the same
type because both have the same generic data type `T`.</span>
-->
<p><span class="caption">Encart 10-7¬†: les champs <code>x</code> et <code>y</code> doivent √™tre du m√™me
type car ils ont tous les deux le m√™me type de donn√©es g√©n√©rique <code>T</code>.</span></p>
<!--
In this example, when we assign the integer value 5 to `x`, we let the
compiler know that the generic type `T` will be an integer for this instance of
`Point<T>`. Then when we specify 4.0 for `y`, which we‚Äôve defined to have the
same type as `x`, we‚Äôll get a type mismatch error like this:
-->
<p>Dans cet exemple, lorsque nous assignons l'entier 5 √† <code>x</code>, nous laissons
entendre au compilateur que le type g√©n√©rique <code>T</code> sera un entier pour cette
instance de <code>Point&lt;T&gt;</code>. Ensuite, lorsque nous assignons 4.0 √† <code>y</code>, que nous
avons d√©fini comme ayant le m√™me type que <code>x</code>, nous obtenons une erreur
d'incompatibilit√© de type comme celle-ci¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 -- > src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
  |                                                ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
To define a `Point` struct where `x` and `y` are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of `Point` to be generic over types
`T` and `U` where `x` is of type `T` and `y` is of type `U`.
-->
<p>Pour d√©finir une structure <code>Point</code> o√π <code>x</code> et <code>y</code> sont tous les deux g√©n√©riques
mais peuvent avoir des types diff√©rents, nous pouvons utiliser plusieurs
param√®tres de types g√©n√©riques diff√©rents. Par exemple, dans l'encart 10-8,
nous pouvons changer la d√©finition de <code>Point</code> pour √™tre g√©n√©rique en fonction
des types <code>T</code> et <code>U</code> o√π <code>x</code> est de type <code>T</code> et <code>y</code> est de type <code>U</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let deux_entiers = Point { x: 5, y: 10 };
    let deux_flottants = Point { x: 1.0, y: 4.0 };
    let un_entier_et_un_flottant = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so
that `x` and `y` can be values of different types</span>
-->
<p><span class="caption">Encart 10-8: un <code>Point&lt;T, U&gt;</code> g√©n√©rique en fonction de
deux types <code>x</code> et <code>y</code> qui peuvent √™tre des valeurs de types diff√©rents</span></p>
<!--
Now all the instances of `Point` shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.
-->
<p>Maintenant, toutes les instances de <code>Point</code> montr√©es ici sont valides¬†! Vous
pouvez utiliser autant de param√®tres de type g√©n√©riques que vous souhaitez dans
la d√©claration de la d√©finition, mais en utiliser plus de quelques-uns rend
votre code difficile √† lire. Lorsque vous avez besoin de nombreux types
g√©n√©riques dans votre code, cela peut √™tre un signe que votre code a besoin
d'√™tre remani√© en √©l√©ments plus petits.</p>
<!--
### In Enum Definitions
-->
<h3 id="dans-les-d√©finitions-d√©num√©rations"><a class="header" href="#dans-les-d√©finitions-d√©num√©rations">Dans les d√©finitions d'√©num√©rations</a></h3>
<!--
As we did with structs, we can define enums to hold generic data types in their
variants. Let‚Äôs take another look at the `Option<T>` enum that the standard
library provides, which we used in Chapter 6:
-->
<p>Comme nous l'avons fait avec les structures, nous pouvons d√©finir des
√©num√©rations qui utilisent des types de donn√©es g√©n√©riques dans leurs variantes.
Commen√ßons par regarder √† nouveau l'√©num√©ration <code>Option&lt;T&gt;</code> que fournit la
biblioth√®que standard, et que nous avons utilis√©e au chapitre 6¬†:</p>
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This definition should now make more sense to you. As you can see, `Option<T>`
is an enum that is generic over type `T` and has two variants: `Some`, which
holds one value of type `T`, and a `None` variant that doesn‚Äôt hold any value.
By using the `Option<T>` enum, we can express the abstract concept of having an
optional value, and because `Option<T>` is generic, we can use this abstraction
no matter what the type of the optional value is.
-->
<p>Cette d√©finition devrait d√©sormais avoir plus de sens pour vous. Comme vous
pouvez le constater, <code>Option&lt;T&gt;</code> est une √©num√©ration qui est g√©n√©rique en
fonction du type <code>T</code> et a deux variantes¬†: <code>Some</code>, qui contient une valeur de
type <code>T</code>, et une variante <code>None</code> qui ne contient aucune valeur. En utilisant
l'√©num√©ration <code>Option&lt;T&gt;</code>, nous pouvons exprimer le concept abstrait d'avoir
une valeur optionnelle, et comme <code>Option&lt;T&gt;</code> est g√©n√©rique, nous pouvons
utiliser cette abstraction peu importe le type de la valeur optionnelle.</p>
<!--
Enums can use multiple generic types as well. The definition of the `Result`
enum that we used in Chapter 9 is one example:
-->
<p>Les √©num√©rations peuvent aussi utiliser plusieurs types g√©n√©riques. La
d√©finition de l'√©num√©ration <code>Result</code> que nous avons utilis√©e au chapitre 9 en est
un exemple¬†:</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result` enum is generic over two types, `T` and `E`, and has two variants:
`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type
`E`. This definition makes it convenient to use the `Result` enum anywhere we
have an operation that might succeed (return a value of some type `T`) or fail
(return an error of some type `E`). In fact, this is what we used to open a
file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when
the file was opened successfully and `E` was filled in with the type
`std::io::Error` when there were problems opening the file.
-->
<p>L'√©num√©ration <code>Result</code> est g√©n√©rique en fonction de deux types, <code>T</code> et <code>E</code>, et a
deux variantes¬†: <code>Ok</code>, qui contient une valeur de type <code>T</code>, et <code>Err</code>, qui
contient une valeur de type <code>E</code>. Cette d√©finition rend possible l'utilisation de
l'√©num√©ration <code>Result</code> partout o√π nous avons une op√©ration qui peut r√©ussir (et
retourner une valeur du type <code>T</code>) ou √©chouer (et retourner une erreur du type
<code>E</code>). En fait, c'est ce qui est utilis√© pour ouvrir un fichier dans l'encart
9-3, o√π <code>T</code> contenait un type <code>std::fs::File</code> lorsque le fichier √©tait ouvert
avec succ√®s et <code>E</code> contenait un type <code>std::io::Error</code> lorsqu'il y avait des
probl√®mes pour ouvrir le fichier.</p>
<!--
When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.
-->
<p>Lorsque vous reconna√Ætrez des cas dans votre code o√π vous aurez plusieurs
d√©finitions de structures ou d'√©num√©rations qui se distinguent uniquement par le
type de valeurs qu'elles stockent, vous pourrez √©viter les doublons en utilisant
des types g√©n√©riques √† la place.</p>
<!--
### In Method Definitions
-->
<h3 id="dans-la-d√©finition-des-m√©thodes"><a class="header" href="#dans-la-d√©finition-des-m√©thodes">Dans la d√©finition des m√©thodes</a></h3>
<!--
We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the `Point<T>`
struct we defined in Listing 10-6 with a method named `x` implemented on it.
-->
<p>Nous pouvons impl√©menter des m√©thodes sur des structures et des √©num√©rations
(comme nous l'avons fait dans le chapitre 5) et aussi utiliser des types
g√©n√©riques dans leurs d√©finitions. L'encart 10-9 montre la structure <code>Point&lt;T&gt;</code>
que nous avons d√©finie dans l'encart 10-6 avec une m√©thode qui s'appelle <code>x</code>
impl√©ment√©e sur cette derni√®re.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-9: Implementing a method named `x` on the
`Point<T>` struct that will return a reference to the `x` field of type
`T`</span>
-->
<p><span class="caption">Encart 10-9¬†: impl√©mentation d'une m√©thode <code>x</code> sur la
structure <code>Point&lt;T&gt;</code> qui va retourner une r√©f√©rence au champ <code>x</code>, de type <code>T</code>
</span></p>
<!--
Here, we‚Äôve defined a method named `x` on `Point<T>` that returns a reference
to the data in the field `x`.
-->
<p>Ici, nous avons d√©fini une m√©thode qui s'appelle <code>x</code> sur <code>Point&lt;T&gt;</code> qui retourne
une r√©f√©rence √† la donn√©e pr√©sente dans le champ <code>x</code>.</p>
<!--
Note that we have to declare `T` just after `impl` so we can use it to specify
that we‚Äôre implementing methods on the type `Point<T>`. By declaring `T` as a
generic type after `impl`, Rust can identify that the type in the angle
brackets in `Point` is a generic type rather than a concrete type. Because this
is declaring the generic again, we could have chosen a different name for the
generic parameter than the generic parameter declared in the struct definition,
but using the same name is conventional. Methods written within an `impl` that
declares the generic type will be defined on any instance of the type, no
matter what concrete type ends up substituting for the generic type.
-->
<p>Notez que nous devons d√©clarer <code>T</code> juste apr√®s <code>impl</code> afin de pouvoir l'utiliser
pour pr√©ciser que nous impl√©mentons des m√©thodes sur le type <code>Point&lt;T&gt;</code>. En
d√©clarant <code>T</code> comme un type g√©n√©rique apr√®s <code>impl</code>, Rust peut comprendre que le
type entre les chevrons dans <code>Point</code> est un type g√©n√©rique plut√¥t qu'un type
concret. Comme cela revient √† d√©clarer √† nouveau le g√©n√©rique, nous aurions pu
choisir un nom diff√©rent pour le param√®tre g√©n√©rique plut√¥t que de r√©utiliser
le m√™me nom que dans la d√©finition de la structure, mais c'est devenu une
convention d'utiliser le m√™me nom. Les m√©thodes √©crites dans un <code>impl</code> qui
d√©clarent un type g√©n√©rique peuvent √™tre d√©finies sur n'importe quelle instance
du type, peu importe quel type concret sera substitu√© dans le type g√©n√©rique.</p>
<!--
The other option we have is defining methods on the type with some constraint
on the generic type. We could, for example, implement methods only on
`Point<f32>` instances rather than on `Point<T>` instances with any generic
type. In Listing 10-10 we use the concrete type `f32`, meaning we don‚Äôt declare
any types after `impl`.
-->
<p>L'autre possibilit√© que nous avons est de d√©finir les m√©thodes sur le type avec
des contraintes sur le type g√©n√©rique. Nous pouvons par exemple impl√©menter des
m√©thodes uniquement sur des instances de <code>Point&lt;f32&gt;</code> plut√¥t que sur des
instances de n'importe quel type <code>Point&lt;T&gt;</code>. Dans l'encart 10-10, nous
utilisons le type concret <code>f32</code>, ce qui veut dire que nous n'avons pas besoin
de d√©clarer un type apr√®s <code>impl</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
# 
# impl<T> Point<T> {
#     fn x(&self) -> &T {
#         &self.x
#     }
# }
# 
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
# 
# fn main() {
#     let p = Point { x: 5, y: 10 };
# 
#     println!("p.x = {}", p.x());
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_depuis_lorigine(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-10: An `impl` block that only applies to a
struct with a particular concrete type for the generic type parameter `T`</span>
-->
<p><span class="caption">Encart 10-10¬†: un bloc <code>impl</code> qui ne s'applique que sur
une structure d'un type concret particulier pour le param√®tre de type g√©n√©rique
<code>T</code>
</span></p>
<!--
This code means the type `Point<f32>` will have a method named
`distance_from_origin` and other instances of `Point<T>` where `T` is not of
type `f32` will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.
-->
<p>Ce code signifie que le type <code>Point&lt;f32&gt;</code> va avoir une m√©thode qui s'appelle
<code>distance_depuis_lorigine</code> et les autres instances de <code>Point&lt;T&gt;</code> o√π <code>T</code> n'est
pas du type <code>f32</code> ne pourront pas appeler cette m√©thode. Cette m√©thode calcule
la distance entre notre point et la coordonn√©e (0.0, 0.0) et utilise des
op√©rations math√©matiques qui ne sont disponibles que pour les types de
flottants.</p>
<!--
Generic type parameters in a struct definition aren‚Äôt always the same as those
you use in that struct‚Äôs method signatures. Listing 10-11 uses the generic
types `X1` and `Y1` for the `Point` struct and `X2` `Y2` for the `mixup` method
signature to make the example clearer. The method creates a new `Point`
instance with the `x` value from the `self` `Point` (of type `X1`) and the `y`
value from the passed-in `Point` (of type `Y2`).
-->
<p>Les param√®tres de type g√©n√©riques dans la d√©finition d'une structure ne sont
pas toujours les m√™mes que ceux qui sont utilis√©s dans la signature des
m√©thodes de cette structure. Par exemple, l'encart 10-11 utilise les types
g√©n√©riques <code>X1</code> et <code>Y1</code> pour la structure <code>Point</code>, ainsi que <code>X2</code> et <code>Y2</code> pour
la signature de la m√©thode <code>melange</code> pour rendre l'exemple plus clair. La
m√©thode cr√©e une nouvelle instance de <code>Point</code> avec la valeur de <code>x</code> provenant
du <code>Point</code> <code>self</code> (de type <code>X1</code>) et la valeur de <code>y</code> provenant du <code>Point</code> en
param√®tre (de type <code>Y2</code>).</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn melange&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.melange(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-11: A method that uses different generic types
from its struct‚Äôs definition</span>
-->
<p><span class="caption">Encart 10-11¬†: une m√©thode qui utilise diff√©rents types
g√©n√©riques provenant de la d√©finition de la structure</span></p>
<!--
In `main`, we‚Äôve defined a `Point` that has an `i32` for `x` (with value `5`)
and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct
that has a string slice for `x` (with value `"Hello"`) and a `char` for `y`
(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,
which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable
will have a `char` for `y`, because `y` came from `p2`. The `println!` macro
call will print `p3.x = 5, p3.y = c`.
-->
<p>Dans le <code>main</code>, nous avons d√©fini un <code>Point</code> qui a un <code>i32</code> pour <code>x</code> (avec la
valeur <code>5</code>) et un <code>f64</code> pour <code>y</code> (avec la valeur 10.4). La variable <code>p2</code> est une
structure <code>Point</code> qui a une slice de chaine de caract√®res pour <code>x</code> (avec la
valeur <code>&quot;Hello&quot;</code>) et un caract√®re <code>char</code> pour <code>y</code> (avec la valeur <code>c</code>). L'appel
√† <code>melange</code> sur <code>p1</code> avec l'argument <code>p2</code> nous donne <code>p3</code>, qui aura un <code>i32</code> pour
<code>x</code>, car <code>x</code> provient de <code>p1</code>. La variable <code>p3</code> aura un caract√®re <code>char</code> pour
<code>y</code>, car <code>y</code> provient de <code>p2</code>. L'appel √† la macro <code>println!</code> va afficher
<code>p3.x = 5, p3.y = c</code>.</p>
<!--
The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with `impl` and some are declared with the method
definition. Here, the generic parameters `X1` and `Y1` are declared after
`impl` because they go with the struct definition. The generic parameters `X2`
and `Y2` are declared after `fn mixup`, because they‚Äôre only relevant to the
method.
-->
<p>Le but de cet exemple est de montrer une situation dans laquelle des param√®tres
g√©n√©riques sont d√©clar√©s avec <code>impl</code> et d'autres sont d√©clar√©s dans la
d√©finition de la m√©thode. Ici, les param√®tres g√©n√©riques <code>X1</code> et <code>Y1</code> sont
d√©clar√©s apr√®s <code>impl</code>, car ils sont li√©s √† la d√©finition de la structure. Les
param√®tres g√©n√©riques <code>X2</code> et <code>Y2</code> sont d√©clar√©s apr√®s <code>fn melange</code>, car ils ne
sont li√©s qu'√† cette m√©thode.</p>
<!--
### Performance of Code Using Generics
-->
<h3 id="performance-du-code-utilisant-les-g√©n√©riques"><a class="header" href="#performance-du-code-utilisant-les-g√©n√©riques">Performance du code utilisant les g√©n√©riques</a></h3>
<!--
You might be wondering whether there is a runtime cost when you‚Äôre using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesn‚Äôt run any slower using generic types than it would
with concrete types.
-->
<p>Vous vous demandez peut-√™tre s'il y a un co√ªt √† l'ex√©cution lorsque vous
utilisez des param√®tres de type g√©n√©riques. La bonne nouvelle est que Rust
impl√©mente les g√©n√©riques de mani√®re √† ce que votre code ne s'ex√©cute pas plus
lentement que vous utilisiez les types g√©n√©riques ou des types concrets.</p>
<!--
Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. *Monomorphization* is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.
-->
<p>Rust accomplit cela en pratiquant la monomorphisation √† la compilation du code
qui utilise les g√©n√©riques. La <em>monomorphisation</em> est un processus qui transforme
du code g√©n√©rique en code sp√©cifique en d√©finissant au moment de la compilation les
types concrets utilis√©s dans le code.</p>
<!--
In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.
-->
<p>Dans ce processus, le compilateur fait l'inverse des √©tapes que nous avons suivies
pour cr√©er la fonction g√©n√©rique de l'encart 10-5¬†: le compilateur cherche tous
les endroits o√π le code g√©n√©rique est utilis√© et g√©n√®re du code pour les types
concrets avec lesquels le code g√©n√©rique est appel√©.</p>
<!--
Let‚Äôs look at how this works with an example that uses the standard library‚Äôs
`Option<T>` enum:
-->
<p>Regardons comment cela fonctionne avec un exemple qui utilise l'√©num√©ration
<code>Option&lt;T&gt;</code> de la biblioth√®que standard¬†:</p>
<!--
```rust
let integer = Some(5);
let float = Some(5.0);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entier = Some(5);
let flottant = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<!--
When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in `Option<T>`
instances and identifies two kinds of `Option<T>`: one is `i32` and the other
is `f64`. As such, it expands the generic definition of `Option<T>` into
`Option_i32` and `Option_f64`, thereby replacing the generic definition with
the specific ones.
-->
<p>Lorsque Rust compile ce code, il applique la monomorphisation. Pendant ce
processus, le compilateur lit les valeurs qui ont √©t√© utilis√©es dans les
instances de <code>Option&lt;T&gt;</code> et en d√©duit les deux sortes de <code>Option&lt;T&gt;</code>¬†: une est
<code>i32</code> et l'autre est <code>f64</code>. Ainsi, il d√©compose la d√©finition g√©n√©rique de
<code>Option&lt;T&gt;</code> en <code>Option_i32</code> et en <code>Option_f64</code>, rempla√ßant ainsi la d√©finition
g√©n√©rique par deux d√©finitions concr√®tes.</p>
<!--
The monomorphized version of the code looks like the following. The generic
`Option<T>` is replaced with the specific definitions created by the compiler:
-->
<p>La version monomorphe du code ressemble √† ce qui suit. Le <code>Option&lt;T&gt;</code> g√©n√©rique
est remplac√© par deux d√©finitions concr√®tes cr√©√©es par le compilateur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let entier = Option_i32::Some(5);
    let flottant = Option_f64::Some(5.0);
}
</code></pre></pre>
<!--
Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rust‚Äôs generics extremely efficient at
runtime.
-->
<p>Comme Rust compile le code g√©n√©rique dans du code qui pr√©cise le type dans
chaque instance, l'utilisation des g√©n√©riques n'a pas de cons√©quence sur les
performances de l'ex√©cution. Quand le code s'ex√©cute, il fonctionne comme il
devrait le faire si nous avions dupliqu√© chaque d√©finition √† la main. Le
processus de monomorphisation rend les g√©n√©riques de Rust tr√®s performants au
moment de l'ex√©cution.</p>
<!--
[traits-as-parameters]: ch10-02-traits.html#traits-as-parameters
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Traits: Defining Shared Behavior
-->
<h2 id="d√©finir-des-comportements-partag√©s-avec-les-traits"><a class="header" href="#d√©finir-des-comportements-partag√©s-avec-les-traits">D√©finir des comportements partag√©s avec les traits</a></h2>
<!--
A *trait* tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic type can be any
type that has certain behavior.
-->
<p>Un <em>trait</em> d√©crit une fonctionnalit√© qu'a un type particulier et qu'il peut
partager avec d'autres types, √† destination du compilateur Rust. Nous pouvons
utiliser les traits pour d√©finir un comportement partag√© de mani√®re abstraite.
Nous pouvons lier ces traits √† un type g√©n√©rique pour exprimer le fait qu'il
puisse √™tre de n'importe quel type √† condition qu'il ait un comportement donn√©.</p>
<!--
> Note: Traits are similar to a feature often called *interfaces* in other
> languages, although with some differences.
-->
<blockquote>
<p>Remarque¬†: les traits sont similaires √† ce qu'on appelle parfois les
<em>interfaces</em> dans d'autres langages, malgr√© quelques diff√©rences.</p>
</blockquote>
<!--
### Defining a Trait
-->
<h3 id="d√©finir-un-trait"><a class="header" href="#d√©finir-un-trait">D√©finir un trait</a></h3>
<!--
A type‚Äôs behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.
-->
<p>Le comportement d'un type s'exprime via les m√©thodes que nous pouvons appeler
sur ce type. Diff√©rents types peuvent partager le m√™me comportement si nous
pouvons appeler les m√™mes m√©thodes sur tous ces types. D√©finir un trait est une
mani√®re de regrouper des signatures de m√©thodes pour d√©finir un comportement
n√©cessaire pour accomplir un objectif.</p>
<!--
For example, let‚Äôs say we have multiple structs that hold various kinds and
amounts of text: a `NewsArticle` struct that holds a news story filed in a
particular location and a `Tweet` that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.
-->
<p>Par exemple, imaginons que nous avons plusieurs structures qui stockent
diff√©rents types et quantit√©s de texte¬†: une structure <code>ArticleDePresse</code>, qui
contient un reportage dans un endroit donn√© et un <code>Tweet</code> qui peut avoir jusqu'√†
280 caract√®res maximum et des m√©tadonn√©es qui indiquent si cela est un nouveau
tweet, un retweet, ou une r√©ponse √† un autre tweet.</p>
<!--
We want to make a media aggregator library crate named `aggregator` that can
display summaries of data that might be stored in a `NewsArticle` or `Tweet`
instance. To do this, we need a summary from each type, and we‚Äôll request
that summary by calling a `summarize` method on an instance. Listing 10-12
shows the definition of a public `Summary` trait that expresses this behavior.
-->
<p>Nous voulons construire une crate de biblioth√®que <code>agregateur</code> pour des
agr√©gateurs de m√©dias qui peut afficher le r√©sum√© des donn√©es stock√©es dans une
instance de <code>ArticleDePresse</code> ou de <code>Tweet</code>. Pour cela, il nous faut un r√©sum√©
pour chaque type, et nous allons demander ce r√©sum√© en appelant la m√©thode
<code>resumer</code> sur une instance. L'encart 10-12 nous montre la d√©finition d'un trait
public <code>Resumable</code> qui d√©crit ce comportement.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize(&self) -> String;
}
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer(&amp;self) -&gt; String;
}
</code></pre>
<!--
<span class="caption">Listing 10-12: A `Summary` trait that consists of the
behavior provided by a `summarize` method</span>
-->
<p><span class="caption">Encart 10-12¬†: un trait <code>Resumable</code> qui repr√©sente le
comportement fourni par une m√©thode <code>resumer</code></span></p>
<!--
Here, we declare a trait using the `trait` keyword and then the trait‚Äôs name,
which is `Summary` in this case. We‚Äôve also declared the trait as `pub` so that
crates depending on this crate can make use of this trait too, as we‚Äôll see in
a few examples. Inside the curly brackets, we declare the method signatures
that describe the behaviors of the types that implement this trait, which in
this case is `fn summarize(&self) -> String`.
-->
<p>Ici, nous d√©clarons un trait en utilisant le mot-cl√© <code>trait</code> et ensuite le nom
du trait, qui est <code>Resumable</code> dans notre cas. Nous avons aussi d√©clar√© le trait
comme <code>pub</code> afin que les crates qui d√©pendent de cette crate puissent
aussi utiliser ce trait, comme nous allons le voir dans quelques exemples.
Entre les accolades, nous d√©clarons la signature de la m√©thode qui d√©crit le
comportement des types qui impl√©mentent ce trait, qui est dans notre cas
<code>fn resumer(&amp;self) -&gt; String</code>.</p>
<!--
After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the `Summary` trait will have the method `summarize`
defined with this signature exactly.
-->
<p>A la fin de la signature de la m√©thode, au lieu de renseigner une impl√©mentation
entre des accolades, nous utilisons un point-virgule. Chaque type qui impl√©mente
ce trait doit renseigner son propre comportement dans le corps de la m√©thode. Le
compilateur va s'assurer que tous les types qui ont le trait <code>Resumable</code> auront
la m√©thode <code>resumer</code> d√©finie avec cette signature pr√©cise.</p>
<!--
A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.
-->
<p>Un trait peut avoir plusieurs m√©thodes dans son corps¬†: les signatures des
m√©thodes sont ajout√©es ligne par ligne et chaque ligne se termine avec un
point-virgule.</p>
<!--
### Implementing a Trait on a Type
-->
<h3 id="impl√©menter-un-trait-sur-un-type"><a class="header" href="#impl√©menter-un-trait-sur-un-type">Impl√©menter un trait sur un type</a></h3>
<!--
Now that we‚Äôve defined the desired signatures of the `Summary` trait‚Äôs methods,
we can implement it on the types in our media aggregator. Listing 10-13 shows
an implementation of the `Summary` trait on the `NewsArticle` struct that uses
the headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.
-->
<p>Maintenant que nous avons d√©fini les signatures souhait√©es des m√©thodes du
trait <code>Resumable</code>, nous pouvons maintenant l'impl√©menter sur les types de notre
agr√©gateur de m√©dias. L'encart 10-13 montre une impl√©mentation du trait
<code>Resumable</code> sur la structure <code>ArticleDePresse</code> qui utilise le titre, le nom de
l'auteur et le lieu pour cr√©er la valeur de retour de <code>resumer</code>. Pour la
structure <code>Tweet</code>, nous d√©finissons <code>resumer</code> avec le nom d'utilisateur suivi
par le texte entier du tweet, en supposant que le contenu du tweet est d√©j√†
limit√© √† 280 caract√®res.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct ArticleDePresse {
    pub titre: String,
    pub lieu: String,
    pub auteur: String,
    pub contenu: String,
}

impl Resumable for ArticleDePresse {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
    }
}

pub struct Tweet {
    pub nom_utilisateur: String,
    pub contenu: String,
    pub reponse: bool,
    pub retweet: bool,
}

impl Resumable for Tweet {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}¬†: {}&quot;, self.nom_utilisateur, self.contenu)
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-13: Implementing the `Summary` trait on the
`NewsArticle` and `Tweet` types</span>
-->
<p><span class="caption">Encart 10-13¬†: impl√©mentation du trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code></span></p>
<!--
Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put the trait name that we want to
implement, then use the `for` keyword, and then specify the name of the type we
want to implement the trait for. Within the `impl` block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.
-->
<p>L'impl√©mentation d'un trait sur un type est similaire √† l'impl√©mentation d'une
m√©thode classique. La diff√©rence est que nous ajoutons le nom du trait que nous
voulons impl√©menter apr√®s le <code>impl</code>, et que nous utilisons ensuite le mot-cl√©
<code>for</code> suivi du nom du type sur lequel nous souhaitons impl√©menter le trait. √Ä
l'int√©rieur du bloc <code>impl</code>, nous ajoutons les signatures des m√©thodes pr√©sentes
dans la d√©finition du trait. Au lieu d'ajouter un point-virgule apr√®s chaque
signature, nous pla√ßons les accolades et on remplit le corps de la m√©thode avec
le comportement sp√©cifique que nous voulons que les m√©thodes du trait suivent
pour le type en question.</p>
<!--
Now that the library has implemented the `Summary` trait on `NewsArticle` and
`Tweet`, users of the crate can call the trait methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods. The only
difference is that the trait has to be brought into scope as well as the types
to get the additional trait methods. Here‚Äôs an example of how a binary crate
could use our `aggregator` library crate:
-->
<p>Maintenant que la biblioth√®que a impl√©ment√© le trait <code>Resumable</code> sur
<code>ArticleDePresse</code> et <code>Tweet</code>, les utilisateurs de cette crate peuvent appeler
les m√©thodes de l'instance de <code>ArticleDePresse</code> et <code>Tweet</code> comme si elles
√©taient des m√©thodes classiques. La seule diff√©rence est que le trait ainsi que
les types doivent √™tre introduits dans la port√©e pour obtenir les m√©thodes de
trait additionnelles. Voici un exemple de comment la crate binaire pourra
utiliser notre crate de biblioth√®que <code>agregateur</code>¬†:</p>
<!--
```rust,ignore
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
```
-->
<pre><code class="language-rust ignore">use agregateur::{Resumable, Tweet};

fn main() {
    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien s√ªr, les amis, comme vous le savez probablement d√©j√†&quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweet¬†: {}&quot;, tweet.resumer());
}
</code></pre>
<!--
This code prints `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.
-->
<p>Ce code affichera <code>1 nouveau tweet¬†: jean¬†: Bien s√ªr, les amis, comme vous le savez probablement d√©j√†</code>.</p>
<!--
Other crates that depend on the `aggregator` crate can also bring the `Summary`
trait into scope to implement the trait on their own types. One restriction to
note with trait implementations is that we can implement a trait on a type only
if at least one of the trait or the type is local to our crate. For example, we
can implement standard library traits like `Display` on a custom type like
`Tweet` as part of our `aggregator` crate functionality, because the type
`Tweet` is local to our `aggregator` crate. We can also implement `Summary` on
`Vec<T>` in our `aggregator` crate, because the trait `Summary` is local to our
`aggregator` crate.
-->
<p>Les autres crates qui d√©pendent de la crate <code>agregateur</code> peuvent aussi importer
dans la port√©e le trait <code>Resumable</code> afin d'impl√©menter le trait sur leurs
propres types. Il y a une limitation √† souligner avec l'impl√©mentation des
traits, c'est que nous ne pouvons impl√©menter un trait sur un type qu'√†
condition qu'au moins le trait ou le type soit d√©fini localement dans notre
crate. Par exemple, nous pouvons impl√©menter des traits de la biblioth√®que
standard comme <code>Display</code> sur un type personnalis√© comme <code>Tweet</code> comme une
fonctionnalit√© de notre crate <code>agregateur</code>, car le type <code>Tweet</code> est d√©fini
localement dans notre crate <code>agregateur</code>. Nous pouvons aussi impl√©menter
<code>Resumable</code> sur <code>Vec&lt;T&gt;</code> dans notre crate <code>agregateur</code>, car le trait
<code>Resumable</code> est d√©fini localement dans notre crate <code>agregateur</code>.</p>
<!--
But we can‚Äôt implement external traits on external types. For example, we can‚Äôt
implement the `Display` trait on `Vec<T>` within our `aggregator` crate,
because `Display` and `Vec<T>` are defined in the standard library and aren‚Äôt
local to our `aggregator` crate. This restriction is part of a property of
programs called *coherence*, and more specifically the *orphan rule*, so named
because the parent type is not present. This rule ensures that other people‚Äôs
code can‚Äôt break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldn‚Äôt know which
implementation to use.
-->
<p>Mais nous ne pouvons pas impl√©menter des traits externes sur des types externes.
Par exemple, nous ne pouvons pas impl√©menter le trait <code>Display</code> sur <code>Vec&lt;T&gt;</code> √†
l'int√©rieur de notre crate <code>agregateur</code>, car <code>Display</code> et <code>Vec&lt;T&gt;</code> sont d√©finis
dans la biblioth√®que standard et ne sont donc pas d√©finis localement dans notre
crate <code>agregateur</code>. Cette limitation fait partie d'une propri√©t√© des programmes
que l'on appelle la <em>coh√©rence</em>, et plus pr√©cis√©ment la <em>r√®gle de l'orphelin</em>,
qui s'appelle ainsi car le type parent n'est pas pr√©sent. Cette r√®gle s'assure
que le code des autres personnes ne casse pas votre code et r√©ciproquement.
Sans cette r√®gle, deux crates pourraient impl√©menter le m√™me trait sur le m√™me
type, et Rust ne saurait pas quelle impl√©mentation utiliser.</p>
<!--
### Default Implementations
-->
<h3 id="impl√©mentations-par-d√©faut"><a class="header" href="#impl√©mentations-par-d√©faut">Impl√©mentations par d√©faut</a></h3>
<!--
Sometimes it‚Äôs useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method‚Äôs default behavior.
-->
<p>Il est parfois utile d'avoir un comportement par d√©faut pour toutes ou une
partie des m√©thodes d'un trait plut√¥t que de demander l'impl√©mentation de toutes
les m√©thodes sur chaque type. Ainsi, si nous impl√©mentons le trait sur un type
particulier, nous pouvons garder ou r√©√©crire le comportement par d√©faut de
chaque m√©thode.</p>
<!--
Listing 10-14 shows how to specify a default string for the `summarize` method
of the `Summary` trait instead of only defining the method signature, as we did
in Listing 10-12.
-->
<p>L'encart 10-14 nous montre comment pr√©ciser une String par d√©faut pour la
m√©thode <code>resumer</code> du trait <code>Resumable</code> plut√¥t que de d√©finir uniquement la
signature de la m√©thode, comme nous l'avons fait dans l'encart 10-12.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer(&amp;self) -&gt; String {
        String::from(&quot;(En savoir plus ...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-14: Definition of a `Summary` trait with a
default implementation of the `summarize` method</span>
-->
<p><span class="caption">Encart 10-14¬†: d√©finition du trait <code>Resumable</code> avec une
impl√©mentation par d√©faut de la m√©thode <code>resumer</code></span></p>
<!--
To use a default implementation to summarize instances of `NewsArticle` instead
of defining a custom implementation, we specify an empty `impl` block with
`impl Summary for NewsArticle {}`.
-->
<p>Pour utiliser l'impl√©mentation par d√©faut pour r√©sumer des instances de
<code>ArticleDePresse</code> au lieu de pr√©ciser une impl√©mentation personnalis√©e, nous
pr√©cisons un bloc <code>impl</code> vide avec <code>impl Resumable for ArticleDePresse {}</code>.</p>
<!--
Even though we‚Äôre no longer defining the `summarize` method on `NewsArticle`
directly, we‚Äôve provided a default implementation and specified that
`NewsArticle` implements the `Summary` trait. As a result, we can still call
the `summarize` method on an instance of `NewsArticle`, like this:
-->
<p>M√™me si nous ne d√©finissons plus directement la m√©thode <code>resumer</code> sur
<code>ArticleDePresse</code>, nous avons fourni une impl√©mentation par d√©faut et pr√©cis√©
que <code>ArticleDePresse</code> impl√©mente le trait <code>Resumable</code>. Par cons√©quent, nous
pouvons toujours appeler la m√©thode <code>resumer</code> sur une instance de
<code>ArticleDePresse</code>, comme ceci¬†:</p>
<!--
```rust,ignore
# use chapter10::{self, NewsArticle, Summary};
# 
# fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, ArticleDePresse, Resumable};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = ArticleDePresse {
        titre: String::from(&quot;Les Penguins ont remport√© la Coupe Stanley¬†!&quot;),
        lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
        auteur: String::from(&quot;Iceburgh&quot;),
        contenu: String::from(
            &quot;Les Penguins de Pittsburgh sont une nouvelle fois la meilleure \
            √©quipe de hockey de la LNH.&quot;,
        ),
    };

    println!(&quot;Nouvel article disponible¬†! {}&quot;, article.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `New article available! (Read more...)`.
-->
<p>Ce code va afficher <code>Nouvel article disponible¬†! (En savoir plus ...)</code>.</p>
<!--
Creating a default implementation for `summarize` doesn‚Äôt require us to change
anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesn‚Äôt have a default
implementation.
-->
<p>La cr√©ation d'une impl√©mentation par d√©faut pour <code>resumer</code> n'a pas besoin que
nous modifiions quelque chose dans l'impl√©mentation de <code>Resumable</code> sur <code>Tweet</code>
dans l'encart 10-13. C'est parce que la syntaxe pour r√©√©crire l'impl√©mentation
par d√©faut est la m√™me que la syntaxe pour impl√©menter une m√©thode qui n'a pas
d'impl√©mentation par d√©faut.</p>
<!--
Default implementations can call other methods in the same trait, even if those
other methods don‚Äôt have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the `Summary` trait to have a
`summarize_author` method whose implementation is required, and then define a
`summarize` method that has a default implementation that calls the
`summarize_author` method:
-->
<p>Les impl√©mentations par d√©faut peuvent appeler d'autres m√©thodes du m√™me trait,
m√™me si ces autres m√©thodes n'ont pas d'impl√©mentation par d√©faut. Ainsi, un
trait peut fournir de nombreuses fonctionnalit√©s utiles et n'exiger du
d√©veloppeur qui l'utilise que d'en impl√©menter une petite partie. Par exemple,
nous pouvons d√©finir le trait <code>Resumable</code> comme ayant une m√©thode
<code>resumer_auteur</code> dont l'impl√©mentation est n√©cessaire, et ensuite d√©finir une
m√©thode <code>resumer</code> qui a une impl√©mentation par d√©faut qui appelle la m√©thode
<code>resumer_auteur</code>¬†:</p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize_author(&self) -> String {
#         format!("@{}", self.username)
#     }
# }
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer_auteur(&amp;self) -&gt; String;

    fn resumer(&amp;self) -&gt; String {
        format!(&quot;(Lire plus d'√©l√©ments de {} ...)&quot;, self.resumer_auteur())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.nom_utilisateur)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
To use this version of `Summary`, we only need to define `summarize_author`
when we implement the trait on a type:
-->
<p>Pour pouvoir utiliser cette version de <code>Resumable</code>, nous avons seulement besoin
de d√©finir <code>resumer_auteur</code> lorsqu'on impl√©mente le trait sur le type¬†:</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize_author(&self) -> String;
# 
#     fn summarize(&self) -> String {
#         format!("(Read more from {}...)", self.summarize_author())
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lire plus d'√©l√©ments de {} ...)&quot;, self.resumer_auteur())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Resumable for Tweet {
    fn resumer_auteur(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nom_utilisateur)
    }
}
</code></pre>
<!--
After we define `summarize_author`, we can call `summarize` on instances of the
`Tweet` struct, and the default implementation of `summarize` will call the
definition of `summarize_author` that we‚Äôve provided. Because we‚Äôve implemented
`summarize_author`, the `Summary` trait has given us the behavior of the
`summarize` method without requiring us to write any more code.
-->
<p>Apr√®s avoir d√©fini <code>resumer_auteur</code>, nous pouvons appeler <code>resumer</code> sur des
instances de la structure <code>Tweet</code>, et l'impl√©mentation par d√©faut de <code>resumer</code>
va appeler <code>resumer_auteur</code>, que nous avons d√©fini. Comme nous avons impl√©ment√©
<code>resumer_auteur</code>, le trait <code>Resumable</code> nous a donn√© le comportement de la
m√©thode <code>resumer</code> sans nous obliger √† √©crire une ligne de code suppl√©mentaire.</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien s√ªr, les amis, comme vous le savez probablement d√©j√†&quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweet¬†: {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: (Read more from @horse_ebooks...)`.
-->
<p>Ce code affichera <code>1 nouveau tweet¬†: (Lire plus d'√©l√©ments de @jean ...)</code>.</p>
<!--
Note that it isn‚Äôt possible to call the default implementation from an
overriding implementation of that same method.
-->
<p>Notez qu'il n'est pas possible d'appeler l'impl√©mentation par d√©faut √† partir
d'une r√©√©criture de cette m√™me m√©thode.</p>
<!--
### Traits as Parameters
-->
<h3 id="des-traits-en-param√®tres"><a class="header" href="#des-traits-en-param√®tres">Des traits en param√®tres</a></h3>
<!--
Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.
-->
<p>Maintenant que vous savez comment d√©finir et impl√©menter les traits, nous
pouvons regarder comment utiliser les traits pour d√©finir des fonctions qui
acceptent plusieurs types diff√©rents.</p>
<!--
For example, in Listing 10-13, we implemented the `Summary` trait on the
`NewsArticle` and `Tweet` types. We can define a `notify` function that calls
the `summarize` method on its `item` parameter, which is of some type that
implements the `Summary` trait. To do this, we can use the `impl Trait`
syntax, like this:
-->
<p>Par exemple, dans l'encart 10-13, nous avons impl√©ment√© le trait <code>Resumable</code>
sur les types <code>ArticleDePresse</code> et <code>Tweet</code>. Nous pouvons d√©finir une fonction
<code>notifier</code> qui va appeler la m√©thode <code>resumer</code> sur son param√®tre <code>element</code>, qui
est d'un type qui impl√©mente le trait <code>Resumable</code>. Pour faire ceci, nous
pouvons utiliser la syntaxe <code>impl Trait</code>, comme ceci¬†:</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}¬†: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notifier(element: &amp;impl Resumable) {
    println!(&quot;Flash info¬†! {}&quot;, element.resumer());
}
</code></pre>
<!--
Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won‚Äôt compile
because those types don‚Äôt implement `Summary`.
-->
<p>Au lieu d'un type concret pour le param√®tre <code>element</code>, nous pr√©cisons le mot-cl√©
<code>impl</code> et le nom du trait. Ce param√®tre accepte n'importe quel type qui
impl√©mente le trait sp√©cifi√©. Dans le corps de <code>notifier</code>, nous pouvons appeler
toutes les m√©thodes sur <code>element</code> qui proviennent du trait <code>Resumable</code>, comme
<code>resumer</code>. Nous pouvons appeler <code>notifier</code> et passer une instance de
<code>ArticleDePresse</code> ou de <code>Tweet</code>. Le code qui appellera la fonction avec un autre
type, comme une <code>String</code> ou un <code>i32</code>, ne va pas se compiler car ces types
n'impl√©mentent pas <code>Resumable</code>.</p>
<!--
#### Trait Bound Syntax
-->
<h4 id="la-syntaxe-du-trait-li√©"><a class="header" href="#la-syntaxe-du-trait-li√©">La syntaxe du trait li√©</a></h4>
<!--
The `impl Trait` syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a *trait bound*; it looks like
this:
-->
<p>La syntaxe <code>impl Trait</code> fonctionne bien pour des cas simples, mais est en
r√©alit√© du sucre syntaxique pour une forme plus longue, qui s'appelle le
<em>trait li√©</em>, qui ressemble √† ceci¬†:</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element: &amp;T) {
    println!(&quot;Flash info¬†! {}&quot;, element.resumer());
}
</code></pre>
<!--
This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.
-->
<p>Cette forme plus longue est √©quivalente √† l'exemple dans la section pr√©c√©dente,
mais est plus verbeuse. Nous pla√ßons les traits li√©s dans la d√©claration des
param√®tres de type g√©n√©riques apr√®s un deux-point entre des chevrons.</p>
<!--
The `impl Trait` syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement `Summary`. Using the `impl
Trait` syntax looks like this:
-->
<p>La syntaxe <code>impl Trait</code> est pratique pour rendre du code plus concis dans des
cas simples. La syntaxe du trait li√© exprime plus de complexit√© dans certains
cas. Par exemple, nous pouvons avoir deux param√®tres qui impl√©mentent
<code>Resumable</code>. En utilisant la syntaxe <code>impl Trait</code>, nous aurons ceci¬†:</p>
<!--
```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element1: &amp;impl Resumable, element2: &amp;impl Resumable) {
</code></pre>
<!--
If we wanted this function to allow `item1` and `item2` to have different
types, using `impl Trait` would be appropriate (as long as both types implement
`Summary`). If we wanted to force both parameters to have the same type, that‚Äôs
only possible to express using a trait bound, like this:
-->
<p>Si nous souhaitons permettre √† <code>element1</code> et <code>element2</code> d'avoir des types
diff√©rents, l'utilisation de <code>impl Trait</code> est appropri√©e (du moment que chacun
de ces types impl√©mentent <code>Resumable</code>). Mais si nous souhaitons forcer les deux
param√®tres √† √™tre du m√™me type, cela n'est possible √† exprimer qu'avec un trait
li√©, comme ceci¬†:</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element1: &amp;T, element2: &amp;T) {
</code></pre>
<!--
The generic type `T` specified as the type of the `item1` and `item2`
parameters constrains the function such that the concrete type of the value
passed as an argument for `item1` and `item2` must be the same.
-->
<p>Le type g√©n√©rique <code>T</code> renseign√© comme type des param√®tres <code>element1</code> et
<code>element2</code> contraint la fonction de mani√®re √† ce que les types concrets des
valeurs pass√©es en arguments pour <code>element1</code> et <code>element2</code> soient identiques.</p>
<!--
#### Specifying Multiple Trait Bounds with the `+` Syntax
-->
<h4 id="renseigner-plusieurs-traits-li√©s-avec-la-syntaxe-"><a class="header" href="#renseigner-plusieurs-traits-li√©s-avec-la-syntaxe-">Renseigner plusieurs traits li√©s avec la syntaxe <code>+</code></a></h4>
<!--
We can also specify more than one trait bound. Say we wanted `notify` to use
display formatting on `item` as well as the `summarize` method: we specify in
the `notify` definition that `item` must implement both `Display` and
`Summary`. We can do so using the `+` syntax:
-->
<p>Nous pouvons aussi pr√©ciser que nous attendons plus d'un trait li√©. Imaginons
que nous souhaitons que <code>notifier</code> utilise le formatage d'affichage sur
<code>element</code> ainsi que la m√©thode <code>resumer</code>¬†: nous indiquons dans la d√©finition de
<code>notify</code> que <code>element</code> doit impl√©menter √† la fois <code>Display</code> et <code>Resumable</code>.
Nous pouvons faire ceci avec la syntaxe <code>+</code>¬†:</p>
<!--
```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element: &amp;(impl Resumable + Display)) {
</code></pre>
<!--
The `+` syntax is also valid with trait bounds on generic types:
-->
<p>La syntaxe <code>+</code> fonctionne aussi avec les traits li√©s sur des types g√©n√©riques¬†:</p>
<!--
```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable + Display&gt;(element: &amp;T) {
</code></pre>
<!--
With the two trait bounds specified, the body of `notify` can call `summarize`
and use `{}` to format `item`.
-->
<p>Avec les deux traits li√©s renseign√©s, le corps de <code>notifier</code> va appeler
<code>resumer</code> et utiliser <code>{}</code> pour formater <code>element</code>.</p>
<!--
#### Clearer Trait Bounds with `where` Clauses
-->
<h4 id="des-traits-li√©s-plus-clairs-avec-la-clause-where"><a class="header" href="#des-traits-li√©s-plus-clairs-avec-la-clause-where">Des traits li√©s plus clairs avec la clause <code>where</code></a></h4>
<!--
Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function‚Äôs name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a `where` clause after the function
signature. So instead of writing this:
-->
<p>L'utilisation de trop nombreux traits li√©s a aussi ses d√©savantages. Chaque
type g√©n√©rique a ses propres traits li√©s, donc les fonctions avec plusieurs
param√®tres de type g√©n√©riques peuvent aussi avoir de nombreuses informations de
traits li√©s entre le nom de la fonction et la liste de ses param√®tres, ce qui
rend la signature de la fonction difficile √† lire. Pour cette raison, Rust a une
syntaxe alternative pour renseigner les traits li√©s, dans une clause <code>where</code>
apr√®s la signature de la fonction. Donc, au lieu d'√©crire ceci ...</p>
<!--
```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```
-->
<pre><code class="language-rust ignore">fn une_fonction&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<!--
we can use a `where` clause, like this:
-->
<p>... nous pouvons utiliser la clause <code>where</code>, comme ceci¬†:</p>
<!--
```rust,ignore
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
```
-->
<pre><code class="language-rust ignore">fn une_fonction&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!--
This function‚Äôs signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.
-->
<p>La signature de cette fonction est moins encombr√©e¬†: le nom de la fonction, la
liste des param√®tres et le type de retour sont plus proches les uns des autres,
comme une fonction sans traits li√©s.</p>
<!--
### Returning Types that Implement Traits
-->
<h3 id="retourner-des-types-qui-impl√©mentent-des-traits"><a class="header" href="#retourner-des-types-qui-impl√©mentent-des-traits">Retourner des types qui impl√©mentent des traits</a></h3>
<!--
We can also use the `impl Trait` syntax in the return position to return a
value of some type that implements a trait, as shown here:
-->
<p>Nous pouvons aussi utiliser la syntaxe <code>impl Trait</code> √† la place du type de
retour afin de retourner une valeur d'un type qui impl√©mente un trait, comme
ci-dessous¬†:</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}¬†: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable() -&gt; impl Resumable {
    Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien s√ªr, les amis, comme vous le savez probablement d√©j√†&quot;),
        reponse: false,
        retweet: false,
    }
}
</code></pre>
<!--
By using `impl Summary` for the return type, we specify that the
`returns_summarizable` function returns some type that implements the `Summary`
trait without naming the concrete type. In this case, `returns_summarizable`
returns a `Tweet`, but the code calling this function doesn‚Äôt know that.
-->
<p>En utilisant <code>impl Resumable</code> pour le type de retour, nous indiquons que la
fonction <code>retourne_resumable</code> retourne un type qui impl√©mente le trait
<code>Resumable</code> sans avoir √† √©crire le nom du type concret. Dans notre cas,
<code>retourne_resumable</code> retourne un <code>Tweet</code>, mais le code qui appellera cette
fonction ne le saura pas.</p>
<!--
The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The `impl Trait` syntax lets you
concisely specify that a function returns some type that implements the
`Iterator` trait without needing to write out a very long type.
-->
<p>La capacit√© de retourner un type qui est uniquement caract√©ris√© par le trait
qu'il impl√©mente est tout particuli√®rement utile dans le cas des fermetures et
des it√©rateurs, que nous verrons au chapitre 13. Les fermetures et les
it√©rateurs cr√©ent des types que seul le compilateur est en mesure de comprendre
ou alors des types qui sont tr√®s longs √† d√©finir. La syntaxe <code>impl Trait</code> vous
permet de renseigner de mani√®re concise qu'une fonction retourne un type
particulier qui impl√©mente le trait <code>Iterator</code> sans avoir √† √©crire un tr√®s long
type.</p>
<!--
However, you can only use `impl Trait` if you‚Äôre returning a single type. For
example, this code that returns either a `NewsArticle` or a `Tweet` with the
return type specified as `impl Summary` wouldn‚Äôt work:
-->
<p>Cependant, vous pouvez seulement utiliser <code>impl Trait</code> si vous retournez un
seul type possible. Par exemple, ce code va retourner soit un
<code>ArticleDePresse</code>, soit un <code>Tweet</code>, alors que le type de retour avec
<code>impl Resumable</code> ne va pas fonctionner¬†:</p>
<!--
```rust,ignore,does_not_compile
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}¬†: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable(estArticle: bool) -&gt; impl Resumable {
    if estArticle {
        ArticleDePresse {
            titre: String::from(&quot;Les Penguins ont remport√© la Coupe Stanley¬†!&quot;),
            lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
            auteur: String::from(&quot;Iceburgh&quot;),
            contenu: String::from(&quot;Les Penguins de Pittsburgh sont une nouvelle fois la \
            meilleure √©quipe de hockey de la LNH.&quot;),
        }
    } else {
        Tweet {
            nom_utilisateur: String::from(&quot;jean&quot;),
            contenu: String::from(&quot;Bien s√ªr, les amis, comme vous le savez probablement d√©j√†&quot;),
            reponse: false,
            retweet: false,
        }
    }
}
</code></pre>
<!--
Returning either a `NewsArticle` or a `Tweet` isn‚Äôt allowed due to restrictions
around how the `impl Trait` syntax is implemented in the compiler. We‚Äôll cover
how to write a function with this behavior in the [‚ÄúUsing Trait Objects That
Allow for Values of Different
Types‚Äù][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section of Chapter 17.
-->
<p>Retourner soit un <code>ArticleDePresse</code>, soit un <code>Tweet</code> n'est pas autoris√© √† cause
des restrictions sur la fa√ßon dont la syntaxe <code>impl Trait</code> est impl√©ment√©e dans
le compilateur. Nous verrons comment √©crire une fonction avec ce comportement
dans une section du
<a href="ch17-02-trait-objects.html">chapitre 17</a><!--
ignore -->.</p>
<!--
### Fixing the `largest` Function with Trait Bounds
-->
<h3 id="corriger-la-fonction-le_plus_grand-avec-les-traits-li√©s"><a class="header" href="#corriger-la-fonction-le_plus_grand-avec-les-traits-li√©s">Corriger la fonction <code>le_plus_grand</code> avec les traits li√©s</a></h3>
<!--
Now that you know how to specify the behavior you want to use using the generic
type parameter‚Äôs bounds, let‚Äôs return to Listing 10-5 to fix the definition of
the `largest` function that uses a generic type parameter! Last time we tried
to run that code, we received this error:
-->
<p>Maintenant que vous savez comment renseigner le comportement que vous souhaitez
utiliser en utilisant les traits li√©s des param√®tres de type g√©n√©riques,
retournons √† l'encart 10-5 pour corriger la d√©finition de la fonction
<code>le_plus_grand</code> qui utilise un param√®tre de type g√©n√©rique ! La derni√®re fois
que nous avons essay√© de lancer ce code, nous avions l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                   ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
In the body of `largest` we wanted to compare two values of type `T` using the
greater than (`>`) operator. Because that operator is defined as a default
method on the standard library trait `std::cmp::PartialOrd`, we need to specify
`PartialOrd` in the trait bounds for `T` so the `largest` function can work on
slices of any type that we can compare. We don‚Äôt need to bring `PartialOrd`
into scope because it‚Äôs in the prelude. Change the signature of `largest` to
look like this:
-->
<p>Dans le corps de <code>le_plus_grand</code>, nous voulions comparer les deux valeurs du
type <code>T</code> en utilisant l'op√©rateur <em>plus grand que</em> (<code>&gt;</code>). Comme cet op√©rateur
est d√©fini comme une m√©thode par d√©faut dans le trait de la biblioth√®que
standard <code>std::cmp::PartialOrd</code>, nous devons pr√©ciser <code>PartialOrd</code> dans les
traits li√©s pour <code>T</code> afin que la fonction <code>le_plus_grand</code> puisse fonctionner
sur les slices de n'importe quel type que nous pouvons comparer. Nous n'avons
pas besoin d'importer <code>PartialOrd</code> dans la port√©e car il est import√© dans
l'√©tape pr√©liminaire. Changez la signature de <code>le_plus_grand</code> par quelque chose
comme ceci¬†:</p>
<!--
```rust,ignore
fn largest<T: PartialOrd>(list: &[T]) -> T {
#     let mut largest = list[0];
# 
#     for &item in list {
#         if item > largest {
#             largest = item;
#         }
#     }
# 
#     largest
# }
# 
# fn main() {
#     let number_list = vec![34, 50, 25, 100, 65];
# 
#     let result = largest(&number_list);
#     println!("The largest number is {}", result);
# 
#     let char_list = vec!['y', 'm', 'a', 'q'];
# 
#     let result = largest(&char_list);
#     println!("The largest char is {}", result);
# }
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T: PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
<span class="boring">    let mut le_plus_grand = liste[0];
</span><span class="boring">
</span><span class="boring">    for &amp;element in liste {
</span><span class="boring">        if element &gt; le_plus_grand {
</span><span class="boring">            le_plus_grand = element;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    le_plus_grand
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let liste_de_nombres = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_nombres);
</span><span class="boring">    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
</span><span class="boring">
</span><span class="boring">    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_caracteres);
</span><span class="boring">    println!(&quot;Le plus grand caract√®re est {}&quot;, resultat);
</span><span class="boring">}
</span></code></pre>
<!--
This time when we compile the code, we get a different set of errors:
-->
<p>Cette fois, lorsque nous allons compiler le code, nous aurons un ensemble
d'erreurs diff√©rent¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- > src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 -- > src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- &gt; src/main.rs:2:23
  |
2 |     let mut le_plus_grand = liste[0];
  |                             ^^^^^^^^
  |                             |
  |                             cannot move out of here
  |                             move occurs because `liste[_]` has type `T`, which does not implement the `Copy` trait
  |                             help: consider borrowing here: `&amp;liste[0]`

error[E0507]: cannot move out of a shared reference
 -- &gt; src/main.rs:4:18
  |
4 |     for &amp;element in liste {
  |         --------    ^^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `element` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `element`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</code></pre>
<!--
The key line in this error is `cannot move out of type [T], a non-copy slice`.
With our non-generic versions of the `largest` function, we were only trying to
find the largest `i32` or `char`. As discussed in the [‚ÄúStack-Only Data:
Copy‚Äù][stack-only-data-copy]<!-- ignore -- > section in Chapter 4, types like
`i32` and `char` that have a known size can be stored on the stack, so they
implement the `Copy` trait. But when we made the `largest` function generic,
it became possible for the `list` parameter to have types in it that don‚Äôt
implement the `Copy` trait. Consequently, we wouldn‚Äôt be able to move the
value out of `list[0]` and into the `largest` variable, resulting in this
error.
-->
<p>L'√©lement-cl√© dans ces erreurs est <code>cannot move out of type [T], a non-copy slice</code> (<em>impossible de d√©placer une valeur hors du type <code>[T]</code>, slice non
<code>Copy</code></em>). Avec notre version non g√©n√©rique de la fonction <code>le_plus_grand</code>, nous
avions essay√© de trouver le plus grand <code>i32</code> ou <code>char</code>. Comme nous l'avons vu
dans la section <a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">‚ÄúDonn√©es uniquement sur la pile¬†: la
copie‚Äù</a><!-- ignore --> du chapitre 4, les types comme
<code>i32</code> et <code>char</code> ont une taille connue et peuvent √™tre stock√©s sur la pile, donc
ils impl√©mentent le trait <code>Copy</code>. Mais quand nous avons rendu g√©n√©rique la
fonction <code>le_plus_grand</code>, il est devenu possible que le param√®tre <code>liste</code>
contienne des types qui n'impl√©mentent pas le trait <code>Copy</code>. Par cons√©quent,
nous ne pouvons pas forc√©ment d√©placer la valeur de <code>list[0]</code> dans notre
variable <code>le_plus_grand</code>, ce qui engendre cette erreur.</p>
<!--
To call this code with only those types that implement the `Copy` trait, we can
add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of
a generic `largest` function that will compile as long as the types of the
values in the slice that we pass into the function implement the `PartialOrd`
*and* `Copy` traits, like `i32` and `char` do.
-->
<p>Pour pouvoir appeler ce code avec seulement les types qui impl√©mentent le trait
<code>Copy</code>, nous pouvons ajouter <code>Copy</code> aux traits li√©s de <code>T</code>¬†! L'encart 10-15 nous
montre le code complet d'une fonction g√©n√©rique <code>le_plus_grand</code> qui va se
compiler tant que le type des valeurs dans la slice que nous passons dans la
fonction impl√©mente les traits <code>PartialOrd</code> <em>et</em> <code>Copy</code>, comme le font <code>i32</code> et
<code>char</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand&lt;T: PartialOrd + Copy&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caract√®re est {}&quot;, resultat);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-15: A working definition of the `largest`
function that works on any generic type that implements the `PartialOrd` and
`Copy` traits</span>
-->
<p><span class="caption">Encart 10-15¬†: une d√©finition de la fonction
<code>le_plus_grand</code> qui fonctionne et s'applique sur n'importe quel type g√©n√©rique
qui impl√©mente les traits <code>PartialOrd</code> et <code>Copy</code></span></p>
<!--
If we don‚Äôt want to restrict the `largest` function to the types that implement
the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead
of `Copy`. Then we could clone each value in the slice when we want the
`largest` function to have ownership. Using the `clone` function means we‚Äôre
potentially making more heap allocations in the case of types that own heap
data like `String`, and heap allocations can be slow if we‚Äôre working with
large amounts of data.
-->
<p>Si nous ne souhaitons pas restreindre la fonction <code>le_plus_grand</code> aux types qui
impl√©mentent le trait <code>Copy</code>, nous pouvons pr√©ciser que <code>T</code> a le trait li√©
<code>Clone</code> plut√¥t que <code>Copy</code>. Ainsi, nous pouvons cloner chaque valeur dans la
slice lorsque nous souhaitons que la fonction <code>le_plus_grand</code> en prenne
possession. L'utilisation de la fonction <code>clone</code> signifie que nous allons
potentiellement allouer plus d'espace sur le tas dans le cas des types qui
poss√®dent des donn√©es sur le tas, comme <code>String</code>, et les allocations sur le tas
peuvent √™tre lentes si nous travaillons avec des grandes quantit√©s de donn√©es.</p>
<!--
Another way we could implement `largest` is for the function to return a
reference to a `T` value in the slice. If we change the return type to `&T`
instead of `T`, thereby changing the body of the function to return a
reference, we wouldn‚Äôt need the `Clone` or `Copy` trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
If you get stuck with errors having to do with lifetimes, keep reading: the
‚ÄúValidating References with Lifetimes‚Äù section coming up will explain, but
lifetimes aren‚Äôt required to solve these challenges.
-->
<p>Une autre fa√ßon d'impl√©menter <code>le_plus_grand</code> est de faire en sorte que la
fonction retourne une r√©f√©rence √† une valeur <code>T</code> de la slice. Si nous changeons
le type de retour en <code>&amp;T</code> √† la place de <code>T</code> et que nous adaptons le corps de la
fonction afin de retourner une r√©f√©rence, nous n'aurions alors plus besoin des
traits li√©s <code>Clone</code> ou <code>Copy</code> et nous pourrions ainsi √©viter l'allocation sur
le tas. Essayez d'impl√©menter ces solutions alternatives par vous-m√™me¬†!
Si vous bloquez sur des erreurs √† propos des dur√©es de vie <em>(lifetimes)</em>, lisez
la suite¬†: la section suivante, ‚ÄúLa conformit√© des r√©f√©rences avec les dur√©es
de vies‚Äù vous expliquera cela, mais les dur√©es de vie ne sont pas n√©cessaires
pour r√©soudre ces exercices.</p>
<!--
### Using Trait Bounds to Conditionally Implement Methods
-->
<h3 id="utiliser-les-traits-li√©s-pour-conditionner-limpl√©mentation-des-m√©thodes"><a class="header" href="#utiliser-les-traits-li√©s-pour-conditionner-limpl√©mentation-des-m√©thodes">Utiliser les traits li√©s pour conditionner l'impl√©mentation des m√©thodes</a></h3>
<!--
By using a trait bound with an `impl` block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type `Pair<T>` in Listing 10-16 always implements the
`new` function to return a new instance of `Pair<T>` (recall from the
[‚ÄùDefining Methods‚Äù][methods]<!-- ignore -- > section of Chapter 5 that `Self`
is a type alias for the type of the `impl` block, which in this case is
`Pair<T>`). But in the next `impl` block, `Pair<T>` only implements the
`cmp_display` method if its inner type `T` implements the `PartialOrd` trait
that enables comparison *and* the `Display` trait that enables printing.
-->
<p>En utilisant un trait li√© avec un bloc <code>impl</code> qui utilise les param√®tres de type
g√©n√©riques, nous pouvons impl√©menter des m√©thodes en fonction des types qui
impl√©mentent des traits particuliers. Par exemple, le type <code>Paire&lt;T&gt;</code> de
l'encart 10-16 impl√©mente toujours la fonction <code>new</code> pour retourner une
nouvelle instance de <code>Paire&lt;T&gt;</code> (pour rappel dans la section
<a href="ch05-03-method-syntax.html#d%C3%A9finir-des-m%C3%A9thodes">‚ÄùD√©finir des m√©thodes‚Äù</a><!-- ignore --> du chapitre 5 que <code>Self</code> est
un alias de type pour le type du bloc <code>impl</code>, qui est dans ce cas le
<code>Paire&lt;T&gt;</code>). Mais dans le bloc <code>impl</code> suivant, <code>Paire&lt;T&gt;</code> impl√©mente la
m√©thode <code>afficher_comparaison</code> uniquement si son type interne <code>T</code> impl√©mente le
trait <code>PartialOrd</code> qui active la comparaison <em>et</em> le trait <code>Display</code> qui permet
l'affichage.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Paire&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Paire&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Paire&lt;T&gt; {
    fn afficher_comparaison(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Le plus grand √©l√©ment est x = {}&quot;, self.x);
        } else {
            println!(&quot;Le plus grand √©l√©ment est y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span>
-->
<p><span class="caption">Encart 10-16¬†: impl√©mentation de m√©thodes sur un type
g√©n√©rique en fonction des traits li√©s</span></p>
<!--
We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called *blanket implementations* and are extensively used in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:
-->
<p>Nous pouvons √©galement impl√©menter un trait sur tout type qui impl√©mente un
autre trait en particulier. L'impl√©mentation d'un trait sur n'importe quel type
qui a un trait li√© est appel√©e <em>impl√©mentation g√©n√©rale</em> et est largement
utilis√©e dans la biblioth√®que standard Rust. Par exemple, la biblioth√®que
standard impl√©mente le trait <code>ToString</code> sur tous les types qui impl√©mentent le
trait <code>Display</code>. Le bloc <code>impl</code> de la biblioth√®que standard ressemble au code
suivant¬†:</p>
<!--
```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // -- partie masqu√©e ici --
}
</code></pre>
<!--
Because the standard library has this blanket implementation, we can call the
`to_string` method defined by the `ToString` trait on any type that implements
the `Display` trait. For example, we can turn integers into their corresponding
`String` values like this because integers implement `Display`:
-->
<p>Comme la biblioth√®que standard a cette impl√©mentation g√©n√©rale, nous pouvons
appeler la m√©thode <code>to_string</code> d√©finie par le trait <code>ToString</code> sur n'importe
quel type qui impl√©mente le trait <code>Display</code>. Par exemple, nous pouvons
transformer les nombres entiers en leur √©quivalent dans une <code>String</code> comme
ci-dessous car les entiers impl√©mentent <code>Display</code>¬†:</p>
<!--
```rust
let s = 3.to_string();
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
Blanket implementations appear in the documentation for the trait in the
‚ÄúImplementors‚Äù section.
-->
<p>Les impl√©mentations g√©n√©rales sont d√©crites dans la documentation du trait, dans
la section ‚ÄúImplementors‚Äù.</p>
<!--
Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didn‚Äôt define the method. But Rust
moves these errors to compile time so we‚Äôre forced to fix the problems before
our code is even able to run. Additionally, we don‚Äôt have to write code that
checks for behavior at runtime because we‚Äôve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.
-->
<p>Les traits et les traits li√©s nous permettent d'√©crire du code qui utilise des
param√®tres de type g√©n√©riques pour r√©duire la duplication de code, mais aussi
pour indiquer au compilateur que nous voulons que le type g√©n√©rique ait un
comportement particulier. Le compilateur peut ensuite utiliser les informations
li√©es aux traits pour v√©rifier que tous les types concrets utilis√©s dans notre
code suivent le comportement souhait√©. Dans les langages typ√©s dynamiquement,
nous aurions une erreur √† l'ex√©cution si nous appelions une m√©thode sur un type
qui n'impl√©menterait pas la m√©thode. Mais Rust d√©cale l'apparition de ces erreurs
au moment de la compilation afin de nous forcer √† r√©soudre les probl√®mes avant
m√™me que notre code soit capable de s'ex√©cuter. De plus, nous n'avons pas besoin
d'√©crire un code qui v√©rifie le comportement lors de l'ex√©cution car nous
l'avons d√©j√† v√©rifi√© au moment de la compilation. Cela permet d'am√©liorer les
performances sans avoir √† sacrifier la flexibilit√© des types g√©n√©riques.</p>
<!--
Another kind of generic that we‚Äôve already been using is called *lifetimes*.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Let‚Äôs look at how
lifetimes do that.
-->
<p>Une autre sorte de g√©n√©rique que nous avons d√©j√† utilis√©e est la <em>dur√©e de
vie</em>. Plut√¥t que de s'assurer qu'un type a le comportement que nous voulons, la
dur√©e de vie s'assure que les r√©f√©rences sont en vigueur aussi longtemps que
nous avons besoin qu'elles le soient. Nous allons voir √† la page suivante
comment la dur√©e de vie fait cela.</p>
<!-- markdownlint-disable -->
<!--
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[methods]: ch05-03-method-syntax.html#defining-methods
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## Validating References with Lifetimes
-->
<h2 id="la-conformit√©-des-r√©f√©rences-avec-les-dur√©es-de-vies"><a class="header" href="#la-conformit√©-des-r√©f√©rences-avec-les-dur√©es-de-vies">La conformit√© des r√©f√©rences avec les dur√©es de vies</a></h2>
<!--
One detail we didn‚Äôt discuss in the [‚ÄúReferences and
Borrowing‚Äù][references-and-borrowing]<!-- ignore -- > section in Chapter 4 is
that every reference in Rust has a *lifetime*, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and
inferred, just like most of the time, types are inferred. We must annotate
types when multiple types are possible. In a similar way, we must annotate
lifetimes when the lifetimes of references could be related in a few different
ways. Rust requires us to annotate the relationships using generic lifetime
parameters to ensure the actual references used at runtime will definitely be
valid.
-->
<p>Il reste un d√©tail que nous n'avons pas abord√© dans la section <a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-et-lemprunt">‚ÄúLes r√©f√©rences
et l'emprunt‚Äù</a><!-- ignore --> du chapitre 4, c'est que
toutes les r√©f√©rences ont une <em>dur√©e de vie</em> dans Rust, qui est la port√©e pour
laquelle cette r√©f√©rence est en vigueur. La plupart du temps, les dur√©es de
vies sont implicites et sont d√©duites automatiquement, comme pour la plupart du
temps les types sont d√©duits. Nous devons renseigner le type lorsque plusieurs
types sont possibles. De la m√™me mani√®re, nous devons renseigner les dur√©es de
vie lorsque les dur√©es de vies des r√©f√©rences peuvent √™tre d√©duites de
diff√©rentes mani√®res. Rust n√©cessite que nous renseignons ces relations en
utilisant des param√®tres de dur√©e de vie g√©n√©riques pour s'assurer que les
r√©f√©rences utilis√©es au moment de la compilation restent bien en vigueur.</p>
<!--
Annotating lifetimes is not even a concept most other programming languages
have, so this is going to feel unfamiliar. Although we won‚Äôt cover lifetimes in
their entirety in this chapter, we‚Äôll discuss common ways you might encounter
lifetime syntax so you can get introduced to the concept.
-->
<p>L'annotation de la dur√©e de vie n'est pas un concept pr√©sent dans la pluspart
des langages de programmation, donc cela n'est pas tr√®s familier. Bien que nous
ne puissions couvrir l'int√©gralit√© de la dur√©e de vie dans ce chapitre, nous
allons voir les cas les plus courants o√π vous allez rencontrer la syntaxe de la
dur√©e de vie, pour vous introduire ces concept.</p>
<!--
### Preventing Dangling References with Lifetimes
-->
<h3 id="eviter-les-r√©f√©rences-pendouillantes-avec-les-dur√©es-de-vie"><a class="header" href="#eviter-les-r√©f√©rences-pendouillantes-avec-les-dur√©es-de-vie">Eviter les r√©f√©rences pendouillantes avec les dur√©es de vie</a></h3>
<!--
The main aim of lifetimes is to prevent dangling references, which cause a
program to reference data other than the data it‚Äôs intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.
-->
<p>L'objectif principal des dur√©es de vies est d'√©viter les r√©f√©rences
pendouillantes qui font qu'un programme pointe des donn√©es autres que celles sur
lesquelles il √©tait cens√© pointer. Soit le programme de l'encart 10-17, qui
a une port√©e externe et une port√©e interne.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-17¬†: tentative d'utiliser une r√©f√©rence vers
une valeur qui est sortie de la port√©e</span></p>
<!--
> Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
> without giving them an initial value, so the variable name exists in the
> outer scope. At first glance, this might appear to be in conflict with Rust‚Äôs
> having no null values. However, if we try to use a variable before giving it
> a value, we‚Äôll get a compile-time error, which shows that Rust indeed does
> not allow null values.
-->
<blockquote>
<p>Remarque¬†: Les exemples dans les encarts 10-17, 10-18 et 10-24 d√©clarent des
variables sans initialiser leur valeur, donc les noms de ces variables
existent dans la port√©e externe. A premi√®re vue, cela semble √™tre en conflit
avec le fonctionnement de Rust qui n'utilise pas les valeurs nulles.
Cependant, si nous essayons d'utiliser une variable avant de lui donner une
valeur, nous aurons une erreur au moment de la compilation, qui confirme que
Rust ne fonctionne pas avec des valeurs nulles.</p>
</blockquote>
<!--
The outer scope declares a variable named `r` with no initial value, and the
inner scope declares a variable named `x` with the initial value of 5. Inside
the inner scope, we attempt to set the value of `r` as a reference to `x`. Then
the inner scope ends, and we attempt to print the value in `r`. This code won‚Äôt
compile because the value `r` is referring to has gone out of scope before we
try to use it. Here is the error message:
-->
<p>La port√©e externe d√©clare une variable <code>r</code> sans valeur initiale, et la port√©e
interne d√©clare une variable <code>x</code> avec la valeur initiale √† <code>5</code>. Au sein de la
port√©e interne, nous essayons d'assigner la valeur de <code>r</code> comme √©tant une
r√©f√©rence √† <code>x</code>. Puis la port√©e interne se ferme, et nous essayons d'afficher la
valeur dans <code>r</code>. Ce code ne va pas se compiler car la valeur <code>r</code> se r√©f√®re √†
quelque chose qui est sorti de la port√©e avant que nous essayons de l'utiliser.
Voici le message d'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  -- > src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The variable `x` doesn‚Äôt ‚Äúlive long enough.‚Äù The reason is that `x` will be out
of scope when the inner scope ends on line 7. But `r` is still valid for the
outer scope; because its scope is larger, we say that it ‚Äúlives longer.‚Äù If
Rust allowed this code to work, `r` would be referencing memory that was
deallocated when `x` went out of scope, and anything we tried to do with `r`
wouldn‚Äôt work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.
-->
<p>La variable <code>x</code> n'existe plus (‚Äúdoes not live long enough‚Äù). La raison √† cela
est que <code>x</code> est sortie de la port√©e lorsque la port√©e interne s'est ferm√©e √† la
ligne 7. Mais <code>r</code> reste en vigueur dans la port√©e externe¬†; car sa port√©e est
plus grande, on dit qu'il ‚Äúvit plus longtemps‚Äù. Si Rust avait permis √† ce code de
s'ex√©cuter, <code>r</code> pointerait sur de la m√©moire d√©sallou√©e d√®s que <code>x</code> est sortie
de la port√©e, ainsi tout ce que nous pourrions faire avec <code>r</code> ne fonctionnerait
pas correctement. Mais comment Rust d√©tecte que ce code est invalide¬†? Il
utilise le v√©rificateur d'emprunt.</p>
<!--
### The Borrow Checker
-->
<h3 id="le-v√©rificateur-demprunt"><a class="header" href="#le-v√©rificateur-demprunt">Le v√©rificateur d'emprunt</a></h3>
<!--
The Rust compiler has a *borrow checker* that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.
-->
<p>Le compilateur de Rust embarque un <em>v√©rificateur d'emprunt</em> (borrow checker) qui
compare les port√©es pour d√©terminer si les emprunts sont valides. L'encart 10-18
montre le m√™me code que l'encart 10-17, mais avec des commentaires qui montrent
les dur√©es de vies des variables.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-18: Annotations of the lifetimes of `r` and
`x`, named `'a` and `'b`, respectively</span>
-->
<p><span class="caption">Encart 10-18¬†: commentaires pour montrer les dur√©es de vie
de <code>r</code> et <code>x</code>, qui s'appellent respectivement <code>'a</code> et <code>'b</code></span></p>
<!--
Here, we‚Äôve annotated the lifetime of `r` with `'a` and the lifetime of `x`
with `'b`. As you can see, the inner `'b` block is much smaller than the outer
`'a` lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory
with a lifetime of `'b`. The program is rejected because `'b` is shorter than
`'a`: the subject of the reference doesn‚Äôt live as long as the reference.
-->
<p>Ici, nous avons montr√© la dur√©e de vie de <code>r</code> avec <code>'a</code> et la dur√©e de vie de
<code>x</code> avec <code>'b</code>. Comme vous pouvez le constater, le bloc interne <code>'b</code> est bien
plus petit que le bloc externe <code>'a</code>. Au moment de la compilation, Rust compare
les tailles des deux dur√©es de vies et constate que <code>r</code> a la dur√©e de vie <code>'a</code>
mais fait r√©f√©rence √† de la m√©moire qui a une dur√©e de vie de <code>'b</code>. Ce programme
est refus√© car <code>'b</code> est plus court que <code>'a</code>¬†: l'√©l√©ment point√© par la r√©f√©rence
n'existe pas aussi longtemps que la r√©f√©rence.</p>
<!--
Listing 10-19 fixes the code so it doesn‚Äôt have a dangling reference and
compiles without any errors.
-->
<p>L'encart 10-19 r√©sout le code afin qu'il n'ait plus de r√©f√©rence pendouillante et
qu'il se compile sans erreur.</p>
<!--
```rust
# fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span>
-->
<p><span class="caption">Encart 10-19¬†: la r√©f√©rence est valide puisque la donn√©e a
une dur√©e de vie plus longue que la r√©f√©rence</span></p>
<!--
Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. This
means `r` can reference `x` because Rust knows that the reference in `r` will
always be valid while `x` is valid.
-->
<p>Ici, <code>x</code> a la dur√©e de vie <code>'b</code>, qui est plus grande dans ce cas que <code>'a</code>. Cela
signifie que <code>r</code> peut r√©f√©rencer <code>x</code> car Rust sait que la r√©f√©rence pr√©sente
dans <code>r</code> sera toujours valide du moment que <code>x</code> est en vigueur.</p>
<!--
Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let‚Äôs explore generic
lifetimes of parameters and return values in the context of functions.
-->
<p>Maintenant que vous savez o√π se situent les dur√©es de vie des r√©f√©rences et
comment Rust analyse les dur√©es de vies pour s'assurer que les r√©f√©rences soient
toujours en vigueur, d√©couvrons les dur√©es de vies g√©n√©riques des param√®tres et
des valeurs de retour dans le cas des fonctions.</p>
<!--
### Generic Lifetimes in Functions
-->
<h3 id="les-dur√©es-de-vies-g√©n√©riques-dans-les-fonctions"><a class="header" href="#les-dur√©es-de-vies-g√©n√©riques-dans-les-fonctions">Les dur√©es de vies g√©n√©riques dans les fonctions</a></h3>
<!--
Let‚Äôs write a function that returns the longer of two string slices. This
function will take two string slices and return a string slice. After we‚Äôve
implemented the `longest` function, the code in Listing 10-20 should print `The
longest string is abcd`.
-->
<p>Ecrivons une fonction qui retourne la plus longue des slice d'une cha√Æne de
caract√®res. Cette fonction va prendre en argument deux slices de cha√Æne de
caract√®res et retourner une slice d'une cha√Æne de caract√®res. Apr√®s avoir
impl√©ment√© la fonction <code>la_plus_longue</code>, le code de l'encart 10-20 devrait
afficher <code>La plus grande cha√Æne est abcd</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let resultat = la_plus_longue(string1.as_str(), string2);
    println!(&quot;La plus grande cha√Æne est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-20: A `main` function that calls the `longest`
function to find the longer of two string slices</span>
-->
<p><span class="caption">Encart 10-20¬†: une fonction <code>main</code> qui appelle la
fonction <code>la_plus_longue</code> pour trouver la plus grande des deux slices de cha√Æne
de caract√®res
</span></p>
<!--
Note that we want the function to take string slices, which are references,
because we don‚Äôt want the `longest` function to take ownership of its
parameters. Refer to the [‚ÄúString Slices as
Parameters‚Äù][string-slices-as-parameters]<!-- ignore -- > section in Chapter 4
for more discussion about why the parameters we use in Listing 10-20 are the
ones we want.
-->
<p>Remarquez que nous souhaitons que la fonction prenne deux slices de cha√Ænes de
caract√®res, qui sont des r√©f√©rences, car nous ne voulons pas que la fonction
<code>la_plus_longue</code> prenne possession de ses param√®tres. Rendez-vous √† la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res-en-param%C3%A8tres">‚ÄúLes slices de cha√Ænes de caract√®res en
param√®tres‚Äù</a><!-- ignore --> du chapitre 4 pour
savoir pourquoi nous utilisons ce type de param√®tres dans l'encart 10-20.</p>
<!--
If we try to implement the `longest` function as shown in Listing 10-21, it
won‚Äôt compile.
-->
<p>Si nous essayons d'impl√©menter la fonction <code>la_plus_longue</code> comme dans l'encart
10-21, cela ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande cha√Æne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-21: An implementation of the `longest`
function that returns the longer of two string slices but does not yet
compile</span>
-->
<p><span class="caption">Encart 10-21¬†: une impl√©mentation de la fonction
<code>la_plus_longue</code> qui retourne la plus longue des deux slices de cha√Ænes de
caract√®res, mais ne se compile pas encore</span></p>
<!--
Instead, we get the following error that talks about lifetimes:
-->
<p>A la place, nous obtenons l'erreur suivante qui nous parle de dur√©es de vie¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 -- > src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                      ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |                  ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can‚Äôt tell whether the reference being returned refers to
`x` or `y`. Actually, we don‚Äôt know either, because the `if` block in the body
of this function returns a reference to `x` and the `else` block returns a
reference to `y`!
-->
<p>La partie ‚Äúhelp‚Äù nous explique que le type de retour a besoin d'un param√®tre de
dur√©e de vie g√©n√©rique car Rust ne sait pas si la r√©f√©rence retourn√©e est li√©e √†
<code>x</code> ou √† <code>y</code>. Pour le moment, nous ne le savons pas nous non plus, car le bloc
<code>if</code> dans le corps de cette fonction retourne une r√©f√©rence √† <code>x</code> et le bloc
<code>else</code> retourne une r√©f√©rence √† <code>y</code>¬†!</p>
<!--
When we‚Äôre defining this function, we don‚Äôt know the concrete values that will
be passed into this function, so we don‚Äôt know whether the `if` case or the
`else` case will execute. We also don‚Äôt know the concrete lifetimes of the
references that will be passed in, so we can‚Äôt look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker can‚Äôt determine this either, because it
doesn‚Äôt know how the lifetimes of `x` and `y` relate to the lifetime of the
return value. To fix this error, we‚Äôll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.
-->
<p>Lorsque nous d√©finissons cette fonction, nous ne connaissons pas les valeurs
concr√®tes qui vont passer dans cette fonction, donc nous ne savons pas si nous
allons ex√©cuter le cas du <code>if</code> ou du <code>else</code>. Nous ne connaissons pas non plus les
dur√©es de vie des r√©f√©rences qui vont passer dans la fonction, donc nous ne
pouvons pas v√©rifier les port√©es comme nous l'avons fait dans les encarts 10-18
et 10-19 pour d√©terminer si la r√©f√©rence que nous allons retourner sera
toujours en vigueur. Le v√©rificateur d'emprunt ne va pas pouvoir non plus
d√©terminer cela, car il ne sait comment les dur√©es de vie de <code>x</code> et de <code>y</code> sont
reli√©es √† la dur√©e de vie de la valeur de retour. Pour r√©soudre cette erreur,
nous allons ajouter des param√®tres de dur√©e de vie g√©n√©riques qui d√©finissent
la relation entre les r√©f√©rences, afin que le v√©rificateur d'emprunt puisse
faire cette analyse.</p>
<!--
### Lifetime Annotation Syntax
-->
<h3 id="la-syntaxe-pour-annoter-les-dur√©es-de-vies"><a class="header" href="#la-syntaxe-pour-annoter-les-dur√©es-de-vies">La syntaxe pour annoter les dur√©es de vies</a></h3>
<!--
Lifetime annotations don‚Äôt change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.
-->
<p>L'annotation des dur√©es de vie ne change pas la longueur de leur dur√©e de vie.
De la m√™me fa√ßon qu'une fonction accepte n'importe quel type lorsque la
signature utilise un param√®tre de type g√©n√©rique, les fonctions peuvent
accepter des r√©f√©rences avec n'importe quelle dur√©e de vie en pr√©cisant un
param√®tre de dur√©e de vie g√©n√©rique. L'annotation des dur√©es de vie d√©crit la
relation des dur√©es de vies de plusieurs r√©f√©rences entre elles sans influencer
les dur√©es de vie.</p>
<!--
Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (`'`) and are usually all lowercase and
very short, like generic types. Most people use the name `'a`. We place
lifetime parameter annotations after the `&` of a reference, using a space to
separate the annotation from the reference‚Äôs type.
-->
<p>L'annotation des dur√©es de vies a une syntaxe un peu inhabituelle¬†: le nom des
param√®tres de dur√©es de vies doit commencer par une apostrophe (<code>'</code>) et est
habituellement en minuscule et tr√®s court, comme les types g√©n√©riques. La
plupart des personnes utilisent le nom <code>'a</code>. Nous pla√ßons le param√®tre de type
apr√®s le <code>&amp;</code> d'une r√©f√©rence, en utilisant un espace pour s√©parer l'annotation
du type de la r√©f√©rence.</p>
<!--
Here are some examples: a reference to an `i32` without a lifetime parameter, a
reference to an `i32` that has a lifetime parameter named `'a`, and a mutable
reference to an `i32` that also has the lifetime `'a`.
-->
<p>Voici quelques exemples¬†: une r√©f√©rence √† un <code>i32</code> sans param√®tre de dur√©e de
vie, une r√©f√©rence √† un <code>i32</code> qui a un param√®tre de dur√©e de vie <code>'a</code>, et une
r√©f√©rence mutable √† un <code>i32</code> qui a aussi la dur√©e de vie <code>'a</code>.</p>
<!--
```rust,ignore
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```
-->
<pre><code class="language-rust ignore">&amp;i32        // une r√©f√©rence
&amp;'a i32     // une r√©f√©rence avec une dur√©e de vie explicite
&amp;'a mut i32 // une r√©f√©rence mutable avec une dur√©e de vie explicite
</code></pre>
<!--
One lifetime annotation by itself doesn‚Äôt have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, let‚Äôs say we have a function with
the parameter `first` that is a reference to an `i32` with lifetime `'a`. The
function also has another parameter named `second` that is another reference to
an `i32` that also has the lifetime `'a`. The lifetime annotations indicate
that the references `first` and `second` must both live as long as that generic
lifetime.
-->
<p>Une annotation de dur√©e de vie toute seule n'a pas vraiment de sens, car les
annotations sont faites pour indiquer √† Rust quels param√®tres de dur√©e de vie
g√©n√©riques de plusieurs r√©f√©rences sont li√©s aux autres. Par exemple, disons que
nous avons une fonction avec le param√®tre <code>premier</code> qui est une r√©f√©rence √† un
<code>i32</code> avec la dur√©e de vie <code>'a</code>. La fonction a aussi un autre param√®tre <code>second</code>
qui est une autre r√©f√©rence √† un <code>i32</code> qui a aussi la dur√©e de vie <code>'a</code>. Les
annotations de dur√©e de vie indiquent que les r√©f√©rences <code>premier</code> et <code>second</code>
doivent tous les deux exister aussi longtemps que la dur√©e de vie g√©n√©rique.</p>
<!--
### Lifetime Annotations in Function Signatures
-->
<h3 id="les-annotations-de-dur√©e-de-vie-dans-les-signatures-des-fonctions"><a class="header" href="#les-annotations-de-dur√©e-de-vie-dans-les-signatures-des-fonctions">Les annotations de dur√©e de vie dans les signatures des fonctions</a></h3>
<!--
Now let‚Äôs examine lifetime annotations in the context of the `longest`
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. The constraint we want to express in this signature is that the lifetimes
of both of the parameters and the lifetime of the returned reference are
related such that the returned reference will be valid as long as both the
parameters are. We‚Äôll name the lifetime `'a` and then add it to each reference,
as shown in Listing 10-22.
-->
<p>Maintenant, examinons les annotations de dur√©e de vie dans contexte de la
fonction <code>la_plus_longue</code>. Comme avec les param√®tres de type g√©n√©riques, nous
devons d√©clarer les param√®tres de dur√©e de vie g√©n√©riques dans des chevrons
entre le nom de la fonction et la liste des param√®tres. Nous souhaitons
contraindre les dur√©es de vie des deux param√®tres et la dur√©e de vie de la
r√©f√©rence retourn√©e de telle mani√®re que la valeur retourn√©e restera en vigueur
tant que les deux param√®tres le seront aussi. Nous allons appeler la dur√©e de
vie <code>'a</code> et ensuite l'ajouter √† chaque r√©f√©rence, comme nous le faisons dans
l'encart 10-22.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande cha√Æne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-22: The `longest` function definition
specifying that all the references in the signature must have the same lifetime
`'a`</span>
-->
<p><span class="caption">Encart 10-22¬†: d√©finition de la fonction <code>la_plus_longue</code>
qui indique que toutes les r√©f√©rences pr√©sentes dans la signature doivent avoir
la m√™me dur√©e de vie <code>'a</code></span></p>
<!--
This code should compile and produce the result we want when we use it with the
`main` function in Listing 10-20.
-->
<p>Le code devrait se compiler et devrait produire le r√©sultat que nous souhaitions
lorsque nous l'utilisions dans la fonction <code>main</code> de l'encart 10-20.</p>
<!--
The function signature now tells Rust that for some lifetime `'a`, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime `'a`. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime `'a`.
In practice, it means that the lifetime of the reference returned by the
`longest` function is the same as the smaller of the lifetimes of the
references passed in. These relationships are what we want Rust to use when
analyzing this code.
-->
<p>La signature de la fonction indique maintenant √† Rust que pour la dur√©e de vie
<code>'a</code>, la fonction prend deux param√®tres, les deux √©tant des slices de cha√Æne de
caract√®res qui vivent aussi longtemps que la dur√©e de vie <code>'a</code>. La signature de
la fonction indique √©galement √† Rust que la slice de cha√Æne de caract√®res qui est
retourn√©e par la fonction vivra au moins aussi longtemps que la dur√©e de vie
<code>'a</code>. Dans la pratique, cela veut dire que dur√©e de vie de la r√©f√©rence
retourn√©e par la fonction <code>la_plus_longue</code> est la m√™me que celle de la plus
petite des dur√©es de vies des r√©f√©rences qu'on lui donne. Cette relation est ce
que nous voulons que Rust mette en place lorsqu'il analysera ce code.</p>
<!--
Remember, when we specify the lifetime parameters in this function signature,
we‚Äôre not changing the lifetimes of any values passed in or returned. Rather,
we‚Äôre specifying that the borrow checker should reject any values that don‚Äôt
adhere to these constraints. Note that the `longest` function doesn‚Äôt need to
know exactly how long `x` and `y` will live, only that some scope can be
substituted for `'a` that will satisfy this signature.
-->
<p>Souvenez-vous, lorsque nous pr√©cisons les param√®tres de dur√©e de vie dans la
signature de cette fonction, nous ne changeons pas les dur√©es de vies des
valeurs qui lui sont envoy√©es ou qu'elle retourne. Ce que nous faisons, c'est
plut√¥t indiquer au v√©rificateur d'emprunt qu'il doit rejeter toute valeur qui
ne r√©pond pas √† ces conditions. Notez que la fonction <code>la_plus_longue</code> n'a pas
besoin de savoir exactement combien de temps <code>x</code> et <code>y</code> vont exister, mais
seulement que cette port√©e peut √™tre substitu√©e par <code>'a</code>, qui satisfera cette
signature.</p>
<!--
When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. The lifetime annotations become part of
the contract of the function, much like the types in the signature are. Having
function signatures contain the lifetime contract means the analysis the Rust
compiler does can be simpler. If there‚Äôs a problem with the way a function is
annotated or the way it is called, the compiler errors can point to the part of
our code and the constraints more precisely. If, instead, the Rust compiler
made more inferences about what we intended the relationships of the lifetimes
to be, the compiler might only be able to point to a use of our code many steps
away from the cause of the problem.
-->
<p>Lorsqu'on pr√©cise les dur√©es de vie dans les fonctions, les annotations se
placent dans la signature de la fonction, pas dans le corps de la fonction. Les
annotations de dur√©e de vie sont devenues partie int√©grante de la fonction,
exactement comme les types dans la signature. Avoir des signatures de fonction
qui int√®grent la dur√©e de vie signifie que l'analyse que va faire le
compilateur Rust sera plus simple. S'il y a un probl√®me avec la fa√ßon dont la
fonction est annot√©e ou appel√©e, les erreurs de compilation peuvent pointer
plus pr√©cis√©ment sur la partie de notre code qui impose ces contraintes. Mais
si au contraire, le compilateur Rust avait d√ª faire plus de suppositions sur
ce que nous voulions cr√©er comme lien de dur√©e de vie, le compilateur n'aurait
pu qu'√©voquer une utilisation de notre code bien plus √©loign√©e de la v√©ritable
raison du probl√®me.</p>
<!--
When we pass concrete references to `longest`, the concrete lifetime that is
substituted for `'a` is the part of the scope of `x` that overlaps with the
scope of `y`. In other words, the generic lifetime `'a` will get the concrete
lifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because
we‚Äôve annotated the returned reference with the same lifetime parameter `'a`,
the returned reference will also be valid for the length of the smaller of the
lifetimes of `x` and `y`.
-->
<p>Lorsque nous donnons une r√©f√©rence concr√®te √† <code>la_plus_longue</code>, la dur√©e de vie
concr√®te qui est mod√©lis√©e par <code>'a</code> est la partie de la port√©e de <code>x</code> qui se
chevauche avec la port√©e de <code>y</code>. Autrement dit, la dur√©e vie g√©n√©rique <code>'a</code> aura
la dur√©e de vie concr√®te qui est √©gale √† la plus petite des dur√©es de vies entre
<code>x</code> et <code>y</code>. Comme nous avons marqu√© la r√©f√©rence retourn√©e avec le m√™me
param√®tre de dur√©e de vie <code>'a</code>, la r√©f√©rence retourn√©e sera toujours en vigueur
pour la dur√©e de la plus petite des dur√©es de vies de <code>x</code> et de <code>y</code>.</p>
<!--
Let‚Äôs look at how the lifetime annotations restrict the `longest` function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.
-->
<p>Regardons comment les annotations de dur√©e de vie restreignent la fonction
<code>la_plus_longue</code> en y passant des r√©f√©rences qui ont des dur√©es de vies
concr√®tement diff√©rentes. L'encart 10-23 en est un exemple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
# 
# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;une longue cha√Æne est longue&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let resultat = la_plus_longue(string1.as_str(), string2.as_str());
        println!(&quot;La cha√Æne la plus longue est {}&quot;, resultat);
    }
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-23: Using the `longest` function with
references to `String` values that have different concrete lifetimes</span>
-->
<p><span class="caption">Encart 10-23¬†: utilisation de la fonction <code>la_plus_longue</code>
sur des r√©f√©rences √† des valeurs <code>String</code> qui ont concr√®tement des dur√©es de vie
diff√©rentes</span></p>
<!--
In this example, `string1` is valid until the end of the outer scope, `string2`
is valid until the end of the inner scope, and `result` references something
that is valid until the end of the inner scope. Run this code, and you‚Äôll see
that the borrow checker approves of this code; it will compile and print `The
longest string is long string is long`.
-->
<p>Dans cet exemple, <code>string1</code> est en vigueur jusqu'√† la fin de la port√©e externe,
<code>string2</code> n'est valide que jusqu'√† la fin de la port√©e interne, et <code>resultat</code>
est une r√©f√©rence vers quelque chose qui est en vigueur jusqu'√† la fin de la
port√©e interne. Lorsque vous lancez ce code, vous constaterez que le
v√©rificateur d'emprunt accepte ce code¬†; il va se compiler et afficher
<code>La cha√Æne la plus longue est une longue cha√Æne est longue</code>.</p>
<!--
Next, let‚Äôs try an example that shows that the lifetime of the reference in
`result` must be the smaller lifetime of the two arguments. We‚Äôll move the
declaration of the `result` variable outside the inner scope but leave the
assignment of the value to the `result` variable inside the scope with
`string2`. Then we‚Äôll move the `println!` that uses `result` outside the inner
scope, after the inner scope has ended. The code in Listing 10-24 will not
compile.
-->
<p>Maintenant, essayons un exemple qui fait en sorte que la dur√©e de vie de la
r√©f√©rence dans <code>resultat</code> sera plus petite que celles des deux arguments. Nous
allons d√©placer la d√©claration de la variable <code>resultat</code> √† l'ext√©rieur de la
port√©e interne mais on va laisser l'affectation de la valeur de la variable
<code>resultat</code> √† l'int√©rieur de la port√©e de <code>string2</code>. Nous allons ensuite d√©placer
le <code>println!</code>, qui utilise <code>resultat</code>, √† l'ext√©rieur de la port√©e interne, apr√®s
que la port√©e soit termin√©e. Le code de l'encart 10-24 ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
# 
# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;une longue cha√Æne est longue&quot;);
    let resultat;
    {
        let string2 = String::from(&quot;xyz&quot;);
        resultat = la_plus_longue(string1.as_str(), string2.as_str());
    }
    println!(&quot;La cha√Æne la plus longue est {}&quot;, resultat);
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-24: Attempting to use `result` after `string2`
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-24¬†: tentative d'utilisation de <code>resultat</code> apr√®s
<code>string2</code>, qui est sortie de la port√©e</span></p>
<!--
When we try to compile this code, we‚Äôll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous aurons cette erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 -- > src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {}", result);
  |                                          ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = la_plus_longue(string1.as_str(), string2.as_str());
  |                                                   ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;La cha√Æne la plus longue est {}&quot;, resultat);
  |                                                 -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The error shows that for `result` to be valid for the `println!` statement,
`string2` would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter `'a`.
-->
<p>L'erreur explique que pour que <code>resultat</code> soit en vigueur pour l'instruction
<code>println!</code>, <code>string2</code> doit toujours √™tre valide jusqu'√† la fin de la port√©e
externe. Rust a d√©duit cela car nous avons pr√©cis√© les dur√©es de vie des
param√®tres de la fonction et des valeurs de retour en utilisant le m√™me
param√®tre de dur√©e de vie <code>'a</code>.</p>
<!--
As humans, we can look at this code and see that `string1` is longer than
`string2` and therefore `result` will contain a reference to `string1`.
Because `string1` has not gone out of scope yet, a reference to `string1` will
still be valid for the `println!` statement. However, the compiler can‚Äôt see
that the reference is valid in this case. We‚Äôve told Rust that the lifetime of
the reference returned by the `longest` function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.
-->
<p>En tant qu'humain, nous pouvons lire ce code et constater que <code>string1</code> est plus
grand que <code>string2</code> et ainsi que <code>resultat</code> contiendra une r√©f√©rence vers
<code>string1</code>. Comme <code>string1</code> n'est pas encore sorti de port√©e, une r√©f√©rence vers
<code>string1</code> sera toujours valide pour l'instruction <code>println!</code>. Cependant, le
compilateur ne peut pas d√©duire que la r√©f√©rence est valide dans notre cas. Nous
avons dit √† Rust que la dur√©e de vie de la r√©f√©rence qui est retourn√©e par la
fonction <code>la_plus_longue</code> est la m√™me que la plus petite des dur√©es de vie des
r√©f√©rences qu'on lui passe en argument. C'est pourquoi le v√©rificateur d'emprunt
rejette le code de l'encart 10-24 car il a potentiellement une r√©f√©rence
invalide.</p>
<!--
Try designing more experiments that vary the values and lifetimes of the
references passed in to the `longest` function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you‚Äôre right!
-->
<p>Essayez d'exp√©rimenter d'autres situations en variant les valeurs et dur√©es de
vie des r√©f√©rences pass√©es en argument de la fonction <code>la_plus_longue</code>, et
aussi pour voir comment on utilise la r√©f√©rence retourn√©e. Faites des
hypoth√®ses pour savoir si ces situations vont passer ou non le v√©rificateur
d'emprunt avant que vous ne compiliez¬†; et v√©rifiez ensuite si vous aviez
raison¬†!</p>
<!--
### Thinking in Terms of Lifetimes
-->
<h3 id="penser-en-termes-de-dur√©es-de-vie"><a class="header" href="#penser-en-termes-de-dur√©es-de-vie">Penser en termes de dur√©es de vie</a></h3>
<!--
The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
`longest` function to always return the first parameter rather than the longest
string slice, we wouldn‚Äôt need to specify a lifetime on the `y` parameter. The
following code will compile:
-->
<p>La fa√ßon dont vous avez √† pr√©ciser les param√®tres de dur√©es de vie d√©pend de ce
que fait votre fonction. Par exemple, si nous changions l'impl√©mentation de la
fonction <code>la_plus_longue</code> pour qu'elle retourne syst√©matiquement le premier
param√®tre plut√¥t que la slice de cha√Æne de caract√®res la plus longue, nous
n'aurions pas besoin de renseigner une dur√©e de vie sur le param√®tre <code>y</code>. Le
code suivant se compile¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "efghijklmnopqrstuvwxyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La cha√Æne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<!--
In this example, we‚Äôve specified a lifetime parameter `'a` for the parameter
`x` and the return type, but not for the parameter `y`, because the lifetime of
`y` does not have any relationship with the lifetime of `x` or the return value.
-->
<p>Dans cet exemple, nous avons pr√©cis√© un param√®tre de dur√©e de vie <code>'a</code> sur le
param√®tre <code>x</code> et sur le type de retour, mais pas sur le param√®tre <code>y</code>, car la
dur√©e de vie de <code>y</code> n'a pas de lien avec la dur√©e de vie de <code>x</code> ou de la valeur
de retour.</p>
<!--
When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does *not* refer to one of the parameters, it must refer
to a value created within this function, which would be a dangling reference
because the value will go out of scope at the end of the function. Consider
this attempted implementation of the `longest` function that won‚Äôt compile:
-->
<p>Lorsqu'on retourne une r√©f√©rence √† partir d'une fonction, le param√®tre de la
dur√©e de vie pour le type de retour doit correspondre √† une des dur√©es des
param√®tres. Si la r√©f√©rence retourn√©e ne se r√©f√®re <em>pas</em> √† un de ses param√®tres,
elle se r√©f√®re probablement √† une valeur cr√©√©e √† l'int√©rieur de cette fonction,
et elle deviendra une r√©f√©rence pendouillante car sa valeur va sortir de la
port√©e √† la fin de la fonction. Imaginons cette tentative d'impl√©mentation de
la fonction <code>la_plus_longue</code> qui ne se compile pas¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La cha√Æne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let resultat = String::from(&quot;tr√®s longue cha√Æne&quot;);
    resultat.as_str()
}
</code></pre>
<!--
Here, even though we‚Äôve specified a lifetime parameter `'a` for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:
-->
<p>Ici, m√™me si nous avons pr√©cis√© un param√®tre de dur√©e de vie <code>'a</code> sur le type de
retour, cette impl√©mentation va √©chouer √† la compilation car la dur√©e de vie de
la valeur de retour n'est pas du tout li√©e √† la dur√©e de vie des param√®tres.
Voici le message d'erreur que nous obtenons¬†:</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  -- > src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     resultat.as_str()
   |     ^^^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The problem is that `result` goes out of scope and gets cleaned up at the end
of the `longest` function. We‚Äôre also trying to return a reference to `result`
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won‚Äôt let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.
-->
<p>Le probl√®me est que <code>resultat</code> sort de la port√©e et est effac√©e √† la fin de la
fonction <code>la_plus_longue</code>. Nous avons aussi essay√© de retourner une r√©f√©rence
vers <code>resultat</code> √† partir de la fonction. Il n'existe aucune fa√ßon d'√©crire les
param√®tres de dur√©e de vie de telle mani√®re que cela changerait la r√©f√©rence
pendouillante, et Rust ne nous laissera pas cr√©er une r√©f√©rence pendouillante.
Dans notre cas, la meilleure solution consiste √† retourner un type de donn√©e
dont on va prendre possession plut√¥t qu'une r√©f√©rence, ainsi le code appelant
sera responsable du nettoyage de la valeur.</p>
<!--
Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they‚Äôre connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.
-->
<p>Enfin, la syntaxe de la dur√©e de vie sert √† interconnecter les dur√©es de vie de
plusieurs param√®tres ainsi que les valeurs de retour des fonctions. Une fois
celles-ci interconnect√©s, Rust a assez d'informations pour autoriser les op√©rations
s√©curis√©es dans la m√©moire et refuser les op√©rations qui pourraient cr√©er des
pointeurs pendouillants ou alors enfreindre la s√©curit√© de la m√©moire.</p>
<!--
### Lifetime Annotations in Struct Definitions
-->
<h3 id="lajout-des-dur√©es-de-vies-dans-les-d√©finitions-des-structures"><a class="header" href="#lajout-des-dur√©es-de-vies-dans-les-d√©finitions-des-structures">L'ajout des dur√©es de vies dans les d√©finitions des structures</a></h3>
<!--
So far, we‚Äôve only defined structs to hold owned types. It‚Äôs possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the struct‚Äôs definition. Listing 10-25 has a
struct named `ImportantExcerpt` that holds a string slice.
-->
<p>Jusqu'√† pr√©sent, nous avons d√©fini des structures pour contenir des types qui
sont poss√©d√©s par elles-m√™mes. Il est possible qu'une structure puisse contenir
des r√©f√©rences, mais dans ce cas nous devons pr√©ciser une dur√©e de vie sur
chaque r√©f√©rence dans la d√©finition de la structure. L'encart 10-25 montre une
structure <code>ExtraitImportant</code> qui stocke une slice de cha√Æne de caract√®res.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct ExtraitImportant&lt;'a&gt; {
    partie: &amp;'a str,
}

fn main() {
    let roman = String::from(&quot;Appelez-moi Isma√´l. Il y a quelques ann√©es ...&quot;);
    let premiere_phrase = roman.split('.')
        .next()
        .expect(&quot;Impossible de trouver un '.'&quot;);
    let i = ExtraitImportant { partie: premiere_phrase };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span>
-->
<p><span class="caption">Encart 10-25¬†: une structure qui stocke une r√©f√©rence,
par cons√©quent sa d√©finition a besoin d'une annotation de dur√©e de vie</span></p>
<!--
This struct has one field, `part`, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of `ImportantExcerpt` can‚Äôt outlive the reference
it holds in its `part` field.
-->
<p>Cette structure a un champ, <code>partie</code>, qui stocke une slice de cha√Æne de
caract√®res, qui est une r√©f√©rence. Comme pour les types de donn√©es g√©n√©riques,
nous d√©clarons le nom du param√®tre de dur√©e de vie g√©n√©rique entre des chevrons
apr√®s le nom de la structure pour que nous puissions utiliser le param√®tre de
dur√©e de vie dans le corps de la d√©finition de la structure. Cette annotation
signifie qu'une instance de <code>ExtraitImportant</code> ne peut pas vivre plus longtemps
que la r√©f√©rence qu'elle stocke dans son champ <code>partie</code>.</p>
<!--
The `main` function here creates an instance of the `ImportantExcerpt` struct
that holds a reference to the first sentence of the `String` owned by the
variable `novel`. The data in `novel` exists before the `ImportantExcerpt`
instance is created. In addition, `novel` doesn‚Äôt go out of scope until after
the `ImportantExcerpt` goes out of scope, so the reference in the
`ImportantExcerpt` instance is valid.
-->
<p>La fonction <code>main</code> cr√©e ici une instance de la structure <code>ExtraitImportant</code> qui
stocke une r√©f√©rence vers la premi√®re phrase de la <code>String</code> poss√©d√©e par la
variable <code>roman</code>. Les donn√©es dans <code>roman</code> existent avant que l'instance de
<code>ExtraitImportant</code> soit cr√©e. De plus, <code>roman</code> ne sort pas de la port√©e avant
que l'instance de <code>ExtraitImportant</code> sorte de la port√©e, donc la r√©f√©rence dans
l'instance de <code>ExtraitImportant</code> est toujours valide.</p>
<!--
### Lifetime Elision
-->
<h3 id="l√©lision-des-dur√©es-de-vie"><a class="header" href="#l√©lision-des-dur√©es-de-vie">L'√©lision des dur√©es de vie</a></h3>
<!--
You‚Äôve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, which is shown again in Listing
10-26, that compiled without lifetime annotations.
-->
<p>Vous avez appris que toute r√©f√©rence a une dur√©e de vie et que vous devez
renseigner des param√®tres de dur√©e de vie sur des fonctions ou des structures
qui utilisent des r√©f√©rences. Cependant, dans le chapitre 4 nous avions une
fonction dans l'encart 4-9, qui est montr√©e √† nouveau dans l'encart 10-26, qui
compilait sans informations de dur√©e de vie.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // first_word works on slices of `String`s
#     let word = first_word(&my_string[..]);
# 
#     let my_string_literal = "hello world";
# 
#     // first_word works on slices of string literals
#     let word = first_word(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = first_word(my_string_literal);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;str) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = premier_mot(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = premier_mot(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = premier_mot(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span>
-->
<p><span class="caption">Encart 10-26¬†: une fonction que nous avons d√©fini dans
l'encart 4-9 qui se compilait sans avoir d'indications sur la dur√©e de vie, m√™me
si les param√®tres et le type de retour sont des r√©f√©rences</span></p>
<!--
The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn‚Äôt have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:
-->
<p>La raison pour laquelle cette fonction se compile sans annotation de dur√©e de
vie est historique¬†: dans les premi√®res versions de Rust (avant la 1.0), ce code
ne se serait pas compil√© parce que chaque r√©f√©rence devait avoir une dur√©e de
vie explicite. A l'√©poque, la signature de la fonction devait √™tre √©crite
ainsi¬†:</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler‚Äôs code so
the borrow checker could infer the lifetimes in these situations and wouldn‚Äôt
need explicit annotations.
-->
<p>Apr√®s avoir √©crit une grande quantit√© de code Rust, l'√©quipe de Rust s'est rendu
compte que les d√©veloppeurs Rust saisissaient toujours les m√™mes dur√©es de vie
encore et encore dans des situations sp√©cifiques. Ces situations √©taient
pr√©visibles et suivaient des sch√©mas pr√©d√©termin√©s. Les d√©veloppeurs ont
programm√© ces sch√©mas dans le code du compilateur afin que le v√©rificateur
d'emprunt puisse deviner les dur√©es de vie dans ces situations et n'auront plus
besoin d'annotations explicites.</p>
<!--
This piece of Rust history is relevant because it‚Äôs possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.
-->
<p>Cette partie de l'histoire de Rust est int√©ressante car il est possible que
d'autres mod√®les pr√©d√©termin√©s √©mergent et soient ajout√©s au compilateur. A
l'avenir, il est possible qu'encore moins d'annotations de dur√©e de vie soient
n√©cessaires.</p>
<!--
The patterns programmed into Rust‚Äôs analysis of references are called the
*lifetime elision rules*. These aren‚Äôt rules for programmers to follow; they‚Äôre
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don‚Äôt need to write the lifetimes explicitly.
-->
<p>Les sch√©mas programm√©s dans l'analyse des r√©f√©rences de Rust s'appellent les
<em>r√®gles d'√©lision des dur√©es de vie</em>. Ce ne sont pas des r√®gles que les
d√©veloppeurs doivent suivre¬†; c'est un jeu de cas particuliers que le
compilateur va essayer de comparer √† votre code, et s'il y a une correspondance
alors vous n'aurez pas besoin d'√©crire explicitement les dur√©es de vie.</p>
<!--
The elision rules don‚Äôt provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler won‚Äôt guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.
-->
<p>Les r√®gles d'√©lision ne permettent pas de faire des d√©ductions compl√®tes. Si
Rust applique les r√®gles de fa√ßon stricte, mais qu'il existe toujours une
ambigu√Øt√© quant √† la dur√©e de vie des r√©f√©rences, le compilateur ne devinera pas
quelle devrait √™tre la dur√©e de vie des autres r√©f√©rences. Dans ce cas, au lieu de
tenter de deviner, le compilateur va vous afficher une erreur que vous devrez
r√©soudre en pr√©cisant les dur√©es de vie qui clarifieront les liens entre chaque
r√©f√©rence.</p>
<!--
Lifetimes on function or method parameters are called *input lifetimes*, and
lifetimes on return values are called *output lifetimes*.
-->
<p>Les dur√©es de vies sur les fonctions ou les param√®tres des fonctions sont
appel√©es les <em>dur√©es de vie des entr√©es</em>, et les dur√©es de vie sur les valeurs
de retour sont appel√©es les <em>dur√©es de vie des sorties</em>.</p>
<!--
The compiler uses three rules to figure out what lifetimes references have when
there aren‚Äôt explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it can‚Äôt
figure out lifetimes, the compiler will stop with an error. These rules apply
to `fn` definitions as well as `impl` blocks.
-->
<p>Le compilateur utilise trois r√®gles pour d√©terminer quelles devraient √™tre les dur√©es
de vie des r√©f√©rences si cela n'est pas indiqu√© explicitement. La premi√®re r√®gle
s'applique sur les dur√©es de vie des entr√©es, et les deuxi√®me et troisi√®me r√®gles
s'appliquent sur les dur√©es de vie des sorties. Si le compilateur arrive √† la
fin des trois r√®gles et qu'il y a encore des r√©f√©rences pour lesquelles il ne
peut pas savoir leur dur√©e de vie, le compilateur s'arr√™te avec une erreur. Ces
r√®gles s'appliquent sur les d√©finitions des <code>fn</code> ainsi que sur celles des blocs
<code>impl</code>.</p>
<!--
The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two
separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so
on.
-->
<p>La premi√®re r√®gle dit que chaque param√®tre qui est une r√©f√©rence a sa propre
dur√©e de vie. Autrement dit, une fonction avec un seul param√®tre va avoir un
seul param√®tre de dur√©e de vie¬†: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>¬†; une fonction avec
deux param√®tres va avoir deux param√®tres de dur√©e de vie s√©par√©s¬†:
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>¬†; et ainsi de suite.</p>
<!--
The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32)
-> &'a i32`.
-->
<p>La deuxi√®me r√®gle dit que s'il y a exactement un seul param√®tre de dur√©e de vie
d'entr√©e, cette dur√©e de vie est assign√©e √† tous les param√®tres de dur√©e de vie
des sorties¬†: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<!--
The third rule is if there are multiple input lifetime parameters, but one of
them is `&self` or `&mut self` because this is a method, the lifetime of `self`
is assigned to all output lifetime parameters. This third rule makes methods
much nicer to read and write because fewer symbols are necessary.
-->
<p>La troisi√®me r√®gle est que lorsque nous avons plusieurs param√®tres de dur√©e de
vie, mais qu'un d'entre eux est <code>&amp;self</code> ou <code>&amp;mut self</code> parce que c'est une
m√©thode, la dur√©e de vie de <code>self</code> sera associ√©e √† tous les param√®tres de dur√©e
de vie des sorties. Cette troisi√®me r√®gle rend les m√©thodes plus faciles √† lire
et √† √©crire car il y a moins de caract√®res n√©cessaires.</p>
<!--
Let‚Äôs pretend we‚Äôre the compiler. We‚Äôll apply these rules to figure out what
the lifetimes of the references in the signature of the `first_word` function
in Listing 10-26 are. The signature starts without any lifetimes associated
with the references:
-->
<p>Imaginons que nous soyons le compilateur. Nous allons appliquer ces r√®gles pour
d√©duire quelles seront les dur√©es de vie des r√©f√©rences dans la signature de la
fonction <code>premier_mot</code> de l'encart 10-26.</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We‚Äôll call it `'a` as usual, so now the signature is
this:
-->
<p>Le compilateur applique alors la premi√®re r√®gle, qui dit que chaque r√©f√©rence
a sa propre dur√©e de vie. Appellons-la <code>'a</code> comme d'habitude, donc maintenant la
signature devient ceci¬†:</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<!--
The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:
-->
<p>La deuxi√®me r√®gle s'applique car il y a exactement une dur√©e de vie d'entr√©e ici.
La deuxi√®me r√®gle dit que la dur√©e de vie du seul param√®tre d'entr√©e est affect√©e
√† la dur√©e de vie des sorties, donc la signature est maintenant ceci¬†:</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.
-->
<p>Maintenant, toutes les r√©f√©rences de cette signature de fonction ont des
dur√©es de vie, et le compilateur peut continuer son analyse sans avoir besoin
que le d√©veloppeur renseigne les dur√©es de vie dans cette signature de
fonction.</p>
<!--
Let‚Äôs look at another example, this time using the `longest` function that had
no lifetime parameters when we started working with it in Listing 10-21:
-->
<p>Voyons un autre exemple, qui utilise cette fois la fonction <code>la_plus_longue</code> qui
n'avait pas de param√®tres de dur√©e de vie lorsque nous avons commenc√© √†
l'utiliser dans l'encart 10-21¬†:</p>
<!--
```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Let‚Äôs apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:
-->
<p>Appliquons la premi√®re r√®gle¬†: chaque r√©f√©rence a sa propre dur√©e de vie. Cette
fois, nous avons avons deux r√©f√©rences au lieu d'une seule, donc nous avons deux
dur√©es de vie¬†:</p>
<!--
```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<!--
You can see that the second rule doesn‚Äôt apply because there is more than one
input lifetime. The third rule doesn‚Äôt apply either, because `longest` is a
function rather than a method, so none of the parameters are `self`. After
working through all three rules, we still haven‚Äôt figured out what the return
type‚Äôs lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldn‚Äôt figure out all the lifetimes of the references in the signature.
-->
<p>Vous pouvez constater que la deuxi√®me r√®gle ne s'applique pas car il y a plus
d'une seule dur√©e de vie. La troisi√®me ne s'applique pas non plus, car
<code>la_plus_longue</code> est une fonction et pas une m√©thode, donc aucun de ses
param√®tres ne sont <code>self</code>. Apr√®s avoir utilis√© ces trois r√®gles, nous n'avons
pas pu en d√©duire la dur√©e de vie de la valeur de retour. C'est pourquoi nous
obtenons une erreur en essayant de compiler le code dans l'encart 10-21¬†: le
compilateur a utilis√© les r√®gles d'√©lision des dur√©es de vie mais n'est pas
capable d'en d√©duire toutes les dur√©es de vie des r√©f√©rences pr√©sentes dans la
signature.</p>
<!--
Because the third rule really only applies in method signatures, we‚Äôll look at
lifetimes in that context next to see why the third rule means we don‚Äôt have to
annotate lifetimes in method signatures very often.
-->
<p>Comme la troisi√®me r√®gle ne s'applique que sur les signatures des m√©thodes, nous
allons examiner les dur√©es de vie dans ce contexte pour comprendre pourquoi la
troisi√®me r√®gle signifie que nous n'avons pas souvent besoin d'annoter les
dur√©es de vie dans les signatures des m√©thodes.</p>
<!--
### Lifetime Annotations in Method Definitions
-->
<h3 id="informations-de-dur√©e-de-vie-dans-les-d√©finitions-des-m√©thodes"><a class="header" href="#informations-de-dur√©e-de-vie-dans-les-d√©finitions-des-m√©thodes">Informations de dur√©e de vie dans les d√©finitions des m√©thodes</a></h3>
<!--
When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they‚Äôre related to the struct
fields or the method parameters and return values.
-->
<p>Lorsque nous impl√©mentons des m√©thodes sur une structure avec des dur√©es de vie,
nous utilisons la m√™me syntaxe que celle des param√®tres de type g√©n√©riques que nous
avons vue dans l'encart 10-11. L'endroit o√π nous d√©clarons et utilisons les
param√®tres de dur√©e de vie d√©pend de s'ils sont reli√©s aux champs des structures
ou aux param√®tres de la m√©thode et aux valeurs de retour.</p>
<!--
Lifetime names for struct fields always need to be declared after the `impl`
keyword and then used after the struct‚Äôs name, because those lifetimes are part
of the struct‚Äôs type.
-->
<p>Les noms des dur√©es de vie pour les champs de structure ont toujours besoin
d'√™tre d√©clar√©s apr√®s le mot-cl√© <code>impl</code> et sont ensuite utilis√©s apr√®s le nom de
la structure, car ces dur√©es vie font partie du type de la structure.</p>
<!--
In method signatures inside the `impl` block, references might be tied to the
lifetime of references in the struct‚Äôs fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren‚Äôt necessary in method signatures. Let‚Äôs look at some examples using the
struct named `ImportantExcerpt` that we defined in Listing 10-25.
-->
<p>Sur les signatures des m√©thodes √† l'int√©rieur du bloc <code>impl</code>, les r√©f√©rences
peuvent √™tre li√©es √† la dur√©e de vie des r√©f√©rences de champs de la structure, ou
elles peuvent √™tre ind√©pendantes. De plus, les r√®gles d'√©lision des dur√©es de
vie font parfois en sorte que l'ajout de dur√©es de vie n'est parfois pas
n√©cessaire dans les signatures des m√©thodes. Voyons quelques exemples en
utilisant la structure <code>ExtraitImportant</code> que nous avons d√©finie dans l'encart
10-25.</p>
<!--
First, we‚Äôll use a method named `level` whose only parameter is a reference to
`self` and whose return value is an `i32`, which is not a reference to anything:
-->
<p>Premi√®rement, nous allons utiliser une m√©thode <code>niveau</code> dont le seul param√®tre
est une r√©f√©rence √† <code>self</code> et dont la valeur de retour sera un <code>i32</code>, qui n'est
pas une r√©f√©rence¬†:</p>
<!--
```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
# 
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
# 
# impl<'a> ImportantExcerpt<'a> {
#     fn announce_and_return_part(&self, announcement: &str) -> &str {
#         println!("Attention please: {}", announcement);
#         self.part
#     }
# }
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ImportantExcerpt {
#         part: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn niveau(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Votre attention s'il vous pla√Æt¬†: {}&quot;, annonce);
</span><span class="boring">        self.partie
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
The lifetime parameter declaration after `impl` and its use after the type name
are required, but we‚Äôre not required to annotate the lifetime of the reference
to `self` because of the first elision rule.
-->
<p>La d√©claration du param√®tre de dur√©e de vie apr√®s <code>impl</code> et son utilisation
apr√®s le nom du type sont n√©cessaires, mais nous n'avons pas √† pr√©ciser la dur√©e
de vie de la r√©f√©rence √† <code>self</code> gr√¢ce √† la premi√®re r√®gle d'√©lision.</p>
<!--
Here is an example where the third lifetime elision rule applies:
-->
<p>Voici un exemple o√π la troisi√®me r√®gle d'√©lision des dur√©es de vie s'applique¬†:</p>
<!--
```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
# 
# impl<'a> ImportantExcerpt<'a> {
#     fn level(&self) -> i32 {
#         3
#     }
# }
# 
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ImportantExcerpt {
#         part: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn niveau(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
        println!(&quot;Votre attention s'il vous pla√Æt¬†: {}&quot;, annonce);
        self.partie
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both `&self` and `announcement` their own lifetimes. Then, because
one of the parameters is `&self`, the return type gets the lifetime of `&self`,
and all lifetimes have been accounted for.
-->
<p>Il y a deux dur√©es de vies des entr√©es, donc Rust applique la premi√®re r√®gle
d'√©lision des dur√©es de vie et donne √† <code>&amp;self</code> et <code>annonce</code> leur
propre dur√©e de vie. Ensuite, comme un des param√®tres est <code>&amp;self</code>, le type de
retour obtient la dur√©e de vie de <code>&amp;self</code>, de sorte que toutes les dur√©es de
vie ont √©t√© calcul√©es.</p>
<!--
### The Static Lifetime
-->
<h3 id="la-dur√©e-de-vie-statique"><a class="header" href="#la-dur√©e-de-vie-statique">La dur√©e de vie statique</a></h3>
<!--
One special lifetime we need to discuss is `'static`, which means that this
reference *can* live for the entire duration of the program. All string
literals have the `'static` lifetime, which we can annotate as follows:
-->
<p>Une dur√©e de vie particuli√®re que nous devons aborder est <code>'static</code>, qui
signifie que cette r√©f√©rence <em>peut</em> vivre pendant la totalit√© de la dur√©e du
programme. Tous les litt√©raux de cha√Ænes de caract√®res ont la dur√©e de vie
<code>'static</code>, que nous pouvons √©crire comme ceci¬†:</p>
<!--
```rust
let s: &'static str = "I have a static lifetime.";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;J'ai une dur√©e de vie statique.&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The text of this string is stored directly in the program‚Äôs binary, which
is always available. Therefore, the lifetime of all string literals is
`'static`.
-->
<p>Le texte de cette cha√Æne de caract√®res est stock√© directement dans le binaire du
programme, qui est toujours disponible. C'est pourquoi la dur√©e de vie de tous
les litt√©raux de cha√Ænes de caract√®res est <code>'static</code>.</p>
<!--
You might see suggestions to use the `'static` lifetime in error messages. But
before specifying `'static` as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not. You might consider whether you want it to live that long, even
if it could. Most of the time, the problem results from attempting to create a
dangling reference or a mismatch of the available lifetimes. In such cases, the
solution is fixing those problems, not specifying the `'static` lifetime.
-->
<p>Il se peut que voyiez des suggestions pour utiliser la dur√©e de vie <code>'static</code>
dans les messages d'erreur. Mais avant d'utiliser <code>'static</code> comme dur√©e de vie
pour une r√©f√©rence, demandez-vous si la r√©f√©rence en question vit bien pendant
toute la vie de votre programme, ou non. Vous devriez vous demander si vous
voulez qu'elle vive aussi longtemps, m√™me si si c'√©tait possible. La plupart du
temps, le probl√®me r√©sulte d'une tentative de cr√©ation d'une r√©f√©rence
pendouillante ou d'une inad√©quation des dur√©es de vie disponibles. Dans ces
cas-l√†, la solution consiste √† r√©soudre ces probl√®mes, et pas √† renseigner la
dur√©e de vie comme √©tant <code>'static</code>.</p>
<!--
## Generic Type Parameters, Trait Bounds, and Lifetimes Together
-->
<h2 id="les-param√®tres-de-type-g√©n√©riques-les-traits-li√©s-et-les-dur√©es-de-vies-ensemble"><a class="header" href="#les-param√®tres-de-type-g√©n√©riques-les-traits-li√©s-et-les-dur√©es-de-vies-ensemble">Les param√®tres de type g√©n√©riques, les traits li√©s, et les dur√©es de vies ensemble</a></h2>
<!--
Let‚Äôs briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!
-->
<p>Regardons bri√®vement la syntaxe pour renseigner tous les param√®tres de type
g√©n√©riques, les traits li√©s, et les dur√©es de vies sur une seule fonction¬†!</p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest_with_an_announcement(
#         string1.as_str(),
#         string2,
#         "Today is someone's birthday!",
#     );
#     println!("The longest string is {}", result);
# }
# 
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue_avec_annonce(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Aujourd'hui, c'est l'anniversaire de quelqu'un¬†!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;La cha√Æne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn la_plus_longue_avec_annonce&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Annonce¬†! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
This is the `longest` function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named `ann` of the generic
type `T`, which can be filled in by any type that implements the `Display`
trait as specified by the `where` clause. This extra parameter will be printed
using `{}`, which is why the `Display` trait bound is necessary. Because
lifetimes are a type of generic, the declarations of the lifetime parameter
`'a` and the generic type parameter `T` go in the same list inside the angle
brackets after the function name.
-->
<p>C'est la fonction <code>la_plus_longue</code> de l'encart 10-22 qui retourne la plus grande
de deux slices de cha√Ænes de caract√®res. Mais maintenant elle a un param√®tre
suppl√©mentaire <code>ann</code> de type g√©n√©rique <code>T</code>, qui peut √™tre remplac√© par n'importe
quel type qui impl√©mente le trait <code>Display</code> comme le pr√©cise la clause <code>where</code>.
Ce param√®tre suppl√©mentaire sera affich√© avec <code>{}</code>, c'est pourquoi le trait li√©
<code>Display</code> est n√©cessaire. Comme les dur√©es de vie sont un type de g√©n√©riques,
les d√©clarations du param√®tre de dur√©e de vie <code>'a</code> et le param√®tre de type
g√©n√©rique <code>T</code> vont dans la m√™me liste √† l'int√©rieur des chevrons apr√®s le nom de
la fonction.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-9"><a class="header" href="#r√©sum√©-9">R√©sum√©</a></h2>
<!--
We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you‚Äôre
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they‚Äôll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won‚Äôt have any dangling references. And all of this
analysis happens at compile time, which doesn‚Äôt affect runtime performance!
-->
<p>Nous avons vu beaucoup de choses dans ce chapitre¬†! Maintenant que vous en
savez plus sur les param√®tres de type g√©n√©riques, les traits et les traits
li√©s, ainsi que sur les param√®tres de dur√©e de vie g√©n√©riques, vous pouvez
maintenant √©crire du code en √©vitant les doublons qui va bien fonctionner dans
de nombreuses situations. Les param√®tres de type g√©n√©riques vous permettent
d'appliquer du code √† diff√©rents types. Les traits et les traits li√©s
s'assurent que bien que les types soient g√©n√©riques, ils auront un comportement
particulier sur lequel le code peut compter. Vous avez appris comment utiliser
les indications de dur√©e de vie pour s'assurer que ce code flexible n'aura pas
de r√©f√©rences pendouillantes. Et toutes ces v√©rifications se font au moment de
la compilation, ce qui n'influe pas sur les performances au moment de
l'ex√©cution du programme¬†!</p>
<!--
Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the [Rust Reference][reference]. But next, you‚Äôll learn how to write tests in
Rust so you can make sure your code is working the way it should.
-->
<p>Croyez-le ou non, mais il y a encore des choses √† apprendre sur les sujets que
nous avons trait√©s dans ce chapitre¬†: le chapitre 17 expliquera les objets de
trait, qui est une fa√ßon d'utiliser les traits. Il existe aussi des situations
plus complexes impliquant des indications de dur√©e de vie dont vous n'aurez
besoin que dans certains cas de figure tr√®s avanc√©s; pour ces cas-l√†, vous
devriez consulter la <a href="https://doc.rust-lang.org/reference/index.html">R√©f√©rence de Rust</a>. Maintenant, nous allons
voir au chapitre suivant comment √©crire des tests en Rust afin que vous
puissiez vous assurer que votre code fonctionne comme il devrait le faire.</p>
<!--
[references-and-borrowing]:
ch04-02-references-and-borrowing.html#references-and-borrowing
[string-slices-as-parameters]:
ch04-03-slices.html#string-slices-as-parameters
[reference]: ../reference/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Writing Automated Tests
-->
<h1 id="ecrire-des-tests-automatis√©s"><a class="header" href="#ecrire-des-tests-automatis√©s">Ecrire des tests automatis√©s</a></h1>
<!--
In his 1972 essay ‚ÄúThe Humble Programmer,‚Äù Edsger W. Dijkstra said that
‚ÄúProgram testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.‚Äù That doesn‚Äôt mean we
shouldn‚Äôt try to test as much as we can!
-->
<p>Dans son essai de 1972 ‚ÄúThe Humble Programmer‚Äù, Edsger W. Dijkstra a dit qu'un
‚Äútest de programme peut √™tre une mani√®re tr√®s efficace de prouver la pr√©sence de
bogues, mais qu'il est totalement inad√©quat pour prouver leur absence‚Äù. Mais
cela ne veut pas dire que nous ne devrions pas tester notre programme autant que
faire se peut¬†!</p>
<!--
Correctness in our programs is the extent to which our code does what we intend
it to do. Rust is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Rust‚Äôs type
system shoulders a huge part of this burden, but the type system cannot catch
every kind of incorrectness. As such, Rust includes support for writing
automated software tests within the language.
-->
<p>L'exactitude de nos programmes est le niveau de conformit√© de notre code par
rapport √† ce que nous voulons qu'il fasse. Rust est con√ßu dans un grand souci
d'exactitude des programmes, mais l'exactitude est complexe et difficile √†
confirmer. Le syst√®me de type de Rust endosse une grande partie de cette charge,
mais le syst√®me de type ne peut pas d√©tecter tous les genres d'erreurs. Ainsi,
Rust embarque des fonctionnalit√©s pour √©crire des tests automatis√©s de logiciels
√† l'int√©rieur du langage.</p>
<!--
As an example, say we write a function called `add_two` that adds 2 to whatever
number is passed to it. This function‚Äôs signature accepts an integer as a
parameter and returns an integer as a result. When we implement and compile
that function, Rust does all the type checking and borrow checking that you‚Äôve
learned so far to ensure that, for instance, we aren‚Äôt passing a `String` value
or an invalid reference to this function. But Rust *can‚Äôt* check that this
function will do precisely what we intend, which is return the parameter plus 2
rather than, say, the parameter plus 10 or the parameter minus 50! That‚Äôs where
tests come in.
-->
<p>Par exemple, imaginons que nous √©crivons une fonction <code>ajouter_deux</code> qui ajoute
2 √† n'importe quel nombre qu'on lui envoie. La signature de cette fonction
prend un entier en param√®tre et retourne un entier comme r√©sultat. Lorsque nous
impl√©mentons et compilons cette fonction, Rust fait toutes les v√©rifications de
type et d'emprunt que vous avez apprises pr√©c√©demment afin de s'assurer que, par
exemple, nous ne passions pas une valeur de type <code>String</code> ou une r√©f√©rence
invalide √† cette fonction. Mais Rust <em>ne peut pas</em> v√©rifier que cette fonction
va faire pr√©cis√©ment ce que nous avions pr√©vu qu'elle fasse, qui en l'occurence
est de retourner le param√®tre incr√©ment√© de 2 plut√¥t que d'ajouter 10 ou
d'enlever 50, par exemple¬†! C'est pour cette situation que les tests sont
utiles.</p>
<!--
We can write tests that assert, for example, that when we pass `3` to the
`add_two` function, the returned value is `5`. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.
-->
<p>Nous pouvons √©crire des tests qui v√©rifient, par exemple, que lorsque nous
donnons <code>3</code> √† la fonction <code>ajouter_deux</code>, elle retourne bien <code>5</code>. Nous pouvons
lancer ces tests √† chaque fois que nous modifions notre code pour s'assurer
qu'aucun comportement existant et satisfaisant n'a chang√©.</p>
<!--
Testing is a complex skill: although we can‚Äôt cover every detail about how to
write good tests in one chapter, we‚Äôll discuss the mechanics of Rust‚Äôs testing
facilities. We‚Äôll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.
-->
<p>Les tests restent une discipline complexe¬†: bien que nous ne puissions couvrir
chaque d√©tail sur l'√©criture de bons tests en un seul chapitre, nous allons
d√©couvrir les  m√©canismes des moyens de test de Rust. Nous allons voir les
annotations et les macros que vous pourrez utiliser lorsque vous √©crirez vos
tests, le comportement par d√©faut et les options disponibles pour lancer vos
tests, et comment organiser les tests en tests unitaires et tests d'int√©gration.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## How to Write Tests
-->
<h2 id="comment-√©crire-des-tests"><a class="header" href="#comment-√©crire-des-tests">Comment √©crire des tests</a></h2>
<!--
Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:
-->
<p>Les tests sont des fonctions Rust qui v√©rifient que le code qui n'est pas un
test se comporte bien de la mani√®re attendue. Les corps des fonctions de test
effectuent g√©n√©ralement ces trois actions¬†:</p>
<!--
1. Set up any needed data or state.
2. Run the code you want to test.
3. Assert the results are what you expect.
-->
<ol>
<li>Initialiser toutes les donn√©es ou les √©tats,</li>
<li>Lancer le code que vous voulez tester,</li>
<li>V√©rifier que les r√©sultats correspondent bien √† ce que vous souhaitez.</li>
</ol>
<!--
Let‚Äôs look at the features Rust provides specifically for writing tests that
take these actions, which include the `test` attribute, a few macros, and the
`should_panic` attribute.
-->
<p>D√©couvrons les fonctionnalit√©s sp√©cifiques qu'offre Rust pour √©crire des tests
qui font ces actions, dont l'attribut <code>test</code>, quelques
macros et l'attribut <code>should_panic</code>.</p>
<!--
### The Anatomy of a Test Function
-->
<h3 id="lanatomie-dune-fonction-de-test"><a class="header" href="#lanatomie-dune-fonction-de-test">L'anatomie d'une fonction de test</a></h3>
<!--
At its simplest, a test in Rust is a function that‚Äôs annotated with the `test`
attribute. Attributes are metadata about pieces of Rust code; one example is
the `derive` attribute we used with structs in Chapter 5. To change a function
into a test function, add `#[test]` on the line before `fn`. When you run your
tests with the `cargo test` command, Rust builds a test runner binary that runs
the functions annotated with the `test` attribute and reports on whether each
test function passes or fails.
-->
<p>Dans la forme la plus simple, un test en Rust est une fonction qui est marqu√©e
avec l'attribut <code>test</code>. Les attributs sont des m√©tadonn√©es sur des parties de
code Rust¬†; un exemple est l'attribut <code>derive</code> que nous avons utilis√© sur les
structures au chapitre 5. Pour transformer une fonction en une fonction de test,
il faut ajouter <code>#[test]</code> dans la ligne avant le <code>fn</code>. Lorsque vous lancez vos
tests avec la commande <code>cargo test</code>, Rust construit un binaire d'ex√©cution de tests
qui ex√©cute les fonctions marqu√©es avec l'attribut <code>test</code> et fait un rapport sur
quelles fonctions ont r√©ussi ou √©chou√©.</p>
<!--
When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you don‚Äôt have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!
-->
<p>Lorsque nous cr√©ons une nouvelle biblioth√®que avec Cargo, un module de tests
qui contient une fonction de test est automatiquement cr√©√© pour nous. Ce module
vous aide √† d√©marrer l'√©criture de vos tests afin que vous n'ayez pas √† chercher
la structure et la syntaxe exacte d'une fonction de test √† chaque fois que vous
d√©butez un nouveau projet. Vous pouvez ajouter autant de fonctions de test et
autant de modules de tests que vous le souhaitez¬†!</p>
<!--
We‚Äôll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then we‚Äôll write some
real-world tests that call some code that we‚Äôve written and assert that its
behavior is correct.
-->
<p>Nous allons d√©couvrir quelques aspects du fonctionnement des tests en
exp√©rimentant avec le mod√®le de tests g√©n√©r√© pour nous, mais qui ne teste aucun
code pour le moment. Ensuite, nous √©crirons quelques tests plus proches de la
r√©alit√©, qui utiliseront du code que nous avons √©crit et qui valideront son bon
comportement.</p>
<!--
Let‚Äôs create a new library project called `adder`:
-->
<p>Commen√ßons par cr√©er un nouveau projet de biblioth√®que que nous appellerons
<code>addition</code>¬†:</p>
<!--
```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```
-->
<pre><code class="language-console">$ cargo new addition --lib
     Created library `addition` project
$ cd addition
</code></pre>
<!--
The contents of the *src/lib.rs* file in your `adder` library should look like
Listing 11-1.
-->
<p>Le contenu de votre fichier <em>src/lib.rs</em> dans votre biblioth√®que <code>addition</code>
devrait ressembler √† l'encart 11-1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new --lib listing-11-01 --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-- >
-->
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let resultat = 2 + 2;
        assert_eq!(resultat, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let resultat = 2 + 2;
        assert_eq!(resultat, 4);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-1: The test module and function generated
automatically by `cargo new`</span>
-->
<p><span class="caption">Encart 11-1¬†: le module de test et la fonction g√©n√©r√©s
automatiquement par <code>cargo new</code></span></p>
<!--
For now, let‚Äôs ignore the top two lines and focus on the function to see how it
works. Note the `#[test]` annotation before the `fn` line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the `tests` module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the `#[test]` attribute.
-->
<p>Pour l'instant, ignorons les deux premi√®res lignes et concentrons-nous sur la
fonction pour voir comment elle fonctionne. Remarquez l'annotation <code>#[test]</code>
avant la ligne <code>fn</code>¬†: cet attribut indique que c'est une fonction de test, donc
l'ex√©cuteur de tests sait qu'il doit consid√©rer cette fonction comme √©tant un
test. Nous pouvons aussi avoir des fonctions qui ne font pas de tests dans le
module <code>tests</code> afin de configurer des sc√©narios communs ou ex√©cuter des
op√©rations communes, c'est pourquoi nous devons indiquer quelles fonctions sont
des tests en utilisant l'attribut <code>#[test]</code>.</p>
<!--
The function body uses the `assert_eq!` macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Let‚Äôs run
it to see that this test passes.
-->
<p>Le corps de la fonction utilise la macro <code>assert_eq!</code> pour v√©rifier que 2 + 2
vaut bien 4. Cette v√©rification sert d'exemple pour expliquer le format d'un
test classique. Lan√ßons-le pour v√©rifier si ce test est valid√©.</p>
<!--
The `cargo test` command runs all tests in our project, as shown in Listing
11-2.
-->
<p>La commande <code>cargo test</code> lance tous les tests pr√©sents dans votre projet, comme
le montre l'encart 11-2.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
<span class="caption">Listing 11-2: The output from running the automatically
generated test</span>
-->
<p><span class="caption">Encart 11-2¬†: le r√©sultat du lancement des tests sur le
test g√©n√©r√© automatiquement</span></p>
<!--
Cargo compiled and ran the test. After the `Compiling`, `Finished`, and
`Running` lines is the line `running 1 test`. The next line shows the name
of the generated test function, called `it_works`, and the result of running
that test, `ok`. The overall summary of running the tests appears next. The
text `test result: ok.` means that all the tests passed, and the portion that
reads `1 passed; 0 failed` totals the number of tests that passed or failed.
-->
<p>Cargo a compil√© et lanc√© le test. Apr√®s les lignes <code>Compiling</code>, <code>Finished</code>, et
<code>Running</code>, on trouve la ligne <code>running 1 test</code>. La ligne suivante montre le nom
de la fonction de test <code>it_works</code>, qui a √©t√© g√©n√©r√©e pr√©c√©demment, et le
r√©sultat de l'ex√©cution de ce test, <code>ok</code>. Le r√©sum√© g√©n√©ral de l'ex√©cution des
tests s'affiche ensuite. Le texte <code>test result: ok.</code> signifie que tous les tests
ont r√©ussi, et la partie <code>1 passed; 0 failed</code> compte le nombre total de tests
qui ont r√©ussi ou √©chou√©.</p>
<!--
Because we don‚Äôt have any tests we‚Äôve marked as ignored, the summary shows `0
ignored`. We also haven‚Äôt filtered the tests being run, so the end of the
summary shows `0 filtered out`. We‚Äôll talk about ignoring and filtering out
tests in the next section, [‚ÄúControlling How Tests Are
Run.‚Äù][controlling-how-tests-are-run]<!-- ignore -- >
-->
<p>Comme nous n'avons aucun test que nous avons marqu√© comme ignor√©, le r√©sum√©
affiche <code>0 ignored</code>. Nous n'avons pas non plus filtr√© les tests qui ont √©t√©
ex√©cut√©s, donc la fin du r√©sum√© affiche <code>0 filtered out</code>. Nous verrons comment
ignorer et filtrer les tests dans la prochaine section, <a href="ch11-02-running-tests.html">‚ÄúContr√¥ler comment les
tests sont ex√©cut√©s‚Äù</a><!-- ignore -->.</p>
<!--
The `0 measured` statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
[the documentation about benchmark tests][bench] to learn more.
-->
<p>La statistique <code>0 measured</code> sert pour des tests de benchmark qui mesurent les
performances. Les tests de benchmark ne sont disponibles pour le moment que dans
la version exp√©rimentale de Rust (nightly), au moment de la r√©daction.
Rendez-vous sur <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">la documentation sur les tests de benchmark</a> pour en
savoir plus.</p>
<!--
[bench]: ../unstable-book/library-features/test.html
-->
<!--
The next part of the test output, which starts with `Doc-tests adder`, is for
the results of any documentation tests. We don‚Äôt have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! We‚Äôll
discuss how to write documentation tests in the [‚ÄúDocumentation Comments as
Tests‚Äù][doc-comments]<!-- ignore -- > section of Chapter 14. For now, we‚Äôll
ignore the `Doc-tests` output.
-->
<p>La partie suivante du r√©sultat des tests, qui commence par <code>Doc-tests addition</code>,
concerne les r√©sultats de tous les tests pr√©sents dans la documentation. Nous
n'avons pas de tests dans la documentation pour le moment, mais Rust peut
compiler tous les exemples de code qui sont pr√©sents dans la documentation de
notre API. Cette fonctionnalit√© nous aide √† garder synchronis√©s notre
documentation et notre code¬†! Nous verrons comment √©crire nos tests dans la
documentation dans une section du chapitre 14. Pour le moment, nous allons
ignorer la partie <code>Doc-tests</code> du r√©sultat.</p>
<!--
Let‚Äôs change the name of our test to see how that changes the test output.
Change the `it_works` function to a different name, such as `exploration`, like
so:
-->
<p>Changeons le nom de notre test pour voir comment cela change le r√©sultat du
test. Changeons le nom de la fonction <code>it_works</code> pour un nom diff√©rent, comme
<code>exploration</code> ci-dessous¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!--
Then run `cargo test` again. The output now shows `exploration` instead of
`it_works`:
-->
<p>Lancez ensuite √† nouveau <code>cargo test</code>. Le r√©sultat affiche d√©sormais
<code>exploration</code> plut√¥t que <code>it_works</code>¬†:</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Let‚Äôs add another test, but this time we‚Äôll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the `panic!` macro. Enter the new test, `another`, so your
*src/lib.rs* file looks like Listing 11-3.
-->
<p>Ajoutons un autre test, mais cette fois nous allons construire un test qui
√©choue¬†! Les tests √©chouent lorsque quelque chose dans la fonction de test
panique. Chaque test est lanc√© dans une nouvelle t√¢che, et lorsque la t√¢che
principale voit qu'une t√¢che de test a √©t√© interrompue par panique, le test est consid√©r√©
comme ayant √©chou√©. Nous avons vu la fa√ßon la plus simple de faire paniquer au
chapitre 9, qui consiste √† appeler la macro <code>panic!</code>. Ecrivez ce nouveau test,
<code>un_autre</code>, de sorte que votre fichier <code>src/lib.rs</code> ressemble √† ceci¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,panics,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!("Fait √©chouer ce test");
    }
}
```
-->
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!(&quot;Fait √©chouer ce test&quot;);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-3: Adding a second test that will fail because
we call the `panic!` macro</span>
-->
<p><span class="caption">Encart 11-3¬†: ajout d'un second test qui va √©chouer car
nous appelons la macro <code>panic!</code></span></p>
<!--
Run the tests again using `cargo test`. The output should look like Listing
11-4, which shows that our `exploration` test passed and `another` failed.
-->
<p>Lancez √† nouveau les tests en utilisant <code>cargo test</code>. Le r√©sultat devrait
ressembler √† l'encart 11-4, qui va afficher que notre test <code>exploration</code> a
r√©ussi et que <code>un_autre</code> a √©chou√©.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait √©chouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait √©chouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
<span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span>
-->
<p><span class="caption">Encart 11-4¬†: les r√©sultats de tests lorsque un test
r√©ussit et un autre test √©choue</span></p>
<!--
Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
`another` failed because it `panicked at 'Make this test fail'`, which happened
on line 10 in the *src/lib.rs* file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we‚Äôll talk more about ways to run tests in
the [‚ÄúControlling How Tests Are Run‚Äù][controlling-how-tests-are-run]<!-- ignore
-- > section.
-->
<p>A la place du <code>ok</code>, la ligne <code>test tests:un_autre</code> affiche <code>FAILED</code>. Deux
nouvelles sections apparaissent entre la liste des tests et le r√©sum√©¬†: la
premi√®re section affiche les raisons d√©taill√©es de chaque √©chec de test. Dans
notre cas, <code>un_autre</code> a √©chou√© car il a paniqu√© √† 'Fait √©chouer ce test', qui
est plac√© √† la ligne 10 du fichier <em>src/lib.rs</em>. La partie suivante liste
simplement les noms de tous les tests qui ont √©chou√©, ce qui est utile lorsqu'il
y a de nombreux tests et beaucoup de d√©tails provenant des tests qui √©chouent.
Nous pouvons utiliser le nom d'un test qui √©choue pour lancer uniquement ce test
afin de d√©boguer plus facilement¬†; nous allons voir plus de fa√ßons de lancer
des tests dans la <a href="ch11-02-running-tests.html">section suivante</a><!-- ignore
-->.</p>
<!--
The summary line displays at the end: overall, our test result is `FAILED`.
We had one test pass and one test fail.
-->
<p>La ligne de r√©sum√© s'affiche √† la fin¬†: au final, le r√©sultat de nos tests est
au statut <code>FAILED</code> (√©chou√©). Nous avons un test r√©ussi et un test √©chou√©.</p>
<!--
Now that you‚Äôve seen what the test results look like in different scenarios,
let‚Äôs look at some macros other than `panic!` that are useful in tests.
-->
<p>Maintenant que vous avez vu √† quoi ressemblent les r√©sultats de tests dans
diff√©rents sc√©narios, voyons d'autres macros que <code>panic!</code> qui nous serons utiles
pour les tests.</p>
<!--
### Checking Results with the `assert!` Macro
-->
<h3 id="v√©rifier-les-r√©sultats-avec-la-macro-assert"><a class="header" href="#v√©rifier-les-r√©sultats-avec-la-macro-assert">V√©rifier les r√©sultats avec la macro <code>assert!</code></a></h3>
<!--
The `assert!` macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to `true`. We give the
`assert!` macro an argument that evaluates to a Boolean. If the value is
`true`, `assert!` does nothing and the test passes. If the value is `false`,
the `assert!` macro calls the `panic!` macro, which causes the test to fail.
Using the `assert!` macro helps us check that our code is functioning in the
way we intend.
-->
<p>La macro <code>assert!</code>, fournie par la biblioth√®que standard, est utile lorsque vous
voulez vous assurer qu'une condition dans un test vaut <code>true</code>. Nous fournissons
√† la macro <code>assert!</code> un argument qui donne un Bool√©en une fois interpr√©t√©. Si la
valeur est <code>true</code>, <code>assert!</code> ne fait rien et le test est r√©ussi. Si la valeur
est <code>false</code>, la macro <code>assert!</code> appelle la macro <code>panic!</code>, qui fait √©chouer le
test. L'utilisation de la macro <code>assert!</code> nous aide √† v√©rifier que notre code
fonctionne bien comme nous le souhaitions.</p>
<!--
In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`
method, which are repeated here in Listing 11-5. Let‚Äôs put this code in the
*src/lib.rs* file and write some tests for it using the `assert!` macro.
-->
<p>Dans le chapitre 5, dans l'encart 5-15, nous avons utilis√© une structure
<code>Rectangle</code> et une m√©thode <code>peut_contenir</code>, qui sont recopi√©s dans l'encart 11-5
ci-dessous. Ajoutons ce code dans le fichier <em>src/lib.rs</em> et √©crivons quelques
tests en utilisant la macro <code>assert!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur > other.largeur && self.hauteur > other.hauteur
    }
}
```
-->
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-5: Using the `Rectangle` struct and its
`can_hold` method from Chapter 5</span>
-->
<p><span class="caption">Encart 11-5¬†: utilisation de la structure <code>Rectangle</code> et
sa m√©thode <code>peut_contenir</code> du chapitre 5</span></p>
<!--
The `can_hold` method returns a Boolean, which means it‚Äôs a perfect use case
for the `assert!` macro. In Listing 11-6, we write a test that exercises the
`can_hold` method by creating a `Rectangle` instance that has a width of 8 and
a height of 7 and asserting that it can hold another `Rectangle` instance that
has a width of 5 and a height of 1.
-->
<p>La m√©thode <code>peut_contenir</code> retourne un Bool√©en, ce qui veut dire que c'est un
cas parfait pour tester la macro <code>assert!</code>. Dans l'encart 11-6, nous √©crivons un
test qui s'applique sur la m√©thode <code>peut_contenir</code> en cr√©ant une instance de
<code>Rectangle</code> qui a une largeur de 8 et une hauteur de 7, et qui v√©rifie qu'il
peut contenir une autre instance de <code>Rectangle</code> qui a une largeur de 6 et une
hauteur de 1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&le_petit));
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&amp;le_petit));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-6: A test for `can_hold` that checks whether a
larger rectangle can indeed hold a smaller rectangle</span>
-->
<p><span class="caption">Encart 11-6¬†: un test pour <code>peut_contenir</code> qui v√©rifie le
cas o√π un grand rectangle peut contenir un plus petit rectangle</span></p>
<!--
Note that we‚Äôve added a new line inside the `tests` module: `use super::*;`.
The `tests` module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the [‚ÄúPaths for Referring to an Item in the Module
Tree‚Äù][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -- >
section. Because the `tests` module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
`tests` module.
-->
<p>Remarquez que nous avons ajout√© une nouvelle ligne √† l'int√©rieur du module
<code>test</code>¬†: <code>use super::*;</code>. Le module <code>tests</code> est un module classique qui suit les
r√®gles de visibilit√© que nous avons vues au chapitre 7 dans la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúLes
chemins pour d√©signer un √©l√©ment dans l'arborescence de
module‚Äù</a><!-- ignore -->.
Comme le module <code>tests</code> est un module interne, nous avons besoin de ramener le
code √† tester qui se trouve dans son module parent dans la port√©e interne du
module. Nous utilisons ici un op√©rateur global afin que tout ce que nous
avons d√©fini dans le module parent soit disponible dans le module <code>tests</code>.</p>
<!--
We‚Äôve named our test `larger_can_hold_smaller`, and we‚Äôve created the two
`Rectangle` instances that we need. Then we called the `assert!` macro and
passed it the result of calling `larger.can_hold(&smaller)`. This expression
is supposed to return `true`, so our test should pass. Let‚Äôs find out!
-->
<p>Nous avons nomm√© notre test <code>un_grand_peut_contenir_un_petit</code>, et nous avons
cr√©√© les deux instances <code>Rectangle</code> que nous avions besoin. Ensuite, nous avons
appel√© la macro <code>assert!</code> et nous lui avons pass√© le r√©sultat de l'appel √†
<code>le_grand.peut_contenir(&amp;le_petit)</code>. Cette expression est cens√©e retourner
<code>true</code>, donc notre test devrait r√©ussir. V√©rifions cela¬†!</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
It does pass! Let‚Äôs add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:
-->
<p>Il a r√©ussi¬†! Ajoutons maintenant un autre test, qui v√©rifie cette fois qu'un
petit rectangle ne peut contenir un rectangle plus grand¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&le_grand));
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
<span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span>    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&amp;le_grand));
    }
}
</code></pre>
<!--
Because the correct result of the `can_hold` function in this case is `false`,
we need to negate that result before we pass it to the `assert!` macro. As a
result, our test will pass if `can_hold` returns `false`:
-->
<p>Comme le r√©sultat correct de la fonction <code>peut_contenir</code> dans ce cas doit √™tre
<code>false</code>, nous devons faire un n√©gatif de cette fonction avant de l'envoyer √† la
macro <code>assert!</code>. Cela aura pour effet de faire r√©ussir notre test si
<code>peut_contenir</code> retourne <code>false</code>¬†:</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Two tests that pass! Now let‚Äôs see what happens to our test results when we
introduce a bug in our code. Let‚Äôs change the implementation of the `can_hold`
method by replacing the greater than sign with a less than sign when it
compares the widths:
-->
<p>Voil√† deux tests qui r√©ussissent¬†! Maintenant, voyons ce qu'il se passe dans les
r√©sultats de nos tests lorsque nous introduisons un bogue dans notre code.
Changeons l'impl√©mentation de la m√©thode <code>peut_contenir</code> en rempla√ßant
l'op√©rateur <em>plus grand que</em> par un <em>plus petit que</em> au moment de la comparaison
des largeurs¬†:</p>
<!--
```rust,not_desired_behavior,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
// -- partie masqu√©e ici --
impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur < other.largeur && self.hauteur > other.hauteur
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_grand_peut_contenir_un_petit() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
#     }
# 
#     #[test]
#     fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(!le_petit.peut_contenir(&le_grand));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici --
impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &lt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_grand_peut_contenir_un_petit() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!le_petit.peut_contenir(&amp;le_grand));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Running the tests now produces the following:
-->
<p>Le lancement des tests donne maintenant le r√©sultat suivant¬†:</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&amp;le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our tests caught the bug! Because `larger.width` is 8 and `smaller.width` is
5, the comparison of the widths in `can_hold` now returns `false`: 8 is not
less than 5.
-->
<p>Nos tests ont rep√©r√© le bogue¬†! Comme <code>le_grand.largeur</code> est 8 et
<code>le_petit.largeur</code> est 5, la comparaison des largeurs dans <code>peut_contenir</code>
retourne maintenant <code>false</code>¬†: 8 n'est pas plus petit que 5.</p>
<!--
### Testing Equality with the `assert_eq!` and `assert_ne!` Macros
-->
<h3 id="tester-l√©galit√©-avec-les-macros-assert_eq-et-assert_ne"><a class="header" href="#tester-l√©galit√©-avec-les-macros-assert_eq-et-assert_ne">Tester l'√©galit√© avec les macros <code>assert_eq!</code> et <code>assert_ne!</code></a></h3>
<!--
A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure they‚Äôre equal. You
could do this using the `assert!` macro and passing it an expression using the
`==` operator. However, this is such a common test that the standard library
provides a pair of macros‚Äî`assert_eq!` and `assert_ne!`‚Äîto perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They‚Äôll also print the two values if the assertion
fails, which makes it easier to see *why* the test failed; conversely, the
`assert!` macro only indicates that it got a `false` value for the `==`
expression, not the values that led to the `false` value.
-->
<p>Une fa√ßon courante de tester des fonctionnalit√©s est de comparer le r√©sultat du
code √† tester par rapport √† une valeur que vous souhaitez que le code retourne,
afin de vous assurer qu'elles soient bien √©gales. Vous pouvez faire cela avec la
macro <code>assert!</code> et en lui passant une expression qui utilise l'op√©rateur <code>==</code>.
Cependant, c'est un test si courant que la biblioth√®que standard fournit une
paire de macros (<code>assert_eq!</code> et <code>assert_ne!</code>) pour proc√©der √† ce test plus
facilement. Les macros comparent respectivement l'√©galit√© ou la non √©galit√© de
deux arguments. Elles vont aussi afficher les deux valeurs si la v√©rification
√©choue, ce qui va nous aider √† comprendre <em>pourquoi</em> le test a √©chou√©¬†;
paradoxalement, la macro <code>assert!</code> indique seulement qu'elle a obtenu une valeur
<code>false</code> de l'expression avec le <code>==</code>, mais n'affiche pas les valeurs qui l'ont
men√© √† la valeur <code>false</code>.</p>
<!--
In Listing 11-7, we write a function named `add_two` that adds `2` to its
parameter and returns the result. Then we test this function using the
`assert_eq!` macro.
-->
<p>Dans l'encart 11-7, nous √©crivons une fonction <code>ajouter_deux</code> qui ajoute <code>2</code> √†
son param√®tre et retourne le r√©sultat. Ensuite, nous testons cette fonction en
utilisant la macro <code>assert_eq!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-7: Testing the function `add_two` using the
`assert_eq!` macro</span>
-->
<p><span class="caption">Encart 11-7¬†: test de la fonction <code>ajouter_deux</code> en
utilisant la macro <code>assert_eq!</code>.</span></p>
<!--
Let‚Äôs check that it passes!
-->
<p>V√©rifions si cela fonctionne¬†!</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The first argument we gave to the `assert_eq!` macro, `4`, is equal to the
result of calling `add_two(2)`. The line for this test is `test
tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed!
-->
<p>Le premier argument que nous avons donn√© √† la macro <code>assert_eq!</code>, <code>4</code>, est bien
√©gal au r√©sultat de l'appel √† <code>ajouter_deux</code>. La ligne correspondant √† ce test
est <code>test tests::cela_ajoute_deux ... ok</code>, et le texte <code>ok</code> indique que notre
test a r√©ussi¬†!</p>
<!--
Let‚Äôs introduce a bug into our code to see what it looks like when a test that
uses `assert_eq!` fails. Change the implementation of the `add_two` function to
instead add `3`:
-->
<p>Ajoutons un bogue dans notre code pour voir ce qu'il se passe lorsque un test
qui utilise <code>assert_eq!</code> √©choue. Changez l'impl√©mentation de la fonction
<code>ajouter_deux</code> pour ajouter plut√¥t <code>3</code>¬†:</p>
<!--
```rust,not_desired_behavior,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 3
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn cela_ajoute_deux() {
#         assert_eq!(4, ajouter_deux(2));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn cela_ajoute_deux() {
</span><span class="boring">        assert_eq!(4, ajouter_deux(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the tests again:
-->
<p>Lancez √† nouveau les tests¬†:</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our test caught the bug! The `it_adds_two` test failed, displaying the message
`` assertion failed: `(left == right)` `` and showing that `left` was `4` and
`right` was `5`. This message is useful and helps us start debugging: it means
the `left` argument to `assert_eq!` was `4` but the `right` argument, where we
had `add_two(2)`, was `5`.
-->
<p>Notre test a d√©tect√© le bogue¬†! Le test <code>cela_ajoute_deux</code> a √©chou√©, ce qui a
affich√© le message <code>assertion failed: `(left == right)`</code> qui nous explique
qu'√† gauche nous avions <code>4</code> et qu'√† droite nous avions <code>5</code>. Ce message utile
nous aide au d√©boguage¬†: cela veut dire que l'argument de gauche de <code>assert_eq!</code>
valait <code>4</code> mais que l'argument de droite, o√π nous avions <code>ajouter_deux(2)</code>,
valait <code>5</code>.</p>
<!--
Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called `expected` and `actual`,
and the order in which we specify the arguments matters. However, in Rust,
they‚Äôre called `left` and `right`, and the order in which we specify the value
we expect and the value that the code under test produces doesn‚Äôt matter. We
could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which
would result in a failure message that displays `` assertion failed: `(left ==
right)` `` and that `left` was `5` and `right` was `4`.
-->
<p>Notez que dans certains langages et environnements de test, les param√®tres des
fonctions qui v√©rifient que deux valeurs soient √©gales sont appel√©s <code>attendu</code> et
<code>effectif</code>, et l'ordre dans lesquels nous renseignons les arguments est
important. Cependant, dans Rust, on les appelle <code>gauche</code> et <code>droite</code>, et l'ordre
dans lesquels nous renseignons la valeur que nous attendons et la valeur que
produit le code √† tester n'est pas important. Nous pouvons √©crire la
v√©rification de ce test dans la forme <code>assert_eq!(ajouter_deux(2), 4)</code>, ce qui
donnera un message d'√©chec qui affichera <code>assertion failed: `(left == right)`</code> et que gauche vaudra <code>5</code> et droit vaudra <code>4</code>.</p>
<!--
The `assert_ne!` macro will pass if the two values we give it are not equal and
fail if they‚Äôre equal. This macro is most useful for cases when we‚Äôre not sure
what a value *will* be, but we know what the value definitely *won‚Äôt* be if our
code is functioning as we intend. For example, if we‚Äôre testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.
-->
<p>La macro <code>assert_ne!</code> va r√©ussir si les deux valeurs que nous lui donnons ne
sont pas √©gales et va √©chouer si elles sont √©gales. Cette macro est utile dans
les cas o√π nous ne sommes pas s√ªr de ce que <em>devrait</em> valoir une valeur, mais
que nous savons ce que la valeur ne devrait surtout <em>pas</em> √™tre si notre code
fonctionne comme nous le souhaitons. Par exemple, si nous testons une fonction
qui doit transformer sa valeur d'entr√©e de mani√®re √† ce qu'elle d√©pend du jour
de la semaine o√π nous lan√ßons nos tests, la meilleure fa√ßon de v√©rifier serait
que la sortie de la fonction ne soit pas √©gale √† son entr√©e.</p>
<!--
Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators
`==` and `!=`, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the `PartialEq` and `Debug` traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, you‚Äôll need to implement `PartialEq` to assert that values of
those types are equal or not equal. You‚Äôll need to implement `Debug` to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum
definition. See Appendix C, [‚ÄúDerivable Traits,‚Äù][derivable-traits]<!-- ignore
-- > for more details about these and other derivable traits.
-->
<p>Sous la surface, les macros <code>assert_eq!</code> et <code>assert_ne!</code> utilisent
respectivement les op√©rateurs <code>==</code> et <code>!=</code>. Lorsque les v√©rifications √©chouent,
ces macros affichent leurs arguments en utilisant le formatage de d√©boguage, ce
qui veut dire que les valeurs compar√©es doivent impl√©menter les traits
<code>PartialEq</code> et <code>Debug</code>. Tous les types primitifs et la plupart des types de
la biblioth√®que standard impl√©mentent ces traits. Concernant les structures et
les √©num√©rations que vous d√©finissez, vous allez avoir besoin de leur
impl√©menter <code>Debug</code> pour afficher les valeurs lorsque les v√©rifications
√©chouent. Comme ces traits sont des traits d√©rivables, comme nous l'avons √©voqu√©
dans l'encart 5-12 du chapitre 5, il suffit g√©n√©ralement de simplement ajouter
l'annotation <code>#[derive(PartialEq, Debug)]</code> sur les d√©finitions de vos structures
ou √©num√©rations. Rendez-vous √† <a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore -->
pour en savoir plus sur ces derniers et les autres traits d√©rivables.</p>
<!--
### Adding Custom Failure Messages
-->
<h3 id="ajouter-des-messages-d√©chec-personnalis√©s"><a class="header" href="#ajouter-des-messages-d√©chec-personnalis√©s">Ajouter des messages d'√©chec personnalis√©s</a></h3>
<!--
You can also add a custom message to be printed with the failure message as
optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any
arguments specified after the one required argument to `assert!` or the two
required arguments to `assert_eq!` and `assert_ne!` are passed along to the
`format!` macro (discussed in Chapter 8 in the [‚ÄúConcatenation with the `+`
Operator or the `format!`
Macro‚Äù][concatenation-with-the--operator-or-the-format-macro]<!-- ignore -- >
section), so you can pass a format string that contains `{}` placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, you‚Äôll have a better idea of what
the problem is with the code.
-->
<p>Vous pouvez aussi ajouter un message personnalis√© qui peut √™tre affich√© avec le
message d'√©chec comme un argument optionnel aux macros <code>assert!</code>, <code>assert_eq!</code>,
et <code>assert_ne!</code>. Tous les arguments renseign√©s apr√®s celui qui est obligatoire
dans <code>assert!</code> ou les deux arguments obligatoires de <code>assert_eq!</code> et
<code>assert_ne!</code> sont envoy√©s √† la macro <code>format!</code> (que nous avons vue dans une
section du
<a href="ch08-02-strings.html">chapitre
8</a><!-- ignore -->), ainsi
vous pouvez passer une chaine de caract√®res de formatage qui contient des espaces
r√©serv√©s <code>{}</code> et les valeurs iront dans ces espaces r√©serv√©s. Les messages
personnalis√©s sont utiles pour documenter ce que fait une v√©rification¬†;
lorsqu'un test √©choue, vous aurez une id√©e plus pr√©cise du probl√®me avec ce
code.</p>
<!--
For example, let‚Äôs say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:
-->
<p>Par exemple, disons que nous avons une fonction qui accueille les gens par leur
nom et que nous voulons tester que le nom que nous envoyons √† la fonction
appara√Æt dans le r√©sultat¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn accueil(nom: &str) -> String {
    format!("Salut, {}¬†!", nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(resultat.contains("Carole"));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn accueil(nom: &amp;str) -&gt; String {
    format!(&quot;Salut, {}¬†!&quot;, nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(resultat.contains(&quot;Carole&quot;));
    }
}
</code></pre>
<!--
The requirements for this program haven‚Äôt been agreed upon yet, and we‚Äôre
pretty sure the `Hello` text at the beginning of the greeting will change. We
decided we don‚Äôt want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
`greeting` function, we‚Äôll just assert that the output contains the text of the
input parameter.
-->
<p>Les sp√©cifications de ce programme n'ont pas √©t√© valid√©es enti√®rement pour le
moment, et on est quasiment s√ªr que le texte <code>Salut</code> au d√©but va changer. Nous
avons d√©cid√© que nous ne devrions pas √† avoir √† changer le test si les
sp√©cifications changent, donc plut√¥t que de v√©rifier l'√©galit√© exacte de la
valeur retourn√©e par la fonction <code>accueil</code>, nous allons uniquement v√©rifier que
le r√©sultat contient le texte correspondant au param√®tre d'entr√©e de la
fonction.</p>
<!--
Let‚Äôs introduce a bug into this code by changing `greeting` to not include
`name` to see what this test failure looks like:
-->
<p>Introduisons un bogue dans ce code en changeant <code>accueil</code> pour ne pas
ajouter <code>nom</code> afin de voir ce que donne l'√©chec de ce test :</p>
<!--
```rust,not_desired_behavior,noplayground
pub fn accueil(name: &str) -> String {
    String::from("Salut¬†!")
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn accueil_contient_le_nom() {
#         let resultat = accueil("Carole");
#         assert!(resultat.contains("Carole"));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground">pub fn accueil(name: &amp;str) -&gt; String {
    String::from(&quot;Salut¬†!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn accueil_contient_le_nom() {
</span><span class="boring">        let resultat = accueil(&quot;Carole&quot;);
</span><span class="boring">        assert!(resultat.contains(&quot;Carole&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Running this test produces the following:
-->
<p>L'ex√©cution du test va donner ceci :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(\"Carole\")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(\&quot;Carole\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the `greeting` function. Let‚Äôs change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the `greeting` function:
-->
<p>Ce r√©sultat indique simplement que la v√©rification a √©chou√©, et √† quel endroit.
Le message d'√©chec serait plus utile dans notre cas s'il affichait la valeur
que nous obtenons de la fonction <code>accueil</code>. Changeons la fonction de test, pour
lui donner un message d'erreur personnalis√©, qui est une cha√Æne de caract√®res
de formatage avec un espace r√©serv√© qui contiendra la valeur que
nous avons obtenue de la fonction <code>accueil</code> :</p>
<!--
```rust,ignore
# pub fn accueil(nom: &str) -> String {
#     String::from("Salut¬†!")
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(
            resultat.contains("Carole"),
            "Le message d'accueil ne contient pas le nom, il vaut¬†`{}`",
            resultat
        );
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub fn accueil(nom: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Salut¬†!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(
            resultat.contains(&quot;Carole&quot;),
            &quot;Le message d'accueil ne contient pas le nom, il vaut¬†`{}`&quot;,
            resultat
        );
    }
<span class="boring">}
</span></code></pre>
<!--
Now when we run the test, we‚Äôll get a more informative error message:
-->
<p>Maintenant, lorsque nous lan√ßons √† nouveau le test, nous obtenons un message
d'√©chec plus explicite :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vaut¬†`Salut¬†!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vaut¬†`Salut¬†!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.
-->
<p>Nous pouvons voir la valeur que nous avons obtenue lors de la lecture du
r√©sultat du test, ce qui va nous aider √† d√©boguer ce qui s'est pass√© √† la
place de ce que nous voulions qu'il se passe.</p>
<!--
### Checking for Panics with `should_panic`
-->
<h3 id="v√©rifier-le-fonctionnement-des-paniques-avec-should_panic"><a class="header" href="#v√©rifier-le-fonctionnement-des-paniques-avec-should_panic">V√©rifier le fonctionnement des paniques avec <code>should_panic</code></a></h3>
<!--
In addition to checking that our code returns the correct values we expect,
it‚Äôs also important to check that our code handles error conditions as we
expect. For example, consider the `Guess` type that we created in Chapter 9,
Listing 9-13. Other code that uses `Guess` depends on the guarantee that `Guess`
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a `Guess` instance with a value outside that
range panics.
-->
<p>En plus de v√©rifier que notre code retourne bien les valeurs que nous
souhaitons, il est aussi important de v√©rifier que notre code g√®re bien les cas
d'erreurs comme nous le souhaitons. Par exemple, utilisons le type <code>Supposition</code>
que nous avons cr√©√© au chapitre 9, dans l'encart 9-13. Les autres codes qui
utilisent <code>Supposition</code> reposent sur la garantie que les instances de
<code>Supposition</code> contiennent uniquement des valeurs entre 1 et 100. Nous pouvons
√©crire un test qui s'assure que la cr√©ation d'une instance de <code>Supposition</code>
avec une valeur en dehors de cette intervalle va faire paniquer le programme.</p>
<!--
We do this by adding another attribute, `should_panic`, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesn‚Äôt panic.
-->
<p>Nous allons v√©rifier cela en ajoutant un autre attribut, <code>should_panic</code>, √† notre
fonction de test. Cet attribut fait r√©ussir le test si le code √† l'int√©rieur
de la fonction fait paniquer ; le test va √©chouer si le code √† l'int√©rieur de
la fonction ne panique pas.</p>
<!--
Listing 11-8 shows a test that checks that the error conditions of `Guess::new`
happen when we expect them to.
-->
<p>L'encart 11-8 nous montre un test qui v√©rifie que les conditions d'erreur de
<code>Supposition::new</code> fonctionne bien comme nous l'avons pr√©vu.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
```
-->
<pre><code class="language-rust noplayground">pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-8: Testing that a condition will cause a
`panic!`</span>
-->
<p><span class="caption">Encart 11-8 : tester qu'une condition va faire un <code>panic</code>
</span></p>
<!--
We place the `#[should_panic]` attribute after the `#[test]` attribute and
before the test function it applies to. Let‚Äôs look at the result when this test
passes:
-->
<p>Nous pla√ßons l'attribut <code>#[should_panic]</code> apr√®s l'attribut <code>#[test]</code> et avant
la fonction de test sur laquelle il s'applique. Voyons le r√©sultat lorsque ce
test r√©ussit :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Looks good! Now let‚Äôs introduce a bug in our code by removing the condition
that the `new` function will panic if the value is greater than 100:
-->
<p>Ca fonctionne ! Maintenant, ajoutons un bogue dans notre code en enlevant
la condition dans laquelle la fonction <code>new</code> panique lorsque la valeur est
plus grande que 100 :</p>
<!--
```rust,not_desired_behavior,noplayground
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masqu√©e ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
When we run the test in Listing 11-8, it will fail:
-->
<p>Lorsque nous lan√ßons le test de l'encart 11-8, il va √©chouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We don‚Äôt get a very helpful message in this case, but when we look at the test
function, we see that it‚Äôs annotated with `#[should_panic]`. The failure we got
means that the code in the test function did not cause a panic.
-->
<p>Dans ce cas, nous n'obtenons pas de message tr√®s utile, mais lorsque nous
regardons la fonction de test, nous constatons qu'elle est marqu√©e avec
<code>#[should_panic]</code>. L'√©chec que nous obtenons signifie que le code dans la
fonction de test n'a pas fait paniquer.</p>
<!--
Tests that use `should_panic` can be imprecise because they only indicate that
the code has caused some panic. A `should_panic` test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make `should_panic` tests more precise, we can add an optional `expected`
parameter to the `should_panic` attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for `Guess` in Listing 11-9 where the `new` function panics with
different messages depending on whether the value is too small or too large.
-->
<p>Les tests qui utilisent <code>should_panic</code> ne sont parfois pas assez explicites car
ils indiquent seulement que le code a paniqu√©. Un test <code>should_panic</code> peut
r√©ussir, m√™me si le test panique pour une raison diff√©rente de celle que nous
attendions. Pour rendre les tests <code>should_panic</code> plus pr√©cis, nous pouvons
ajouter un param√®tre optionnel <code>expected</code> √† l'attribut <code>should_panic</code>. Le
syst√®me de test va s'assurer que le message d'√©chec contient bien le texte
renseign√©. Par exemple, imaginons le code modifi√© de <code>Supposition</code> dans
l'encart 11-9 o√π la fonction <code>new</code> panique avec des messages diff√©rents si la
valeur est trop petite ou trop grande.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masqu√©e ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit √™tre plus petite ou √©gale √† 100, et nous avons {}.",
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "La supposition doit √™tre plus petite ou √©gale √† 100")]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit √™tre plus petite ou √©gale √† 100, et nous avons {}.&quot;,
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;La supposition doit √™tre plus petite ou √©gale √† 100&quot;)]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-9: Testing that a condition will cause a
`panic!` with a particular panic message</span>
-->
<p><span class="caption">Encart 11-9 : on v√©rifie qu'une situation va provoquer un
<code>panic!</code> avec un message de panique bien pr√©cis</span></p>
<!--
This test will pass because the value we put in the `should_panic` attribute‚Äôs
`expected` parameter is a substring of the message that the `Guess::new`
function panics with. We could have specified the entire panic message that we
expect, which in this case would be `Guess value must be less than or equal to
100, got 200.` What you choose to specify in the expected parameter for
`should_panic` depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the `else if value > 100` case.
-->
<p>Ce test va r√©ussir car la valeur que nous ins√©rons dans l'attribut <code>expected</code>
de <code>should_panic</code> est une partie du message de panique de la fonction
<code>Supposition::new</code>. Nous aurions pu renseigner le message de panique en entier
que nous attendions, qui dans ce cas est <code>La supposition doit √™tre plus petite ou √©gale √† 100, et nous avons 200.</code>. Ce que vous choisissez de renseigner dans
le param√®tre <code>expected</code> de <code>should_panic</code> d√©pend de la mesure dans laquelle le
message de panique est unique ou dynamique et de la pr√©cision de votre test que
vous souhaitez appliquer. Dans ce cas, un extrait du message de panique est
suffisant pour s'assurer que le code de la fonction de test s'ex√©cute dans le
cas du <code>else if valeur &gt; 100</code>.</p>
<!--
To see what happens when a `should_panic` test with an `expected` message
fails, let‚Äôs again introduce a bug into our code by swapping the bodies of the
`if value < 1` and the `else if value > 100` blocks:
-->
<p>Pour voir ce qui se passe lorsqu'un test <code>should_panic</code> qui a un message
<code>expected</code> qui √©choue, essayons √† nouveau d'introduire un bogue dans notre code
en permutant les corps des blocs de <code>if valeur &lt; 1</code> et de
<code>else if valeur &gt; 100</code> :</p>
<!--
```rust,ignore,not_desired_behavior
# pub struct Supposition {
#     valeur: i32,
# }
# 
# impl Supposition {
#     pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit √™tre plus petite ou √©gale √† 100, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons {}.",
                valeur
            );
        }
# 
#         Supposition { valeur }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic(expected = "La supposition doit √™tre plus petite ou √©gale √† 100")]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Supposition {
</span><span class="boring">    pub fn new(valeur: i32) -&gt; Supposition {
</span>        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit √™tre plus petite ou √©gale √† 100, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons {}.&quot;,
                valeur
            );
        }
<span class="boring">
</span><span class="boring">        Supposition { valeur }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;La supposition doit √™tre plus petite ou √©gale √† 100&quot;)]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This time when we run the `should_panic` test, it will fail:
-->
<p>Cette fois, lorsque nous lan√ßons le test avec <code>should_panic</code>, il devrait
√©chouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons 200."`,
 expected substring: `"La supposition doit √™tre plus petite ou √©gale √† 100"`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons 200.&quot;`,
 expected substring: `&quot;La supposition doit √™tre plus petite ou √©gale √† 100&quot;`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string `'Guess value must be
less than or equal to 100'`. The panic message that we did get in this case was
`Guess value must be greater than or equal to 1, got 200.` Now we can start
figuring out where our bug is!
-->
<p>Le message d'√©chec nous informe que ce test a paniqu√© comme pr√©vu, mais que le
message de panique n'inclus pas la cha√Æne de caract√®res pr√©vue <code>'La supposition doit √™tre plus petite ou √©gale √† 100'</code>. Le message de panique que nous avons
obtenu dans ce cas √©tait <code>La supposition doit √™tre plus grande ou √©gale √† 1, et nous avons 200.</code>. Maintenant, on comprend mieux o√π est le bogue !</p>
<!--
### Using `Result<T, E>` in Tests
-->
<h3 id="utiliser-resultt-e-dans-les-tests"><a class="header" href="#utiliser-resultt-e-dans-les-tests">Utiliser <code>Result&lt;T, E&gt;</code> dans les tests</a></h3>
<!--
So far, we‚Äôve written tests that panic when they fail. We can also write tests
that use `Result<T, E>`! Here‚Äôs the test from Listing 11-1, rewritten to use
`Result<T, E>` and return an `Err` instead of panicking:
-->
<p>Pr√©c√©demment, nous avons √©crit des tests qui paniquent lorsqu'ils √©chouent.
Nous pouvons √©galement √©crire des tests qui utilisent <code>Result&lt;T, E&gt;</code> ! Voici
le test de l'encart 11-1, r√©√©crit pour utiliser <code>Result&lt;T, E&gt;</code> et retourner
une <code>Err</code> au lieu de paniquer :</p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("deux plus deux ne vaut pas quatre"))
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;deux plus deux ne vaut pas quatre&quot;))
        }
    }
}
</code></pre>
<!--
The `it_works` function now has a return type, `Result<(), String>`. In the
body of the function, rather than calling the `assert_eq!` macro, we return
`Ok(())` when the test passes and an `Err` with a `String` inside when the test
fails.
-->
<p>La fonction <code>it_works</code> a maintenant un type de retour, <code>Result&lt;(), String&gt;</code>.
Dans le corps de la fonction, plut√¥t que d'appeler la macro <code>assert_eq!</code>, nous
retournons <code>Ok(())</code> lorsque le test r√©ussit et une <code>Err</code> avec une <code>String</code> √†
l'int√©rieur lorsque le test √©choue.</p>
<!--
Writing tests so they return a `Result<T, E>` enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an `Err` variant.
-->
<p>Ecrire vos tests afin qu'ils retournent un <code>Result&lt;T, E&gt;</code> vous permet
d'utiliser l'op√©rateur <em>point d'interrogation</em> dans le corps des tests, ce
qui est un outil facile √† utiliser pour √©crire des tests qui peuvent √©chouer
si n'importe quelle op√©ration en son sein retourne une variante de <code>Err</code>.</p>
<!--
You can‚Äôt use the `#[should_panic]` annotation on tests that use `Result<T,
E>`. To assert that an operation returns an `Err` variant, *don‚Äôt* use the
question mark operator on the `Result<T, E>` value. Instead, use
`assert!(value.is_err())`.
-->
<p>Vous ne pouvez pas utiliser l'annotation <code>#[should_panic]</code> sur les tests qui
utilisent <code>Result&lt;T, E&gt;</code>. Pour v√©rifier qu'une op√©ration retourne une variante
<code>Err</code>, <em>n'utilisez pas</em> l'op√©rateur &quot;point d'interrogation&quot; sur la valeur de
type <code>Result&lt;T, E&gt;</code>. A la place, utilisez plut√¥t <code>assert!(valeur.is_err())</code>.</p>
<!--
Now that you know several ways to write tests, let‚Äôs look at what is happening
when we run our tests and explore the different options we can use with `cargo
test`.
-->
<p>Maintenant que vous avez appris diff√©rentes mani√®res d'√©crire des tests, voyons
ce qui se passe lorsque nous lan√ßons nos tests et explorons les diff√©rentes
options que nous pouvons utiliser avec <code>cargo test</code>.</p>
<!--
[concatenation-with-the--operator-or-the-format-macro]:
ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro
[controlling-how-tests-are-run]:
ch11-02-running-tests.html#controlling-how-tests-are-run
[derivable-traits]: appendix-03-derivable-traits.html
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Controlling How Tests Are Run
-->
<h2 id="g√©rer-lex√©cution-des-tests"><a class="header" href="#g√©rer-lex√©cution-des-tests">G√©rer l'ex√©cution des tests</a></h2>
<!--
Just as `cargo run` compiles your code and then runs the resulting binary,
`cargo test` compiles your code in test mode and runs the resulting test
binary. You can specify command line options to change the default behavior of
`cargo test`. For example, the default behavior of the binary produced by
`cargo test` is to run all the tests in parallel and capture output generated
during test runs, preventing the output from being displayed and making it
easier to read the output related to the test results.
-->
<p>Comme <code>cargo run</code> qui compile votre code et qui ex√©cute ensuite le binaire qui
en r√©sulte, <code>cargo test</code> compile votre code en mode test et lance le binaire de
tests qu'il produit. Vous pouvez rajouter des options en ligne de commande pour
changer le comportement par d√©faut de <code>cargo test</code>. Par exemple, le
comportement par d√©faut des binaires produits par <code>cargo test</code> est de lancer
tous les tests en parall√®le et de capturer la sortie pendant l'ex√©cution des
tests, ce qui lui √©vite d'√™tre affich√©e sur l'√©cran pendant ce temps,
facilitant la lecture des messages relatifs aux r√©sultats de l'ex√©cution des
tests.</p>
<!--
Some command line options go to `cargo test`, and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that
go to `cargo test` followed by the separator `--` and then the ones that go to
the test binary. Running `cargo test --help` displays the options you can use
with `cargo test`, and running `cargo test -- --help` displays the options you
can use after the separator `--`.
-->
<p>Certaines options de la ligne de commande s'appliquent √† <code>cargo test</code>, et
certaines au binaire de tests qui en r√©sulte. Pour s√©parer ces types
d'arguments, il faut lister les arguments qui s'appliquent √† <code>cargo test</code>,
suivis du s√©parateur <code>--</code>, puis ajouter ceux qui s'appliquent au binaire
de tests. L'ex√©cution de <code>cargo test --help</code> affiche les options que vous
pouvez utiliser sur <code>cargo test</code>, et l'ex√©cution de <code>cargo test -- --help</code>
affiche les options que vous pouvez utiliser apr√®s le s√©parateur <code>--</code>.</p>
<!--
### Running Tests in Parallel or Consecutively
-->
<h3 id="lancer-les-tests-en-parall√®le-ou-en-s√©quence"><a class="header" href="#lancer-les-tests-en-parall√®le-ou-en-s√©quence">Lancer les tests en parall√®le ou en s√©quence</a></h3>
<!--
When you run multiple tests, by default they run in parallel using threads.
This means the tests will finish running faster so you can get feedback quicker
on whether or not your code is working. Because the tests are running at the
same time, make sure your tests don‚Äôt depend on each other or on any shared
state, including a shared environment, such as the current working directory or
environment variables.
-->
<p>Lorsque vous lancez de nombreux tests, par d√©faut ils s'ex√©cutent en parall√®le
dans des t√¢ches. Cela veut dire que tous les tests vont finir de s'ex√©cuter plus
rapidement afin que vous sachiez si votre code fonctionne ou non. Comme les
tests s'ex√©cutent en m√™me temps, il faut s'assurer qu'ils ne d√©pendent
pas les uns des autres ou d'un √©tat partag√©, y compris un environnement partag√©,
comme le dossier de travail actuel ou des variables d'environnement.</p>
<!--
For example, say each of your tests runs some code that creates a file on disk
named *test-output.txt* and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file between when another test writes and reads the
file. The second test will then fail, not because the code is incorrect but
because the tests have interfered with each other while running in parallel.
One solution is to make sure each test writes to a different file; another
solution is to run the tests one at a time.
-->
<p>Par exemple, disons que chacun de vos tests ex√©cute du code qui cr√©e un fichier
<em>test-sortie.txt</em> sur le disque dur et qu'il √©crit quelques donn√©es dans ce
fichier. Ensuite, chaque test lit les donn√©es de ce fichier et v√©rifie que le
fichier contient une valeur pr√©cise, qui est diff√©rente dans chaque test. Comme
les tests sont lanc√©s en m√™me temps, un test risque d'√©craser le contenu du
fichier entre le moment o√π un autre test lit et √©crit sur ce fichier. Le second
test va ensuite √©chouer, non pas parce que le code est incorrect mais parce
que les tests se sont perturb√©s mutuellement pendant qu'ils s'ex√©cutaient en
parall√®le. Une solution serait de s'assurer que chaque test √©crit dans un
fichier diff√©rent ; une autre serait de lancer les tests les uns apr√®s les autres.</p>
<!--
If you don‚Äôt want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the `--test-threads` flag
and the number of threads you want to use to the test binary. Take a look at
the following example:
-->
<p>Si vous ne souhaitez pas ex√©cuter les tests en parall√®le ou si vous voulez un
contr√¥le plus pr√©cis du nombre de t√¢ches utilis√©es, vous pouvez utiliser l'option
<code>--test-threads</code> suivie du nombre de t√¢ches que vous souhaitez
que le binaire de test ex√©cute en parall√®le. Regardez cet exemple :</p>
<!--
```console
$ cargo test -- --test-threads=1
```
-->
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<!--
We set the number of test threads to `1`, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won‚Äôt interfere with each other if they share
state.
-->
<p>Nous avons r√©gl√© le nombre de t√¢ches √† <code>1</code>, ce qui indique au programme de ne
pas utiliser le parall√©lisme. Ex√©cuter ces tests en n'effectuant qu'une seule
t√¢che √† la fois va prendre plus de temps que de les lancer en parall√®le, mais
cela assure que les tests ne vont pas s'influencer mutuellement s'ils partagent
le m√™me √©tat.</p>
<!--
### Showing Function Output
-->
<h3 id="afficher-la-sortie-de-la-fonction"><a class="header" href="#afficher-la-sortie-de-la-fonction">Afficher la sortie de la fonction</a></h3>
<!--
By default, if a test passes, Rust‚Äôs test library captures anything printed to
standard output. For example, if we call `println!` in a test and the test
passes, we won‚Äôt see the `println!` output in the terminal; we‚Äôll see only the
line that indicates the test passed. If a test fails, we‚Äôll see whatever was
printed to standard output with the rest of the failure message.
-->
<p>Par d√©faut, si un test r√©ussit, la biblioth√®que de test de Rust r√©cup√®re tout
ce qui est affich√© sur la sortie standard. Par exemple, si nous appelons
<code>println!</code> dans un test et que le test r√©ussit, nous ne verrons pas la sortie
correspondant au <code>println!</code> dans le terminal ; on verra seulement la ligne qui
indique que le test a r√©ussi. Si un test √©choue, nous verrons ce qui a √©t√©
affich√© sur la sortie standard avec le reste des messages d'erreur.</p>
<!--
As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.
-->
<p>Par exemple, l'encart 11-10 a une fonction stupide qui affiche la valeur de ses
param√®tres et retourne 10, ainsi qu'un test qui r√©ussit et un test qui √©choue.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,panics,noplayground
fn affiche_et_retourne_10(a: i32) -> i32 {
    println!("J'ai obtenu la valeur {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ce_test_reussit() {
        let valeur = affiche_et_retourne_10(4);
        assert_eq!(10, valeur);
    }

    #[test]
    fn ce_test_echoue() {
        let valeur = affiche_et_retourne_10(8);
        assert_eq!(5, valeur);
    }
}
```
-->
<pre><code class="language-rust panics noplayground">fn affiche_et_retourne_10(a: i32) -&gt; i32 {
    println!(&quot;J'ai obtenu la valeur {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ce_test_reussit() {
        let valeur = affiche_et_retourne_10(4);
        assert_eq!(10, valeur);
    }

    #[test]
    fn ce_test_echoue() {
        let valeur = affiche_et_retourne_10(8);
        assert_eq!(5, valeur);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-10: Tests for a function that calls
`println!`</span>
-->
<p><span class="caption">Encart 11-10 : tests d'une fonction qui fait appel √†
<code>println!</code></span></p>
<!--
When we run these tests with `cargo test`, we‚Äôll see the following output:
-->
<p>Lorsque nous lan√ßons ces tests avec <code>cargo test</code>, nous voyons cette sortie :</p>
<!--
```console
$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Note that nowhere in this output do we see `I got the value 4`, which is what
is printed when the test that passes runs. That output has been captured. The
output from the test that failed, `I got the value 8`, appears in the section
of the test summary output, which also shows the cause of the test failure.
-->
<p>Remarquez que nous n'avons jamais vu <code>J'ai obtenu la valeur 4</code> dans cette
sortie, qui est ce qui est affich√© lors de l'ex√©cution du test qui r√©ussit.
Cette sortie a √©t√© captur√©e. La sortie pour le test qui a √©chou√©,
<code>J'ai obtenu la valeur 8</code>, s'affiche dans la section de la sortie
correspondante au r√©sum√© des tests, qui affiche aussi les causes de l'√©chec
du test.</p>
<!--
If we want to see printed values for passing tests as well, we can tell Rust
to also show the output of successful tests at the end with `--show-output`.
-->
<p>Si nous voulons aussi voir les valeurs affich√©es pour les tests r√©ussis, nous
pouvons demander √† Rust d'afficher √©galement la sortie des tests fructueux en
lui rajoutant √† la fin <code>--show-output</code>.</p>
<!--
```console
$ cargo test -- --show-output
```
-->
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<!--
When we run the tests in Listing 11-10 again with the `--show-output` flag, we
see the following output:
-->
<p>Lorsque nous lan√ßons √† nouveau les tests de l'encart 11-10 avec l'option
<code>--show-output</code>, nous voyons la sortie suivante :</p>
<!--
```console
$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

successes:

---- tests::ce_test_reussit stdout ----
J'ai obtenu la valeur 4


successes:
    tests::ce_test_reussit

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

successes:

---- tests::ce_test_reussit stdout ----
J'ai obtenu la valeur 4


successes:
    tests::ce_test_reussit

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
### Running a Subset of Tests by Name
-->
<h3 id="ex√©cuter-un-sous-ensemble-de-tests-en-fonction-de-son-nom"><a class="header" href="#ex√©cuter-un-sous-ensemble-de-tests-en-fonction-de-son-nom">Ex√©cuter un sous-ensemble de tests en fonction de son nom</a></h3>
<!--
Sometimes, running a full test suite can take a long time. If you‚Äôre working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing `cargo test` the name
or names of the test(s) you want to run as an argument.
-->
<p>Parfois, lancer une suite de tests enti√®re peut prendre beaucoup de temps. Si
vous travaillez sur du code d'un p√©rim√®tre bien d√©fini, vous pourriez avoir
besoin d'ex√©cuter uniquement les tests relatifs √† ce code. Vous pouvez choisir
quels tests ex√©cuter en envoyant le ou les noms du ou des tests que vous souhaitez
ex√©cuter en argument de <code>cargo test</code>.</p>
<!--
To demonstrate how to run a subset of tests, we‚Äôll create three tests for our
`add_two` function, as shown in Listing 11-11, and choose which ones to run.
-->
<p>Dans le but de d√©montrer comment lancer un sous-ensemble de tests, nous allons
cr√©er trois tests pour notre fonction <code>ajouter_deux</code> dans l'encart 11-11, et
choisir lesquels nous allons ex√©cuter.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ajouter_deux_a_deux() {
        assert_eq!(4, ajouter_deux(2));
    }

    #[test]
    fn ajouter_deux_a_trois() {
        assert_eq!(5, ajouter_deux(3));
    }

    #[test]
    fn cent() {
        assert_eq!(102, ajouter_deux(100));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ajouter_deux_a_deux() {
        assert_eq!(4, ajouter_deux(2));
    }

    #[test]
    fn ajouter_deux_a_trois() {
        assert_eq!(5, ajouter_deux(3));
    }

    #[test]
    fn cent() {
        assert_eq!(102, ajouter_deux(100));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-11: Three tests with three different
names</span>
-->
<p><span class="caption">Encart 11-11 : trois tests avec trois noms diff√©rents
</span></p>
<!--
If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:
-->
<p>Si nous ex√©cutons les tests sans ajouter d'arguments, comme nous l'avons vu
pr√©c√©demment, tous les tests vont s'ex√©cuter en parall√®le :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok
test tests::cent ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok
test tests::cent ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
#### Running Single Tests
-->
<h4 id="ex√©cuter-des-tests-individuellement"><a class="header" href="#ex√©cuter-des-tests-individuellement">Ex√©cuter des tests individuellement</a></h4>
<!--
We can pass the name of any test function to `cargo test` to run only that test:
-->
<p>Nous pouvons donner le nom de n'importe quelle fonction de test √† <code>cargo test</code>
afin d'ex√©cuter uniquement ce test :</p>
<!--
```console
$ cargo test cent
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cent ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test cent
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cent ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<!--
Only the test with the name `one_hundred` ran; the other two tests didn‚Äôt match
that name. The test output lets us know we had more tests than what this
command ran by displaying `2 filtered out` at the end of the summary line.
-->
<p>Le test avec le nom <code>cent</code> est le seul ex√©cut√© ; les deux autres tests ne
correspondent pas √† ce nom. La sortie du test nous indique que nous avons
d'autres tests en plus de celui que cette commande a ex√©cut√© en affichant
<code>2 filtered out</code> √† la fin de la ligne de r√©sum√©.</p>
<!--
We can‚Äôt specify the names of multiple tests in this way; only the first value
given to `cargo test` will be used. But there is a way to run multiple tests.
-->
<p>Nous ne pouvons pas renseigner plusieurs noms de tests de cette mani√®re ; il
n'y a que la premi√®re valeur fournie √† <code>cargo test</code> qui sera utilis√©e. Mais
il existe un moyen d'ex√©cuter plusieurs tests.</p>
<!--
#### Filtering to Run Multiple Tests
-->
<h4 id="filtrer-pour-ex√©cuter-plusieurs-tests"><a class="header" href="#filtrer-pour-ex√©cuter-plusieurs-tests">Filtrer pour ex√©cuter plusieurs tests</a></h4>
<!--
We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests‚Äô names contain `add`, we can
run those two by running `cargo test add`:
-->
<p>Nous pouvons ne renseigner qu'une partie d'un nom de test, et tous les tests dont
les noms correspondent √† cette valeur vont √™tre ex√©cut√©s. Par exemple, comme
deux de nos noms de tests contiennent <code>ajouter</code>, nous pouvons ex√©cuter ces deux
en lan√ßant <code>cargo test ajouter</code> :</p>
<!--
```console
$ cargo test ajouter
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```
-->
<pre><code class="language-console">$ cargo test ajouter
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
</code></pre>
<!--
This command ran all tests with `add` in the name and filtered out the test
named `one_hundred`. Also note that the module in which a test appears becomes
part of the test‚Äôs name, so we can run all the tests in a module by filtering
on the module‚Äôs name.
-->
<p>Cette commande a lanc√© tous les tests qui contiennent <code>ajouter</code> dans leur nom
et a filtr√© le test <code>cent</code>. Notez aussi que le module dans lequel un test est
pr√©sent fait partie du nom du test, ainsi nous pouvons ex√©cuter tous les tests
d'un module en filtrant avec le nom du module.</p>
<!--
### Ignoring Some Tests Unless Specifically Requested
-->
<h3 id="ignorer-certains-tests-sauf-sils-sont-demand√©s-explicitement"><a class="header" href="#ignorer-certains-tests-sauf-sils-sont-demand√©s-explicitement">Ignorer certains tests sauf s'ils sont demand√©s explicitement</a></h3>
<!--
Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of `cargo test`. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the `ignore` attribute to exclude them, as shown
here:
-->
<p>Parfois, certains tests sp√©cifiques peuvent prendre beaucoup de temps √†
s'ex√©cuter, de sorte que vous voulez les exclure de la majorit√© des ex√©cutions
de <code>cargo test</code>. Plut√¥t que de lister en argument tous les tests que vous
souhaitez ex√©cuter, vous pouvez plut√¥t faire une annotation sur les tests qui
prennent du temps en utilisant l'attribut <code>ignore</code> pour les exclure, comme
ci-dessous :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn test_long() {
    // du code qui prend une heure √† s'ex√©cuter
}
```
-->
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn test_long() {
    // du code qui prend une heure √† s'ex√©cuter
}
</code></pre>
<!--
After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now
when we run our tests, `it_works` runs, but `expensive_test` doesn‚Äôt:
-->
<p>Apr√®s <code>#[test]</code>, nous avons ajout√© la ligne <code>#[ignore]</code> pour le test que nous
souhaitons exclure. Maintenant lorsque nous ex√©cutons nos tests, <code>it_works</code>
s'ex√©cute, mais pas <code>test_long</code> :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test test_long ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test test_long ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The `expensive_test` function is listed as `ignored`. If we want to run only
the ignored tests, we can use `cargo test -- --ignored`:
-->
<p>La fonction <code>test_long</code> est list√©e comme <code>ignored</code>. Si nous voulons ex√©cuter
uniquement les tests ignor√©s, nous pouvons utiliser <code>cargo test -- --ignored</code> :</p>
<!--
```console
$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test test_long ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test test_long ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
By controlling which tests run, you can make sure your `cargo test` results
will be fast. When you‚Äôre at a point where it makes sense to check the results
of the `ignored` tests and you have time to wait for the results, you can run
`cargo test -- --ignored` instead. If you want to run all tests whether they‚Äôre
ignored or not, you can run `cargo test -- --include-ignored`.
-->
<p>En g√©rant quels tests sont ex√©cut√©s, vous pouvez vous assurer que vos r√©sultats
de <code>cargo test</code> seront rapides. Lorsque vous arrivez √† un stade o√π il est
justifi√© de v√©rifier le r√©sultat des tests <code>ignored</code> et que vous avez le temps
d'attendre ces r√©sultats, vous pouvez lancer √† la place
<code>cargo test -- --ignored</code>. Si vous voulez ex√©cuter tous les tests q'uils soient
ignor√©s ou non, vous pouvez lancer <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Test Organization
-->
<h2 id="lorganisation-des-tests"><a class="header" href="#lorganisation-des-tests">L'organisation des tests</a></h2>
<!--
As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: *unit tests* and
*integration tests*. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.
-->
<p>Comme nous l'avons √©voqu√© au d√©but du chapitre, le test est une discipline
complexe, et diff√©rentes personnes utilisent des terminologies et organisations
diff√©rentes. La communaut√© Rust a con√ßu les tests dans deux cat√©gories
principales¬†: <em>les tests unitaires</em> et <em>les tests d'int√©gration</em>. Les tests
unitaires sont petits et plus pr√©cis, testent un module isol√© √† la fois, et
peuvent tester les interfaces priv√©es. Les tests d'int√©gration sont uniquement
externes √† notre biblioth√®que et consomment notre code exactement de la m√™me
mani√®re que tout autre code externe le ferait, en utilisant uniquement
l'interface publique et √©ventuellement en utilisant plusieurs modules dans un
test.</p>
<!--
Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.
-->
<p>L'√©criture de ces deux types de tests est importante pour s'assurer que chaque
√©l√©ment de notre biblioth√®que fait bien ce que vous attendiez d'eux, de
mani√®re isol√©e et conjugu√©e avec d'autres.</p>
<!--
### Unit Tests
-->
<h3 id="les-tests-unitaires"><a class="header" href="#les-tests-unitaires">Les tests unitaires</a></h3>
<!--
The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn‚Äôt working as
expected. You‚Äôll put unit tests in the *src* directory in each file with the
code that they‚Äôre testing. The convention is to create a module named `tests`
in each file to contain the test functions and to annotate the module with
`cfg(test)`.
-->
<p>Le but des tests unitaires est de tester chaque √©l√©ment du code de mani√®re
s√©par√©e du reste du code pour identifier rapidement o√π le code fonctionne
ou non comme pr√©vu. Vous devriez ins√©rer les tests unitaires dans le
dossier <em>src</em> dans chaque fichier, √† c√¥t√© du code qu'ils testent. La convention
est de cr√©er un module <code>tests</code> dans chaque fichier qui contient les fonctions
de test et de marquer le module avec <code>cfg(test)</code>.</p>
<!--
#### The Tests Module and `#[cfg(test)]`
-->
<h4 id="les-modules-de-tests-et-cfgtest"><a class="header" href="#les-modules-de-tests-et-cfgtest">Les modules de tests et <code>#[cfg(test)]</code></a></h4>
<!--
The `#[cfg(test)]` annotation on the tests module tells Rust to compile and run
the test code only when you run `cargo test`, not when you run `cargo build`.
This saves compile time when you only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. You‚Äôll
see that because integration tests go in a different directory, they don‚Äôt need
the `#[cfg(test)]` annotation. However, because unit tests go in the same files
as the code, you‚Äôll use `#[cfg(test)]` to specify that they shouldn‚Äôt be
included in the compiled result.
-->
<p>L'annotation <code>#[cfg(test)]</code> sur les modules de tests indique √† Rust de
compiler et d'ex√©cuter le code de test seulement lorsque vous lancez
<code>cargo test</code>, et non pas lorsque vous lancez <code>cargo build</code>. Cela diminue la
dur√©e de compilation lorsque vous souhaitez uniquement compiler la biblioth√®que
et cela r√©duit la taille dans l'artefact compil√© qui en r√©sulte car les tests
n'y sont pas int√©gr√©s. Vous verrez plus tard que comme les tests d'int√©gration
se placent dans un r√©pertoire diff√©rent, ils n'ont pas besoin de l'annotation
<code>#[cfg(test)]</code>. Cependant, comme les tests unitaires vont dans les m√™mes
fichiers que le code, vous devriez utiliser <code>#[cfg(test)]</code> pour marquer qu'ils
ne devraient pas √™tre inclus dans les r√©sultats de compilation.</p>
<!--
Recall that when we generated the new `adder` project in the first section of
this chapter, Cargo generated this code for us:
-->
<p>Souvenez-vous, lorsque nous avons g√©n√©r√© le nouveau projet <code>addition</code> dans la
premi√®re section de ce chapitre, Cargo a g√©n√©r√© ce code pour nous¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let resultat = 2 + 2;
        assert_eq!(resultat, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let resultat = 2 + 2;
        assert_eq!(resultat, 4);
    }
}
</code></pre>
<!--
This code is the automatically generated test module. The attribute `cfg`
stands for *configuration* and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is `test`, which is provided by Rust for compiling and
running tests. By using the `cfg` attribute, Cargo compiles our test code only
if we actively run the tests with `cargo test`. This includes any helper
functions that might be within this module, in addition to the functions
annotated with `#[test]`.
-->
<p>Ce code est le module de test g√©n√©r√© automatiquement. L'attribut <code>cfg</code> est
l'abr√©viation de <em>configuration</em> et indique √† Rust que l'√©l√©ment suivant ne
doit √™tre int√©gr√© que lorsqu'une certaine option de configuration est donn√©e. Dans
ce cas, l'option de configuration est <code>test</code>, qui est fournie par Rust pour la
compilation et l'ex√©cution des tests. En utilisant l'attribut <code>cfg</code>, Cargo
compile notre code de tests uniquement si nous avons ex√©cut√© les tests avec
<code>cargo test</code>. Cela inclut toutes les fonctions auxiliaires qui pourraient se
trouver dans ce module, en plus des fonctions marqu√©es d'un <code>#[test]</code>.</p>
<!--
#### Testing Private Functions
-->
<h4 id="tester-des-fonctions-priv√©es"><a class="header" href="#tester-des-fonctions-priv√©es">Tester des fonctions priv√©es</a></h4>
<!--
There‚Äôs debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust‚Äôs privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function `internal_adder`.
-->
<p>Il existe un d√©bat dans la communaut√© des testeurs au sujet de la n√©cessit√© ou non
de tester directement les fonctions priv√©es, et d'autres langages rendent
difficile, voir impossible, de tester les fonctions priv√©es. Quelle que soit
votre approche des tests, les r√®gles de protection de Rust vous permettent de
tester des fonctions priv√©es. Imaginons le code de l'encart 11-12 qui contient
la fonction priv√©e <code>addition_interne</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-12: Testing a private function</span>
-->
<p><span class="caption">Encart 11-12¬†: test d'une fonction priv√©e</span></p>
<!--
Note that the `internal_adder` function is not marked as `pub`. Tests are just
Rust code, and the `tests` module is just another module. As we discussed in
the [‚ÄúPaths for Referring to an Item in the Module Tree‚Äù][paths]<!-- ignore -- >
section, items in child modules can use the items in their ancestor modules. In
this test, we bring all of the `test` module‚Äôs parent‚Äôs items into scope with
`use super::*`, and then the test can call `internal_adder`. If you don‚Äôt think
private functions should be tested, there‚Äôs nothing in Rust that will compel
you to do so.
-->
<p>Remarquez que la fonction <code>addition_interne</code> n'est pas marqu√©e comme <code>pub</code>. Les
tests sont uniquement du code Rust, et le module <code>test</code> est simplement un autre
module. Comme nous l'avons vu dans <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">la section &quot;D√©signer un √©l√©ment dans
l'arborescence de modules&quot;</a><!-- ignore -->, les
√©l√©ments dans les modules enfants peuvent utiliser les √©l√©ments dans leurs
modules parents. Dans ce test, nous importons dans la port√©e tous les √©l√©ments
du parent du module <code>test</code> gr√¢ce √† <code>use super::*;</code>, permettant ensuite au test
de faire appel √† <code>addition_interne</code>. Si vous pensez qu'une fonction priv√©e ne
doit pas √™tre test√©e, il n'y a rien qui vous y force avec Rust.</p>
<!--
### Integration Tests
-->
<h3 id="les-tests-dint√©gration"><a class="header" href="#les-tests-dint√©gration">Les tests d'int√©gration</a></h3>
<!--
In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library‚Äôs public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a *tests* directory.
-->
<p>En Rust, les tests d'int√©gration sont exclusivement externes √† votre
biblioth√®que. Ils consomment votre biblioth√®que de la m√™me mani√®re que n'importe
quel autre code, ce qui signifie qu'ils ne peuvent appeler que les
fonctions qui font partie de l'interface de programmation applicative (API)
publique de votre biblioth√®que. Leur but est de tester si les multiples parties
de votre biblioth√®que fonctionnent correctement ensemble. Les portions de code
qui fonctionnent bien toutes seules pourraient rencontrer des probl√®mes une fois
imbriqu√©es avec d'autres, donc les tests qui couvrent l'int√©gration du code sont
tout aussi importants. Pour cr√©er des tests d'int√©gration, vous avez d'abord besoin
d'un dossier <em>tests</em>.</p>
<!--
#### The *tests* Directory
-->
<h4 id="le-dossier-tests"><a class="header" href="#le-dossier-tests">Le dossier <em>tests</em></a></h4>
<!--
We create a *tests* directory at the top level of our project directory, next
to *src*. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.
-->
<p>Nous cr√©ons un dossier <em>tests</em> au niveau le plus haut de notre dossier projet,
juste √† c√¥t√© de <em>src</em>. Cargo sait qu'il doit rechercher les fichiers de test
d'int√©gration dans ce dossier. Nous pouvons ensuite construire autant de
fichiers de test que nous le souhaitons dans ce dossier, et Cargo va compiler
chacun de ces fichiers comme une crate individuelle.</p>
<!--
Let‚Äôs create an integration test. With the code in Listing 11-12 still in the
*src/lib.rs* file, make a *tests* directory, create a new file named
*tests/integration_test.rs*, and enter the code in Listing 11-13.
-->
<p>Commen√ßons √† cr√©er un test d'int√©gration. Avec le code de l'encart 11-12
toujours pr√©sent dans le fichier <em>src/lib.rs</em>, cr√©ez un dossier <em>tests</em>, puis
un nouveau fichier <em>tests/test_integration.rs</em> et ins√©rez-y le code de l'encart
11-13.</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">Fichier¬†: tests/test_integration.rs</span></p>
<!--
```rust,ignore
use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
<span class="caption">Listing 11-13: An integration test of a function in the
`adder` crate</span>
-->
<p><span class="caption">Encart 11-13¬†: un test d'int√©gration d'une fonction
pr√©sente dans la crate <code>addition</code></span></p>
<!--
We‚Äôve added `use adder` at the top of the code, which we didn‚Äôt need in the
unit tests. The reason is that each file in the `tests` directory is a separate
crate, so we need to bring our library into each test crate‚Äôs scope.
-->
<p>Nous avons ajout√© <code>use addition</code> en haut du code, ce que nous n'avions pas
besoin de faire dans les tests unitaires. La raison √† cela est que chaque
fichier dans le dossier <code>tests</code> est une crate s√©par√©e, donc nous devons importer
notre biblioth√®que dans la port√©e de chaque crate de test.</p>
<!--
We don‚Äôt need to annotate any code in *tests/integration_test.rs* with
`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files
in this directory only when we run `cargo test`. Run `cargo test` now:
-->
<p>Nous n'avons pas besoin de marquer du code avec <code>#[cfg(test)]</code> dans
<em>tests/test_integration.rs</em>. Cargo traite le dossier <code>tests</code> de mani√®re
particuli√®re et compile les fichiers pr√©sents dans ce dossier uniquement si nous
lan√ßons <code>cargo test</code>. Lancez d√®s maintenant <code>cargo test</code>¬†:</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/addition-1082c4b063a8fbe6)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/addition-1082c4b063a8fbe6)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we‚Äôve been
seeing: one line for each unit test (one named `internal` that we added in
Listing 11-12) and then a summary line for the unit tests.
-->
<p>Les trois sections de la sortie concernent les tests unitaires, les tests
d'int√©gration et les tests de documentation. La premi√®re section relative aux
tests unitaires est la m√™me que celle que nous avons d√©j√† vue¬†: une ligne pour
chaque test unitaire (celui qui s'appelle <code>interne</code> que nous avons ins√©r√© dans
l'encart 11-12) suivie d'une ligne de r√©sum√© des tests unitaires.</p>
<!--
The integration tests section starts with the line `Running
target/debug/deps/integration_test-1082c4b063a8fbe6` (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the `Doc-tests adder` section starts.
-->
<p>La section des tests d'int√©gration commence avec la ligne <code>Running target/debug/deps/test_integration-1082c4b063a8fbe6</code> (le hachage √† la fin de
votre sortie pourrait √™tre diff√©rent). Ensuite, il y a une ligne pour chaque
fonction de test pr√©sente dans ce test d'int√©gration et une ligne de r√©sum√© pour
les r√©sultats des tests d'int√©gration, juste avant que la section
<code>Doc-tests addition</code> ne commence.</p>
<!--
Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test file‚Äôs section. Each
integration test file has its own section, so if we add more files in the
*tests* directory, there will be more integration test sections.
-->
<p>De la m√™me fa√ßon que plus vous ajoutiez de fonctions de tests unitaires et plus
vous aviez de lignes de r√©sultats dans la section des tests unitaires, plus
vous ajoutez des fonctions de tests aux fichiers de tests d'int√©gration et plus
vous obtenez de lignes de r√©sultat dans la section correspondant aux fichiers
des tests d'int√©gration. Chaque fichier de test d'int√©gration a sa propre section,
donc si nous ajoutons plus de fichiers dans le dossier <em>tests</em>, il y aura plus
de sections de tests d'int√©gration.</p>
<!--
We can still run a particular integration test function by specifying the test
function‚Äôs name as an argument to `cargo test`. To run all the tests in a
particular integration test file, use the `--test` argument of `cargo test`
followed by the name of the file:
-->
<p>Nous pouvons aussi ex√©cuter une fonction de test d'int√©gration pr√©cise en
utilisant le nom de la fonction de test comme argument √† <code>cargo test</code>. Pour
ex√©cuter tous les tests d'un fichier de tests d'int√©gration pr√©cis, utilisez
l'argument <code>--test</code> de <code>cargo test</code> suivi du nom du fichier¬†:</p>
<!--
```console
$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
This command runs only the tests in the *tests/integration_test.rs* file.
-->
<p>Cette commande ex√©cute seulement les tests dans le fichier
<em>tests/test_integration.rs</em>.</p>
<!--
#### Submodules in Integration Tests
-->
<h4 id="les-sous-modules-des-tests-dint√©gration"><a class="header" href="#les-sous-modules-des-tests-dint√©gration">Les sous-modules des tests d'int√©gration</a></h4>
<!--
As you add more integration tests, you might want to make more than one file in
the *tests* directory to help organize them; for example, you can group the
test functions by the functionality they‚Äôre testing. As mentioned earlier, each
file in the *tests* directory is compiled as its own separate crate.
-->
<p>Au fur et √† mesure que vous ajouterez des tests d'int√©gration, vous pourriez
avoir besoin de les diviser en plusieurs fichiers dans le dossier <em>tests</em> pour
vous aider √† les organiser¬†; par exemple, vous pouvez regrouper les fonctions
de test par fonctionnalit√©s qu'elles testent. Comme mentionn√© pr√©c√©demment,
chaque fichier dans le dossier <em>tests</em> est compil√© comme √©tant sa propre crate
s√©par√©e de tous les autres.</p>
<!--
Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the *tests* directory don‚Äôt share the same
behavior as files in *src* do, as you learned in Chapter 7 regarding how to
separate code into modules and files.
-->
<p>Le fait que chaque fichier de test d'int√©gration soit sa propre crate est utile
pour cr√©er des port√©es s√©par√©es qui ressemblent √† la mani√®re dont les
d√©veloppeurs vont consommer votre crate. Cependant, cela veut aussi dire que
les fichiers dans le dossier <em>tests</em> ne partagent pas le m√™me comportement que les
les fichiers dans <em>src</em>, comme vous l'avez appris au chapitre 7 √†
propos de la mani√®re de s√©parer le code dans des modules et des fichiers.</p>
<!--
The different behavior of files in the *tests* directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the [‚ÄúSeparating
Modules into Different Files‚Äù][separating-modules-into-files]<!-- ignore -- >
section of Chapter 7 to extract them into a common module. For example, if we
create *tests/common.rs* and place a function named `setup` in it, we can add
some code to `setup` that we want to call from multiple test functions in
multiple test files:
-->
<p>Ce comportement diff√©rent des fichiers dans le dossier <em>tests</em> est encore plus
notable lorsque vous avez un jeu de fonctions d'aide qui s'av√®rent utiles
pour plusieurs fichiers de test d'int√©gration et que vous essayez de suivre les
√©tapes de la section <a href="ch07-05-separating-modules-into-different-files.html">‚ÄúS√©parer les modules dans diff√©rents
fichiers‚Äù</a><!-- ignore --> du chapitre 7 afin de
les extraire dans un module en commun. Par exemple, si nous cr√©ons
<em>tests/commun.rs</em> et que nous y pla√ßons une fonction <code>parametrage</code> √†
l'int√©rieur, nous pourrions ajouter du code √† <code>parametrage</code> que nous voudrions
appeler √† partir de diff√©rentes fonctions de test dans diff√©rents fichiers de
test¬†:</p>
<!--
<span class="filename">Filename: tests/common.rs</span>
-->
<p><span class="filename">Fichier¬†: tests/commun.rs</span></p>
<!--
```rust
pub fn parametrage() {
    // code de param√©trage sp√©cifique √† vos tests de votre biblioth√®que ici
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parametrage() {
    // code de param√©trage sp√©cifique √† vos tests de votre biblioth√®que ici
}
<span class="boring">}
</span></code></pre></pre>
<!--
When we run the tests again, we‚Äôll see a new section in the test output for the
*common.rs* file, even though this file doesn‚Äôt contain any test functions nor
did we call the `setup` function from anywhere:
-->
<p>Lorsque nous lan√ßons les tests √† nouveau, nous allons voir une nouvelle section
dans la sortie des tests, correspondant au fichier <em>commun.rs</em>, m√™me si ce
fichier ne contient aucune fonction de test et que nous n'avons utilis√© nulle
part la fonction <code>parametrage</code>¬†:</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests (target/debug/deps/addition-92948b65e88960b4)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests (target/debug/deps/addition-92948b65e88960b4)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Having `common` appear in the test results with `running 0 tests` displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.
-->
<p>Nous ne voulons pas que <code>commun</code> apparaisse dans les r√©sultats, ni que cela
affiche <code>running 0 tests</code>. Nous voulons juste partager du code avec les autres
fichiers de test d'int√©gration.</p>
<!--
To avoid having `common` appear in the test output, instead of creating
*tests/common.rs*, we‚Äôll create *tests/common/mod.rs*. This is an alternate
naming convention that Rust also understands. Naming the file this way tells
Rust not to treat the `common` module as an integration test file. When we move
the `setup` function code into *tests/common/mod.rs* and delete the
*tests/common.rs* file, the section in the test output will no longer appear.
Files in subdirectories of the *tests* directory don‚Äôt get compiled as separate
crates or have sections in the test output.
-->
<p>Pour √©viter que <code>commun</code> s'affiche sur la sortie de test, au lieu de cr√©er le
fichier <em>tests/commun.rs</em>, nous allons cr√©er <em>tests/commun/mod.rs</em>. C'est
une convention de nommage alternative que Rust comprend aussi. Nommer le
fichier ainsi indique √† Rust de ne pas traiter le module <code>commun</code> comme un
fichier de test d'int√©gration. Lorsque nous d√©pla√ßons le code de la fonction
<code>parametrage</code> dans <em>tests/commun/mod.rs</em> et que nous supprimons le fichier
<em>tests/commun.rs</em>, la section dans la sortie des tests ne va plus s'afficher.
Les fichiers dans les sous-r√©pertoires du dossier <em>tests</em> ne seront pas
compil√©s comme √©tant une crate s√©par√©e et n'auront pas de sections dans la
sortie des tests.</p>
<!--
After we‚Äôve created *tests/common/mod.rs*, we can use it from any of the
integration test files as a module. Here‚Äôs an example of calling the `setup`
function from the `it_adds_two` test in *tests/integration_test.rs*:
-->
<p>Apr√®s avoir cr√©√© <em>tests/commun/mod.rs</em>, nous pouvons l'utiliser √† partir de
n'importe quel fichier de test d'int√©gration comme un module. Voici un
exemple d'appel √† la fonction <code>parametrage</code> √† partir du test
<code>cela_ajoute_deux</code> dans <em>tests/test_integration.rs</em>¬†:</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">Fichier¬†: tests/integration_test.rs</span></p>
<!--
```rust,ignore
use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
Note that the `mod common;` declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then in the test function, we can call the
`common::setup()` function.
-->
<p>Remarquez que la d√©claration <code>mod commun;</code> est la m√™me que la d√©claration d'un
module que nous avons montr√©e dans l'encart 7-21. Ensuite, dans la fonction
de tests, nous pouvons appeler la fonction <code>commun::parametrage</code>.</p>
<!--
#### Integration Tests for Binary Crates
-->
<h4 id="tests-dint√©gration-pour-les-crates-binaires"><a class="header" href="#tests-dint√©gration-pour-les-crates-binaires">Tests d'int√©gration pour les crates binaires</a></h4>
<!--
If our project is a binary crate that only contains a *src/main.rs* file and
doesn‚Äôt have a *src/lib.rs* file, we can‚Äôt create integration tests in the
*tests* directory and bring functions defined in the *src/main.rs* file into
scope with a `use` statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.
-->
<p>Si notre projet est une crate binaire qui contient uniquement un fichier
<em>src/main.rs</em> et n'a pas de fichier <em>src/lib.rs</em>, nous ne pouvons pas cr√©er
de tests d'int√©gration dans le dossier <em>tests</em> et importer les fonctions
d√©finies dans le fichier <em>src/main.rs</em> dans notre port√©e avec une instruction
<code>use</code>. Seules les crates de biblioth√®que exposent des fonctions que les autres
crates peuvent utiliser¬†; les crates binaires sont con√ßues pour √™tre ex√©cut√©es
de mani√®re isol√©e.</p>
<!--
This is one of the reasons Rust projects that provide a binary have a
straightforward *src/main.rs* file that calls logic that lives in the
*src/lib.rs* file. Using that structure, integration tests *can* test the
library crate with `use` to make the important functionality available.
If the important functionality works, the small amount of code in the
*src/main.rs* file will work as well, and that small amount of code doesn‚Äôt
need to be tested.
-->
<p>C'est une des raisons pour lesquelles les projets Rust qui fournissent un
binaire ont un simple fichier <em>src/main.rs</em> qui fait appel √† la logique
pr√©sente dans le fichier <em>src/lib.rs</em>. En utilisant cette structure, les tests
d'int√©gration <em>peuvent</em> tester la crate de biblioth√®que avec le <code>use</code> pour
importer les importantes fonctionnalit√©s disponibles. Si les fonctionnalit√©s
importantes fonctionnent, la petite portion de code dans le fichier
<em>src/main.rs</em> va fonctionner, et cette petite partie de code n'a pas besoin
d'√™tre test√©e.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-10"><a class="header" href="#r√©sum√©-10">R√©sum√©</a></h2>
<!--
Rust‚Äôs testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library‚Äôs public API to test the code
in the same way external code will use it. Even though Rust‚Äôs type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.
-->
<p>Les fonctionnalit√©s de test de Rust permettent de sp√©cifier comment le code
doit fonctionner pour garantir qu'il va continuer √† fonctionner comme vous le
souhaitez, m√™me si vous faites des changements. Les tests unitaires permettent
de tester s√©par√©ment diff√©rentes parties d'une biblioth√®que et peuvent tester
l'impl√©mentation des √©l√©ments priv√©s. Les tests d'int√©gration v√©rifient que de
nombreuses parties de la biblioth√®que fonctionnent correctement ensemble, et
ils utilisent l'API publique de la biblioth√®que pour tester le code, de la m√™me
mani√®re  que le ferait du code externe qui l'utiliserait. M√™me si le syst√®me de
type de Rust et les r√®gles de possession aident √† emp√™cher certains types de
bogues, les tests restent toujours importants pour r√©duire les bogues de
logique concernant le comportement attendu de votre code.</p>
<!--
Let‚Äôs combine the knowledge you learned in this chapter and in previous
chapters to work on a project!
-->
<p>Et maintenant, combinons le savoir que vous avez accumul√© dans ce chapitre et
dans les chapitres pr√©c√©dents en travaillant sur un nouveau projet¬†!</p>
<!--
[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[separating-modules-into-files]:
ch07-05-separating-modules-into-different-files.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# An I/O Project: Building a Command Line Program
-->
<h1 id="un-projet-dentr√©esortie--construire-un-programme-en-ligne-de-commande"><a class="header" href="#un-projet-dentr√©esortie--construire-un-programme-en-ligne-de-commande">Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></h1>
<!--
This chapter is a recap of the many skills you‚Äôve learned so far and an
exploration of a few more standard library features. We‚Äôll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.
-->
<p>Ce chapitre est un r√©sum√© de toutes les nombreuses comp√©tences que vous avez
apprises pr√©c√©demment et une d√©couverte de quelques fonctionnalit√©s
suppl√©mentaires de la biblioth√®que standard. Nous allons construire un outil en
ligne de commande qui interagit avec des fichiers et les entr√©es/sorties de la
ligne de commande pour mettre en pratique certains concepts Rust dont vous avez
maintenant connaissance.</p>
<!--
Rust‚Äôs speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, we‚Äôll
make our own version of the classic command line tool `grep` (**g**lobally
search a **r**egular **e**xpression and **p**rint). In the simplest use case,
`grep` searches a specified file for a specified string. To do so, `grep` takes
as its arguments a filename and a string. Then it reads the file, finds lines
in that file that contain the string argument, and prints those lines.
-->
<p>Sa rapiditi√©, ses fonctionnalit√©s de s√©curit√©, sa sortie binaire unifi√©e et sa prise
en charge de multiples plateformes font de Rust le langage id√©al pour cr√©er des outils
en ligne de commande, donc pour notre projet, nous allons construire notre
version de l'outil en ligne de commande <code>grep</code> (qui signifie <strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint, soit <em>recherche globale et
affichage d'une expression r√©guli√®re</em>). Dans des cas d'usage tr√®s simple,
<code>grep</code> recherche une cha√Æne de caract√®res pr√©cise dans un fichier pr√©cis. Pour
ce faire, <code>grep</code> prend en argument un nom de fichier et une cha√Æne de
caract√®res. Ensuite, il lit le fichier, trouve les lignes de ce fichier qui
contiennent la cha√Æne de caract√®res pass√©e en argument, puis affiche ces lignes.</p>
<!--
Along the way, we‚Äôll show how to make our command line tool use features of the
terminal that many command line tools use. We‚Äôll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We‚Äôll also print error messages to the standard error console stream (`stderr`)
instead of standard output (`stdout`), so, for example, the user can redirect
successful output to a file while still seeing error messages onscreen.
-->
<p>En chemin, nous allons vous montrer comment utiliser dans votre outil en
ligne de commande les fonctionnalit√©s des terminaux que de nombreux outils en
ligne de commande utilisent. Nous allons lire la valeur d'une variable
d'environnement pour permettre √† l'utilisateur de configurer le comportement de
notre outil. Nous allons aussi afficher des messages d'erreur vers le flux
d'erreur standard de la console (<code>stderr</code>) plut√¥t que vers la sortie standard
(<code>stdout</code>), pour, par exemple, que l'utilisateur puisse rediriger la sortie
fructueuse vers un fichier, tout en affichant les messages d'erreur √† l'√©cran.</p>
<!--
One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of `grep`, called `ripgrep`. By comparison, our
version of `grep` will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project such as
`ripgrep`.
-->
<p>Un membre de la communaut√© Rust, Andrew Gallant, a d√©j√† cr√©√© une version
compl√®te et tr√®s performante de <code>grep</code>, qu'il a appel√©e <code>ripgrep</code>. En
comparaison, notre version de <code>grep</code> sera plut√¥t simple, mais ce chapitre va
vous donner les connaissances de base dont vous avez besoin pour appr√©hender
un projet r√©el comme <code>ripgrep</code>.</p>
<!--
Our `grep` project will combine a number of concepts you‚Äôve learned so far:
-->
<p>Notre projet <code>grep</code> va combiner un certain nombre de concepts que vous avez
d√©j√† acquis √† ce stade¬†:</p>
<!--
* Organizing code (using what you learned about modules in [Chapter 7][ch7]<!--
  ignore -- >)
* Using vectors and strings (collections, [Chapter 8][ch8]<!-- ignore -- >)
* Handling errors ([Chapter 9][ch9]<!-- ignore -- >)
* Using traits and lifetimes where appropriate ([Chapter 10][ch10]<!-- ignore
  -- >)
* Writing tests ([Chapter 11][ch11]<!-- ignore -- >)
-->
<ul>
<li>Organiser le code (en utilisant ce que vous avez appris sur les modules au
<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">chapitre 7</a><!-- ignore -->)</li>
<li>Utiliser les vecteurs et les cha√Ænes de caract√®res (les collections du
<a href="ch08-00-common-collections.html">chapitre 8</a><!-- ignore -->)</li>
<li>G√©rer les erreurs (<a href="ch09-00-error-handling.html">chapitre 9</a><!-- ignore -->)</li>
<li>Utiliser les traits et les dur√©es de vie lorsque c'est appropri√©
(<a href="ch10-00-generics.html">chapitre 10</a><!-- ignore -->)</li>
<li>Ecrire les tests (<a href="ch11-00-testing.html">chapitre 11</a><!-- ignore -->)</li>
</ul>
<!--
We‚Äôll also briefly introduce closures, iterators, and trait objects, which
Chapters [13][ch13]<!-- ignore -- > and [17][ch17]<!-- ignore -- > will cover in
detail.
-->
<p>Nous vous pr√©senterons aussi bri√®vement les fermetures, les it√©rateurs et les
objets de trait, que les chapitres <a href="ch13-00-functional-features.html">13</a><!-- ignore --> et
<a href="ch17-00-oop.html">17</a><!-- ignore --> traiteront en d√©tails.</p>
<!--
[ch7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[ch8]: ch08-00-common-collections.html
[ch9]: ch09-00-error-handling.html
[ch10]: ch10-00-generics.html
[ch11]: ch11-00-testing.html
[ch13]: ch13-00-functional-features.html
[ch17]: ch17-00-oop.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Accepting Command Line Arguments
-->
<h2 id="r√©cup√©rer-les-arguments-de-la-ligne-de-commande"><a class="header" href="#r√©cup√©rer-les-arguments-de-la-ligne-de-commande">R√©cup√©rer les arguments de la ligne de commande</a></h2>
<!--
Let‚Äôs create a new project with, as always, `cargo new`. We‚Äôll call our project
`minigrep` to distinguish it from the `grep` tool that you might already have
on your system.
-->
<p>Cr√©ons un nouveau projet comme √† l'accoutum√©e avec <code>cargo new</code>. Appelons
notre projet <code>minigrep</code> pour le distinguer de l'outil <code>grep</code> que vous avez
probablement d√©j√† sur votre syst√®me.</p>
<!--
```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```
-->
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<!--
The first task is to make `minigrep` accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with `cargo run`, a string to search for, and a path to a file to
search in, like so:
-->
<p>La premi√®re t√¢che est de faire en sorte que <code>minigrep</code> utilise ses deux
arguments en ligne de commande¬†: le nom du fichier et la cha√Æne de caract√®res √†
rechercher. Autrement dit, nous voulons pouvoir ex√©cuter notre programme avec
<code>cargo run</code>, une cha√Æne de caract√®res √† rechercher, et un chemin vers un
fichier dans lequel chercher, comme ceci¬†:</p>
<!--
```console
$ cargo run searchstring example-filename.txt
```
-->
<pre><code class="language-console">$ cargo run chaine_a_chercher fichier-exemple.txt
</code></pre>
<!--
Right now, the program generated by `cargo new` cannot process arguments we
give it. Some existing libraries on [crates.io](https://crates.io/) can help
with writing a program that accepts command line arguments, but because you‚Äôre
just learning this concept, let‚Äôs implement this capability ourselves.
-->
<p>Pour l'instant, le programme g√©n√©r√© par <code>cargo new</code> ne peut pas traiter les
arguments que nous lui donnons. Certaines biblioth√®ques qui existent sur
<a href="https://crates.io/">crates.io</a> peuvent vous aider √† √©crire un programme
qui prend des arguments en ligne de commande, mais comme vous apprenez
juste ce concept, impl√©mentons cette capacit√© par nous-m√™mes.</p>
<!--
### Reading the Argument Values
-->
<h3 id="lire-les-valeurs-des-arguments"><a class="header" href="#lire-les-valeurs-des-arguments">Lire les valeurs des arguments</a></h3>
<!--
To enable `minigrep` to read the values of command line arguments we pass to
it, we‚Äôll need a function provided in Rust‚Äôs standard library, which is
`std::env::args`. This function returns an iterator of the command line
arguments that were given to `minigrep`. We‚Äôll cover iterators fully in
[Chapter 13][ch13]<!-- ignore -- >. For now, you only need to know two details
about iterators: iterators produce a series of values, and we can call the
`collect` method on an iterator to turn it into a collection, such as a vector,
containing all the elements the iterator produces.
-->
<p>Pour permettre √† <code>minigrep</code> de lire les valeurs des arguments de la ligne de
commande que nous lui envoyons, nous allons avoir besoin d'une fonction fournie
par la biblioth√®que standard de Rust, qui est <code>std::env::args</code>. Cette fonction
retourne un it√©rateur des arguments de la ligne de commande qui ont √©t√© donn√©s
√† <code>minigrep</code>. Nous verrons les it√©rateurs plus pr√©cis√©ment au
<a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->. Pour l'instant, vous avez juste √† savoir
deux choses √† propos des it√©rateurs¬†: les it√©rateurs engendrent une s√©rie de
valeurs, et nous pouvons appeler la m√©thode <code>collect</code> sur un it√©rateur pour le
transformer en collection, comme les vecteurs, qui contiennent tous les
√©l√©ments qu'un it√©rateur engendrent.</p>
<!--
Use the code in Listing 12-1 to allow your `minigrep` program to read any
command line arguments passed to it and then collect the values into a vector.
-->
<p>Utilisez le code de l'encart 12-1 pour permettre √† votre programme <code>minigrep</code>
de lire tous les arguments qui lui sont envoy√©s et ensuite collecter les
valeurs dans un vecteur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span>
-->
<p><span class="caption">Encart 12-1¬†: Collecter les arguments de la ligne de
commande dans un vecteur et les afficher</span></p>
<!--
First, we bring the `std::env` module into scope with a `use` statement so we
can use its `args` function. Notice that the `std::env::args` function is
nested in two levels of modules. As we discussed in [Chapter
7][ch7-idiomatic-use]<!-- ignore -- >, in cases where the desired function is
nested in more than one module, it‚Äôs conventional to bring the parent module
into scope rather than the function. By doing so, we can easily use other
functions from `std::env`. It‚Äôs also less ambiguous than adding `use
std::env::args` and then calling the function with just `args`, because `args`
might easily be mistaken for a function that‚Äôs defined in the current module.
-->
<p>D'abord, nous importons le module <code>std::env</code> dans la port√©e avec une
instruction <code>use</code> afin que nous puissions utiliser sa fonction <code>args</code>. Notez
que la fonction <code>std::env::args</code> est imbriqu√©e sur deux niveaux de modules.
Comme nous l'avons vu dans le <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html">chapitre 7</a><!-- ignore -->,
il est courant d'importer le module parent dans la port√©e plut√¥t que la
fonction. En faisant ainsi, nous pouvons facilement utiliser les autres
fonctions de <code>std::env</code>. C'est aussi moins ambig√º que d'importer uniquement
<code>std::env::args</code> et ensuite d'appeler la fonction avec seulement <code>args</code>, car
<code>args</code> peu facilement √™tre confondu avec une fonction qui est d√©finie dans le
module courant.</p>
<!--
> ### The `args` Function and Invalid Unicode
>
> Note that `std::env::args` will panic if any argument contains invalid
> Unicode. If your program needs to accept arguments containing invalid
> Unicode, use `std::env::args_os` instead. That function returns an iterator
> that produces `OsString` values instead of `String` values. We‚Äôve chosen to
> use `std::env::args` here for simplicity, because `OsString` values differ
> per platform and are more complex to work with than `String` values.
-->
<blockquote>
<h3 id="la-fonction-args-et-lunicode-invalide"><a class="header" href="#la-fonction-args-et-lunicode-invalide">La fonction <code>args</code> et l'unicode invalide</a></h3>
<p>Notez que <code>std::env::args</code> va paniquer si un des arguments contient de
l'unicode invalide. Si votre programme a besoin d'utiliser des arguments qui
contiennent de l'unicode invalide, utilisez plut√¥t <code>std::env::args_os</code> √† la
place. Cette fonction retourne un it√©rateur qui engendre des valeurs <code>OsString</code>
plut√¥t que des valeurs <code>String</code>. Nous avons choisi d'utiliser ici
<code>std::env::args</code> par simplicit√©, car les valeurs <code>OsString</code> diff√®rent selon
la plateforme et c'est plus complexe de travailler avec par rapport aux
valeurs de type <code>String</code>.</p>
</blockquote>
<!--
On the first line of `main`, we call `env::args`, and we immediately use
`collect` to turn the iterator into a vector containing all the values produced
by the iterator. We can use the `collect` function to create many kinds of
collections, so we explicitly annotate the type of `args` to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, `collect` is one function you do often need to annotate because Rust
isn‚Äôt able to infer the kind of collection you want.
-->
<p>Dans la premi√®re ligne du <code>main</code>, nous appelons <code>env::args</code>, et nous utilisons
imm√©diatement <code>collect</code> pour retourner un it√©rateur dans un vecteur qui
contient toutes les valeurs engendr√©es par l'it√©rateur. Nous pouvons utiliser
la fonction <code>collect</code> pour cr√©er n'importe quel genre de collection, donc nous
avons annot√© explicitement le type de <code>args</code> pour pr√©ciser que nous attendions
un vecteur de cha√Ænes de caract√®res. Bien que nous n'ayons que tr√®s
rarement d'annoter les types en Rust, <code>collect</code> est une fonction que vous
aurez souvent besoin d'annoter car Rust n'est pas capable de d√©duire le type
de collection que vous attendez.</p>
<!--
Finally, we print the vector using the debug formatter, `:?`. Let‚Äôs try running
the code first with no arguments and then with two arguments:
-->
<p>Enfin, nous affichons le vecteur en utilisant la cha√Æne de formatage <code>:?</code>.
Essayons d'abord de lancer le code sans arguments, puis ensuite avec deux
arguments¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
["target/debug/minigrep"]
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[&quot;target/debug/minigrep&quot;]
</code></pre>
<!--
```console
$ cargo run aiguille botte_de_foin
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep aiguille botte_de_foin`
["target/debug/minigrep", "aiguille", "botte_de_foin"]
```
-->
<pre><code class="language-console">$ cargo run aiguille botte_de_foin
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep aiguille botte_de_foin`
[&quot;target/debug/minigrep&quot;, &quot;aiguille&quot;, &quot;botte_de_foin&quot;]
</code></pre>
<!--
Notice that the first value in the vector is `"target/debug/minigrep"`, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It‚Äôs often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we‚Äôll ignore it and save only the two arguments we need.
-->
<p>Remarquez que la premi√®re valeur dans le vecteur est
<code>&quot;target/debug/minigrep&quot;</code>, qui est le nom de notre binaire. Cela correspond
au fonctionnement de la liste d'arguments en C, qui laissent les programmes
utiliser le nom sous lequel ils ont √©t√© invoqu√©s dans leur ex√©cution. C'est
parfois pratique pour avoir acc√®s au nom du programme dans le cas o√π vous
souhaitez l'afficher dans des messages, ou changer le comportement du programme
en fonction de ce que l'alias de la ligne de commande utilise pour invoquer le
programme. Mais pour les besoins de ce chapitre, nous allons l'ignorer et
r√©cup√©rer uniquement les deux arguments dont nous avons besoin.</p>
<!--
### Saving the Argument Values in Variables
-->
<h3 id="enregistrer-les-valeurs-des-arguments-dans-des-variables"><a class="header" href="#enregistrer-les-valeurs-des-arguments-dans-des-variables">Enregistrer les valeurs des arguments dans des variables</a></h3>
<!--
Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2.
-->
<p>L'affichage des valeurs du vecteur des arguments nous a d√©montr√© que le
programme peut avoir acc√®s aux valeurs envoy√©es en arguments d'une ligne de
commande. Maintenant, nous avons besoin d'enregistrer les valeurs des deux
arguments dans des variables afin que nous puissions utiliser les valeurs pour
le reste du programme. C'est que nous faisons dans l'encart 12-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let recherche = &args[1];
    let nom_fichier = &args[2];

    println!("On recherche¬†: {}", recherche);
    println!("Dans le fichier¬†: {}", nom_fichier);
}
```
-->
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    println!(&quot;On recherche¬†: {}&quot;, recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, nom_fichier);
}
</code></pre>
<!--
<span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span>
-->
<p><span class="caption">Encart 12-2¬†: Cr√©ation de variables pour r√©cup√©rer
les arguments recherche et nom_fichier</span></p>
<!--
As we saw when we printed the vector, the program‚Äôs name takes up the first
value in the vector at `args[0]`, so we‚Äôre starting at index `1`. The first
argument `minigrep` takes is the string we‚Äôre searching for, so we put a
reference to the first argument in the variable `query`. The second argument
will be the filename, so we put a reference to the second argument in the
variable `filename`.
-->
<p>Comme nous l'avons vu lorsque nous avons affich√© le vecteur, le nom du
programme prend la premi√®re valeur dans le vecteur, dans <code>args[0]</code>, donc nous
allons commencer √† l'indice <code>1</code>. Le premier argument que prend <code>minigrep</code> est
la cha√Æne de caract√®res que nous recherchons, donc nous ins√©rons la r√©f√©rence
vers le premier argument dans la variable <code>recherche</code>. Le second argument sera
le nom du fichier, donc nous ins√©rons une r√©f√©rence vers le second argument
dans la variable <code>nom_fichier</code>.</p>
<!--
We temporarily print the values of these variables to prove that the code is
working as we intend. Let‚Äôs run this program again with the arguments `test`
and `sample.txt`:
-->
<p>Nous affichons temporairement les valeurs de ces variables pour prouver que le
code fonctionne bien comme nous le souhaitons. Lan√ßons √† nouveau ce programme
avec les arguments <code>test</code> et <code>example.txt</code>¬†:</p>
<!--
```console
$ cargo run test exemple.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test exemple.txt`
On recherche¬†: test
Dans le fichier¬†: exemple.txt
```
-->
<pre><code class="language-console">$ cargo run test exemple.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test exemple.txt`
On recherche¬†: test
Dans le fichier¬†: exemple.txt
</code></pre>
<!--
Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we‚Äôll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we‚Äôll ignore that situation and work on adding file-reading
capabilities instead.
-->
<p>Tr√®s bien, notre programme fonctionne¬†! Les valeurs des arguments dont nous
avons besoin sont enregistr√©es dans les bonnes variables. Plus tard, nous
allons ajouter de la gestion d'erreurs pour pallier aux potentielles situations
d'erreurs, comme lorsque l'utilisateur ne fournit pas d'arguments¬†; pour le
moment, nous allons ignorer ces situations et continuer √† travailler pour
l'ajout d'une capacit√© de lecture de fichier, √† la place.</p>
<!--
[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Reading a File
-->
<h2 id="lire-un-fichier"><a class="header" href="#lire-un-fichier">Lire un fichier</a></h2>
<!--
Now we‚Äôll add functionality to read the file that is specified in the
`filename` command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure `minigrep` is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
*poem.txt* at the root level of your project, and enter the poem ‚ÄúI‚Äôm Nobody!
Who are you?‚Äù
-->
<p>Maintenant, nous allons ajouter une fonctionnalit√© pour lire le fichier qui est
renseign√© dans l'argument <code>nom_fichier</code> de la ligne de commande. D'abord, nous
avons besoin d'un fichier d'exemple pour le tester¬†: le meilleur type de
fichier pour s'assurer que <code>minigrep</code> fonctionne est un fichier avec une petite
quantit√© de texte sur plusieurs lignes avec quelques mots r√©p√©t√©s. L'encart 12-3
pr√©sente un po√®me en Anglais de Emily Dickinson qui fonctionnera bien pour ce
test¬†! Cr√©ez un fichier <em>poem.txt</em> √† la racine de votre projet, et saisissez ce
po√®me ‚ÄúI‚Äôm Nobody! Who are you?‚Äù.</p>
<!--
<span class="filename">Filename: poem.txt</span>
-->
<p><span class="filename">Filename: poem.txt</span></p>
<!--
```text
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```
-->
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
<span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test
case</span>
-->
<p><span class="caption">Encart 12-3¬†: Un po√®me Anglais d'Emily Dickinson qui fait
un bon sujet d'essai</span></p>
<!--
With the text in place, edit *src/main.rs* and add code to read the file, as
shown in Listing 12-4.
-->
<p>Une fois ce texte enregistr√©, √©ditez le <em>src/main.rs</em> et ajoutez-y le code pour
lire le fichier, comme indiqu√© dans l'encart 12-4.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
use std::env;
use std::fs;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let query = &args[1];
#     let filename = &args[2];
# 
#     println!("Searching for {}", query);
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}
```
-->
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // -- partie masqu√©e ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let recherche = &amp;args[1];
</span><span class="boring">    let nom_fichier = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, recherche);
</span>    println!(&quot;Dans le fichier¬†: {}&quot;, nom_fichier);

    let contenu = fs::read_to_string(nom_fichier)
        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte¬†:\n{}&quot;, contenu);
}
</code></pre>
<!--
<span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span>
-->
<p><span class="caption">Encart 12-4¬†: Lecture du contenu du fichier renseign√© en
second argument</span></p>
<!--
First, we add another `use` statement to bring in a relevant part of the
standard library: we need `std::fs` to handle files.
-->
<p>Premi√®rement, nous ajoutons une autre instruction <code>use</code> pour importer une
partie significative de la biblioth√®que standard¬†: nous avons besoin de
<code>std::fs</code> pour manipuler les fichiers.</p>
<!--
In `main`, we‚Äôve added a new statement: `fs::read_to_string` takes the
`filename`, opens that file, and returns a `Result<String>` of the file‚Äôs
contents.
-->
<p>Dans le <code>main</code>, nous avons ajout√© une nouvelle instruction¬†:
<code>fs::read_to_string</code> qui prend le <code>nom_fichier</code>, ouvre ce fichier, et retourne
un <code>Result&lt;String&gt;</code> du contenu du fichier.</p>
<!--
After that statement, we‚Äôve again added a temporary `println!` statement that
prints the value of `contents` after the file is read, so we can check that the
program is working so far.
-->
<p>Apr√®s cette instruction, nous avons ajout√© √† nouveau une instruction <code>println!</code>
qui affiche la valeur de <code>contenu</code> apr√®s la lecture de ce fichier, afin que
nous puissions v√©rifier que ce programme fonctionne correctement.</p>
<!--
Let‚Äôs run this code with any string as the first command line argument (because
we haven‚Äôt implemented the searching part yet) and the *poem.txt* file as the
second argument:
-->
<p>Ex√©cutons ce code avec n'importe quelle cha√Æne de caract√®res dans le premier
argument de la ligne de commande (car nous n'avons pas encore impl√©ment√© la
partie de recherche pour l'instant), ainsi que le fichier <em>poem.txt</em> en
second argument¬†:</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
On recherche¬†: the
Dans le fichier¬†: poem.txt
Dans le texte¬†:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Great! The code read and then printed the contents of the file. But the code
has a few flaws. The `main` function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we‚Äôre not handling errors as well
as we could. The program is still small, so these flaws aren‚Äôt a big problem,
but as the program grows, it will be harder to fix them cleanly. It‚Äôs good
practice to begin refactoring early on when developing a program, because it‚Äôs
much easier to refactor smaller amounts of code. We‚Äôll do that next.
-->
<p>Tr√®s bien¬†! Notre code lit et affiche ensuite le contenu du fichier. Mais le
code a quelques d√©fauts. La fonction <code>main</code> a plusieurs responsabilit√©s¬†:
g√©n√©ralement, les r√¥les des fonctions sont plus clairs et faciles √† entretenir
si chaque fonction est en charge d'une seule t√¢che. L'autre probl√®me est que
nous ne g√©rons pas les erreurs correctement. Le programme est encore tr√®s
modeste, donc ces imperfections ne sont pas un gros probl√®me, mais d√®s que le
programme va grossir, il sera plus difficile de les corriger proprement. Le
remaniement du code tr√®s t√¥t lors du d√©veloppement d'un logiciel est une bonne
pratique, car c'est beaucoup plus facile de remanier des petites portions de
code. C'est ce que nous allons faire d√®s maintenant.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Refactoring to Improve Modularity and Error Handling
-->
<h2 id="remanier-le-code-pour-am√©liorer-sa-modularit√©-et-la-gestion-des-erreurs"><a class="header" href="#remanier-le-code-pour-am√©liorer-sa-modularit√©-et-la-gestion-des-erreurs">Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></h2>
<!--
To improve our program, we‚Äôll fix four problems that have to do with the
program‚Äôs structure and how it‚Äôs handling potential errors.
-->
<p>Pour am√©liorer notre programme, nous allons r√©soudre quatre probl√®mes li√©s
√† la structure du programme et √† la fa√ßon dont il g√®re de potentielles erreurs.</p>
<!--
First, our `main` function now performs two tasks: it parses arguments and
reads files. For such a small function, this isn‚Äôt a major problem. However, if
we continue to grow our program inside `main`, the number of separate tasks the
`main` function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It‚Äôs best to separate functionality so each
function is responsible for one task.
-->
<p>Premi√®rement, notre fonction <code>main</code> assure deux t√¢ches¬†: elle interpr√®te les
arguments et elle lit des fichiers. Pour une fonction aussi petite, ce n'est
pas un probl√®me majeur. Cependant, si nous continuons √† faire grossir notre
programme dans le <code>main</code>, le nombre des diff√©rentes t√¢ches qu'assure la
fonction <code>main</code> va continuer √† s'agrandir. Plus une fonction assure des
t√¢ches diff√©rentes, plus cela devient difficile de la comprendre, de la tester,
et d'y faire des changements sans casser ses autres constituants. Cela est
mieux de s√©parer les fonctionnalit√©s afin que chaque fonction n'assure qu'une
seule t√¢che.</p>
<!--
This issue also ties into the second problem: although `query` and `filename`
are configuration variables to our program, variables like `contents` are used
to perform the program‚Äôs logic. The longer `main` becomes, the more variables
we‚Äôll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It‚Äôs best to group the
configuration variables into one structure to make their purpose clear.
-->
<p>Cette probl√©matique est aussi li√©e au deuxi√®me probl√®me¬†: bien que <code>recherche</code> et
<code>nom_fichier</code> soient des variables de configuration de notre programme, les
variables telles que <code>contenu</code> sont utilis√©es pour appuyer la logique du
programme. Plus <code>main</code> est grand, plus nous aurons des variables √† importer
dans la port√©e¬†; plus nous avons des variables dans notre port√©e, plus il sera
difficile de se souvenir √† quoi elles servent. Il est pr√©f√©rable de regrouper
les variables de configuration dans une structure pour clarifier leur usage.</p>
<!--
The third problem is that we‚Äôve used `expect` to print an error message when
reading the file fails, but the error message just prints `Something went wrong
reading the file`. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, we‚Äôd print the `Something went wrong reading
the file` error message, which wouldn‚Äôt give the user any information!
-->
<p>Le troisi√®me probl√®me est que nous avons utilis√© <code>expect</code> pour afficher un
message d'erreur lorsque la lecture du fichier √©choue, mais le message affiche
uniquement <code>Quelque chose s'est mal pass√© lors de la lecture du fichier</code>. Lire
un fichier peut √©chouer pour de nombreuses raisons¬†: par exemple, le fichier
peut ne pas exister, ou parce que nous n'avons pas le droit de l'ouvrir. Pour
le moment, quelle que soit la raison, nous affichons le message d'erreur
<code>Quelque chose s'est mal pass√© lors de la lecture du fichier</code>, ce qui ne donne
aucune information √† l'utilisateur¬†!</p>
<!--
Fourth, we use `expect` repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they‚Äôll get an `index out
of bounds` error from Rust that doesn‚Äôt clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we‚Äôre printing messages that will be meaningful to our end users.
-->
<p>Quatri√®mement, nous utilisons <code>expect</code> √† r√©p√©tition pour g√©rer les diff√©rentes
erreurs, et si l'utilisateur lance notre programme sans renseigner d'arguments,
il va avoir une erreur <code>index out of bounds</code> provenant de Rust, qui n'explique
pas clairement le probl√®me. Il serait plus judicieux que tout le code de gestion
des erreurs se trouve au m√™me endroit afin que les futurs mainteneurs n'aient
qu'un seul endroit √† consulter dans le code si la logique de gestion des
erreurs doit √™tre modifi√©e. Avoir tout le code de gestion des erreurs dans un
seul endroit va aussi garantir que nous affichons des messages qui ont du sens
pour les utilisateurs.</p>
<!--
Let‚Äôs address these four problems by refactoring our project.
-->
<p>Corrigeons ces quatre probl√®mes en remaniant notre projet.</p>
<!--
### Separation of Concerns for Binary Projects
-->
<h3 id="s√©paration-des-t√¢ches-des-projets-de-binaires"><a class="header" href="#s√©paration-des-t√¢ches-des-projets-de-binaires">S√©paration des t√¢ches des projets de binaires</a></h3>
<!--
The organizational problem of allocating responsibility for multiple tasks to
the `main` function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when `main` starts getting large. The
process has the following steps:
-->
<p>Le probl√®me de l'organisation de la r√©partition des t√¢ches multiples dans la
fonction <code>main</code> est commun √† de nombreux projets binaires. En cons√©quence, la
communaut√© Rust a d√©velopp√© une proc√©dure √† utiliser comme ligne conductrice
pour partager les t√¢ches d'un programme binaire lorsque <code>main</code> commence √†
grossir. Le processus se d√©compose selon les √©tapes suivantes¬†:</p>
<!--
* Split your program into a *main.rs* and a *lib.rs* and move your program‚Äôs
  logic to *lib.rs*.
* As long as your command line parsing logic is small, it can remain in
  *main.rs*.
* When the command line parsing logic starts getting complicated, extract it
  from *main.rs* and move it to *lib.rs*.
-->
<ul>
<li>Diviser votre programme dans un <em>main.rs</em> et un <em>lib.rs</em> et d√©placer la
logique de votre programme dans <em>lib.rs</em>.</li>
<li>Tant que votre logique d'interpr√©tation de la ligne de commande est peu
volumineuse, elle peut rester dans le <em>main.rs</em></li>
<li>Lorsque la logique d'interpr√©tation de la ligne de commande commence √† devenir
compliqu√©e, il faut la d√©placer du <em>main.rs</em> vers le <em>lib.rs</em>.</li>
</ul>
<!--
The responsibilities that remain in the `main` function after this process
should be limited to the following:
-->
<p>Les fonctionnalit√©s qui restent dans la fonction <code>main</code> apr√®s cette proc√©dure
seront les suivantes¬†:</p>
<!--
* Calling the command line parsing logic with the argument values
* Setting up any other configuration
* Calling a `run` function in *lib.rs*
* Handling the error if `run` returns an error
-->
<ul>
<li>Appeler la logique d'interpr√©tation de ligne de commande avec les valeurs des
arguments</li>
<li>R√©gler toutes les autres configurations</li>
<li>Appeler une fonction <code>run</code> de <em>lib.rs</em></li>
<li>G√©rer l'erreur si <code>run</code> retourne une erreur</li>
</ul>
<!--
This pattern is about separating concerns: *main.rs* handles running the
program, and *lib.rs* handles all the logic of the task at hand. Because you
can‚Äôt test the `main` function directly, this structure lets you test all of
your program‚Äôs logic by moving it into functions in *lib.rs*. The only code
that remains in *main.rs* will be small enough to verify its correctness by
reading it. Let‚Äôs rework our program by following this process.
-->
<p>Cette structure permet de s√©parer les responsabilit√©s¬†: <em>main.rs</em> se charge de
lancer le programme, et <em>lib.rs</em> renferme toute la logique des t√¢ches √†
accomplir. Comme vous ne pouvez pas directement tester la fonction <code>main</code>, cette
structure vous permet de tester toute la logique de votre programme en les
d√©pla√ßant dans des fonctions dans <em>lib.rs</em>. Le seul code qui restera dans le
<em>main.rs</em> sera suffisamment petit pour s'assurer qu'il soit correct en le
lisant. Lan√ßons-nous dans le remaniement de notre programme en suivant cette
proc√©dure.</p>
<!--
#### Extracting the Argument Parser
-->
<h4 id="extraction-de-linterpr√©teur-des-arguments"><a class="header" href="#extraction-de-linterpr√©teur-des-arguments">Extraction de l'interpr√©teur des arguments</a></h4>
<!--
We‚Äôll extract the functionality for parsing arguments into a function that
`main` will call to prepare for moving the command line parsing logic to
*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new
function `parse_config`, which we‚Äôll define in *src/main.rs* for the moment.
-->
<p>Nous allons d√©placer la fonctionnalit√© de l'interpr√©tation des arguments dans
une fonction que <code>main</code> va appeler afin de pr√©parer le d√©placement de la logique
de l'interpr√©teur dans <em>src/lib.rs</em>. L'encart 12-5 montre le nouveau d√©but du
<code>main</code> qui appelle une nouvelle fonction <code>interpreter_config</code>, que nous allons
d√©finir dans <em>src/main.rs</em> pour le moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
# 
#     println!("Searching for {}", query);
#     println!("In file {}", filename);
# 
#     let contents = fs::read_to_string(filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (recherche, nom_fichier) = interpreter_config(&amp;args);

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

fn interpreter_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    (recherche, nom_fichier)
}
</code></pre>
<!--
<span class="caption">Listing 12-5: Extracting a `parse_config` function from
`main`</span>
-->
<p><span class="caption">Encart 12-5¬†: Extraction d'une fonction
<code>interpreter_config</code> √† partir de <code>main</code></span></p>
<!--
We‚Äôre still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable `query` and the
argument value at index 2 to the variable `filename` within the `main`
function, we pass the whole vector to the `parse_config` function. The
`parse_config` function then holds the logic that determines which argument
goes in which variable and passes the values back to `main`. We still create
the `query` and `filename` variables in `main`, but `main` no longer has the
responsibility of determining how the command line arguments and variables
correspond.
-->
<p>Nous continuons √† r√©cup√©rer les arguments de la ligne de commande dans un
vecteur, mais au lieu d'assigner la valeur de l'argument d'indice 1 √† la
variable <code>recherche</code> et la valeur de l'argument d'indice 2 √† la variable
<code>nom_fichier</code> dans la fonction <code>main</code>, nous passons le vecteur entier √† la
fonction <code>interpreter_config</code>. La fonction <code>interpreter_config</code> renferme la
logique qui d√©termine quel argument va dans quelle variable et renvoie les
valeurs au <code>main</code>. Nous continuons √† cr√©er les variables <code>recherche</code> et
<code>nom_fichier</code> dans le <code>main</code>, mais <code>main</code> n'a plus la responsabilit√© de
d√©terminer quelles sont les variables qui correspondent aux arguments de la
ligne de commande.</p>
<!--
This rework may seem like overkill for our small program, but we‚Äôre refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It‚Äôs good to check your progress
often, to help identify the cause of problems when they occur.
-->
<p>Ce remaniement peut sembler excessif pour notre petit programme, mais nous
remanions de mani√®re incr√©mentale par de petites √©tapes. Apr√®s avoir fait
ces changements, lancez √† nouveau le programme pour v√©rifier que l'envoi des
arguments fonctionne toujours. C'est une bonne chose de v√©rifier souvent lorsque
vous avancez, pour vous aider √† mieux identifier les causes de probl√®mes
lorsqu'ils apparaissent.</p>
<!--
#### Grouping Configuration Values
-->
<h4 id="grouper-les-valeurs-de-configuration"><a class="header" href="#grouper-les-valeurs-de-configuration">Grouper les valeurs de configuration</a></h4>
<!--
We can take another small step to improve the `parse_config` function further.
At the moment, we‚Äôre returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don‚Äôt have
the right abstraction yet.
-->
<p>Nous pouvons appliquer une nouvelle petite √©tape pour am√©liorer la fonction
<code>interpreter_config</code>. Pour le moment, nous retournons un tuple, mais ensuite
nous divisons imm√©diatement ce tuple √† nouveau en plusieurs √©l√©ments. C'est un
signe que nous n'avons peut-√™tre pas la bonne approche.</p>
<!--
Another indicator that shows there‚Äôs room for improvement is the `config` part
of `parse_config`, which implies that the two values we return are related and
are both part of one configuration value. We‚Äôre not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.
-->
<p>Un autre signe qui indique qu'il y a encore de la place pour de l'am√©lioration
est la partie <code>config</code> de <code>interpreter_config</code> qui sous-entend que les
deux valeurs que nous retournons sont li√©es et font partie d'une m√™me valeur de
configuration. Or, √† ce stade, nous ne tenons pas compte de cela dans la
structure des donn√©es que nous utilisons si ce n'est en regroupant les deux
valeurs dans un tuple¬†; nous pourrions mettre les deux valeurs dans une seule
structure et donner un nom significatif √† chacun des champs de la structure.
Faire ainsi permet de faciliter la compr√©hension du code par les futurs
d√©veloppeurs de ce code pour mettre en √©vidence le lien entre les deux valeurs
et leurs r√¥les respectifs.</p>
<!--
Listing 12-6 shows the improvements to the `parse_config` function.
-->
<p>L'encart 12-6 montre les am√©liorations apport√©es √† la fonction
<code>interpreter_config</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
# 
#     println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
```
-->
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = interpreter_config(&amp;args);

    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);

    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

struct Config {
    recherche: String,
    nom_fichier: String,
}

fn interpreter_config(args: &amp;[String]) -&gt; Config {
    let recherche = args[1].clone();
    let nom_fichier = args[2].clone();

    Config { recherche, nom_fichier }
}
</code></pre>
<!--
<span class="caption">Listing 12-6: Refactoring `parse_config` to return an
instance of a `Config` struct</span>
-->
<p><span class="caption">Encart 12-6¬†: Remaniement de <code>interpreter_config</code> pour
retourner une instance de la structure <code>Config</code></span></p>
<!--
We‚Äôve added a struct named `Config` defined to have fields named `query` and
`filename`. The signature of `parse_config` now indicates that it returns a
`Config` value. In the body of `parse_config`, where we used to return string
slices that reference `String` values in `args`, we now define `Config` to
contain owned `String` values. The `args` variable in `main` is the owner of
the argument values and is only letting the `parse_config` function borrow
them, which means we‚Äôd violate Rust‚Äôs borrowing rules if `Config` tried to take
ownership of the values in `args`.
-->
<p>Nous avons ajout√© une structure <code>Config</code> qui a deux champs <code>recherche</code> et
<code>nom_fichier</code>. La signature de <code>interpreter_config</code> indique maintenant qu'elle
retourne une valeur <code>Config</code>. Dans le corps de <code>interpreter_config</code>, o√π nous
retournions une slice de cha√Ænes de caract√®res qui pointaient sur des valeurs
<code>String</code> pr√©sentes dans <code>args</code>, nous d√©finissons maintenant la structure
<code>Config</code> pour contenir des valeurs <code>String</code> qu'elle poss√®de. La variable <code>args</code>
du <code>main</code> est la propri√©taire des valeurs des arguments et permet uniquement √†
la fonction <code>interpreter_config</code> de les emprunter, ce qui signifie que nous
violons les r√®gles d'emprunt de Rust si <code>Config</code> essaye de prendre possession
des valeurs provenant de <code>args</code>.</p>
<!--
We could manage the `String` data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the `clone` method on
the values. This will make a full copy of the data for the `Config` instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don‚Äôt have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.
-->
<p>Nous pourrions g√©rer les donn√©es <code>String</code> de plusieurs mani√®res, mais la fa√ßon
la plus facile, bien que non optimis√©e, est d'appeler la m√©thode <code>clone</code> sur
les valeurs. Cela va produire une copie compl√®te des donn√©es pour que
l'instance de <code>Config</code> puisse se les approprier, ce qui va prendre plus de
temps et de m√©moire que de stocker une r√©f√©rence vers les donn√©es de la cha√Æne
de caract√®res. Cependant le clonage des donn√©es rend votre code tr√®s simple
car nous n'avons pas √† g√©rer les dur√©es de vie des r√©f√©rences¬†; dans ces
circonstances, sacrifier un peu de performances pour gagner en simplicit√© est
un compromis qui en vaut la peine.</p>
<!--
> ### The Trade-Offs of Using `clone`
>
> There‚Äôs a tendency among many Rustaceans to avoid using `clone` to fix
> ownership problems because of its runtime cost. In
> [Chapter 13][ch13]<!-- ignore -- >, you‚Äôll learn how to use more efficient
> methods in this type of situation. But for now, it‚Äôs okay to copy a few
> strings to continue making progress because you‚Äôll make these copies only
> once and your filename and query string are very small. It‚Äôs better to have
> a working program that‚Äôs a bit inefficient than to try to hyperoptimize code
> on your first pass. As you become more experienced with Rust, it‚Äôll be
> easier to start with the most efficient solution, but for now, it‚Äôs
> perfectly acceptable to call `clone`.
-->
<blockquote>
<h3 id="les-contre-parties-de-lutilisation-de-clone"><a class="header" href="#les-contre-parties-de-lutilisation-de-clone">Les contre-parties de l'utilisation de <code>clone</code></a></h3>
<p>Il y a une tendance chez les Rustac√©s de s'interdire l'utilisation de <code>clone</code>
pour r√©gler les probl√®mes d'appartenance √† cause du co√ªt √† l'ex√©cution. Dans
le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->, vous allez apprendre √† utiliser des
m√©thodes plus efficaces dans ce genre de situation. Mais pour le moment, ce
n'est pas un probl√®me de copier quelques cha√Ænes de caract√®res pour continuer
√† progresser car vous allez le faire une seule fois et les cha√Ænes de
caract√®res <code>nom_fichier</code> et <code>recherche</code> sont tr√®s courtes. Il est plus
important d'avoir un programme fonctionnel qui n'est pas tr√®s optimis√© plut√¥t
que d'essayer d'optimiser √† outrance le code d√®s sa premi√®re √©criture. Plus
vous deviendrez exp√©riment√© en Rust, plus il sera facile de commencer par la
solution la plus performante, mais pour le moment, il est parfaitement
acceptable de faire appel √† <code>clone</code>.</p>
</blockquote>
<!--
We‚Äôve updated `main` so it places the instance of `Config` returned by
`parse_config` into a variable named `config`, and we updated the code that
previously used the separate `query` and `filename` variables so it now uses
the fields on the `Config` struct instead.
-->
<p>Nous avons actualis√© <code>main</code> pour qu'il utilise l'instance de <code>Config</code> retourn√©e
par <code>interpreter_config</code> dans une variable <code>config</code>, et nous avons rafra√Æchi le
code qui utilisait les variables s√©par√©es <code>recherche</code> et <code>nom_fichier</code> pour
qu'il utilise maintenant les champs de la structure <code>Config</code> √† la place.</p>
<!--
Now our code more clearly conveys that `query` and `filename` are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the `config` instance in the fields
named for their purpose.
-->
<p>Maintenant, notre code indique clairement que <code>recherche</code> et <code>nom_fichier</code> sont
reli√©s et que leur but est de configurer le fonctionnement du programme.
N'importe quel code qui utilise ces valeurs sait comment les retrouver dans les
champs de l'instance <code>config</code> gr√¢ce √† leurs noms donn√©s √† cet effet.</p>
<!--
#### Creating a Constructor for `Config`
-->
<h4 id="cr√©er-un-constructeur-pour-config"><a class="header" href="#cr√©er-un-constructeur-pour-config">Cr√©er un constructeur pour <code>Config</code></a></h4>
<!--
So far, we‚Äôve extracted the logic responsible for parsing the command line
arguments from `main` and placed it in the `parse_config` function. Doing so
helped us to see that the `query` and `filename` values were related and that
relationship should be conveyed in our code. We then added a `Config` struct to
name the related purpose of `query` and `filename` and to be able to return the
values‚Äô names as struct field names from the `parse_config` function.
-->
<p>Pour l'instant, nous avons extrait la logique en charge d'interpr√©ter les
arguments de la ligne de commande √† partir du <code>main</code> et nous l'avons plac√© dans
la fonction <code>interpreter_config</code>. Cela nous a aid√© √† d√©couvrir que les valeurs
<code>recherche</code> et <code>nom_fichier</code> √©taient li√©es et que ce lien devait √™tre
retranscrit dans notre code. Nous avons ensuite cr√©√© une structure <code>Config</code>
afin de donner un nom au r√¥le apparent√© √† <code>recherche</code> et √† <code>nom_fichier</code>, et
pour pouvoir retourner les noms des valeurs sous la forme de noms de champs √†
partir de la fonction <code>interpreter_config</code>.</p>
<!--
So now that the purpose of the `parse_config` function is to create a `Config`
instance, we can change `parse_config` from a plain function to a function
named `new` that is associated with the `Config` struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as `String`, by calling `String::new`. Similarly, by
changing `parse_config` into a `new` function associated with `Config`, we‚Äôll
be able to create instances of `Config` by calling `Config::new`. Listing 12-7
shows the changes we need to make.
-->
<p>Maintenant que le but de la fonction <code>interpreter_config</code> est de cr√©er une
instance de <code>Config</code>, nous pouvons transformer <code>interpreter_config</code> d'une
simple fonction √† une fonction <code>new</code> qui est associ√©e √† la structure <code>Config</code>.
Ce changement rendra le code plus familier. Habituellement, nous cr√©ons des
instances de types de la biblioth√®que standard, comme <code>String</code>, en appelant
<code>String::new</code>. Si on change le <code>interpreter_config</code> en une fonction <code>new</code>
associ√©e √† <code>Config</code>, nous pourrons cr√©er de la m√™me fa√ßon des instances de
<code>Config</code> en appelant <code>Config::new</code>. L'encart 12-7 nous montre les changements
que nous devons faire pour cela.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);

    // --snip--
}

// --snip--

# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
```
-->
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>
    // -- partie masqu√©e ici --
}

// -- partie masqu√©e ici --

<span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Config { recherche, nom_fichier }
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-7: Changing `parse_config` into
`Config::new`</span>
-->
<p><span class="caption">Encart 12-7¬†: Transformer <code>interpreter_config</code> en
<code>Config::new</code></span></p>
<!--
We‚Äôve updated `main` where we were calling `parse_config` to instead call
`Config::new`. We‚Äôve changed the name of `parse_config` to `new` and moved it
within an `impl` block, which associates the `new` function with `Config`. Try
compiling this code again to make sure it works.
-->
<p>Nous avons actualis√© le <code>main</code> o√π nous appelions <code>interpreter_config</code> pour
appeler √† la place le <code>Config::new</code>. Nous avons chang√© le nom de
<code>interpreter_config</code> par <code>new</code> et nous l'avons d√©plac√© dans un bloc <code>impl</code>,
ce qui relie la fonction <code>new</code> √† <code>Config</code>. Essayez √† nouveau de compiler ce
code pour vous assurer qu'il fonctionne.</p>
<!--
### Fixing the Error Handling
-->
<h3 id="corriger-la-gestion-des-erreurs"><a class="header" href="#corriger-la-gestion-des-erreurs">Corriger la gestion des erreurs</a></h3>
<!--
Now we‚Äôll work on fixing our error handling. Recall that attempting to access
the values in the `args` vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:
-->
<p>Maintenant, nous allons nous pencher sur la correction de la gestion des
erreurs. Rappellez-vous que la tentative d'acc√©der aux valeurs dans le vecteur
<code>args</code> aux indices 1 ou 2 va faire paniquer le programme si le vecteur contient
moins de trois √©l√©ments. Essayez de lancer le programme sans aucun argument¬†;
cela donnera quelque chose comme ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The line `index out of bounds: the len is 1 but the index is 1` is an error
message intended for programmers. It won‚Äôt help our end users understand what
happened and what they should do instead. Let‚Äôs fix that now.
-->
<p>La ligne <code>index out of bounds: the len is 1 but the index is 1</code> est un
message d'erreur destin√© aux d√©veloppeurs. Il n'aidera pas nos utilisateurs
finaux √† comprendre ce qu'il s'est pass√© et ce qu'ils devraient faire √† la
place. Corrigeons cela d√®s maintenant.</p>
<!--
#### Improving the Error Message
-->
<h4 id="am√©liorer-le-message-derreur"><a class="header" href="#am√©liorer-le-message-derreur">Am√©liorer le message d'erreur</a></h4>
<!--
In Listing 12-8, we add a check in the `new` function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isn‚Äôt long
enough, the program panics and displays a better error message than the `index
out of bounds` message.
-->
<p>Dans l'encart 12-8, nous ajoutons une v√©rification dans la fonction <code>new</code>, qui
va v√©rifier que le slice est suffisamment grand avant d'acc√©der aux indices 1
et 2. Si le slice n'est pas suffisamment grand, le programme va paniquer et
afficher un meilleur message d'erreur que le message <code>index out of bounds</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
    // --snip--
    fn new(args: &[String]) -> Config {
        if args.len() < 3 {
            panic!("not enough arguments");
        }
        // --snip--
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Config { query, filename }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // -- partie masqu√©e ici --
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;il n'y a pas assez d'arguments&quot;);
        }
        // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { recherche, nom_fichier }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-8: Adding a check for the number of
arguments</span>
-->
<p><span class="caption">Encart 12-8¬†: Ajout d'une v√©rification du nombre
d'arguments</span></p>
<!--
This code is similar to [the `Guess::new` function we wrote in Listing
9-13][ch9-custom-types]<!-- ignore -- >, where we called `panic!` when the
`value` argument was out of the range of valid values. Instead of checking for
a range of values here, we‚Äôre checking that the length of `args` is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If `args` has fewer than three items, this condition
will be true, and we call the `panic!` macro to end the program immediately.
-->
<p>Ce code est similaire √† <a href="ch09-03-to-panic-or-not-to-panic.html">la fonction Supposition::new que nous avons √©crit
dans l'encart 9-13</a><!-- ignore -->, dans laquelle nous
appelions <code>panic!</code> lorsque l'argument <code>valeur</code> √©tait hors de l'intervalle des
valeurs valides. Plut√¥t que de v√©rifier un intervalle de valeurs dans le cas
pr√©sent, nous v√©rifions que la taille de <code>args</code> est au moins de 3 et que le
reste de la fonction puisse fonctionner en s'appuyant sur l'affirmation que
cette condition a bien √©t√© remplie. Si <code>args</code> avait moins de trois √©l√©ments,
cette fonction serait vraie, et nous appellerions alors la macro <code>panic!</code>
pour mettre fin au programme imm√©diatement.</p>
<!--
With these extra few lines of code in `new`, let‚Äôs run the program without any
arguments again to see what the error looks like now:
-->
<p>Avec ces quelques lignes de code en plus dans <code>new</code>, lan√ßons le programme sans
aucun argument √† nouveau pour voir √† quoi ressemble d√©sormais l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'il n'y a pas assez d'arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
This output is better: we now have a reasonable error message. However, we also
have extraneous information we don‚Äôt want to give to our users. Perhaps using
the technique we used in Listing 9-13 isn‚Äôt the best to use here: a call to
`panic!` is more appropriate for a programming problem than a usage problem,
[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -- >. Instead, we
can use the other technique you learned about in Chapter 9‚Äî[returning a
`Result`][ch9-result]<!-- ignore -- > that indicates either success or an error.
-->
<p>Cette sortie est meilleure¬†: nous avons maintenant un message d'erreur
compr√©hensible. Cependant, nous avons aussi des informations superflues que
nous ne souhaitons pas afficher √† nos utilisateurs. Peut-√™tre que la technique
que nous avons utilis√©e dans l'encart 9-13 n'est pas la plus appropri√©e dans ce
cas¬†: un appel √† <code>panic!</code> est plus appropri√© pour un probl√®me de d√©veloppement
qu'un probl√®me d'utilisation, <a href="ch09-03-to-panic-or-not-to-panic.html">comme nous l'avons appris au chapitre
9</a><!-- ignore -->. A la place, nous pourrions utiliser
une autre technique que vous avez apprise au chapitre 9 ‚Äî <a href="ch09-02-recoverable-errors-with-result.html">retourner un
<code>Result</code></a><!-- ignore --> qui indique si c'est un succ√®s ou une
erreur.</p>
<!--
#### Returning a `Result` from `new` Instead of Calling `panic!`
-->
<h4 id="retourner-un-result-√†-partir-de-new-plut√¥t-que-dappeler-panic"><a class="header" href="#retourner-un-result-√†-partir-de-new-plut√¥t-que-dappeler-panic">Retourner un <code>Result</code> √† partir de <code>new</code> plut√¥t que d'appeler <code>panic!</code></a></h4>
<!--
We can instead return a `Result` value that will contain a `Config` instance in
the successful case and will describe the problem in the error case. When
`Config::new` is communicating to `main`, we can use the `Result` type to
signal there was a problem. Then we can change `main` to convert an `Err`
variant into a more practical error for our users without the surrounding text
about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.
-->
<p>Nous pouvons √† la place retourner une valeur <code>Result</code> qui contiendra une
instance de <code>Config</code> dans le cas d'un succ√®s et va d√©crire le probl√®me dans le
cas d'une erreur. Lorsque <code>Config::new</code> communiquera avec le <code>main</code>, nous
pourrons utiliser le type de <code>Result</code> pour signaler o√π il y a un probl√®me.
Ensuite, nous pourrons changer le <code>main</code> pour convertir une variante de <code>Err</code>
dans une erreur plus pratique pour nos utilisateurs sans avoir le texte √†
propos de <code>thread 'main'</code> et de <code>RUST_BACKTRACE</code> qui sont provoqu√©s par l'appel
√† <code>panic!</code>.</p>
<!--
Listing 12-9 shows the changes we need to make to the return value of
`Config::new` and the body of the function needed to return a `Result`. Note
that this won‚Äôt compile until we update `main` as well, which we‚Äôll do in the
next listing.
-->
<p>L'encart 12-9 nous montre les changements que nous devons apporter √† la
valeur de retour de <code>Config::new</code> et le corps de la fonction pour pouvoir retourner
un <code>Result</code>. Notez que cela ne va pas se compiler tant que nous ne corrigeons
pas aussi le <code>main</code>, ce que nous allons faire dans le prochain encart.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Ok(Config { recherche, nom_fichier })
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-9: Returning a `Result` from
`Config::new`</span>
-->
<p><span class="caption">Encart 12-9¬†: Retourner un <code>Result</code> √† partir de
<code>Config::new</code></span></p>
<!--
Our `new` function now returns a `Result` with a `Config` instance in the
success case and a `&'static str` in the error case. Our error values will
always be string literals that have the `'static` lifetime.
-->
<p>Notre fonction <code>new</code> retourne d√©sormais un <code>Result</code> contenant une instance de
<code>Config</code> dans le cas d'un succ√®s et une <code>&amp;'static str</code> dans le cas d'une
erreur. Nos valeurs d'erreur seront toujours des lit√©raux de cha√Æne de
caract√®res qui ont la dur√©e de vie <code>'static</code>.</p>
<!--
We‚Äôve made two changes in the body of the `new` function: instead of calling
`panic!` when the user doesn‚Äôt pass enough arguments, we now return an `Err`
value, and we‚Äôve wrapped the `Config` return value in an `Ok`. These changes
make the function conform to its new type signature.
-->
<p>Nous avons fait deux changements dans le corps de notre fonction <code>new</code>¬†:
plut√¥t que d'avoir √† appeler <code>panic!</code> lorsque l'utilisateur n'envoie pas assez
d'arguments, nous retournons maintenant une valeur <code>Err</code>, et nous avons int√©gr√©
la valeur de retour <code>Config</code> dans un <code>Ok</code>. Ces modifications rendent la
fonction conforme √† son nouveau type de signature.</p>
<!--
Returning an `Err` value from `Config::new` allows the `main` function to
handle the `Result` value returned from the `new` function and exit the process
more cleanly in the error case.
-->
<p>Retourner une valeur <code>Err</code> √† partir de <code>Config::new</code> permet √† la fonction
<code>main</code> de g√©rer la valeur <code>Result</code> retourn√©e par la fonction <code>new</code> et de
terminer plus proprement le processus dans le cas d'une erreur.</p>
<!--
#### Calling `Config::new` and Handling Errors
-->
<h4 id="appeler-confignew-et-g√©rer-les-erreurs"><a class="header" href="#appeler-confignew-et-g√©rer-les-erreurs">Appeler <code>Config::new</code> et g√©rer les erreurs</a></h4>
<!--
To handle the error case and print a user-friendly message, we need to update
`main` to handle the `Result` being returned by `Config::new`, as shown in
Listing 12-10. We‚Äôll also take the responsibility of exiting the command line
tool with a nonzero error code from `panic!` and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.
-->
<p>Pour g√©rer les cas d'erreurs et afficher un message correct pour
l'utilisateur, nous devons mettre √† jour <code>main</code> pour g√©rer le <code>Result</code>
retourn√© par <code>Config::new</code>, comme dans l'encart 12-10. Nous allons aussi
prendre la d√©cision de quitter l'outil en ligne de commande avec un code
d'erreur diff√©rent de z√©ro avec <code>panic!</code> et nous allons l'impl√©menter
manuellement. Un statut de sortie diff√©rent de z√©ro est une convention pour
signaler au processus qui a appel√© notre programme que le programme s'est
termin√© dans un √©tat d'erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
        process::exit(1);
    });

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-10: Exiting with an error code if creating a
new `Config` fails</span>
-->
<p><span class="caption">Encart 12-10¬†: Quitter avec un code d'erreur si la
cr√©ation d'une nouvelle <code>Config</code> √©choue.
</span></p>
<!--
In this listing, we‚Äôve used a method we haven‚Äôt covered in detail yet:
`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.
Using `unwrap_or_else` allows us to define some custom, non-`panic!` error
handling. If the `Result` is an `Ok` value, this method‚Äôs behavior is similar
to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value
is an `Err` value, this method calls the code in the *closure*, which is an
anonymous function we define and pass as an argument to `unwrap_or_else`. We‚Äôll
cover closures in more detail in [Chapter 13][ch13]<!-- ignore -- >. For now,
you just need to know that `unwrap_or_else` will pass the inner value of the
`Err`, which in this case is the static string `"not enough arguments"` that we
added in Listing 12-9, to our closure in the argument `err` that appears
between the vertical pipes. The code in the closure can then use the `err`
value when it runs.
-->
<p>Dans cet encart, nous avons utilis√© une m√©thode que nous n'avons pas encore
d√©taill√©e pour l'instant¬†: <code>unwrap_or_else</code>, qui est d√©finie sur <code>Result&lt;T, E&gt;</code>
par la biblioth√®que standard. L'utilisation de <code>unwrap_or_else</code> nous permet de
d√©finir une gestion des erreurs personnalis√©e, exempt de <code>panic!</code>. Si le
<code>Result</code> est une valeur <code>Ok</code>, le comportement de cette m√©thode est similaire √†
<code>unwrap</code>¬†: elle retourne la valeur √† l'int√©rieur du <code>Ok</code>. Cependant, si la
valeur est une valeur <code>Err</code>, cette m√©thode appelle le code dans la <em>fermeture</em>,
qui est une fonction anonyme que nous d√©finissons et passons en argument de
<code>unwrap_or_else</code>. Nous verrons les fermetures plus en d√©tail dans le <a href="ch13-00-functional-features.html">chapitre
13</a><!-- ignore -->. Pour l'instant, vous avez juste √† savoir que le
<code>unwrap_or_else</code> va passer la valeur interne du <code>Err</code> (qui dans ce cas est la
cha√Æne de caract√®res statique <code>&quot;pas assez d'arguments&quot;</code> que nous avons ajout√©e
dans l'encart 12-9) √† notre fermeture dans l'argument <code>err</code> qui est pr√©sent
entre deux barres verticales. Le code dans la fermeture peut ensuite utiliser
la valeur <code>err</code> lorsqu'il est ex√©cut√©.</p>
<!--
We‚Äôve added a new `use` line to bring `process` from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the `err` value and then call `process::exit`. The
`process::exit` function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
`panic!`-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let‚Äôs try it:
-->
<p>Nous avons ajout√© une nouvelle ligne <code>use</code> pour importer <code>process</code> dans la port√©e
√† partir de la biblioth√®que standard. Le code dans la fermeture qui sera ex√©cut√©
dans le cas d'une erreur fait uniquement deux lignes¬†: nous affichons la valeur
de <code>err</code> et nous appelons ensuite <code>process::exit</code>. La fonction <code>process::exit</code>
va stopper le programme imm√©diatement et retourner le nombre qui lui a √©t√© donn√©
en param√®tre comme code de statut de sortie. C'est semblable √† la gestion bas√©e
sur <code>panic!</code> que nous avons utilis√©e √† l'encart 12-8, mais nous n'avons plus tout
le texte en plus. Essayons cela¬†:</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: il n'y a pas assez d'arguments
</code></pre>
<!--
Great! This output is much friendlier for our users.
-->
<p>Tr√®s bien ! Cette sortie est bien plus compr√©hensible pour nos utilisateurs.</p>
<!--
### Extracting Logic from `main`
-->
<h3 id="extraction-de-la-logique-du-main"><a class="header" href="#extraction-de-la-logique-du-main">Extraction de la logique du <code>main</code></a></h3>
<!--
Now that we‚Äôve finished refactoring the configuration parsing, let‚Äôs turn to
the program‚Äôs logic. As we stated in [‚ÄúSeparation of Concerns for Binary
Projects‚Äù](#separation-of-concerns-for-binary-projects)<!-- ignore -- >, we‚Äôll
extract a function named `run` that will hold all the logic currently in the
`main` function that isn‚Äôt involved with setting up configuration or handling
errors. When we‚Äôre done, `main` will be concise and easy to verify by
inspection, and we‚Äôll be able to write tests for all the other logic.
-->
<p>Maintenant que nous avons fini le remaniement de l'interpr√©tation de la
configuration, occupons-nous de la logique du programme. Comme nous l'avons dit
dans <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">‚ÄúS√©paration des t√¢ches des projets de
binaires‚Äù</a><!-- ignore -->, nous
allons extraire une fonction <code>run</code> qui va contenir toute la logique qui est
actuellement dans la fonction <code>main</code> qui n'est pas li√©e au r√©glage de la
configuration ou la gestion des erreurs. Lorsque nous aurons termin√©, <code>main</code>
sera plus concise et facile √† v√©rifier en l'inspectant, et nous pourrons √©crire
des tests pour toutes les autres logiques.</p>
<!--
Listing 12-11 shows the extracted `run` function. For now, we‚Äôre just making
the small, incremental improvement of extracting the function. We‚Äôre still
defining the function in *src/main.rs*.
-->
<p>L'encart 12-11 montre la fonction <code>run</code> extraite. Pour le moment, nous faisons
des petites am√©liorations progressives pour extraire les fonctions. Nous
continuons √† d√©finir la fonction dans <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masqu√©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);

    run(config);
}

fn run(config: Config) {
    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal pass√© lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte :\n{}&quot;, contenu);
}

// -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-11: Extracting a `run` function containing the
rest of the program logic</span>
-->
<p><span class="caption">Encart 12-11¬†: Extraction d'une fonction <code>run</code> qui
contient le reste de la logique du programme</span></p>
<!--
The `run` function now contains all the remaining logic from `main`, starting
from reading the file. The `run` function takes the `Config` instance as an
argument.
-->
<p>La fonction <code>run</code> contient maintenant toute la logique qui restait dans le
<code>main</code>, en commen√ßant par la lecture du fichier. La fonction <code>run</code> prend
l'instance de <code>Config</code> en argument.</p>
<!--
#### Returning Errors from the `run` Function
-->
<h4 id="retourner-des-erreurs-avec-la-fonction-run"><a class="header" href="#retourner-des-erreurs-avec-la-fonction-run">Retourner des erreurs avec la fonction <code>run</code></a></h4>
<!--
With the remaining program logic separated into the `run` function, we can
improve the error handling, as we did with `Config::new` in Listing 12-9.
Instead of allowing the program to panic by calling `expect`, the `run`
function will return a `Result<T, E>` when something goes wrong. This will let
us further consolidate into `main` the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of `run`.
-->
<p>Avec le restant de la logique du programme maintenant s√©par√©e dans la fonction
<code>run</code>, nous pouvons am√©liorer la gestion des erreurs, comme nous l'avons fait
avec <code>Config::new</code> dans l'encart 12-9. Plut√¥t que de permettre au programme de
paniquer en appelant <code>expect</code>, la fonction <code>run</code> va retourner un <code>Result&lt;T, E&gt;</code>
lorsque quelque chose se passe mal. Cela va nous permettre de consolider
davantage la logique de gestion des erreurs dans le <code>main</code> pour qu'elle soit
plus conviviale pour l'utilisateur. L'encart 12-12 montre les changements que
nous devons appliquer √† la signature et au corps du <code>run</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
use std::error::Error;

// --snip--

# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     run(config);
# }
# 
fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// -- partie masqu√©e ici --

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    println!(&quot;Dans le texte :\n{}&quot;, contenu);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-12: Changing the `run` function to return
`Result`</span>
-->
<p><span class="caption">Encart 12-12¬†: Changer la fonction <code>run</code> pour retourner
un <code>Result</code></span></p>
<!--
We‚Äôve made three significant changes here. First, we changed the return type of
the `run` function to `Result<(), Box<dyn Error>>`. This function previously
returned the unit type, `()`, and we keep that as the value returned in the
`Ok` case.
-->
<p>Nous avons fait trois changements significatifs ici. Premi√®rement, nous avons
chang√© le type de retour de la fonction <code>run</code> en <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>.
Cette fonction renvoyait pr√©c√©demment le type unit√©, <code>()</code>, que nous gardons
comme valeur de retour dans le cas de <code>Ok</code>.</p>
<!--
For the error type, we used the *trait object* `Box<dyn Error>` (and we‚Äôve
brought `std::error::Error` into scope with a `use` statement at the top).
We‚Äôll cover trait objects in [Chapter 17][ch17]<!-- ignore -- >. For now, just
know that `Box<dyn Error>` means the function will return a type that
implements the `Error` trait, but we don‚Äôt have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The `dyn` keyword is short
for ‚Äúdynamic.‚Äù
-->
<p>En ce qui concerne le type d'erreur, nous avons utilis√© <em>l'objet trait</em>
<code>Box&lt;dyn Error&gt;</code> (et nous avons import√© <code>std::error::Error</code> dans la port√©e avec
une instruction <code>use</code> en haut). Nous allons voir les objets trait dans le
<a href="ch17-00-oop.html">chapitre 17</a><!-- ignore -->. Pour l'instant, retenez juste que
<code>Box&lt;dyn Error&gt;</code> signifie que la fonction va retourner un type qui impl√©mente
le trait <code>Error</code>, mais que nous n'avons pas √† sp√©cifier quel sera pr√©cis√©ment le
type de la valeur de retour. Cela nous donne la flexibilit√© de retourner des valeurs
d'erreurs qui peuvent √™tre de diff√©rents types dans diff√©rents cas d'erreurs.
Le mot-cl√© <code>dyn</code> est un raccourci pour ‚Äúdynamique‚Äù.</p>
<!--
Second, we‚Äôve removed the call to `expect` in favor of the `?` operator, as we
talked about in [Chapter 9][ch9-question-mark]<!-- ignore -- >. Rather than
`panic!` on an error, `?` will return the error value from the current function
for the caller to handle.
-->
<p>Deuxi√®mement, nous avons enlev√© l'appel √† <code>expect</code> pour privil√©gier l'op√©rateur
<code>?</code>, que nous avons vu dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore -->.
Au lieu de faire un <code>panic!</code> sur une erreur, <code>?</code> va retourner la valeur d'erreur
de la fonction courante vers le code qui l'a appel√© pour qu'il la g√®re.</p>
<!--
Third, the `run` function now returns an `Ok` value in the success case. We‚Äôve
declared the `run` function‚Äôs success type as `()` in the signature, which
means we need to wrap the unit type value in the `Ok` value. This `Ok(())`
syntax might look a bit strange at first, but using `()` like this is the
idiomatic way to indicate that we‚Äôre calling `run` for its side effects only;
it doesn‚Äôt return a value we need.
-->
<p>Troisi√®mement, la fonction <code>run</code> retourne maintenant une valeur <code>Ok</code> dans les
cas de succ√®s. Nous avons d√©clar√© dans la signature que le type de succ√®s de la
fonction <code>run</code> √©tait <code>()</code>, ce qui signifie que nous avons envelopp√© la valeur
de type unit√© dans la valeur <code>Ok</code>. Cette syntaxe <code>Ok(())</code> peut sembler un peu
√©trange au d√©part, mais utiliser <code>()</code> de cette mani√®re est la fa√ßon id√©ale
d'indiquer que nous appelons <code>run</code> uniquement pour ses effets de bord¬†; elle
ne retourne pas de valeur dont nous pourrions avoir besoin.</p>
<!--
When you run this code, it will compile but will display a warning:
-->
<p>Lorsque vous ex√©cutez ce code, il va se compiler mais il va afficher un
avertissement¬†:</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  -- > src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
On recherche¬†: the
Dans le fichier¬†: poem.txt
Dans le texte :
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Rust tells us that our code ignored the `Result` value and the `Result` value
might indicate that an error occurred. But we‚Äôre not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let‚Äôs rectify that problem now.
-->
<p>Rust nous informe que notre code ignore la valeur <code>Result</code> et que cette valeur
<code>Result</code> pourrait indiquer qu'une erreur s'est pass√©e. Mais nous ne v√©rifions
pas pour savoir si oui ou non il y a eu une erreur, et le compilateur nous
rappelle que nous devrions avoir du code de gestion des erreurs ici !
Corrigeons d√®s √† pr√©sent ce probl√®me.</p>
<!--
#### Handling Errors Returned from `run` in `main`
-->
<h4 id="g√©rer-les-erreurs-retourn√©es-par-run-dans-main"><a class="header" href="#g√©rer-les-erreurs-retourn√©es-par-run-dans-main">G√©rer les erreurs retourn√©es par <code>run</code> dans <code>main</code></a></h4>
<!--
We‚Äôll check for errors and handle them using a technique similar to one we used
with `Config::new` in Listing 12-10, but with a slight difference:
-->
<p>Nous allons v√©rifier les erreurs et les g√©rer en utilisant une technique
similaire √† celle que nous avons utilis√©e avec <code>Config::new</code> dans l'encart
12-10, mais avec une l√©g√®re diff√©rence¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}
# 
# fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masqu√©e ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);

    if let Err(e) = run(config) {
        println!(&quot;Erreur applicative¬†: {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We use `if let` rather than `unwrap_or_else` to check whether `run` returns an
`Err` value and call `process::exit(1)` if it does. The `run` function doesn‚Äôt
return a value that we want to `unwrap` in the same way that `Config::new`
returns the `Config` instance. Because `run` returns `()` in the success case,
we only care about detecting an error, so we don‚Äôt need `unwrap_or_else` to
return the unwrapped value because it would only be `()`.
-->
<p>Nous utilisons <code>if let</code> plut√¥t que <code>unwrap_or_else</code> pour v√©rifier si <code>run</code>
retourne un valeur <code>Err</code> et appeler <code>process::exit(1)</code> le cas √©ch√©ant. La
fonction <code>run</code> ne retourne pas de valeur sur laquelle nous aurions besoin
d'utiliser <code>unwrap</code> comme avec le <code>Config::new</code> qui retournait une instance de
<code>Config</code>. Comme <code>run</code> retourne <code>()</code> dans le cas d'un succ√®s, nous nous
pr√©occupons uniquement de d√©tecter les erreurs, donc nous n'avons pas besoin de
<code>unwrap_or_else</code> pour retourner la valeur extraite car elle sera toujours
<code>()</code>.</p>
<!--
The bodies of the `if let` and the `unwrap_or_else` functions are the same in
both cases: we print the error and exit.
-->
<p>Les corps du <code>if let</code> et de la fonction <code>unwrap_or_else</code> sont identiques dans
les deux cas¬†: nous affichons l'erreur et nous quittons.</p>
<!--
### Splitting Code into a Library Crate
-->
<h3 id="d√©placer-le-code-dans-une-crate-de-biblioth√®que"><a class="header" href="#d√©placer-le-code-dans-une-crate-de-biblioth√®que">D√©placer le code dans une crate de biblioth√®que</a></h3>
<!--
Our `minigrep` project is looking good so far! Now we‚Äôll split the
*src/main.rs* file and put some code into the *src/lib.rs* file so we can test
it and have a *src/main.rs* file with fewer responsibilities.
-->
<p>Notre projet <code>minigrep</code> se pr√©sente plut√¥t bien pour le moment¬†! Maintenant,
nous allons diviser notre fichier <em>src/main.rs</em> et d√©placer du code dans le
fichier <em>src/lib.rs</em> pour que nous puissions le tester et avoir un fichier
<em>src/main.rs</em> qui h√©berge moins de fonctionnalit√©s.</p>
<!--
Let‚Äôs move all the code that isn‚Äôt the `main` function from *src/main.rs* to
*src/lib.rs*:
-->
<p>D√©pla√ßons tout le code qui ne fait pas partie de la fonction <code>main</code> dans le
<em>src/main.rs</em> vers le <em>src/lib.rs</em>¬†:</p>
<!--
* The `run` function definition
* The relevant `use` statements
* The definition of `Config`
* The `Config::new` function definition
-->
<ul>
<li>La d√©finition de la fonction <code>run</code></li>
<li>Les instructions <code>use</code> correspondantes</li>
<li>La d√©finition de <code>Config</code></li>
<li>La d√©finition de la fonction <code>Config::new</code></li>
</ul>
<!--
The contents of *src/lib.rs* should have the signatures shown in Listing 12-13
(we‚Äôve omitted the bodies of the functions for brevity). Note that this won‚Äôt
compile until we modify *src/main.rs* in Listing 12-14.
-->
<p>Le contenu du <em>src/lib.rs</em> devrait contenir les signatures de l'encart 12-13
(nous avons enlev√© les corps des fonctions pour des raisons de bri√®vet√©). Notez
que cela ne va pas se compiler jusqu'√† ce que nous modifions le <em>src/main.rs</em>
dans l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        // --snip--
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masqu√©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // -- partie masqu√©e ici --
<span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 12-13: Moving `Config` and `run` into
*src/lib.rs*</span>
-->
<p><span class="caption">Encart 12-13¬†: D√©placement de <code>Config</code> et de <code>run</code> dans
<em>src/lib.rs</em></span></p>
<!--
We‚Äôve made liberal use of the `pub` keyword: on `Config`, on its fields and its
`new` method, and on the `run` function. We now have a library crate that has a
public API that we can test!
-->
<p>Nous avons fait un usage g√©n√©reux du mot-cl√© <code>pub</code>¬†: sur <code>Config</code>, sur ses
champs et sur la m√©thode <code>new</code> et enfin sur la fonction <code>run</code>. Nous avons maintenant
une crate de biblioth√®que qui a une API publique que nous pouvons tester¬†!</p>
<!--
Now we need to bring the code we moved to *src/lib.rs* into the scope of the
binary crate in *src/main.rs*, as shown in Listing 12-14.
-->
<p>Maintenant nous devons importer le code que nous avons d√©plac√© dans
<em>src/lib.rs</em> dans la port√©e de la crate binaire dans <em>src/main.rs</em>, comme dans
l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
    if let Err(e) = minigrep::run(config) {
        // --snip--
#         println!("Application error: {}", e);
# 
#         process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // -- partie masqu√©e ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche¬†: {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier¬†: {}&quot;, config.nom_fichier);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // -- partie masqu√©e ici --
<span class="boring">        println!(&quot;Erreur applicative¬†: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 12-14: Using the `minigrep` library crate in
*src/main.rs*</span>
-->
<p><span class="caption">Encart 12-14¬†: Utilisation de la crate de biblioth√®que
<code>minigrep</code> dans <em>src/main.rs</em></span></p>
<!--
We add a `use minigrep::Config` line to bring the `Config` type from the
library crate into the binary crate‚Äôs scope, and we prefix the `run` function
with our crate name. Now all the functionality should be connected and should
work. Run the program with `cargo run` and make sure everything works
correctly.
-->
<p>Nous avons ajout√© une ligne <code>use minigrep::Config</code> pour importer le type
<code>Config</code> de la crate de biblioth√®que dans la port√©e de la crate binaire, et
nous avons avons pr√©fix√© la fonction <code>run</code> avec le nom de notre crate.
Maintenant, toutes les fonctionnalit√©s devraient √™tre connect√©es et devraient
fonctionner. Lancez le programme avec <code>cargo run</code> pour vous assurer que tout
fonctionne correctement.</p>
<!--
Whew! That was a lot of work, but we‚Äôve set ourselves up for success in the
future. Now it‚Äôs much easier to handle errors, and we‚Äôve made the code more
modular. Almost all of our work will be done in *src/lib.rs* from here on out.
-->
<p>Ouah¬†! C'√©tait pas mal de travail, mais nous nous sommes organis√©s pour nous assurer
le succ√®s √† venir. Maintenant il est bien plus facile de g√©rer les erreurs, et
nous avons rendu le code plus modulaire. A partir de maintenant, l'essentiel de
notre travail sera effectu√© dans <em>src/lib.rs</em>.</p>
<!--
Let‚Äôs take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we‚Äôll
write some tests!
-->
<p>Profitons de cette nouvelle modularit√© en accomplissant quelque chose qui
aurait √©t√© difficile √† faire avec l'ancien code, mais qui est facile avec ce
nouveau code¬†: nous allons √©crire des tests¬†!</p>
<!--
[ch13]: ch13-00-functional-features.html
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[ch9-result]: ch09-02-recoverable-errors-with-result.html
[ch17]: ch17-00-oop.html
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Developing the Library‚Äôs Functionality with Test-Driven Development
-->
<h2 id="d√©velopper-les-fonctionnalit√©s-de-la-biblioth√®que-avec-le-tdd"><a class="header" href="#d√©velopper-les-fonctionnalit√©s-de-la-biblioth√®que-avec-le-tdd">D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></h2>
<!--
Now that we‚Äôve extracted the logic into *src/lib.rs* and left the argument
collecting and error handling in *src/main.rs*, it‚Äôs much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line.
-->
<p>Maintenant que nous avons extrait la logique dans <em>src/lib.rs</em> et que nous
avons laiss√© la r√©cup√©ration des arguments et la gestion des erreurs dans
<em>src/main.rs</em>, il est bien plus facile d'√©crire les tests pour les
fonctionnalit√©s de base de notre code. Nous pouvons appeler les fonctions
directement avec diff√©rents arguments et v√©rifier les valeurs de retour sans
avoir √† appeler notre binaire dans la ligne de commande.</p>
<!--
In this section, we‚Äôll add the searching logic to the `minigrep` program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:
-->
<p>Dans cette section, nous allons ajouter la logique de recherche au programme
<code>minigrep</code> en utilisant le processus de d√©veloppement orient√© par les tests
(c'est le TDD¬†: <em>Test-Driven Development</em>). Cette technique de d√©veloppement
de logiciels suit ces trois √©tapes¬†:</p>
<!--
1. Write a test that fails and run it to make sure it fails for the reason you
   expect.
2. Write or modify just enough code to make the new test pass.
3. Refactor the code you just added or changed and make sure the tests
   continue to pass.
4. Repeat from step 1!
-->
<ol>
<li>Ecrire un test qui √©choue et lancez-le pour vous assurer qu'il va √©chouer
pour la raison que vous attendiez.</li>
<li>Ecrire ou modifier juste assez de code pour faire r√©ussir ce nouveau test.</li>
<li>Remanier le code que vous venez d'ajouter ou de changer pour vous assurer
que les tests continuent √† r√©ussir.</li>
<li>Recommencer √† l'√©tape 1¬†!</li>
</ol>
<!--
This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.
-->
<p>Ce processus n'est qu'une des diff√©rentes mani√®res d'√©crire des programmes,
mais le TDD peut aussi aider √† piloter sa conception. Ecrire les tests avant
d'√©crire le code qui fait r√©ussir les tests aide √† maintenir une haute
couverture de tests tout le long du processus.</p>
<!--
We‚Äôll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We‚Äôll add this functionality in a function called
`search`.
-->
<p>Nous allons exp√©rimenter cela avec l'impl√©mentation de la fonctionnalit√© qui va
rechercher la cha√Æne de caract√®res demand√©e dans le contenu du fichier et
g√©n√©rer une liste de lignes qui correspond √† cette recherche. Nous ajouterons
cette fonctionnalit√© dans une fonction <code>rechercher</code>.</p>
<!--
### Writing a Failing Test
-->
<h3 id="ecrire-un-test-qui-√©choue"><a class="header" href="#ecrire-un-test-qui-√©choue">Ecrire un test qui √©choue</a></h3>
<!--
Because we don‚Äôt need them anymore, let‚Äôs remove the `println!` statements from
*src/lib.rs* and *src/main.rs* that we used to check the program‚Äôs behavior.
Then, in *src/lib.rs*, we‚Äôll add a `tests` module with a test function, as we
did in [Chapter 11][ch11-anatomy]<!-- ignore -- >. The test function specifies
the behavior we want the `search` function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which won‚Äôt compile
yet.
-->
<p>Comme nous n'en avons plus besoin, enlevons les instructions <code>println!</code> de
<em>src/lib.rs</em> et <em>src/main.rs</em> que nous avions utilis√© pour v√©rifier le bon
comportement du programme. Ensuite, dans <em>src/lib.rs</em>, nous allons ajouter un
module <code>tests</code> avec une fonction de test, comme nous l'avions fait dans le
<a href="ch11-01-writing-tests.html">chapitre 11</a><!-- ignore -->. La fonction de test d√©finit le
comportement que nous voulons qu'ait la fonction <code>rechercher</code>¬†: elle va prendre
en arguments une recherche et le texte dans lequel rechercher, et elle va
retourner seulement les lignes du texte qui correspondent √† la recherche.
L'encart 12-15 montre ce test, qui ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_resultat() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
s√©curit√©, rapidit√©, productivit√©.
Obtenez les trois en m√™me temps.&quot;;

        assert_eq!(
            vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;],
            rechercher(recherche, contenu)
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-15: Creating a failing test for the `search`
function we wish we had</span>
-->
<p><span class="caption">Encart 12-15¬†: Cr√©ation d'un test qui √©choue pour la
fonction <code>rechercher</code> que nous souhaitons concevoir</span></p>
<!--
This test searches for the string `"duct"`. The text we‚Äôre searching is three
lines, only one of which contains `"duct"` (Note that the backslash after the
opening double quote tells Rust not to put a newline character at the beginning
of the contents of this string literal). We assert that the value returned from
the `search` function contains only the line we expect.
-->
<p>Ce test recherche la cha√Æne de caract√®res <code>&quot;duct&quot;</code>. Le texte dans lequel nous
recherchons fait trois lignes, et seulement une d'entre elles contient <code>&quot;duct&quot;</code>
(remarquez que l'antislash apr√®s la double-guillet ouvrante indique √† Rust de
ne pas ins√©rer un caract√®re de nouvelle ligne au d√©but du contenu de ce lit√©ral
de cha√Æne de caract√®re). Nous v√©rifions que la valeur retourn√©e par la fonction
<code>rechercher</code> contient seulement la ligne que nous avions pr√©vu.</p>
<!--
We aren‚Äôt able to run this test and watch it fail because the test doesn‚Äôt even
compile: the `search` function doesn‚Äôt exist yet! So now we‚Äôll add just enough
code to get the test to compile and run by adding a definition of the `search`
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn‚Äôt match a vector
containing the line `"safe, fast, productive."`
-->
<p>Nous ne pouvons pas encore ex√©cuter ce test et v√©rifier s'il √©choue car m√™me le
test ne peut pas se compiler¬†: la fonction <code>rechercher</code> n'existe pas encore¬†!
Donc pour le moment nous allons ajouter juste assez de code pour que le test
puisse compiler et s'ex√©cuter en ajoutant une d√©finition de la fonction
<code>rechercher</code> qui retourne un vecteur vide, comme dans l'encart 12-16. Ensuite
le test va compiler et √©chouer car un vecteur vide ne correspond pas au vecteur
qui contient la ligne <code>&quot;s√©curit√©, rapidit√©, productivit√©.&quot;</code></p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-16: Defining just enough of the `search`
function so our test will compile</span>
-->
<p><span class="caption">Encart 12-16¬†: D√©finition du strict minimum de la fonction
<code>rechercher</code> pour que notre test puisse compiler</span></p>
<!--
Notice that we need an explicit lifetime `'a` defined in the signature of
`search` and used with the `contents` argument and the return value. Recall in
[Chapter 10][ch10-lifetimes]<!-- ignore -- > that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument `contents` (rather than the
argument `query`).
-->
<p>Remarquez que nous avons besoin de pr√©ciser explicitement une dur√©e de vie <code>'a</code>
d√©finie dans la signature de <code>rechercher</code> et l'utiliser sur l'argument <code>contenu</code>
et la valeur de retour. Rappelez-vous que dans le
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> nous avions vu que le param√®tre
de dur√©e de vie indique quelle dur√©e de vie d'argument est connect√©e
√† la dur√©e de vie de la valeur de retour. Dans notre cas, nous indiquons que le
vecteur retourn√© devrait contenir des slices de cha√Ænes de caract√®res qui
proviennent des slices de l'argument <code>contenu</code> (et pas de l'argument
<code>recherche</code>).</p>
<!--
In other words, we tell Rust that the data returned by the `search` function
will live as long as the data passed into the `search` function in the
`contents` argument. This is important! The data referenced *by* a slice needs
to be valid for the reference to be valid; if the compiler assumes we‚Äôre making
string slices of `query` rather than `contents`, it will do its safety checking
incorrectly.
-->
<p>Autrement dit, nous disons √† Rust que les donn√©es retourn√©es par la fonction
<code>rechercher</code> vont vivre aussi longtemps que la donn√©e dans l'argument <code>contenu</code>
de la fonction <code>rechercher</code>. C'est tr√®s important¬†! Les donn√©es sur lesquelles
pointent les slices doivent toujours √™tre en vigueur pour que la r√©f√©rence
reste valide¬†; si le compilateur croit que nous cr√©ons des slices de
<code>recherche</code> plut√¥t que de <code>contenu</code>, ses v√©rifications de s√©curit√© seront
incorrectes.</p>
<!--
If we forget the lifetime annotations and try to compile this function, we‚Äôll
get this error:
-->
<p>Si nous oublions les annotations de dur√©e de vie et que nous essayons de
compiler cette fonction, nous allons obtenir cette erreur¬†:</p>
<!--
```console
$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  -- > src/lib.rs:28:51
   |
28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn rechercher(recherche: &amp;str, contenu: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                              ----           ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `recherche` or `contenu`
help: consider introducing a named lifetime parameter
   |
28 | pub fn rechercher&lt;'a&gt;(recherche: &amp;'a str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |                  ++++             ++            ++              ++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<!--
Rust can‚Äôt possibly know which of the two arguments we need, so we need to tell
it. Because `contents` is the argument that contains all of our text and we
want to return the parts of that text that match, we know `contents` is the
argument that should be connected to the return value using the lifetime syntax.
-->
<p>Rust ne peut pas deviner lequel des deux arguments nous allons utiliser, donc
nous devons lui dire. Comme <code>contenu</code> est l'argument qui contient tout notre
texte et que nous voulons retourner des extraits de ce texte qui correspondent √†
la recherche, nous savons que <code>contenu</code> est l'argument qui doit √™tre connect√© √†
la valeur de retour, en utilisant la syntaxe de dur√©e de vie.</p>
<!--
Other programming languages don‚Äôt require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the [‚ÄúValidating
References with Lifetimes‚Äù][validating-references-with-lifetimes]<!-- ignore
-- > section in Chapter 10.
-->
<p>Les autres langages de programmation n'ont pas besoin que vous connectiez les
arguments aux valeurs de retour dans la signature. Bien que cela puisse para√Ætre
√©trange, cela devient plus facile au fil du temps. Vous devriez peut-√™tre
comparer cet exemple √† la
<a href="ch10-03-lifetime-syntax.html">section 3 du chapitre 10</a><!-- ignore -->.</p>
<!--
Now let‚Äôs run the test:
-->
<p>Maintenant, ex√©cutons le test¬†:</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... FAILED

failures:

---- tests::un_resultat stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;s√©curit√©, rapidit√©, productivit√©.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_resultat

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Great, the test fails, exactly as we expected. Let‚Äôs get the test to pass!
-->
<p>Tr√®s bien, le test a √©chou√©, comme nous nous y attendions. Faisons maintenant en
sorte qu'il r√©ussisse¬†!</p>
<!--
### Writing Code to Pass the Test
-->
<h3 id="ecrire-du-code-pour-r√©ussir-au-test"><a class="header" href="#ecrire-du-code-pour-r√©ussir-au-test">Ecrire du code pour r√©ussir au test</a></h3>
<!--
Currently, our test is failing because we always return an empty vector. To fix
that and implement `search`, our program needs to follow these steps:
-->
<p>Pour le moment, notre test √©choue car nous retournons toujours un vecteur vide.
Pour corriger cela et impl√©menter <code>rechercher</code>, notre programme doit suivre les
√©tapes suivantes¬†:</p>
<!--
* Iterate through each line of the contents.
* Check whether the line contains our query string.
* If it does, add it to the list of values we‚Äôre returning.
* If it doesn‚Äôt, do nothing.
* Return the list of results that match.
-->
<ul>
<li>It√©rer sur chacune des lignes de <code>contenu</code>.</li>
<li>V√©rifier si la ligne contient la cha√Æne de caract√®res recherch√©e.</li>
<li>Si c'est le cas, l'ajouter √† la liste des valeurs que nous retournerons.</li>
<li>Si ce n'est pas le cas, ne rien faire.</li>
<li>Retourner la liste des r√©sultats qui ont √©t√© trouv√©s.</li>
</ul>
<!--
Let‚Äôs work through each step, starting with iterating through lines.
-->
<p>Travaillons sur chacune de ces √©tapes, en commen√ßant par l'it√©ration sur les
lignes.</p>
<!--
#### Iterating Through Lines with the `lines` Method
-->
<h4 id="it√©rer-sur-chacune-des-lignes-avec-la-m√©thode-lines"><a class="header" href="#it√©rer-sur-chacune-des-lignes-avec-la-m√©thode-lines">It√©rer sur chacune des lignes avec la m√©thode <code>lines</code></a></h4>
<!--
Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named `lines`, that works as shown in Listing 12-17. Note this
won‚Äôt compile yet.
-->
<p>Rust a une m√©thode tr√®s pratique pour g√©rer l'it√©ration ligne-par-ligne des
cha√Ænes de caract√®res, judicieusement appel√©e <code>lines</code>, qui fonctionne comme dans
l'encart 12-17. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        // faire quelquechose avec ligne ici
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-17: Iterating through each line in `contents`
</span>
-->
<p><span class="caption">Encart 12-17¬†: It√©ration sur chacune des lignes de
<code>contenu</code> </span></p>
<!-- markdownlint-disable -->
<!--
The `lines` method returns an iterator. We‚Äôll talk about iterators in depth in
[Chapter 13][ch13-iterators]<!-- ignore -- >, but recall that you saw this way of using an
iterator in [Listing 3-5][ch3-iter]<!-- ignore -- >, where we used a `for` loop
with an iterator to run some code on each item in a collection.
-->
<!-- markdownlint-restore -->
<p>La m√©thode <code>lines</code> retourne un it√©rateur. Nous verrons plus tard les it√©rateurs
dans le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, mais souvenez-vous que
vous avez vu cette fa√ßon d'utiliser un it√©rateur dans
<a href="ch03-05-control-flow.html">l'encart 3-5</a><!-- ignore -->, dans lequel nous avions utilis√© une
boucle <code>for</code> sur un it√©rateur pour ex√©cuter du code sur chaque √©l√©ment d'une
collection.</p>
<!--
#### Searching Each Line for the Query
-->
<h4 id="trouver-chaque-ligne-correspondante-√†-la-recherche"><a class="header" href="#trouver-chaque-ligne-correspondante-√†-la-recherche">Trouver chaque ligne correspondante √† la recherche</a></h4>
<!--
Next, we‚Äôll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note this still won‚Äôt compile yet.
-->
<p>Ensuite, nous allons v√©rifier que la ligne courante contient la cha√Æne de
caract√®res que nous recherchons. Heureusement, les cha√Ænes de caract√®res ont une
m√©thode <code>contains</code> assez pratique qui fait cela pour nous¬†! Ajoutez l'appel √†
la m√©thode <code>contains</code> dans la fonction <code>rechercher</code>, comme dans l'encart 12-18.
Notez qu'ici non plus nous ne pouvons pas encore compiler.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            // faire quelquechose avec la ligne ici
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in `query`</span>
-->
<p><span class="caption">Encart 12-18¬†: Ajout d'une fonctionnalit√© pour trouver
quelle ligne contient la cha√Æne de caract√®res <code>recherche</code></span></p>
<!--
#### Storing Matching Lines
-->
<h4 id="stocker-les-lignes-trouv√©es"><a class="header" href="#stocker-les-lignes-trouv√©es">Stocker les lignes trouv√©es</a></h4>
<!--
We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the `for` loop and call the `push` method
to store a `line` in the vector. After the `for` loop, we return the vector, as
shown in Listing 12-19.
-->
<p>Nous avons aussi besoin d'un moyen de stocker les lignes qui contiennent la
cha√Æne de caract√®res que nous recherchons. Pour cela, nous pouvons cr√©er un
vecteur mutable avant la boucle <code>for</code> et appeler la m√©thode <code>push</code> pour
enregistrer la <code>ligne</code> dans le vecteur. Apr√®s la boucle <code>for</code>, nous retournons
le vecteur, comme dans l'encart 12-19¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span>
-->
<p><span class="caption">Encart 12-19¬†: Enregistrement des lignes qui sont
trouv√©es afin que nous puissions les retourner</span></p>
<!--
Now the `search` function should return only the lines that contain `query`,
and our test should pass. Let‚Äôs run the test:
-->
<p>Maintenant, notre fonction <code>rechercher</code> retourne uniquement les lignes qui
contiennent <code>recherche</code>, et notre test devrait r√©ussir. Ex√©cutons le test¬†:</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Our test passed, so we know it works!
-->
<p>Notre test a r√©ussi, donc nous savons que cela fonctionne¬†!</p>
<!--
At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn‚Äôt too bad,
but it doesn‚Äôt take advantage of some useful features of iterators. We‚Äôll
return to this example in [Chapter 13][ch13-iterators]<!-- ignore -- >, where we‚Äôll
explore iterators in detail, and look at how to improve it.
-->
<p>Arriv√© √† ce stade, nous pourrions envisager des pistes de remaniement pour
l'impl√©mentation de la fonction de recherche tout en faisant en sorte que les
tests r√©ussissent toujours afin de conserver les m√™mes fonctionnalit√©s. Le code
de la fonction de recherche n'est pas mauvais, mais il ne profite pas de
quelques fonctionnalit√©s utiles des it√©rateurs. Nous retrouverons cet exemple dans
le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, dans lequel nous explorerons
les it√©rateurs en d√©tail, et ainsi d√©couvrir comment nous pourrions l'am√©liorer.</p>
<!--
#### Using the `search` Function in the `run` Function
-->
<h4 id="utiliser-la-fonction-rechercher-dans-la-fonction-run"><a class="header" href="#utiliser-la-fonction-rechercher-dans-la-fonction-run">Utiliser la fonction <code>rechercher</code> dans la fonction <code>run</code></a></h4>
<!--
Now that the `search` function is working and tested, we need to call `search`
from our `run` function. We need to pass the `config.query` value and the
`contents` that `run` reads from the file to the `search` function. Then `run`
will print each line returned from `search`:
-->
<p>Maintenant que la fonction <code>rechercher</code> fonctionne et est test√©e, nous devons
appeler <code>rechercher</code> dans notre fonction <code>run</code>. Nous devons passer √†
<code>rechercher</code> la valeur de <code>config.recherche</code>  et le <code>contenu</code> que <code>run</code> obtient
en lisant le fichier. Ensuite, <code>run</code> devra afficher chaque ligne retourn√©e par
<code>rechercher</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}
# 
# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
#     let mut results = Vec::new();
# 
#     for line in contents.lines() {
#         if line.contains(query) {
#             results.push(line);
#         }
#     }
# 
#     results
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We‚Äôre still using a `for` loop to return each line from `search` and print it.
-->
<p>Nous utilisons ici aussi une boucle <code>for</code> pour r√©cup√©rer chaque ligne provenant
de <code>rechercher</code> et l'afficher.</p>
<!--
Now the entire program should work! Let‚Äôs try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, ‚Äúfrog‚Äù:
-->
<p>Maintenant, l'int√©gralit√© du programme devrait fonctionner¬†! Essayons-le, pour
commencer avec un mot qui devrait retourner exactement une seule ligne du po√®me
d'Emily Dickinson, ‚Äúfrog‚Äù¬†:</p>
<!--
```console
$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```
-->
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!--
Cool! Now let‚Äôs try a word that will match multiple lines, like ‚Äúbody‚Äù:
-->
<p>Super¬†! Maintenant, essayons un mot qui devrait retourner plusieurs lignes,
comme ‚Äúbody‚Äù¬†:</p>
<!--
```console
$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
And finally, let‚Äôs make sure that we don‚Äôt get any lines when we search for a
word that isn‚Äôt anywhere in the poem, such as ‚Äúmonomorphization‚Äù:
-->
<p>Et enfin, assurons-nous que nous n'obtenons aucune ligne lorsque nous cherchons
un mot qui n'est nulle part dans le po√®me, comme ‚Äúmonomorphization‚Äù¬†:</p>
<!--
```console
$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```
-->
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!--
Excellent! We‚Äôve built our own mini version of a classic tool and learned a lot
about how to structure applications. We‚Äôve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.
-->
<p>Tr√®s bien¬†! Nous avons construit notre propre mini-version d'un outil classique
et nous avons beaucoup appris sur la fa√ßon de structurer nos applications. Nous
en avons aussi appris un peu sur les entr√©es et sorties des fichiers, les
dur√©es de vie, les tests et l'interpr√©tation de la ligne de commande.</p>
<!--
To round out this project, we‚Äôll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you‚Äôre writing command line programs.
-->
<p>Pour cl√¥turer ce projet, nous allons bri√®vement voir comment travailler avec les
variables d'environnement et comment √©crire sur la sortie standard des erreurs,
ce qui peut s'av√©rer utile lorsque vous √©crivez des programmes en ligne de
commande.</p>
<!--
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Working with Environment Variables
-->
<h2 id="travailler-avec-des-variables-denvironnement"><a class="header" href="#travailler-avec-des-variables-denvironnement">Travailler avec des variables d'environnement</a></h2>
<!--
We‚Äôll improve `minigrep` by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we‚Äôll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.
-->
<p>Nous allons am√©liorer <code>minigrep</code> en lui ajoutant une fonctionnalit√©
suppl√©mentaire : une option pour rechercher sans √™tre sensible √† la casse que
l'utilisateur pourra activer via une variable d'environnement. Nous pourrions
appliquer cette fonctionnalit√© avec une option en ligne de commande et demander
√† l'utilisateur de la renseigner √† chaque fois qu'il veut l'activer, mais √† la
place nous allons utiliser une variable d'environnement. Ceci permet √† nos
utilisateurs de r√©gler la variable d'environnement une seule fois et d'avoir
leurs recherches insensibles √† la casse dans cette session du terminal.</p>
<!--
### Writing a Failing Test for the Case-Insensitive `search` Function
-->
<h3 id="ecrire-un-test-qui-√©choue-pour-la-fonction-rechercher-insensible-√†-la-casse"><a class="header" href="#ecrire-un-test-qui-√©choue-pour-la-fonction-rechercher-insensible-√†-la-casse">Ecrire un test qui √©choue pour la fonction <code>rechercher</code> insensible √† la casse</a></h3>
<!--
We want to add a new `search_case_insensitive` function that we‚Äôll call when
the environment variable is on. We‚Äôll continue to follow the TDD process, so
the first step is again to write a failing test. We‚Äôll add a new test for the
new `search_case_insensitive` function and rename our old test from
`one_result` to `case_sensitive` to clarify the differences between the two
tests, as shown in Listing 12-20.
-->
<p>Nous souhaitons ajouter une nouvelle fonction <code>rechercher_insensible_casse</code> que
nous allons appeler lorsque la variable d'environnement est active. Nous allons
continuer √† suivre le processus de TDD, donc la premi√®re √©tape est d'√©crire √†
nouveau un test qui √©choue. Nous allons ajouter un nouveau test pour la nouvelle
fonction <code>rechercher_insensible_casse</code> et renommer notre ancien test
<code>un_resultat</code> en <code>sensible_casse</code> pour clarifier les diff√©rences entre les deux
tests, comme dans l'encart 12-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     for ligne in rechercher(&config.recherche, &contenu) {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sensible_casse() {
        let recherche = "duct";
        let contenu = "\
Rust:
s√©curit√©, rapidit√©, productivit√©.
Obtenez les trois en m√™me temps.
Duck tape.";

        assert_eq!(vec!["s√©curit√©, rapidit√©, productivit√©."], rechercher(recherche, contenu));
    }

    #[test]
    fn insensible_casse() {
        let recherche = "rUsT";
        let contenu = "\
Rust:
s√©curit√©, rapidit√©, productivit√©.
Obtenez les trois en m√™me temps.
C'est pas rustique.";

        assert_eq!(
            vec!["Rust:", "C'est pas rustique."],
            rechercher_insensible_casse(recherche, contenu)
        );
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sensible_casse() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
s√©curit√©, rapidit√©, productivit√©.
Obtenez les trois en m√™me temps.
Duck tape.&quot;;

        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
    }

    #[test]
    fn insensible_casse() {
        let recherche = &quot;rUsT&quot;;
        let contenu = &quot;\
Rust:
s√©curit√©, rapidit√©, productivit√©.
Obtenez les trois en m√™me temps.
C'est pas rustique.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;C'est pas rustique.&quot;],
            rechercher_insensible_casse(recherche, contenu)
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function we‚Äôre about to add</span>
-->
<p><span class="caption">Encart 12-20 : Ajout d'un nouveau test qui √©choue pour la
fonction insensible √† la casse que nous sommes en train d'ajouter</span></p>
<!--
Note that we‚Äôve edited the old test‚Äôs `contents` too. We‚Äôve added a new line
with the text `"Duct tape."` using a capital D that shouldn‚Äôt match the query
`"duct"` when we‚Äôre searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don‚Äôt accidentally break the case-sensitive
search functionality that we‚Äôve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.
-->
<p>Remarquez que nous avons aussi modifi√© le <code>contenu</code> de l'ancien test.
Nous avons ajout√© une nouvelle ligne avec le texte <code>&quot;Duct tape.&quot;</code> en utilisant
un D majuscule qui ne devrait pas correspondre √† la recherche <code>&quot;duct&quot;</code> lorsque
nous recherchons de mani√®re √† √™tre sensible √† la casse. Ce changement de
l'ancien test permet de nous assurer que nous ne casserons pas accidentellement
la fonction de recherche sensible √† la casse que nous avons d√©j√† impl√©ment√©. Ce
test devrait toujours continuer √† r√©ussir au fur et √† mesure que nous progressons
sur la recherche insensible √† la casse.</p>
<!--
The new test for the case-*insensitive* search uses `"rUsT"` as its query. In
the `search_case_insensitive` function we‚Äôre about to add, the query `"rUsT"`
should match the line containing `"Rust:"` with a capital R and match the line
`"Trust me."` even though both have different casing from the query. This is
our failing test, and it will fail to compile because we haven‚Äôt yet defined
the `search_case_insensitive` function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the `search` function in Listing 12-16 to see the test compile and fail.
-->
<p>Le nouveau test pour la recherche insensible √† la casse utilise <code>&quot;rUsT&quot;</code> comme
recherche. Dans la fonction <code>rechercher_insensible_casse</code> que nous sommes en
train d'ajouter, la recherche <code>&quot;rUsT&quot;</code> devrait correspondre √† la ligne qui
contient <code>&quot;Rust:&quot;</code> avec un R majuscule ainsi que la ligne <code>C'est pas rustique.</code>
m√™me si ces deux cas ont des casses diff√©rentes de la recherche. C'est notre
test qui doit √©chouer, et il ne devrait pas se compiler car nous n'avons pas
encore d√©fini la fonction <code>rechercher_insensible_casse</code>. Ajoutez son
impl√©mentation qui retourne toujours un vecteur vide, de la m√™me mani√®re que
nous l'avions fait pour la fonction <code>rechercher</code> dans l'encart 12-16 pour voir
si les tests se compilent et √©chouent.</p>
<!--
### Implementing the `search_case_insensitive` Function
-->
<h3 id="impl√©menter-la-fonction-rechercher_insensible_casse"><a class="header" href="#impl√©menter-la-fonction-rechercher_insensible_casse">Impl√©menter la fonction <code>rechercher_insensible_casse</code></a></h3>
<!--
The `search_case_insensitive` function, shown in Listing 12-21, will be almost
the same as the `search` function. The only difference is that we‚Äôll lowercase
the `query` and each `line` so whatever the case of the input arguments,
they‚Äôll be the same case when we check whether the line contains the query.
-->
<p>La fonction <code>rechercher_insensible_casse</code>, pr√©sente dans l'encart 12-21, sera
presque la m√™me que la fonction <code>rechercher</code>. La seule diff√©rence est que nous
allons transformer en minuscule le contenu de <code>recherche</code> et de chaque <code>ligne</code>
pour que quelle que soit la casse des arguments d'entr√©e, nous aurons toujours la
m√™me casse lorsque nous v√©rifierons si la ligne contient la recherche.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     for ligne in rechercher(&config.recherche, &contenu) {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
pub fn rechercher_insensible_casse<'a>(
    recherche: &str,
    contenu: &'a str
) -> Vec<&'a str> {
    let recherche = recherche.to_lowercase();
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.to_lowercase().contains(&recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# s√©curit√©, rapidit√©, productivit√©.
# Obtenez les trois en m√™me temps.
# Duck tape.";
# 
#         assert_eq!(vec!["s√©curit√©, rapidit√©, productivit√©."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn insensible_casse() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# s√©curit√©, rapidit√©, productivit√©.
# Obtenez les trois en m√™me temps.
# C'est pas rustique.";
# 
#         assert_eq!(
#             vec!["Rust:", "C'est pas rustique."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher_insensible_casse&lt;'a&gt;(
    recherche: &amp;str,
    contenu: &amp;'a str
) -&gt; Vec&lt;&amp;'a str&gt; {
    let recherche = recherche.to_lowercase();
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.to_lowercase().contains(&amp;recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.
</span><span class="boring">Duck tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn insensible_casse() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.
</span><span class="boring">C'est pas rustique.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;C'est pas rustique.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-21: Defining the `search_case_insensitive`
function to lowercase the query and the line before comparing them</span>
-->
<p><span class="caption">Encart 12-21 : D√©finition de la fonction
<code>rechercher_insensible_casse</code> pour obtenir en minuscule la recherche et la
ligne avant de les comparer</span></p>
<!--
First, we lowercase the `query` string and store it in a shadowed variable with
the same name. Calling `to_lowercase` on the query is necessary so no matter
whether the user‚Äôs query is `"rust"`, `"RUST"`, `"Rust"`, or `"rUsT"`, we‚Äôll
treat the query as if it were `"rust"` and be insensitive to the case. While
`to_lowercase` will handle basic Unicode, it won‚Äôt be 100% accurate. If we were
writing a real application, we‚Äôd want to do a bit more work here, but this section
is about environment variables, not Unicode, so we‚Äôll leave it at that here.
-->
<p>D'abord, nous obtenons la cha√Æne de caract√®res <code>recherche</code> en minuscule et nous
l'enregistrons dans une variable masqu√©e avec le m√™me nom. L'appel √†
<code>to_lowercase</code> sur la recherche est n√©cessaire afin que quel que soit la
recherche de l'utilisateur, comme <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, ou <code>&quot;rUsT&quot;</code>,
nous traitons la recherche comme si elle √©tait <code>&quot;rust&quot;</code> et par cons√©quent elle
est insensible √† la casse. La m√©thode <code>to_lowercase</code> devrait g√©rer de l'Unicode
de base, mais ne sera pas fiable √† 100%. Si nous avions √©crit une application
s√©rieuse, nous aurions d√ª faire plus de choses √† ce sujet, toutefois vu que la section
actuelle traite des variables d'environnement et pas de la gestion de
l'Unicode, nous allons conserver ce code simplifi√©.</p>
<!--
Note that `query` is now a `String` rather than a string slice, because calling
`to_lowercase` creates new data rather than referencing existing data. Say the
query is `"rUsT"`, as an example: that string slice doesn‚Äôt contain a lowercase
`u` or `t` for us to use, so we have to allocate a new `String` containing
`"rust"`. When we pass `query` as an argument to the `contains` method now, we
need to add an ampersand because the signature of `contains` is defined to take
a string slice.
-->
<p>Notez que <code>recherche</code> est d√©sormais une <code>String</code> et non plus une slice de cha√Æne
de caract√®res, car l'appel √† <code>to_lowercase</code> cr√©e des nouvelles donn√©es au lieu
de modifier les donn√©es d√©j√† existantes. Par exemple, disons que la recherche
est <code>&quot;rUsT&quot;</code> : cette slice de cha√Æne de caract√®res ne contient pas de <code>u</code> ou de
<code>t</code> minuscule que nous pourrions utiliser, donc nous devons allouer une nouvelle
<code>String</code> qui contient <code>&quot;rust&quot;</code>. Maintenant, lorsque nous passons <code>recherche</code> en
argument de la m√©thode <code>contains</code>, nous devons rajouter une esperluette car la
signature de <code>contains</code> est d√©finie pour prendre une slice de cha√Æne de
caract√®res.</p>
<!--
Next, we add a call to `to_lowercase` on each `line` before we check whether it
contains `query` to lowercase all characters. Now that we‚Äôve converted `line`
and `query` to lowercase, we‚Äôll find matches no matter what the case of the
query is.
-->
<p>Ensuite, nous ajoutons un appel √† <code>to_lowercase</code> sur chaque <code>ligne</code> avant de
v√©rifier si elle contient <code>recherche</code> afin d'obtenir tous ses caract√®res en
minuscule. Maintenant que nous avons <code>ligne</code> et <code>recherche</code> en minuscules, nous
allons rechercher les correspondances peu importe la casse de la recherche.</p>
<!--
Let‚Äôs see if this implementation passes the tests:
-->
<p>Voyons si cette impl√©mentation passe les tests :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::sensible_casse ... ok
test tests::insensible_casse ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::sensible_casse ... ok
test tests::insensible_casse ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Great! They passed. Now, let‚Äôs call the new `search_case_insensitive` function
from the `run` function. First, we‚Äôll add a configuration option to the
`Config` struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we aren‚Äôt initializing
this field anywhere yet:
-->
<p>Tr√®s bien ! Elles ont r√©ussi. Maintenant, utilisons la nouvelle fonction
<code>rechercher_insensible_casse</code> dans la fonction <code>run</code>. Pour commencer, nous
allons ajouter une option de configuration √† la structure <code>Config</code> pour changer
entre la recherche sensible et non sensible √† la casse. L'ajout de ce champ va
causer des erreurs de compilation car nous n'avons jamais initialis√© ce champ
pour le moment :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
    pub sensible_casse: bool,
}
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
    pub sensible_casse: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Note that we added the `case_sensitive` field that holds a Boolean. Next, we
need the `run` function to check the `case_sensitive` field‚Äôs value and use
that to decide whether to call the `search` function or the
`search_case_insensitive` function, as shown in Listing 12-22. Note this still
won‚Äôt compile yet.
-->
<p>Remarquez que le champ <code>sensible_casse</code> que nous avons ajout√© est un Bool√©en.
Ensuite, nous devons faire en sorte que la fonction <code>run</code> v√©rifie la valeur du
champ <code>sensible_casse</code> et l'utilise pour d√©cider si elle doit appeler la
fonction <code>rechercher</code> ou la fonction <code>rechercher_insensible_casse</code>, comme dans
l'encart 12-22. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    let resultats = if config.sensible_casse {
        rechercher(&config.recherche, &contenu)
    } else {
        rechercher_insensible_casse(&config.recherche, &contenu)
    };

    for ligne in resultats {
        println!("{}", ligne);
    }

    Ok(())
}
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    let resultats = if config.sensible_casse {
        rechercher(&amp;config.recherche, &amp;contenu)
    } else {
        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
    };

    for ligne in resultats {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-22: Calling either `search` or
`search_case_insensitive` based on the value in `config.case_sensitive`</span>
-->
<p><span class="caption">Encart 12-22 : Appeler <code>rechercher</code> ou
<code>rechercher_insensible_casse</code> en fonction de la valeur dans <code>config.sensible_casse</code>
</span></p>
<!--
Finally, we need to check for the environment variable. The functions for
working with environment variables are in the `env` module in the standard
library, so we want to bring that module into scope with a `use std::env;` line
at the top of *src/lib.rs*. Then we‚Äôll use the `var` function from the `env`
module to check for an environment variable named `CASE_INSENSITIVE`, as shown
in Listing 12-23.
-->
<p>Enfin, nous devons v√©rifier la variable d'environnement. Les fonctions pour
travailler avec les variables d'environnement sont dans le module <code>env</code> de la
biblioth√®que standard, donc nous allons importer ce module dans la port√©e avec
une ligne <code>use std::env;</code> en haut de <em>src/lib.rs</em>. Ensuite, nous allons utiliser
la fonction <code>var</code> du module <code>env</code> pour v√©rifier la pr√©sence d'une variable
d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code>, comme dans l'encart 12-23.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::env;
// -- partie masqu√©e ici --

# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust noplayground">use std::env;
// -- partie masqu√©e ici --

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-23: Checking for an environment variable named
`CASE_INSENSITIVE`</span>
-->
<p><span class="caption">Encart 12-23 : V√©rification de la pr√©sence de la variable
d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code></span></p>
<!--
Here, we create a new variable `case_sensitive`. To set its value, we call the
`env::var` function and pass it the name of the `CASE_INSENSITIVE` environment
variable. The `env::var` function returns a `Result` that will be the successful
`Ok` variant that contains the value of the environment variable if the
environment variable is set. It will return the `Err` variant if the
environment variable is not set.
-->
<p>Ici, nous cr√©ons une nouvelle variable <code>sensible_casse</code>. Pour lui donner une
valeur, nous appelons la fonction <code>env::var</code> et nous lui passons le nom de la
variable d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code>. La fonction <code>env::var</code>
retourne un <code>Result</code> qui sera en cas de succ√®s la variante <code>Ok</code> qui contiendra
la valeur de la variable d'environnement si cette variable d'environnement est
d√©finie. Elle retournera la variante <code>Err</code> si cette variable d'environnement
n'est pas d√©finie.</p>
<!--
We‚Äôre using the `is_err` method on the `Result` to check whether it‚Äôs an error
and therefore unset, which means it *should* do a case-sensitive search. If the
`CASE_INSENSITIVE` environment variable is set to anything, `is_err` will
return false and the program will perform a case-insensitive search. We don‚Äôt
care about the *value* of the environment variable, just whether it‚Äôs set or
unset, so we‚Äôre checking `is_err` rather than using `unwrap`, `expect`, or any
of the other methods we‚Äôve seen on `Result`.
-->
<p>Nous utilisons la m√©thode <code>is_err</code> sur le <code>Result</code> pour v√©rifier si nous obtenons
une erreur, signalant par cons√©quent que la variable d'environnement n'est pas
d√©finie et donc que nous <em>devons</em> effectuer une recherche sensible √† la casse.
Si la variable d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code> a une valeur qui lui
a √©t√© assign√©e, <code>is_err</code> va retourner <code>false</code> et le programme va proc√©der √† une
recherche non sensible √† la casse. Nous ne nous pr√©occupons pas de la <em>valeur</em>
de la variable d'environnement, mais uniquement de savoir si elle est d√©finie
ou non, donc nous utilisons <code>is_err</code> plut√¥t que <code>unwrap</code>, <code>expect</code> ou toute
autre m√©thode que nous avons vue avec <code>Result</code>.</p>
<!--
We pass the value in the `case_sensitive` variable to the `Config` instance so
the `run` function can read that value and decide whether to call `search` or
`search_case_insensitive`, as we implemented in Listing 12-22.
-->
<p>Nous passons la valeur de la variable <code>sensible_casse</code> √† l'instance de <code>Config</code>
afin que la fonction <code>run</code> puisse lire cette valeur et d√©cider d'appeler
<code>rechercher</code> ou <code>rechercher_insensible_casse</code>, comme nous l'avons impl√©ment√©
dans l'encart 12-22.</p>
<!--
Let‚Äôs give it a try! First, we‚Äôll run our program without the environment
variable set and with the query `to`, which should match any line that contains
the word ‚Äúto‚Äù in all lowercase:
-->
<p>Faisons un essai ! D'abord, nous allons lancer notre programme avec la variable
d'environnement non d√©finie et avec la recherche <code>to</code>, qui devrait trouver
toutes les lignes qui contiennent le mot ‚Äúto‚Äù en minuscules :</p>
<!--
```console
$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
Looks like that still works! Now, let‚Äôs run the program with `CASE_INSENSITIVE`
set to `1` but with the same query `to`.
-->
<p>On dirait que cela fonctionne ! Maintenant, lan√ßons le programme avec
<code>MINIGREP_INSENSIBLE_CASSE</code> d√©finie √† <code>1</code> mais avec la m√™me recherche <code>to</code>.</p>
<!--
If you‚Äôre using PowerShell, you will need to set the environment
variable and run the program as separate commands:
-->
<p>Si vous utilisez PowerShell, vous allez avoir besoin d'affecter la variable
d'environnement puis ex√©cuter le programme avec deux commandes distinctes :</p>
<!--
```console
PS> $Env:CASE_INSENSITIVE=1; cargo run to poem.txt
```
-->
<pre><code class="language-console">PS&gt; $Env:MINIGREP_INSENSIBLE_CASSE=1; cargo run to poem.txt
</code></pre>
<!--
This will make `CASE_INSENSITIVE` persist for the remainder of your shell
session. It can be unset with the `Remove-Item` cmdlet:
-->
<p>Cela va faire persister la variable <code>MINIGREP_INSENSIBLE_CASSE</code> pour la dur√©e de
votre session de terminal. Elle peut √™tre d√©saffect√©e avec la cmdlet
<code>Remove-Item</code>¬†:</p>
<!--
```console
PS> Remove-Item Env:CASE_INSENSITIVE
```
-->
<pre><code class="language-console">PS&gt; Remove-Item Env:MINIGREP_INSENSIBLE_CASSE
</code></pre>
<!--
We should get lines that contain ‚Äúto‚Äù that might have uppercase letters:
-->
<p>Nous devrions trouver cette fois-ci √©galement toutes les lignes qui contiennent
‚Äúto‚Äù √©crit avec certaines lettres en majuscule:</p>
<!--
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
CASE_INSENSITIVE=1 cargo run to poem.txt
can't extract because of the environment variable
-- >
-->
<!--
```console
$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```
-->
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
Excellent, we also got lines containing ‚ÄúTo‚Äù! Our `minigrep` program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.
-->
<p>Tr√®s bien, nous avons aussi obtenu les lignes qui contiennent ‚ÄúTo‚Äù ! Notre
programme <code>minigrep</code> peut maintenant faire des recherches insensibles √† la
casse, contr√¥l√©es par une variable d'environnement. Vous savez maintenant comment
g√©rer des options d√©finies soit par des arguments en ligne de commande, soit
par des variables d'environnement.</p>
<!--
Some programs allow arguments *and* environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.
-->
<p>Certains programmes permettent d'utiliser les arguments <em>et</em> les variables
d'environnement pour un m√™me r√©glage. Dans ce cas, le programme d√©cide si l'un
ou l'autre a la priorit√©. Pour vous exercer √† nouveau, essayez de contr√¥ler la
sensibilit√© √† la casse via un argument de ligne de commande ou une variable
d'environnement. Vous devrez choisir qui de l'argument de la ligne de commande ou
de la variable d'environnement doit √™tre prioritaire lorsque les deux sont configur√©s
simultan√©ment mais de mani√®re contradictoire quand le programme est ex√©cut√©.</p>
<!--
The `std::env` module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.
-->
<p>Le module <code>std::env</code> contient plein d'autres fonctionnalit√©s utiles pour
utiliser les variables d'environnement : regardez sa documentation pour voir ce
qu'il est possible de faire.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Writing Error Messages to Standard Error Instead of Standard Output
-->
<h2 id="ecrire-les-messages-derreur-sur-la-sortie-derreur-standard-au-lieu-de-la-sortie-normale"><a class="header" href="#ecrire-les-messages-derreur-sur-la-sortie-derreur-standard-au-lieu-de-la-sortie-normale">Ecrire les messages d'erreur sur la sortie d'erreur standard au lieu de la sortie normale</a></h2>
<!--
At the moment, we‚Äôre writing all of our output to the terminal using the
`println!` macro. In most terminals, there are two kinds of output: *standard
output* (`stdout`) for general information and *standard error* (`stderr`) for
error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.
-->
<p>Pour l'instant, nous avons √©crit toutes nos sorties du terminal en utilisant
la macro <code>println!</code>. Dans la plupart des terminaux, il y a deux genres de
sorties¬†: la <em>sortie standard</em> (<code>stdout</code>) pour les informations g√©n√©rales
et <em>la sortie d'erreur standard</em> (<code>stderr</code>) pour les messages d'erreur. Cette
distinction permet √† l'utilisateur de choisir de rediriger la sortie des
messages sans erreurs d'un programme vers un fichier mais continuer √† afficher
les messages d'erreur √† l'√©cran.</p>
<!--
The `println!` macro is only capable of printing to standard output, so we
have to use something else to print to standard error.
-->
<p>La macro <code>println!</code> ne peut √©crire que sur la sortie standard, donc nous
devons utiliser autre chose pour √©crire sur la sortie d'erreur standard.</p>
<!--
### Checking Where Errors Are Written
-->
<h3 id="v√©rifier-o√π-sont-√©crites-les-erreurs"><a class="header" href="#v√©rifier-o√π-sont-√©crites-les-erreurs">V√©rifier o√π sont √©crites les erreurs</a></h3>
<!--
First, let‚Äôs observe how the content printed by `minigrep` is currently being
written to standard output, including any error messages we want to write to
standard error instead. We‚Äôll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won‚Äôt redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.
-->
<p>Commen√ßons par observer comment le contenu √©crit par <code>minigrep</code> est actuellement
√©crit sur la sortie standard, y compris les messages d'erreur que nous
souhaitons plut√¥t √©crire sur la sortie d'erreur standard. Nous allons faire cela
en redirigeant le flux de sortie standard vers un fichier pendant que nous
d√©clencherons intentionnellement une erreur. Nous ne redirigerons pas le flux
de sortie d'erreur standard, si bien que n'importe quel contenu envoy√© √† la sortie
d'erreur standard va continuer √† s'afficher √† l'√©cran.</p>
<!--
Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we‚Äôre about to see that it saves the error message output to a file instead!
-->
<p>Les programmes en ligne de commande sont cens√©s envoyer leurs messages d'erreur
dans le flux d'erreurs standard afin que nous puissions continuer √† voir les
messages d'erreurs √† l'√©cran m√™me si nous redirigeons le flux de la sortie
standard dans un fichier. Notre programme ne se comporte pas comme il le
devrait¬†: nous allons voir qu'√† la place, il envoie les messages d'erreur
dans le fichier¬†!</p>
<!--
The way to demonstrate this behavior is by running the program with `>` and the
filename, *output.txt*, that we want to redirect the standard output stream to.
We won‚Äôt pass any arguments, which should cause an error:
-->
<p>Pour d√©montrer ce comportement, il faut ex√©cuter le programme avec <code>&gt;</code> suivi du
nom du fichier, <em>sortie.txt</em>, dans lequel nous souhaitons rediriger le flux de
sortie standard. Nous ne fournissons aucun argument, ce qui va causer une
erreur¬†:</p>
<!--
```console
$ cargo run > output.txt
```
-->
<pre><code class="language-console">$ cargo run &gt; sortie.txt
</code></pre>
<!--
The `>` syntax tells the shell to write the contents of standard output to
*output.txt* instead of the screen. We didn‚Äôt see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what *output.txt* contains:
-->
<p>La syntaxe indique √† l'invite de commande d'√©crire le contenu de la sortie
standard dans <em>sortie.txt</em> plut√¥t qu'√† l'√©cran. Nous n'avons pas vu le
message d'erreur que nous nous attendions de voir √† l'√©cran, ce qui veut
dire qu'il a d√ª finir dans le fichier. Voici ce que <em>sortie.txt</em> contient¬†:</p>
<!--
```text
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-text">Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: il n'y a pas assez d'arguments
</code></pre>
<!--
Yup, our error message is being printed to standard output. It‚Äôs much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We‚Äôll change that.
-->
<p>Effectivement, notre message d'erreur est √©crit sur la sortie standard. Il
serait bien plus utile que les messages d'erreur comme celui-ci soient √©crits
sur la sortie d'erreur standard afin que seules les donn√©es produites par
ex√©cution fructueuse finissent dans le fichier. Nous allons corriger cela.</p>
<!--
### Printing Errors to Standard Error
-->
<h3 id="ecrire-les-erreurs-sur-la-sortie-derreur-standard"><a class="header" href="#ecrire-les-erreurs-sur-la-sortie-derreur-standard">Ecrire les erreurs sur la sortie d'erreur standard</a></h3>
<!--
We‚Äôll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, `main`. The standard library provides
the `eprintln!` macro that prints to the standard error stream, so let‚Äôs change
the two places we were calling `println!` to print errors to use `eprintln!`
instead.
-->
<p>Nous allons utiliser le code de l'encart 12-24 pour changer la mani√®re dont les
messages d'erreur sont √©crits. Gr√¢ce au remaniement que nous avons fait plus t√¥t
dans ce chapitre, tout le code qui √©crit les messages d'erreurs se trouve dans
une seule fonction, <code>main</code>. La biblioth√®que standard fournit la macro
<code>eprintln!</code> qui √©crit dans le flux d'erreur standard, donc changeons les deux
endroits o√π nous appelons <code>println!</code> afin d'utiliser <code>eprintln!</code> √† la place.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}", err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Erreur applicative¬†: {}", e);

        process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Erreur applicative¬†: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using `eprintln!`</span>
-->
<p><span class="caption">Encart 12-24¬†: Ecrire les messages d'erreur sur la sortie
d'erreur standard au lieu de la sortie standard en utilisant <code>eprintln!</code></span></p>
<!--
After changing `println!` to `eprintln!`, let‚Äôs run the program again in the
same way, without any arguments and redirecting standard output with `>`:
-->
<p>Apr√®s avoir chang√© <code>println!</code> en <code>eprintln!</code>, ex√©cutons √† nouveau le programme
de la m√™me mani√®re, sans aucun argument et en redirigeant la sortie standard
avec <code>&gt;</code>¬†:</p>
<!--
```console
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run &gt; sortie.txt
Probl√®me rencontr√© lors de l'interpr√©tation des arguments¬†: il n'y a pas assez d'arguments
</code></pre>
<!--
Now we see the error onscreen and *output.txt* contains nothing, which is the
behavior we expect of command line programs.
-->
<p>D√©sormais nous pouvons voir l'erreur √† l'√©cran et <em>sortie.txt</em> ne contient rien,
ce qui est le comportement que nous attendons d'un programme en ligne de
commande.</p>
<!--
Let‚Äôs run the program again with arguments that don‚Äôt cause an error but still
redirect standard output to a file, like so:
-->
<p>Ex√©cutons le programme √† nouveau avec des arguments qui ne causent pas d'erreur
tout en continuant √† rediriger la sortie standard vers un fichier, comme ceci¬†:</p>
<!--
```console
$ cargo run to poem.txt > output.txt
```
-->
<pre><code class="language-console">$ cargo run to poem.txt &gt; sortie.txt
</code></pre>
<!--
We won‚Äôt see any output to the terminal, and *output.txt* will contain our
results:
-->
<p>Nous ne voyons rien sur la sortie du terminal, et <em>sortie.txt</em> devrait contenir
notre r√©sultat¬†:</p>
<!--
<span class="filename">Filename: output.txt</span>
-->
<p><span class="filename">Fichier¬†: sortie.txt</span></p>
<!--
```text
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
This demonstrates that we‚Äôre now using standard output for successful output
and standard error for error output as appropriate.
-->
<p>Ceci prouve qu'en fonction des circonstances, nous utilisons maintenant la
sortie standard pour la sortie sans les erreurs et l'erreur standard pour la
sortie d'erreur.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-11"><a class="header" href="#r√©sum√©-11">R√©sum√©</a></h2>
<!--
This chapter recapped some of the major concepts you‚Äôve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the `eprintln!` macro for printing
errors, you‚Äôre now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.
-->
<p>Ce chapitre a r√©sum√© certains des concepts majeurs que vous avez appris
pr√©c√©demment et expliqu√© comment proc√©der √† des op√©rations courantes sur les
entr√©es/sorties en Rust. En utilisant les arguments en ligne de commande, les
fichiers, les variables d'environnement et la macro <code>eprintln!</code> pour √©crire les
erreurs, vous pouvez d√©sormais √©crire des applications en ligne de commande. En
suivant les concepts vus dans les chapitres pr√©c√©dents, votre code restera bien
organis√©, stockera les donn√©es dans les bonnes structures de donn√©es, g√©rera
correctement les erreurs et sera correctement test√©.</p>
<!--
Next, we‚Äôll explore some Rust features that were influenced by functional
languages: closures and iterators.
-->
<p>Maintenant, nous allons d√©couvrir quelques fonctionnalit√©s de Rust qui ont √©t√©
influenc√©es par les langages fonctionnels¬†: les fermetures et les it√©rateurs.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Functional Language Features: Iterators and Closures
-->
<h1 id="les-fonctionnalit√©s-des-langages-fonctionnels--les-it√©rateurs-et-les-fermetures"><a class="header" href="#les-fonctionnalit√©s-des-langages-fonctionnels--les-it√©rateurs-et-les-fermetures">Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></h1>
<!--
Rust‚Äôs design has taken inspiration from many existing languages and
techniques, and one significant influence is *functional programming*.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.
-->
<p>La conception de Rust s'est inspir√©e de nombreux langages et technologies
existantes, et une de ses influences la plus marquante est la <em>programmation
fonctionnelle</em>. La programmation fonctionnelle consiste souvent √† utiliser une
fonction comme une valeur en la passant en argument d'une autre fonction, la
retourner en r√©sultat d'une autre fonction ou l'assigner √† une variable pour
l'ex√©cuter plus tard, par exemple.</p>
<!--
In this chapter, we won‚Äôt debate the issue of what functional programming is or
isn‚Äôt but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.
-->
<p>Dans ce chapitre, nous n'allons pas d√©battre sur ce qu'est ou non la
programmation fonctionnelle, mais nous allons plut√¥t voir quelques
fonctionnalit√©s de Rust qui sont similaires √† celles des autres langages
souvent consid√©r√©s comme fonctionnels.</p>
<!--
More specifically, we‚Äôll cover:
-->
<p>Plus pr√©cis√©ment, nous allons voir¬†:</p>
<!--
* *Closures*, a function-like construct you can store in a variable
* *Iterators*, a way of processing a series of elements
* How to use these two features to improve the I/O project in Chapter 12
* The performance of these two features (Spoiler alert: they‚Äôre faster than you
  might think!)
-->
<ul>
<li><em>les fermetures</em>, une construction qui ressemble √† une fonction que vous
pouvez stocker dans une variable</li>
<li><em>les it√©rateurs</em>, une fa√ßon de travailler sur une s√©rie d'√©l√©ments</li>
<li>Comment utiliser ces deux fonctionnalit√©s pour am√©liorer le projet
d'entr√©e/sortie du chapitre 12</li>
<li>Etudier la performance de ces deux fonctionnalit√©s (divulg√¢chage¬†: elles sont
probablement plus rapides que ce que vous pensez¬†!)</li>
</ul>
<!--
Other Rust features, such as pattern matching and enums, which we‚Äôve covered in
other chapters, are influenced by the functional style as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we‚Äôll devote this entire chapter to them.
-->
<p>Les autres fonctionnalit√©s de Rust, comme le filtrage par motif et les
√©num√©rations, que nous avons vues dans les chapitres pr√©c√©dents sont influenc√©s
par la programmation fonctionnelle. La ma√Ætrise des fermetures et des it√©rateurs
est une √©tape importante pour √©crire du code Rust performant, c'est pourquoi
nous allons leur d√©dier ce chapitre entier.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Closures: Anonymous Functions that Can Capture Their Environment
-->
<h2 id="les-fermetures--fonctions-anonymes-qui-peuvent-utiliser-leur-environnement"><a class="header" href="#les-fermetures--fonctions-anonymes-qui-peuvent-utiliser-leur-environnement">Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></h2>
<!--
Rust‚Äôs closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they‚Äôre defined. We‚Äôll
demonstrate how these closure features allow for code reuse and behavior
customization.
-->
<p>Les fermetures en Rust sont des fonctions anonymes qui peuvent √™tre
sauvegard√©es dans une variable ou qui peuvent √™tre pass√©es en argument √†
d'autres fonctions. Il est possible de cr√©er une fermeture √† un endroit du code
et ensuite de l'appeler dans un contexte diff√©rent pour l'ex√©cuter.
Contrairement aux fonctions, les fermetures ont la possibilit√© de capturer les
valeurs pr√©sentes dans le contexte o√π elles sont appel√©es. Nous allons montrer
comment les fonctionnalit√©s des fermetures permettent de r√©utiliser du code et
suivre des comportements personnalis√©s.</p>
<!--
### Creating an Abstraction of Behavior with Closures
-->
<h3 id="cr√©er-une-abstraction-de-comportement-avec-une-fermeture"><a class="header" href="#cr√©er-une-abstraction-de-comportement-avec-une-fermeture">Cr√©er une abstraction de comportement avec une fermeture</a></h3>
<!--
Let‚Äôs work on an example of a situation in which it‚Äôs useful to store a closure
to be executed later. Along the way, we‚Äôll talk about the syntax of closures,
type inference, and traits.
-->
<p>Travaillons sur un exemple d'une situation o√π il est utile de stocker une
fermeture qui s'ex√©cutera ult√©rieurement. Au cours de ce chapitre, nous allons
parler de la syntaxe des fermetures, de l'inf√©rence de type et des traits.</p>
<!--
Consider this hypothetical situation: we work at a startup that‚Äôs making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app user‚Äôs age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn‚Äôt
important in this example; what‚Äôs important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we don‚Äôt make the user wait more than necessary.
-->
<p>Imaginons la situation suivante¬†: nous travaillons dans une <em>startup</em> qui cr√©e
une application destin√©e √† g√©n√©rer des programmes d'entra√Ænements physiques
personnalis√©s. L'application dorsale est √©crite en Rust et repose sur un
algorithme qui g√©n√®re les exercices en fonction de beaucoup de facteurs tels
que l'√¢ge de l'utilisateur, son indice de masse corporelle, ses pr√©f√©rences et
une intensit√© qu'il aura param√©tr√©. L'algorithme r√©ellement utilis√© n'est pas
important pour cet exemple¬†: ce qui est important c'est que le calcul prenne
plusieurs secondes. Nous voulons appeler l'algorithme uniquement lorsque nous
en avons besoin, et seulement une fois, afin que l'utilisateur n'ait pas √†
attendre plus longtemps que n√©cessaire.</p>
<!--
We‚Äôll simulate calling this hypothetical algorithm with the function
`simulated_expensive_calculation` shown in Listing 13-1, which will print
`calculating slowly...`, wait for two seconds, and then return whatever number
we passed in.
-->
<p>Pour simuler l'appel √† cet algorithme hypoth√©tique, nous allons utiliser la
fonction <code>simuler_gros_calcul</code> pr√©sent dans l'encart 13-1, qui affichera
<code>calcul tr√®s lent ...</code> et attendra deux secondes avant de retourner le nombre
qui lui a √©t√© donn√©¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
    println!(&quot;calcul tr√®s lent ...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensite
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span>
-->
<p><span class="caption">Encart 13-1¬†: une fonction pour remplacer un calcul
hypoth√©tique qui prend environ deux secondes √† s'ex√©cuter</span></p>
<!--
Next is the `main` function, which contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app‚Äôs frontend isn‚Äôt relevant to the use of closures, we‚Äôll hardcode values
representing inputs to our program and print the outputs.
-->
<p>Ensuite, nous avons la fonction <code>main</code> qui contient les parties de
l'application d'entra√Ænement qui sont importantes pour cet exemple. Cette
fonction repr√©sente le code que l'application appellera lorsqu'un utilisateur
demande un programme d'entra√Ænement. Comme l'interaction avec l'interface
frontale de l'application n'apporte rien dans l'√©tude de l'utilisation des
fermetures qui nous occupe ici, nous allons nous contenter de coder en dur les
valeurs repr√©sentant les entr√©es de notre programme puis afficher les r√©sultats
obtenus.</p>
<!--
The required inputs are these:
-->
<p>Les param√®tres d'entr√©es n√©cessaires sont¬†:</p>
<!--
* An intensity number from the user, which is specified when they request
  a workout to indicate whether they want a low-intensity workout or a
  high-intensity workout
* A random number that will generate some variety in the workout plans
-->
<ul>
<li><code>intensite</code> qui est un nombre saisi par utilisateur lorsqu'il demande un
entra√Ænement afin d'indiquer s'il veut un entra√Ænement de
faible ou de haute intensit√©.</li>
<li>Un nombre al√©atoire faisant varier les programmes d'entra√Ænement</li>
</ul>
<!--
The output will be the recommended workout plan. Listing 13-2 shows the `main`
function we‚Äôll use.
-->
<p>Le r√©sultat sera le programme d'entra√Ænement recommand√©. L'encart 13-2 montre la
fonction <code>main</code> que nous allons utiliser.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
# fn generate_workout(intensity: u32, random_number: u32) {}
# 
fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul tr√®s lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {}
</span><span class="boring">
</span>fn main() {
    let valeur_utilisateur_simule = 10;
    let nombre_aleatoire_simule = 7;

    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-2: A `main` function with hardcoded values to
simulate user input and random number generation</span>
-->
<p><span class="caption">Encart 13-2¬†: une fonction <code>main</code> avec des valeurs cod√©es
en dur pour simuler la saisie d'une valeur d'intensit√© par l'utilisateur et la
g√©n√©ration d'un nombre al√©atoire</span></p>
<!--
We‚Äôve hardcoded the variable `simulated_user_specified_value` as 10 and the
variable `simulated_random_number` as 7 for simplicity‚Äôs sake; in an actual
program, we‚Äôd get the intensity number from the app frontend, and we‚Äôd use the
`rand` crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The `main` function calls a `generate_workout` function
with the simulated input values.
-->
<p>Nous avons cod√© en dur la variable <code>valeur_utilisateur_simule</code> √† 10 et la
variable <code>nombre_aleatoire_simule</code> √† 7 pour des raisons de simplicit√©¬†; dans un
vrai programme nous obtiendrions la valeur d'intensit√© √† partir de l'interface
frontale et nous utiliserions la crate <code>rand</code> pour g√©n√©rer un nombre al√©atoire,
comme nous l'avons fait dans l'exemple du jeu du plus ou du moins dans le
chapitre 2. La fonction <code>main</code> appelle une fonction <code>generer_exercices</code> avec ces
valeurs d'entr√©e simul√©es.</p>
<!--
Now that we have the context, let‚Äôs get to the algorithm. The function
`generate_workout` in Listing 13-3 contains the business logic of the
app that we‚Äôre most concerned with in this example. The rest of the code
changes in this example will be made to this function.
-->
<p>Maintenant que nous avons le contexte, passons √† l'algorithme. La fonction
<code>generer_exercices</code> dans l'encart 13-3 contient la logique m√©tier de
l'application qui nous pr√©occupe le plus dans cet exemple. Le reste des
changements de code dans cet exemple seront appliqu√©s √† cette fonction¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            simulated_expensive_calculation(intensity)
        );
        println!(
            "Next, do {} situps!",
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul tr√®s lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    if intensite &lt; 25 {
        println!(
            &quot;Aujourd'hui, faire {} pompes¬†!&quot;,
            simuler_gros_calcul(intensite)
        );
        println!(
            &quot;Ensuite, faire {} abdominaux¬†!&quot;,
            simuler_gros_calcul(intensite)
        );
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui¬†! Rappelez-vous de bien vous hydrater¬†!&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutes¬†!&quot;,
                simuler_gros_calcul(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the `simulated_expensive_calculation`
function</span>
-->
<p><span class="caption">Encart 13-3¬†: la logique m√©tier qui affiche les programmes
d'entra√Ænement en fonction des entr√©es et des appels √† la fonction
<code>simuler_gros_calcul</code>.</span></p>
<!--
The code in Listing 13-3 has multiple calls to the slow calculation function.
The first `if` block calls `simulated_expensive_calculation` twice, the `if`
inside the outer `else` doesn‚Äôt call it at all, and the code inside the
second `else` case calls it once.
-->
<p>Le code de l'encart 13-3 a plusieurs appels √† la fonction de calcul lent¬†: le
premier bloc <code>if</code> appelle <code>simuler_gros_calcul</code> deux fois, le <code>if</code> √† l'int√©rieur
du <code>else</code> ne l'appelle pas du tout, et le code √† l'int√©rieur du second <code>else</code>
l'appelle une seule fois.</p>
<!--
The desired behavior of the `generate_workout` function is to first check
whether the user wants a low-intensity workout (indicated by a number less than
25) or a high-intensity workout (a number of 25 or greater).
-->
<p>Le comportement souhait√© de la fonction <code>generer_exercices</code> est de v√©rifier
d'abord si l'utilisateur veut un entra√Ænement de faible intensit√© (indiqu√© par
un nombre inf√©rieur √† 25) ou un entra√Ænement de haute intensit√© (un nombre de 25
ou plus).</p>
<!--
Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we‚Äôre simulating.
-->
<p>Les plans d'entra√Ænement √† faible intensit√© recommanderont un certain nombre de
pompes et d'abdominaux bas√©s sur l'algorithme complexe que nous simulons.</p>
<!--
If the user wants a high-intensity workout, there‚Äôs some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.
-->
<p>Si l'utilisateur souhaite un entra√Ænement de haute intensit√©, il y a une logique
en plus¬†: si la valeur du nombre al√©atoire g√©n√©r√© par l'application est 3,
l'application recommandera une pause et une hydratation √† la place. Sinon,
l'utilisateur recevra un nombre de minutes de course √† pied calcul√© par
l'algorithme complexe.</p>
<!--
This code works the way the business wants it to now, but let‚Äôs say the data
science team decides that we need to make some changes to the way we call the
`simulated_expensive_calculation` function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
`simulated_expensive_calculation` function only once. We also want to cut the
place where we‚Äôre currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don‚Äôt want
to call it if the result isn‚Äôt needed, and we still want to call it only once.
-->
<p>Ce code fonctionne comme la logique m√©tier le souhaite, mais imaginons que
l'√©quipe de science des donn√©es nous informe qu'il va y avoir des changements
dans la fa√ßon dont nous devrons appeler l'algorithme √† l'avenir. Pour simplifier
la mise √† jour lorsque ces changements se produiront, nous voulons remanier ce
code de sorte qu'il n'appelle la fonction <code>simuler_gros_calcul</code> qu'une seule fois.
Nous voulons √©galement nous d√©barrasser de l'endroit o√π nous appelons la
fonction deux fois inutilement, sans ajouter d'autres appels √† cette fonction au
cours de ce processus. Autrement dit, nous ne voulons pas l'appeler si le
r√©sultat n'en a pas besoin, et nous voulons ne l'appeler qu'une seule fois.</p>
<!--
#### Refactoring Using Functions
-->
<h4 id="remaniement-en-utilisant-des-fonctions"><a class="header" href="#remaniement-en-utilisant-des-fonctions">Remaniement en utilisant des fonctions</a></h4>
<!--
We could restructure the workout program in many ways. First, we‚Äôll try
extracting the duplicated call to the `simulated_expensive_calculation`
function into a variable, as shown in Listing 13-4.
-->
<p>Nous pourrions restructurer le programme d'entra√Ænement de plusieurs mani√®res.
Tout d'abord, nous allons essayer d'extraire l'appel en double √† la fonction
<code>simuler_gros_calcul</code> dans une variable, comme dans l'encart 13-4¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_result);
        println!("Next, do {} situps!", expensive_result);
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!("Today, run for {} minutes!", expensive_result);
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul tr√®s lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let resultat_lent = simuler_gros_calcul(intensite);

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompes¬†!&quot;, resultat_lent);
        println!(&quot;Ensuite, faire {} abdominaux¬†!&quot;, resultat_lent);
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui¬†! Rappelez-vous de bien vous hydrater¬†!&quot;);
        } else {
            println!(&quot;Aujourd'hui, courrez pendant {} minutes¬†!&quot;, resultat_lent);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-4: Extracting the calls to
`simulated_expensive_calculation` to one place and storing the result in the
`expensive_result` variable</span>
-->
<p><span class="caption">Encart 13-4¬†: extraction des appels √†
<code>simuler_gros_calcul</code> dans un seul endroit et stockage du r√©sultat dans la
variable <code>resultat_lent</code>.</span></p>
<!--
This change unifies all the calls to `simulated_expensive_calculation` and
solves the problem of the first `if` block unnecessarily calling the function
twice. Unfortunately, we‚Äôre now calling this function and waiting for the
result in all cases, which includes the inner `if` block that doesn‚Äôt use the
result value at all.
-->
<p>Ce changement unifie tous les appels √† <code>simuler_gros_calcul</code> et r√©sout le
probl√®me du premier bloc <code>if</code> qui appelle inutilement la fonction √† deux
reprises. Malheureusement, nous appelons maintenant cette fonction et attendons
le r√©sultat dans tous les cas, ce qui inclut le bloc <code>if</code> interne qui n'utilise
pas du tout la valeur du r√©sultat.</p>
<!--
We want to refer to `simulated_expensive_calculation` only once in
`generate_workout`, but defer the expensive calculation to only where
we actually need the result. This is a use case for closures!
-->
<p>Nous voulons nous r√©f√©rer √† <code>simuler_gros_calcul</code> qu'une seule fois dans
<code>generer_exercices</code>, mais retarder le gros calcul jusqu'au moment o√π nous avons
avons r√©ellement besoin du r√©sultat. C'est un cas d'utilisation des fermetures¬†!</p>
<!--
#### Refactoring with Closures to Store Code
-->
<h4 id="remanier-le-code-avec-des-fermetures-pour-stocker-du-code"><a class="header" href="#remanier-le-code-avec-des-fermetures-pour-stocker-du-code">Remanier le code avec des fermetures pour stocker du code</a></h4>
<!--
Instead of always calling the `simulated_expensive_calculation` function before
the `if` blocks, we can define a closure and store the *closure* in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of `simulated_expensive_calculation` within
the closure we‚Äôre introducing here.
-->
<p>Au lieu d'appeler syst√©matiquement la fonction <code>simuler_gros_calcul</code> avant
les blocs <code>if</code>, nous pouvons d√©finir une fermeture et la stocker dans une
variable au lieu de le faire pour le r√©sultat, comme le montre l'encart 13-5.
Nous pouvons en fait d√©placer l'ensemble du corps de <code>simuler_gros_calcul</code> dans
la fermeture que nous introduisons ici.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
# 
#     if intensity < 25 {
#         println!("Today, do {} pushups!", expensive_closure(intensity));
#         println!("Next, do {} situps!", expensive_closure(intensity));
#     } else {
#         if random_number == 3 {
#             println!("Take a break today! Remember to stay hydrated!");
#         } else {
#             println!(
#                 "Today, run for {} minutes!",
#                 expensive_closure(intensity)
#             );
#         }
#     }
# }
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
</span>    let fermeture_lente = |nombre| {
        println!(&quot;calcul tr√®s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };
<span class="boring">
</span><span class="boring">    if intensite &lt; 25 {
</span><span class="boring">        println!(&quot;Aujourd'hui, faire {} pompes¬†!&quot;, fermeture_lente(intensite));
</span><span class="boring">        println!(&quot;Ensuite, faire {} abdominaux¬†!&quot;, fermeture_lente(intensite));
</span><span class="boring">    } else {
</span><span class="boring">        if nombre_aleatoire == 3 {
</span><span class="boring">            println!(&quot;Faites une pause aujourd'hui¬†! Rappelez-vous de bien vous hydrater¬†!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Aujourd'hui, courrez pendant {} minutes¬†!&quot;,
</span><span class="boring">                fermeture_lente(intensite)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-5: Defining a closure and storing it in the
`expensive_closure` variable</span>
-->
<p><span class="caption">Encart 13-5¬†: d√©finition d'une fermeture et son
enregistrement dans la variable <code>fermeture_lente</code>.</span></p>
<!--
The closure definition comes after the `=` to assign it to the variable
`expensive_closure`. To define a closure, we start with a pair of vertical
pipes (`|`), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named `num`: if we had more than one
parameter, we would separate them with commas, like `|param1, param2|`.
-->
<p>La d√©finition de la fermeture vient apr√®s le <code>=</code> pour l'assigner √† la variable
<code>fermeture_lente</code>. Pour d√©finir une fermeture, on commence par une paire de
barres verticales (<code>|</code>), √† l'int√©rieur desquelles on renseigne les param√®tres de
la fermeture¬†; cette syntaxe a √©t√© choisie en raison de sa similitude avec les
d√©finitions des fermetures en Smalltalk et en Ruby. Cette fermeture a un
param√®tre <code>nombre</code>¬†: si nous avions plus d'un param√®tre, nous les s√©parerions
par des virgules, comme ceci¬†: <code>|param1, param2|</code>.</p>
<!--
After the parameters, we place curly brackets that hold the body of the
closure‚Äîthese are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
`let` statement. The value returned from the last line in the closure body
(`num`) will be the value returned from the closure when it‚Äôs called, because
that line doesn‚Äôt end in a semicolon; just as in function bodies.
-->
<p>Apr√®s les param√®tres, on ajoute des accolades qui contiennent le corps de la
fermeture, celles-ci sont facultatives si le corps de la fermeture est une seule
expression. Apr√®s les accolades, nous avons besoin d'un point-virgule
pour terminer l'instruction <code>let</code>. La valeur √† la derni√®re ligne dans le corps
de la fermeture (<code>nombre</code>) sera la valeur retourn√©e par la fermeture lorsqu'elle
sera ex√©cut√©e, et cette ligne ne se termine pas par un point-virgule, exactement
comme dans le corps des fonctions.</p>
<!--
Note that this `let` statement means `expensive_closure` contains the
*definition* of an anonymous function, not the *resulting value* of calling the
anonymous function. Recall that we‚Äôre using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in `expensive_closure`.
-->
<p>Notez que cette instruction <code>let</code> signifie que la variable <code>fermeture_lente</code>
contient la <em>d√©finition</em> d'une fonction anonyme, pas la <em>valeur r√©sultante</em> √†
l'appel de cette fonction anonyme. Rappelons que nous utilisons une fermeture
pour d√©finir le code √† appeler dans un seul endroit, stocker ce code et
l'appeler plus tard¬†; le code que nous voulons appeler est maintenant stock√©
dans <code>fermeture_lente</code>.</p>
<!--
With the closure defined, we can change the code in the `if` blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6.
-->
<p>Maintenant que nous avons d√©fini la fermeture, nous pouvons changer le code dans
les blocs <code>if</code> pour appeler la fermeture afin d'ex√©cuter le code et obtenir la
valeur r√©sultante. L'appel d'une fermeture fonctionne comme pour l'appel d'une
fonction¬†: nous renseignons le nom de la variable qui stocke la d√©finition de la
fermeture et la compl√©tons avec des parenth√®ses contenant les valeurs du ou des
arguments que nous voulons utiliser pour cet appel, comme dans l'encart 13-6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let fermeture_lente = |nombre| {
        println!(&quot;calcul tr√®s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompes¬†!&quot;, fermeture_lente(intensite));
        println!(&quot;Ensuite, faire {} abdominaux¬†!&quot;, fermeture_lente(intensite));
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui¬†! Rappelez-vous de bien vous hydrater¬†!&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutes¬†!&quot;,
                fermeture_lente(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-6: Calling the `expensive_closure` we‚Äôve
defined</span>
-->
<p><span class="caption">Encart 13-6¬†: appel de la fermeture <code>fermeture_lente</code>
que nous avons d√©finie</span></p>
<!--
Now how to perform the expensive calculation is defined in only one
place, and we‚Äôre only executing that code where we need the results.
-->
<p>D√©sormais, le calcul lent n'est d√©fini qu'√† un seul endroit et nous
n'ex√©cutons ce code qu'aux endroits o√π nous avons besoin des r√©sultats.</p>
<!--
However, we‚Äôve reintroduced one of the problems from Listing 13-3: we‚Äôre still
calling the closure twice in the first `if` block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that `if` block to hold
the result of calling the closure, but closures provide us with another
solution. We‚Äôll talk about that solution in a bit. But first let‚Äôs talk about
why there aren‚Äôt type annotations in the closure definition and the traits
involved with closures.
-->
<p>Cependant, nous avons r√©introduit l'un des probl√®mes de l'encart 13-3¬†: nous
continuons d'appeler la fermeture deux fois dans le premier bloc <code>if</code>, qui
appellera le code lent √† deux reprises et fera attendre l'utilisateur deux fois
plus longtemps que n√©cessaire. Nous pourrions r√©soudre ce probl√®me en cr√©ant une
variable locale √† ce bloc <code>if</code> pour conserver le r√©sultat de l'appel √† la
fermeture, mais les fermetures nous ouvrent d'autres solutions. Commen√ßons
d'abord par expliquer pourquoi il n'y a pas d'annotation de type dans la
d√©finition des fermetures et des traits li√©s aux fermetures.</p>
<!--
### Closure Type Inference and Annotation
-->
<h3 id="linf√©rence-de-type-et-lannotation-des-fermetures"><a class="header" href="#linf√©rence-de-type-et-lannotation-des-fermetures">L'inf√©rence de type et l'annotation des fermetures</a></h3>
<!--
Closures don‚Äôt require you to annotate the types of the parameters or the
return value like `fn` functions do. Type annotations are required on functions
because they‚Äôre part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren‚Äôt used in an
exposed interface like this: they‚Äôre stored in variables and used without
naming them and exposing them to users of our library.
-->
<p>Les fermetures ne n√©cessitent pas d'annoter le type des param√®tres ou de la
valeur de retour comme le font les fonctions <code>fn</code>. Les annotations de type sont
n√©cessaires pour les fonctions car elles font partie d'une interface explicite
expos√©e √† leurs utilisateurs. D√©finir cette interface de mani√®re rigide est
n√©cessaire pour s'assurer que tout le monde s'accorde sur les types de valeurs
qu'une fonction utilise et retourne. Mais les fermetures ne sont pas utilis√©es
dans une interface expos√©e de cette fa√ßon¬†: elles sont stock√©es dans des
variables et utilis√©es sans les nommer ni les exposer aux utilisateurs de notre
biblioth√®que.</p>
<!--
Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how it‚Äôs able to infer the types of most variables.
-->
<p>En outre, les fermetures sont g√©n√©ralement br√®ves et ne sont pertinentes que
dans un contexte pr√©cis plut√¥t que pour des cas g√©n√©riques. Dans ce contexte
pr√©cis, le compilateur est capable de d√©duire le type des param√®tres et le type
de retour, tout comme il est capable d'inf√©rer le type de la plupart des variables.</p>
<!--
Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.
-->
<p>Demander aux d√©veloppeurs d'annoter le type dans ces petites fonctions anonymes
serait p√©nible et largement redondant avec l'information dont dispose d√©j√† le
compilateur.</p>
<!--
As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7.
-->
<p>Comme pour les variables, nous pouvons ajouter des annotations de type si nous
voulons rendre explicite et clarifier le code au risque d'√™tre plus verbeux que
ce qui est strictement n√©cessaire. Annoter les types de la fermeture que nous
avons d√©finie dans l'encart 13-5 ressemblerait √† l'encart 13-7.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
# 
#     if intensity < 25 {
#         println!("Today, do {} pushups!", expensive_closure(intensity));
#         println!("Next, do {} situps!", expensive_closure(intensity));
#     } else {
#         if random_number == 3 {
#             println!("Take a break today! Remember to stay hydrated!");
#         } else {
#             println!(
#                 "Today, run for {} minutes!",
#                 expensive_closure(intensity)
#             );
#         }
#     }
# }
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
</span>    let fermeture_lente = |nombre: u32| -&gt; u32 {
        println!(&quot;calcul tr√®s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };
<span class="boring">
</span><span class="boring">    if intensite &lt; 25 {
</span><span class="boring">        println!(&quot;Aujourd'hui, faire {} pompes¬†!&quot;, fermeture_lente(intensite));
</span><span class="boring">        println!(&quot;Ensuite, faire {} abdominaux¬†!&quot;, fermeture_lente(intensite));
</span><span class="boring">    } else {
</span><span class="boring">        if nombre_aleatoire == 3 {
</span><span class="boring">            println!(&quot;Faites une pause aujourd'hui¬†! Rappelez-vous de bien vous hydrater¬†!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Aujourd'hui, courrez pendant {} minutes¬†!&quot;,
</span><span class="boring">                fermeture_lente(intensite)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span>
-->
<p><span class="caption">Encart 13-7¬†: ajout d'annotations de type optionnelles sur
les param√®tres et les valeurs de retour de la fermeture</span></p>
<!--
With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. We‚Äôve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:
-->
<p>La syntaxe des fermetures et des fonctions semble plus similaire avec les
annotations de type. Ce qui suit est une comparaison verticale entre la syntaxe
d'une d√©finition d'une fonction qui ajoute 1 √† son param√®tre, et d'une fermeture
qui a le m√™me comportement. Nous avons ajout√© des espaces pour aligner les
parties pertinentes. Ceci met en √©vidence la similarit√© entre la syntaxe des
fermetures et celle des fonctions, hormis l'utilisation des barres verticales
et certaines syntaxes facultatives¬†:</p>
<!--
```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```
-->
<pre><code class="language-rust ignore">fn  ajouter_un_v1   (x: u32) -&gt; u32 { x + 1 }
let ajouter_un_v2 = |x: u32| -&gt; u32 { x + 1 };
let ajouter_un_v3 = |x|             { x + 1 };
let ajouter_un_v4 = |x|               x + 1  ;
</code></pre>
<!--
The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they‚Äôre called. Calling
the closures is required for `add_one_v3` and `add_one_v4` to be able to
compile because the types will be inferred from their usage.
-->
<p>La premi√®re ligne affiche la d√©finition d'une fonction et la deuxi√®me ligne une
d√©finition d'une fermeture enti√®rement annot√©e. La troisi√®me ligne supprime les
annotations de type de la d√©finition de la fermeture, et la quatri√®me ligne
supprime les accolades qui sont facultatives, parce que le corps d'une fermeture
n'a qu'une seule expression. Ce sont toutes des d√©finitions valides qui
suivront le m√™me comportement lorsqu'on les appellera. L'appel aux fermetures
est n√©cessaire pour que <code>ajouter_un_v3</code> et <code>ajouter_un_v4</code> puissent √™tre compil√©s
car les types seront d√©duits en fonction de leur utilisation.</p>
<!--
Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn‚Äôt very useful except for the purposes of this
example. Note that we haven‚Äôt added any type annotations to the definition: if
we then try to call the closure twice, using a `String` as an argument the
first time and a `u32` the second time, we‚Äôll get an error.
-->
<p>Les d√©finitions des fermetures auront un type concret d√©duit pour chacun de
leurs param√®tres et pour leur valeur de retour. Par exemple, l'encart 13-8
montre la d√©finition d'une petite fermeture qui renvoie simplement la valeur
qu'elle re√ßoit comme param√®tre. Cette fermeture n'est pas tr√®s utile sauf pour
les besoins de cet exemple. Notez que nous n'avons pas ajout√© d'annotation de
type √† la d√©finition¬†: si nous essayons alors d'appeler la fermeture deux fois,
en utilisant une <code>String</code> comme argument la premi√®re fois et un <code>u32</code> la
deuxi√®me fois, nous obtiendrons une erreur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let fermeture_exemple = |x| x;

    let s = fermeture_exemple(String::from(&quot;hello&quot;));
    let n = fermeture_exemple(5);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span>
-->
<p><span class="caption">Encart 13-8¬†: tentative d'appeler une fermeture dont les
types sont d√©duits avec deux types diff√©rents</span></p>
<!--
The compiler gives us this error:
-->
<p>Le compilateur nous renvoie l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 -- > src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method: `.to_string()`
  |                             |
  |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = fermeture_exemple(5);
  |                               ^- help: try using a conversion method: `.to_string()`
  |                               |
  |                               expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<!--
The first time we call `example_closure` with the `String` value, the compiler
infers the type of `x` and the return type of the closure to be `String`. Those
types are then locked into the closure in `example_closure`, and we get a type
error if we try to use a different type with the same closure.
-->
<p>La premi√®re fois que nous appelons <code>fermeture_exemple</code> avec une <code>String</code>, le
compilateur d√©duit que le type de <code>x</code> et le type de retour de la fermeture sont
de type <code>String</code>. Ces types sont ensuite verrouill√©s dans <code>fermeture_exemple</code>,
et nous obtenons une erreur de type si nous essayons d'utiliser un type
diff√©rent avec la m√™me fermeture.</p>
<!--
### Storing Closures Using Generic Parameters and the `Fn` Traits
-->
<h3 id="stockage-des-fermetures-avec-des-param√®tres-g√©n√©riques-et-le-trait-fn"><a class="header" href="#stockage-des-fermetures-avec-des-param√®tres-g√©n√©riques-et-le-trait-fn">Stockage des fermetures avec des param√®tres g√©n√©riques et le trait <code>Fn</code></a></h3>
<!--
Let‚Äôs return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.
-->
<p>Revenons √† notre application de g√©n√©ration d'entra√Ænements. Dans l'encart 13-6,
notre code appelait toujours la fermeture lente plus de fois que n√©cessaire. Une
option pour r√©soudre ce probl√®me est de sauvegarder le r√©sultat de la fermeture
lente dans une variable pour une future utilisation et d'utiliser la variable √†
chaque endroit o√π nous en avons besoin au lieu de rappeler la fermeture √†
nouveau. Cependant, cette m√©thode pourrait donner lieu √† du code tr√®s r√©p√©t√©.</p>
<!--
Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn‚Äôt have to be
responsible for saving and reusing the result. You may know this pattern as
*memoization* or *lazy evaluation*.
-->
<p>Heureusement, une autre solution s'offre √† nous. Nous pouvons cr√©er une
structure qui stockera la fermeture et la valeur qui en r√©sulte. La structure
n'ex√©cutera la fermeture que si nous avons besoin de la valeur
r√©sultante, et elle mettra en cache la valeur r√©sultante pour que le reste de
notre code n'ait pas la responsabilit√© de sauvegarder et de r√©utiliser le r√©sultat.
Vous connaissez peut-√™tre cette technique sous le nom de <em>m√©mo√Øsation</em> ou
<em>d'√©valuation paresseuse</em>.</p>
<!--
To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.
-->
<p>Pour faire en sorte qu'une structure d√©tienne une fermeture, il faut pr√©ciser
le type de fermeture, car une d√©finition de structure a besoin de conna√Ætre les
types de chacun de ses champs. Chaque instance de fermeture a son propre type
anonyme unique¬†: cela signifie que m√™me si deux fermetures ont la m√™me
signature, leurs types sont toujours consid√©r√©s comme diff√©rents. Pour d√©finir
des structures, des √©num√©rations ou des param√®tres de fonction qui utilisent des
fermetures, nous utilisons des g√©n√©riques et des traits li√©s, comme nous
l'avons vu au chapitre 10.</p>
<!--
The `Fn` traits are provided by the standard library. All closures implement at
least one of the traits: `Fn`, `FnMut`, or `FnOnce`. We‚Äôll discuss the
difference between these traits in the [‚ÄúCapturing the Environment with
Closures‚Äù](#capturing-the-environment-with-closures)<!-- ignore -- > section; in
this example, we can use the `Fn` trait.
-->
<p>Les traits <code>Fn</code> sont fournis par la biblioth√®que standard. Toutes les fermetures
impl√©mentent au moins un des traits suivants¬†: <code>Fn</code>, <code>FnMut</code> ou <code>FnOnce</code>. Nous
verrons la diff√©rence entre ces traits dans la section
<a href="ch13-01-closures.html#capturer-lenvironnement-avec-les-fermetures">‚ÄúCapturer l'environnement avec les
fermetures‚Äù</a><!-- ignore -->¬†; dans
cet exemple, nous pouvons utiliser le trait <code>Fn</code>.</p>
<!--
We add types to the `Fn` trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type `u32` and returns a `u32`, so the
trait bound we specify is `Fn(u32) -> u32`.
-->
<p>Nous ajoutons des types au trait li√© <code>Fn</code> pour repr√©senter les types de
param√®tres et les valeurs de retour que les fermetures doivent avoir pour
correspondre √† ce trait li√©. Dans ce cas, notre fermeture a un param√®tre de type
<code>u32</code> et renvoie un <code>u32</code>, le trait li√© que nous pr√©cisons est donc
<code>Fn (u32) -&gt; u32</code>.</p>
<!--
Listing 13-9 shows the definition of the `Cacher` struct that holds a closure
and an optional result value.
-->
<p>L'encart 13-9 montre la d√©finition de la structure <code>Cache</code> qui poss√®de une
fermeture et une valeur de r√©sultat optionnelle¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    value: Option<u32>,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Cache&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calcul: T,
    valeur: Option&lt;u32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-9: Defining a `Cacher` struct that holds a
closure in `calculation` and an optional result in `value`</span>
-->
<p><span class="caption">Encart 13-9¬†: d√©finition d'une structure <code>Cache</code> qui
poss√®de une fermeture dans <code>calcul</code> et un r√©sultat optionnel dans <code>valeur</code>.
</span></p>
<!--
The `Cacher` struct has a `calculation` field of the generic type `T`. The
trait bounds on `T` specify that it‚Äôs a closure by using the `Fn` trait. Any
closure we want to store in the `calculation` field must have one `u32`
parameter (specified within the parentheses after `Fn`) and must return a
`u32` (specified after the `->`).
-->
<p>La structure <code>Cache</code> a un champ <code>calcul</code> du type g√©n√©rique <code>T</code>. Le trait li√© <code>T</code>
pr√©cise que c'est une fermeture en utilisant le trait <code>Fn</code>. Toute fermeture que
l'on veut stocker dans le champ <code>calcul</code> doit avoir un param√®tre <code>u32</code> (ce qui
est pr√©cis√© entre parenth√®se apr√®s le <code>Fn</code>) et doit retourner un <code>u32</code> (ce qui
est pr√©cis√© apr√®s le <code>-&gt;</code>).</p>
<!--
> Note: Functions can implement all three of the `Fn` traits too. If what we
> want to do doesn‚Äôt require capturing a value from the environment, we can use
> a function rather than a closure where we need something that implements an
> `Fn` trait.
-->
<blockquote>
<p>Remarque¬†: les fonctions peuvent aussi impl√©menter chacun de ces trois traits
<code>Fn</code>. Si ce que nous voulons faire ne n√©cessite pas de capturer une valeur de
l'environnement, nous pouvons utiliser une fonction plut√¥t qu'une fermeture
lorsque nous avons besoin de quelque chose qui impl√©mente un trait <code>Fn</code>.</p>
</blockquote>
<!--
The `value` field is of type `Option<u32>`. Before we execute the closure,
`value` will be `None`. When code using a `Cacher` asks for the *result* of the
closure, the `Cacher` will execute the closure at that time and store the
result within a `Some` variant in the `value` field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
`Cacher` will return the result held in the `Some` variant.
-->
<p>Le champ <code>valeur</code> est de type <code>Option&lt;u32&gt;</code>. Avant d'ex√©cuter la fermeture,
<code>valeur</code> sera initialis√©e √† <code>None</code>. Lorsque du code utilisant un <code>Cache</code> demande
le <em>r√©sultat</em> de la fermeture, le <code>Cache</code> ex√©cutera la fermeture √† ce moment-l√†
et stockera le r√©sultat dans une variante <code>Some</code> dans le champ <code>valeur</code>.
Ensuite, si le code demande √† nouveau le r√©sultat de la fermeture, le <code>Cache</code>
renverra le r√©sultat contenu dans la variante <code>Some</code> au lieu d'ex√©cuter √†
nouveau la fermeture.</p>
<!--
The logic around the `value` field we‚Äôve just described is defined in Listing
13-10.
-->
<p>La logique autour du champ <code>valeur</code> que nous venons de d√©crire est d√©finie dans
l'encart 13-10¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cache&lt;T&gt;
where
    T: Fn(u32) -&gt; u32
{
    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
        Cache {
            calcul,
            valeur: None,
        }
    }

    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
        match self.valeur {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calcul)(arg);
                self.valeur = Some(v);
                v
            },
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-10: The caching logic of `Cacher`</span>
-->
<p><span class="caption">Encart 13-10¬†: la logique de <code>Cache</code></span></p>
<!--
We want `Cacher` to manage the struct fields‚Äô values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.
-->
<p>Nous voulons que <code>Cache</code> g√®re les valeurs des champs de structure plut√¥t que de
laisser la possibilit√© au code appelant la possibilit√© de modifier directement
les valeurs dans ces champs, donc nous faisons en sorte que ces champs soient
priv√©s.</p>
<!--
The `Cacher::new` function takes a generic parameter `T`, which we‚Äôve defined
as having the same trait bound as the `Cacher` struct. Then `Cacher::new`
returns a `Cacher` instance that holds the closure specified in the
`calculation` field and a `None` value in the `value` field, because we haven‚Äôt
executed the closure yet.
-->
<p>La fonction <code>Cache::new</code> prend un param√®tre g√©n√©rique <code>T</code>, que nous avons
d√©fini comme ayant le m√™me trait li√© que la structure <code>Cache</code>. Puis <code>Cache::new</code>
renvoie une instance <code>Cache</code> qui contient la fermeture pr√©sente dans le champ
<code>calcul</code> et une valeur <code>None</code> dans le champ <code>valeur</code>, car nous n'avons pas
encore ex√©cut√© la fermeture.</p>
<!--
When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the `value` method. This method
checks whether we already have a resulting value in `self.value` in a `Some`;
if we do, it returns the value within the `Some` without executing the closure
again.
-->
<p>Lorsque le code appelant veut le r√©sultat de l'ex√©cution de la fermeture, au
lieu d'appeler directement la fermeture, il appellera la m√©thode <code>valeur</code>. Cette
m√©thode v√©rifie si nous avons d√©j√† une valeur dans un <code>Some</code> dans
<code>self.valeur</code>¬†; et si c'est le cas, elle renvoie la valeur contenue dans le
<code>Some</code> sans ex√©cuter de nouveau la fermeture.</p>
<!--
If `self.value` is `None`, the code calls the closure stored in
`self.calculation`, saves the result in `self.value` for future use, and
returns the value as well.
-->
<p>Si <code>self.valeur</code> est <code>None</code>, nous appelons la fermeture stock√©e dans
<code>self.calcul</code>, et nous sauvegardons le r√©sultat dans <code>self.valeur</code> pour une
utilisation future, puis nous retournons la valeur.</p>
<!--
Listing 13-11 shows how we can use this `Cacher` struct in the function
`generate_workout` from Listing 13-6.
-->
<p>L'encart 13-11 montre comment utiliser cette structure <code>Cache</code> dans la fonction
<code>generer_exercices</code> de l'encart 13-6¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
# impl<T> Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     fn new(calculation: T) -> Cacher<T> {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
# 
#     fn value(&mut self, arg: u32) -> u32 {
#         match self.value {
#             Some(v) => v,
#             None => {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             }
#         }
#     }
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_result.value(intensity));
        println!("Next, do {} situps!", expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result.value(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
</span><span class="boring">        Cache {
</span><span class="boring">            calcul,
</span><span class="boring">            valeur: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.valeur {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calcul)(arg);
</span><span class="boring">                self.valeur = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let mut resultat_lent = Cache::new(|nombre| {
        println!(&quot;calcul tr√®s lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    });

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompes¬†!&quot;, resultat_lent.valeur(intensite));
        println!(&quot;Ensuite, faire {} abdominaux¬†!&quot;, resultat_lent.valeur(intensite));
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui¬†! Rappelez-vous de bien vous hydrater¬†!&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutes¬†!&quot;,
                resultat_lent.valeur(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-11: Using `Cacher` in the `generate_workout`
function to abstract away the caching logic</span>
-->
<p><span class="caption">Encart 13-11¬†: utilisation de <code>Cache</code> dans la fonction
<code>generer_exercices</code> pour masquer la logique du cache.</span></p>
<!--
Instead of saving the closure in a variable directly, we save a new instance of
`Cacher` that holds the closure. Then, in each place we want the result, we
call the `value` method on the `Cacher` instance. We can call the `value`
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.
-->
<p>Au lieu de sauvegarder la fermeture dans une variable directement, nous
sauvegardons une nouvelle instance de <code>Cache</code> qui contient la fermeture.
Ensuite, √† chaque fois que nous voulons le r√©sultat, nous appelons la m√©thode
<code>valeur</code> sur cette instance de <code>Cache</code>. Nous pouvons appeler la m√©thode <code>valeur</code>
autant de fois que nous le souhaitons, ou ne pas l'appeler du tout, et le calcul
lent sera ex√©cut√© une fois au maximum.</p>
<!--
Try running this program with the `main` function from Listing 13-2. Change the
values in the `simulated_user_specified_value` and `simulated_random_number`
variables to verify that in all the cases in the various `if` and `else`
blocks, `calculating slowly...` appears only once and only when needed. The
`Cacher` takes care of the logic necessary to ensure we aren‚Äôt calling the
expensive calculation more than we need to so `generate_workout` can focus on
the business logic.
-->
<p>Essayez d'ex√©cuter ce programme avec la fonction <code>main</code> de l'encart 13-2.
Modifiez les valeurs des variables <code>valeur_utilisateur_simule</code> et
<code>nombre_aleatoire_simule</code> pour v√©rifier que dans tous les cas des diff√©rents
blocs <code>if</code> et <code>else</code>, <code>calcul tr√®s lent ...</code> n'appara√Æt qu'une seule fois et
seulement si n√©cessaire. Le <code>Cache</code> se charge de la logique n√©cessaire pour
s'assurer que nous n'appelons pas le calcul lent plus que nous n'en avons
besoin afin que <code>generer_exercices</code> puisse se concentrer sur la logique m√©tier.</p>
<!--
### Limitations of the `Cacher` Implementation
-->
<h3 id="limitations-de-limpl√©mentation-de-cache"><a class="header" href="#limitations-de-limpl√©mentation-de-cache">Limitations de l'impl√©mentation de <code>Cache</code></a></h3>
<!--
Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of `Cacher` that would make reusing it
in different contexts difficult.
-->
<p>La mise en cache des valeurs est un comportement g√©n√©ralement utile que nous
pourrions vouloir utiliser dans d'autres parties de notre code avec diff√©rentes
fermetures. Cependant, il y a deux probl√®mes avec l'impl√©mentation actuelle de
<code>Cache</code> qui rendraient difficile sa r√©utilisation dans des contextes diff√©rents.</p>
<!--
The first problem is that a `Cacher` instance assumes it will always get the
same value for the parameter `arg` to the `value` method. That is, this test of
`Cacher` will fail:
-->
<p>Le premier probl√®me est qu'une instance de <code>Cache</code> suppose qu'elle obtienne
toujours la m√™me valeur, ind√©pendamment du param√®tre <code>arg</code> de la m√©thode
<code>valeur</code>. Autrement dit, ce test sur <code>Cache</code> √©chouera¬†:</p>
<!--
```rust,ignore,panics
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
# impl<T> Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     fn new(calculation: T) -> Cacher<T> {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
# 
#     fn value(&mut self, arg: u32) -> u32 {
#         match self.value {
#             Some(v) => v,
#             None => {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             }
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
</span><span class="boring">        Cache {
</span><span class="boring">            calcul,
</span><span class="boring">            valeur: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.valeur {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calcul)(arg);
</span><span class="boring">                self.valeur = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_avec_differentes_valeurs() {
        let mut c = Cache::new(|a| a);

        let v1 = c.valeur(1);
        let v2 = c.valeur(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}
</span></code></pre>
<!--
This test creates a new `Cacher` instance with a closure that returns the value
passed into it. We call the `value` method on this `Cacher` instance with an
`arg` value of 1 and then an `arg` value of 2, and we expect the call to
`value` with the `arg` value of 2 to return 2.
-->
<p>Ce test cr√©e une nouvelle instance de <code>Cache</code> avec une fermeture qui retourne
la valeur qui lui est pass√©e. Nous appelons la m√©thode <code>valeur</code> sur cette
instance de <code>Cache</code> avec une valeur <code>arg</code> de 1 et ensuite une valeur <code>arg</code>
de 2, et nous nous attendons √† ce que l'appel √† <code>valeur</code> avec la valeur <code>arg</code>
de 2 retourne 2.</p>
<!--
Run this test with the `Cacher` implementation in Listing 13-9 and Listing
13-10, and the test will fail on the `assert_eq!` with this message:
-->
<p>Ex√©cutez ce test avec l'impl√©mentation de <code>Cache</code> de l'encart 13-9 et de
l'encart 13-10, et le test √©chouera sur le <code>assert_eq!</code> avec ce message¬†:</p>
<!--
```console
$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::appel_avec_differentes_valeurs ... FAILED

failures:

---- tests::appel_avec_differentes_valeurs stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::appel_avec_differentes_valeurs

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The problem is that the first time we called `c.value` with 1, the `Cacher`
instance saved `Some(1)` in `self.value`. Thereafter, no matter what we pass into
the `value` method, it will always return 1.
-->
<p>Le probl√®me est que la premi√®re fois que nous avons appel√© <code>c.valeur</code> avec 1,
l'instance <code>Cache</code> a sauvegard√© <code>Some(1)</code> dans <code>self.valeur</code>. Par la suite, peu
importe ce que nous passons √† la m√©thode <code>valeur</code>, elle retournera toujours 1.</p>
<!--
Try modifying `Cacher` to hold a hash map rather than a single value. The keys
of the hash map will be the `arg` values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether `self.value` directly has a `Some` or a `None` value, the
`value` function will look up the `arg` in the hash map and return the value if
it‚Äôs present. If it‚Äôs not present, the `Cacher` will call the closure and save
the resulting value in the hash map associated with its `arg` value.
-->
<p>Essayez de modifier <code>Cache</code> pour tenir une table de hachage plut√¥t qu'une seule
valeur. Les cl√©s de la table de hachage seront les valeurs <code>arg</code> qui lui sont
pass√©es, et les valeurs de la table de hachage seront le r√©sultat de l'appel √†
la fermeture avec cette cl√©. Plut√¥t que de regarder directement si <code>self.valeur</code>
a une valeur <code>Some</code> ou une valeur <code>None</code>, la fonction <code>valeur</code> recherchera <code>arg</code>
dans la table de hachage et retournera la valeur si elle est pr√©sente. S'il
n'est pas pr√©sent, le <code>Cache</code> appellera la fermeture et sauvegardera la valeur
r√©sultante dans la table de hachage associ√©e √† sa cl√© <code>arg</code>.</p>
<!--
The second problem with the current `Cacher` implementation is that it only
accepts closures that take one parameter of type `u32` and return a `u32`. We
might want to cache the results of closures that take a string slice and return
`usize` values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the `Cacher` functionality.
-->
<p>Le second probl√®me avec l'impl√©mentation actuelle de <code>Cache</code> est qu'il n'accepte
que les fermetures qui prennent un param√®tre de type <code>u32</code> et renvoient un
<code>u32</code>. Nous pourrions vouloir mettre en cache les r√©sultats des fermetures qui
prennent une slice d'une cha√Æne de caract√®res et renvoient des valeurs <code>usize</code>,
par exemple. Pour corriger ce probl√®me, essayez d'introduire des param√®tres plus
g√©n√©riques pour augmenter la flexibilit√© de la fonctionnalit√© offerte par
<code>Cache</code>.</p>
<!--
### Capturing the Environment with Closures
-->
<h3 id="capturer-lenvironnement-avec-les-fermetures"><a class="header" href="#capturer-lenvironnement-avec-les-fermetures">Capturer l'environnement avec les fermetures</a></h3>
<!--
In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don‚Äôt
have: they can capture their environment and access variables from the scope in
which they‚Äôre defined.
-->
<p>Dans l'exemple du g√©n√©rateur d'entra√Ænement, nous n'avons utilis√© les fermetures
que comme des fonctions anonymes internes. Cependant, les fermetures ont
une capacit√© suppl√©mentaire que les fonctions n'ont pas¬†: elles peuvent capturer
leur environnement et acc√©der aux variables de la port√©e dans laquelle elles
sont d√©finies.</p>
<!--
Listing 13-12 has an example of a closure stored in the `equal_to_x` variable
that uses the `x` variable from the closure‚Äôs surrounding environment.
-->
<p>L'encart 13-12 montre un exemple de fermeture stock√©e dans la variable
<code>egal_a_x</code> qui utilise la variable <code>x</code> de l'environnement environnant de la
fermeture¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let egal_a_x = |z| z == x;

    let y = 4;

    assert!(egal_a_x(y));
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span>
-->
<p><span class="caption">Encart 13-12¬†: exemple d'une fermeture qui se r√©f√®re √† une
variable pr√©sente dans la port√©e qui la contient.</span></p>
<!--
Here, even though `x` is not one of the parameters of `equal_to_x`, the
`equal_to_x` closure is allowed to use the `x` variable that‚Äôs defined in the
same scope that `equal_to_x` is defined in.
-->
<p>Ici, m√™me si <code>x</code> n'est pas un des param√®tres de <code>egal_a_x</code>, la fermeture
<code>egal_a_x</code> est autoris√©e √† utiliser la variable <code>x</code> d√©finie dans la m√™me
port√©e que celle o√π est d√©finie <code>egal_a_x</code>.</p>
<!--
We can‚Äôt do the same with functions; if we try with the following example, our
code won‚Äôt compile:
-->
<p>Nous ne pouvons pas faire la m√™me chose avec les fonctions¬†; si nous essayons
avec l'exemple suivant, notre code ne se compilera pas¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -> bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 4;

    fn egal_a_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(egal_a_x(y));
}
</code></pre>
<!--
We get an error:
-->
<p>Nous obtenons l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 -- > src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x` due to previous error
</code></pre>
<!--
The compiler even reminds us that this only works with closures!
-->
<p>Le compilateur nous rappelle m√™me que cela ne fonctionne qu'avec les
fermetures¬†!</p>
<!--
When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don‚Äôt want to pay in more common cases where we want to execute code that
doesn‚Äôt capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.
-->
<p>Lorsqu'une fermeture capture une valeur de son environnement, elle utilise la
m√©moire pour stocker les valeurs √† utiliser dans son corps. Cette utilisation de
la m√©moire a un co√ªt suppl√©mentaire que nous ne voulons pas payer dans les cas
les plus courants o√π nous voulons ex√©cuter du code qui ne capture pas son
environnement. Comme les fonctions ne sont jamais autoris√©es √† capturer leur
environnement, la d√©finition et l'utilisation des fonctions n'occasionneront
jamais cette surcharge.</p>
<!--
Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three `Fn` traits as follows:
-->
<p>Les fermetures peuvent capturer les valeurs de leur environnement de trois
fa√ßons diff√©rentes, qui correspondent directement aux trois fa√ßons dont une
fonction peut prendre un param√®tre¬†: prendre possession, emprunter de mani√®re
immuable et emprunter de mani√®re mutable. Ces moyens sont cod√©s dans les trois
traits <code>Fn</code> comme ceci¬†:</p>
<!--
* `FnOnce` consumes the variables it captures from its enclosing scope, known
  as the closure‚Äôs *environment*. To consume the captured variables, the
  closure must take ownership of these variables and move them into the closure
  when it is defined. The `Once` part of the name represents the fact that the
  closure can‚Äôt take ownership of the same variables more than once, so it can
  be called only once.
* `FnMut` can change the environment because it mutably borrows values.
* `Fn` borrows values from the environment immutably.
-->
<ul>
<li><code>FnOnce</code> consomme les variables qu'il capture √† partir de sa port√©e, d√©sign√©e
sous le nom de <em>l'environnement</em> de la fermeture. Pour consommer les variables
captur√©es, la fermeture doit prendre possession de ces variables et les
d√©placer dans la fermeture lorsqu'elle est d√©finie. La partie <code>Once</code> du nom
repr√©sente le fait que la fermeture ne puisse pas prendre prendre possession
des m√™mes variables plus d'une fois, donc elle ne peut √™tre appel√©e qu'une
seule fois.</li>
<li><code>FnMut</code> peut changer l'environnement car elle emprunte des valeurs de mani√®re
mutable.</li>
<li><code>Fn</code> emprunte des valeurs de l'environnement de mani√®re immuable.</li>
</ul>
<!--
When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement `FnOnce`
because they can all be called at least once. Closures that don‚Äôt move the
captured variables also implement `FnMut`, and closures that don‚Äôt need mutable
access to the captured variables also implement `Fn`. In Listing 13-12, the
`equal_to_x` closure borrows `x` immutably (so `equal_to_x` has the `Fn` trait)
because the body of the closure only needs to read the value in `x`.
-->
<p>Lorsque nous cr√©ons une fermeture, Rust d√©duit quel trait utiliser en se basant
sur la fa√ßon dont la fermeture utilise les valeurs de l'environnement. Toutes
les fermetures impl√©mentent <code>FnOne</code> car elles peuvent toute √™tre appel√©es au
moins une fois. Les fermetures qui ne d√©placent pas les variables captur√©es
impl√©mentent √©galement <code>FnMut</code>, et les fermetures qui n'ont pas besoin d'acc√®s
mutable aux variables captur√©es impl√©mentent aussi <code>Fn</code>. Dans l'encart 13-12, la
fermeture <code>egal_a_x</code> emprunte <code>x</code> immuablement (donc <code>egal_a_x</code> a le trait <code>Fn</code>)
parce que le corps de la fermeture ne fait que lire la valeur de <code>x</code>.</p>
<!--
If you want to force the closure to take ownership of the values it uses in the
environment, you can use the `move` keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it‚Äôs owned by the new thread.
-->
<p>Si nous voulons forcer la fermeture √† prendre possession des valeurs qu'elle
utilise dans l'environnement, nous pouvons utiliser le mot-cl√© <code>move</code> avant la
liste des param√®tres. Cette technique est tr√®s utile lorsque vous passez une
fermeture √† une nouvelle t√¢che pour d√©placer les donn√©es afin qu'elles
appartiennent √† la nouvelle t√¢che.</p>
<!--
> Note: `move` closures may still implement `Fn` or `FnMut`, even though
> they capture variables by move. This is because the traits implemented by a
> closure type are determined by what the closure does with captured values,
> not how it captures them. The `move` keyword only specifies the latter.
-->
<blockquote>
<p>Remarque¬†: les fermetures <code>move</code> peuvent toujours impl√©menter <code>Fn</code> ou
<code>FnMut</code>, m√™me si elles capturent les variables en les d√©pla√ßant. C'est
possible car les traits impl√©ment√©s par un type de fermeture sont d√©termin√©s
par ce que font ces fermetures avec les valeurs d√©plac√©es et pas d'apr√®s la fa√ßon
dont elles les capturent. Le mot-cl√© <code>move</code> ne d√©finit que ce dernier aspect.</p>
</blockquote>
<!--
We‚Äôll have more examples of `move` closures in Chapter 16 when we talk about
concurrency. For now, here‚Äôs the code from Listing 13-12 with the `move`
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.
-->
<p>Nous verrons d'autres exemples de fermetures utilisant <code>move</code> au chapitre 16
lorsque nous parlerons de la concurrence. Pour l'instant, voici le code de
l'encart 13-12 avec le mot-cl√© <code>move</code> ajout√© √† la d√©finition de la fermeture et
utilisant des vecteurs au lieu d'entiers, car les entiers peuvent √™tre copi√©s
plut√¥t que d√©plac√©s¬†; notez aussi que ce code ne compile pas encore.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let egal_a_x = move |z| z == x;

    println!(&quot;On ne peut pas utiliser x ici¬†: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(egal_a_x(y));
}
</code></pre>
<!--
We receive the following error:
-->
<p>Nous obtenons l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 -- > src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `Vec<i32>`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!("can't use x here: {:?}", x);
  |                                        ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let egal_a_x = move |z| z == x;
  |                    --------      - variable moved due to use in closure
  |                    |
  |                    value moved into closure here
5 | 
6 |     println!(&quot;On ne peut pas utiliser x ici¬†: {:?}&quot;, x);
  |                                                      ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x` due to previous error
</code></pre>
<!--
The `x` value is moved into the closure when the closure is defined, because we
added the `move` keyword. The closure then has ownership of `x`, and `main`
isn‚Äôt allowed to use `x` anymore in the `println!` statement. Removing
`println!` will fix this example.
-->
<p>La valeur <code>x</code> est d√©plac√©e dans la fermeture lorsque la fermeture est d√©finie,
parce que nous avons ajout√© le mot-cl√© <code>move</code>. La fermeture a alors la propri√©t√©
de <code>x</code>, et <code>main</code> n'est plus autoris√© √† utiliser <code>x</code> dans l'instruction
<code>println!</code>. Supprimer <code>println!</code> corrigera cet exemple.</p>
<!--
Most of the time when specifying one of the `Fn` trait bounds, you can start
with `Fn` and the compiler will tell you if you need `FnMut` or `FnOnce` based
on what happens in the closure body.
-->
<p>La plupart du temps, lorsque vous renseignez l'un des traits li√©s <code>Fn</code>, vous
pouvez commencer par <code>Fn</code> et le compilateur vous dira si vous avez besoin de
<code>FnMut</code> ou <code>FnOnce</code> en fonction de ce qui se passe dans le corps de la
fermeture.</p>
<!--
To illustrate situations where closures that can capture their environment are
useful as function parameters, let‚Äôs move on to our next topic: iterators.
-->
<p>Pour illustrer les situations o√π des fermetures qui capturent leur
environnement sont utiles comme param√®tres de fonction, passons √† notre
sujet suivant¬†: les it√©rateurs.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Processing a Series of Items with Iterators
-->
<h2 id="traiter-une-s√©rie-d√©l√©ments-avec-un-it√©rateur"><a class="header" href="#traiter-une-s√©rie-d√©l√©ments-avec-un-it√©rateur">Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></h2>
<!--
The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don‚Äôt
have to reimplement that logic yourself.
-->
<p>Les it√©rateurs vous permettent d'effectuer une t√¢che sur une s√©quence d'√©l√©ments
√† tour de r√¥le. Un <em>it√©rateur</em> est responsable de la logique d'it√©ration sur
chaque √©l√©ment et de d√©terminer lorsque la s√©quence est termin√©e. Lorsque nous
utilisons des it√©rateurs, nous n'avons pas besoin de r√©-impl√©menter cette
logique nous-m√™mes.</p>
<!--
In Rust, iterators are *lazy*, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector `v1` by calling
the `iter` method defined on `Vec<T>`. This code by itself doesn‚Äôt do anything
useful.
-->
<p>En Rust, un it√©rateur est <em>une √©valuation paresseuse</em>, ce qui signifie qu'il n'a
aucun effet jusqu'√† ce que nous appelions des m√©thodes qui consomment
l'it√©rateur pour l'utiliser. Par exemple, le code dans l'encart 13-13 cr√©e un
it√©rateur sur les √©l√©ments du vecteur <code>v1</code> en appelant la m√©thode <code>iter</code> d√©finie
sur <code>Vec&lt;T&gt;</code>. Ce code en lui-m√™me ne fait rien d'utile.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-13: Creating an iterator</span>
-->
<p><span class="caption">Encart 13-13¬†: cr√©ation d'un it√©rateur</span></p>
<!--
Once we‚Äôve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with `for` loops to execute some code on
each item, although we glossed over what the call to `iter` did until now.
-->
<p>Une fois que nous avons cr√©√© un it√©rateur, nous pouvons l'utiliser de diverses
mani√®res. Dans l'encart 3-4 du chapitre 3, nous avions utilis√© des it√©rateurs
avec des boucles <code>for</code> pour ex√©cuter du code sur chaque √©l√©ment, bien que nous
ayons laiss√© de c√¥t√© ce que l'appel √† <code>iter</code> faisait jusqu'√† pr√©sent.</p>
<!--
The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the `for` loop. The iterator is stored in the `v1_iter`
variable, and no iteration takes place at that time. When the `for` loop is
called using the iterator in `v1_iter`, each element in the iterator is used in
one iteration of the loop, which prints out each value.
-->
<p>L'exemple dans l'encart 13-14 s√©pare la cr√©ation de l'it√©rateur de son
utilisation dans la boucle <code>for</code>. L'it√©rateur est stock√© dans la variable
<code>v1_iter</code>, et aucune it√©ration n'a lieu √† ce moment-l√†. Lorsque la boucle <code>for</code>
est appel√©e en utilisant l'it√©rateur <code>v1_iter</code>, chaque √©l√©ment de l'it√©rateur
est utilis√© √† chaque it√©ration de la boucle, qui affiche chaque valeur.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;On a¬†: {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-14: Using an iterator in a `for` loop</span>
-->
<p><span class="caption">Encart 13-14¬†: utilisation d'un it√©rateur dans une boucle
<code>for</code></span></p>
<!--
In languages that don‚Äôt have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.
-->
<p>Dans les langages qui n'ont pas d'it√©rateurs fournis par leur biblioth√®que
standard, nous √©cririons probablement cette m√™me fonctionnalit√© en d√©marrant une
variable √† l'indice 0, en utilisant cette variable comme indice sur le vecteur afin
d'obtenir une valeur puis en incr√©mentant la valeur de cette variable dans une boucle
jusqu'√† ce qu'elle atteigne le nombre total d'√©l√©ments dans le vecteur.</p>
<!--
Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let‚Äôs examine how iterators do that.
-->
<p>Les it√©rateurs s'occupent de toute cette logique pour nous, r√©duisant le code
redondant dans lequel nous pourrions potentiellement faire des erreurs. Les
it√©rateurs nous donnent plus de flexibilit√© pour utiliser la m√™me logique avec
de nombreux types de s√©quences diff√©rentes, et pas seulement avec des
structures de donn√©es avec lesquelles nous pouvons utiliser des indices, telles que
les vecteurs. Voyons comment les it√©rateurs font cela.</p>
<!--
### The `Iterator` Trait and the `next` Method
-->
<h3 id="le-trait-iterator-et-la-m√©thode-next"><a class="header" href="#le-trait-iterator-et-la-m√©thode-next">Le trait <code>Iterator</code> et la m√©thode <code>next</code></a></h3>
<!--
All iterators implement a trait named `Iterator` that is defined in the
standard library. The definition of the trait looks like this:
-->
<p>Tous les it√©rateurs impl√©mentent un trait appel√© <code>Iterator</code> qui est d√©fini dans
la biblioth√®que standard. La d√©finition du trait ressemble √† ceci¬†:</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // les m√©thodes avec des impl√©mentations par d√©faut ont √©t√© exclues
}
<span class="boring">}
</span></code></pre></pre>
<!--
Notice this definition uses some new syntax: `type Item` and `Self::Item`,
which are defining an *associated type* with this trait. We‚Äôll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the `Iterator` trait requires that you also define
an `Item` type, and this `Item` type is used in the return type of the `next`
method. In other words, the `Item` type will be the type returned from the
iterator.
-->
<p>Remarquez que cette d√©finition utilise une nouvelle syntaxe¬†: <code>type Item</code> et
<code>Self::Item</code>, qui d√©finissent un <em>type associ√©</em> √† ce trait. Nous verrons ce que
sont les types associ√©s au chapitre 19. Pour l'instant, tout ce que vous devez
savoir est que ce code dit que l'impl√©mentation du trait <code>Iterator</code> n√©cessite
que vous d√©finissiez aussi un type <code>Item</code>, et ce type <code>Item</code> est utilis√© dans le
type de retour de la m√©thode <code>next</code>. En d'autres termes, le type <code>Item</code> sera le
type retourn√© par l'it√©rateur.</p>
<!--
The `Iterator` trait only requires implementors to define one method: the
`next` method, which returns one item of the iterator at a time wrapped in
`Some` and, when iteration is over, returns `None`.
-->
<p>Le trait <code>Iterator</code> exige la d√©finition d'une seule m√©thode par les
d√©veloppeurs¬†: la m√©thode <code>next</code>, qui retourne un √©l√©ment de l'it√©rateur √† la
fois int√©gr√© dans un <code>Some</code>, et lorsque l'it√©ration est termin√©e, il retourne
<code>None</code>.</p>
<!--
We can call the `next` method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to `next` on the iterator created
from the vector.
-->
<p>On peut appeler la m√©thode <code>next</code> directement sur les it√©rateurs¬†; l'encart
13-15 montre quelles valeurs sont retourn√©es par des appels r√©p√©t√©s √† <code>next</code> sur
l'it√©rateur cr√©√© √† partir du vecteur.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn demo_iterateur() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-15: Calling the `next` method on an
iterator</span>
-->
<p><span class="caption">Encart 13-15¬†: appel de la m√©thode <code>next</code> sur un it√©rateur
</span></p>
<!--
Note that we needed to make `v1_iter` mutable: calling the `next` method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code *consumes*, or uses up, the
iterator. Each call to `next` eats up an item from the iterator. We didn‚Äôt need
to make `v1_iter` mutable when we used a `for` loop because the loop took
ownership of `v1_iter` and made it mutable behind the scenes.
-->
<p>Remarquez que nous avons eu besoin de rendre mutable <code>v1_iter</code>¬†: appeler la
m√©thode <code>next</code> sur un iterator change son √©tat interne qui garde en m√©moire l'endroit
o√π il en est dans la s√©quence. En d'autres termes, ce code <em>consomme</em>, ou utilise,
l'it√©rateur. Chaque appel √† <code>next</code> consomme un √©l√©ment de l'it√©rateur. Nous
n'avions pas eu besoin de rendre mutable <code>v1_iter</code> lorsque nous avions utilis√©
une boucle <code>for</code> parce que la boucle avait pris possession de <code>v1_iter</code> et l'avait
rendu mutable en coulisses.</p>
<!--
Also note that the values we get from the calls to `next` are immutable
references to the values in the vector. The `iter` method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of `v1` and returns owned values, we can call `into_iter` instead of
`iter`. Similarly, if we want to iterate over mutable references, we can call
`iter_mut` instead of `iter`.
-->
<p>Notez √©galement que les valeurs que nous obtenons des appels √† <code>next</code> sont des
r√©f√©rences immuables aux valeurs dans le vecteur. La m√©thode <code>iter</code> produit un
it√©rateur pour des r√©f√©rences immuables. Si nous voulons cr√©er un it√©rateur qui
prend possession de <code>v1</code> et retourne les valeurs poss√©d√©es, nous pouvons appeler
<code>into_iter</code> au lieu de <code>iter</code>. De m√™me, si nous voulons it√©rer sur des
r√©f√©rences mutables, nous pouvons appeler <code>iter_mut</code> au lieu de <code>iter</code>.</p>
<!--
### Methods that Consume the Iterator
-->
<h3 id="les-m√©thodes-qui-consomment-un-it√©rateur"><a class="header" href="#les-m√©thodes-qui-consomment-un-it√©rateur">Les m√©thodes qui consomment un it√©rateur</a></h3>
<!--
The `Iterator` trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the `Iterator`
trait. Some of these methods call the `next` method in their definition, which
is why you‚Äôre required to implement the `next` method when implementing the
`Iterator` trait.
-->
<p>Le trait <code>Iterator</code> a un certain nombre de m√©thodes diff√©rentes avec des
impl√©mentations par d√©faut que nous fournit la biblioth√®que standard¬†; vous
pouvez d√©couvrir ces m√©thodes en regardant dans la documentation de l'API de la
biblioth√®que standard pour le trait <code>Iterator</code>. Certaines de ces m√©thodes
appellent la m√©thode <code>next</code> dans leur d√©finition, c'est pourquoi nous devons
toujours impl√©menter la m√©thode <code>next</code> lors de l'impl√©mentation du trait
<code>Iterator</code>.</p>
<!--
Methods that call `next` are called *consuming adaptors*, because calling them
uses up the iterator. One example is the `sum` method, which takes ownership of
the iterator and iterates through the items by repeatedly calling `next`, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the `sum` method:
-->
<p>Les m√©thodes qui appellent <code>next</code> sont appel√©es des
<em>adaptateurs de consommation</em>, parce que les appeler consomme l'it√©rateur. Un
exemple est la m√©thode <code>sum</code>, qui prend possession de l'it√©rateur et it√©re sur
ses √©l√©ments en appelant plusieurs fois <code>next</code>, consommant ainsi l'it√©rateur. A
chaque √©tape de l'it√©ration, il ajoute chaque √©l√©ment √† un total en cours et
retourne le total une fois l'it√©ration termin√©e. L'encart 13-16 a un test
illustrant une utilisation de la m√©thode <code>sum</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-16: Calling the `sum` method to get the total
of all items in the iterator</span>
-->
<p><span class="caption">Encart 13-16¬†: appel de la m√©thode <code>sum</code> pour obtenir la
somme de tous les √©l√©ments pr√©sents dans l'it√©rateur</span></p>
<!--
We aren‚Äôt allowed to use `v1_iter` after the call to `sum` because `sum` takes
ownership of the iterator we call it on.
-->
<p>Nous ne sommes pas autoris√©s √† utiliser <code>v1_iter</code> apr√®s l'appel √† <code>sum</code> car
<code>sum</code> a pris possession de l'it√©rateur avec lequel nous l'appelons.</p>
<!--
### Methods that Produce Other Iterators
-->
<h3 id="m√©thodes-qui-produisent-dautres-it√©rateurs"><a class="header" href="#m√©thodes-qui-produisent-dautres-it√©rateurs">M√©thodes qui produisent d'autres it√©rateurs</a></h3>
<!--
Other methods defined on the `Iterator` trait, known as *iterator adaptors*,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.
-->
<p>D'autres m√©thodes d√©finies sur le trait <code>Iterator</code>, connues sous le nom
<em>d'adaptateurs d'it√©ration</em>, nous permettent de transformer un it√©rateur en un
type d'it√©rateur diff√©rent. Nous pouvons encha√Æner plusieurs appels √† des
adaptateurs d'it√©ration pour effectuer des actions complexes de mani√®re
compr√©hensible. Mais comme les it√©rateurs sont <em>des √©valuations paresseuses</em>,
nous devons faire appel √† l'une des m√©thodes d'adaptation de consommation pour
obtenir les r√©sultats des appels aux adaptateurs d'it√©ration.</p>
<!--
Listing 13-17 shows an example of calling the iterator adaptor method `map`,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:
-->
<p>L'encart 13-17 montre un exemple d'appel √† la m√©thode d'adaptation d'it√©ration
<code>map</code>, qui prend en param√®tre une fermeture qui va s'ex√©cuter sur chaque √©l√©ment
pour produire un nouvel it√©rateur. La fermeture cr√©e ici un nouvel it√©rateur
dans lequel chaque √©l√©ment du vecteur a √©t√© incr√©ment√© de 1. Cependant, ce code
d√©clenche un avertissement¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,not_desired_behavior
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
# }
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-17: Calling the iterator adaptor `map` to
create a new iterator</span>
-->
<p><span class="caption">Encart 13-17¬†: appel de l'adaptateur d'it√©ration <code>map</code>
pour cr√©er un nouvel it√©rateur</span></p>
<!--
The warning we get is this:
-->
<p>Voici l'avertissement que nous obtenons¬†:</p>
<!--
```console
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 -- > src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin "iterators") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```
-->
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<!--
The code in Listing 13-17 doesn‚Äôt do anything; the closure we‚Äôve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.
-->
<p>Le code dans l'encart 13-17 ne fait rien¬†; la fermeture que nous avons renseign√©e
n'est jamais ex√©cut√©e. L'avertissement nous rappelle pourquoi¬†: les adaptateurs
d'it√©ration sont des <em>√©valuations paresseuses</em>, c'est pourquoi nous devons
consommer l'it√©rateur ici.</p>
<!--
To fix this and consume the iterator, we‚Äôll use the `collect` method, which we
used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.
-->
<p>Pour corriger ceci et consommer l'it√©rateur, nous utiliserons la m√©thode
<code>collect</code>, que vous avez utilis√© avec <code>env::args</code> dans l'encart 12-1 du
chapitre 12. Cette m√©thode consomme l'it√©rateur et collecte les valeurs
r√©sultantes dans un type de collection de donn√©es.</p>
<!--
In Listing 13-18, we collect the results of iterating over the iterator that‚Äôs
returned from the call to `map` into a vector. This vector will end up
containing each item from the original vector incremented by 1.
-->
<p>Dans l'encart 13-18, nous recueillons les r√©sultats de l'it√©ration sur
l'it√©rateur qui sont retourn√©s par l'appel √† <code>map</code> sur un vecteur. Ce vecteur
finira par contenir chaque √©l√©ment du vecteur original incr√©ment√© de 1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-18: Calling the `map` method to create a new
iterator and then calling the `collect` method to consume the new iterator and
create a vector</span>
-->
<p><span class="caption">Encart 13-18¬†: appel de la m√©thode <code>map</code> pour cr√©er un
nouvel it√©rateur, puis appel de la m√©thode <code>collect</code> pour consommer le nouvel
it√©rateur afin de cr√©er un vecteur</span></p>
<!--
Because `map` takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the `Iterator` trait
provides.
-->
<p>Comme <code>map</code> prend en param√®tre une fermeture, nous pouvons renseigner n'importe
quelle op√©ration que nous souhaitons ex√©cuter sur chaque √©l√©ment. C'est un bon
exemple de la fa√ßon dont les fermetures nous permettent de personnaliser
certains comportements tout en r√©utilisant le comportement d'it√©ration fourni
par le trait <code>Iterator</code>.</p>
<!--
### Using Closures that Capture Their Environment
-->
<h3 id="utilisation-de-fermetures-capturant-leur-environnement"><a class="header" href="#utilisation-de-fermetures-capturant-leur-environnement">Utilisation de fermetures capturant leur environnement</a></h3>
<!--
Now that we‚Äôve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the `filter` iterator adaptor.
The `filter` method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns `true`, the value
will be included in the iterator produced by `filter`. If the closure returns
`false`, the value won‚Äôt be included in the resulting iterator.
-->
<p>Maintenant que nous avons pr√©sent√© les it√©rateurs, nous pouvons illustrer une
utilisation commune des fermetures qui capturent leur environnement en utilisant
l'adaptateur d'it√©ration <code>filter</code>. La m√©thode <code>filter</code> appel√©e sur un it√©rateur
prend en param√®tre une fermeture qui s'ex√©cute sur chaque √©l√©ment de l'it√©rateur
et retourne un bool√©en pour chacun. Si la fermeture retourne <code>true</code>, la valeur
sera incluse dans l'it√©rateur produit par <code>filter</code>. Si la fermeture retourne
<code>false</code>, la valeur ne sera pas incluse dans l'it√©rateur r√©sultant.</p>
<!--
In Listing 13-19, we use `filter` with a closure that captures the `shoe_size`
variable from its environment to iterate over a collection of `Shoe` struct
instances. It will return only shoes that are the specified size.
-->
<p>Dans l'encart 13-19, nous utilisons <code>filter</code> avec une fermeture qui capture la
variable <code>pointure_chaussure</code> de son environnement pour it√©rer sur une
collection d'instances de la structure <code>Chaussure</code>. Il ne retournera que les
chaussures avec la pointure demand√©e.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```
-->
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Chaussure {
    pointure: u32,
    style: String,
}

fn chaussures_a_la_pointure(chaussures: Vec&lt;Chaussure&gt;, pointure_chaussure: u32) -&gt; Vec&lt;Chaussure&gt; {
    chaussures.into_iter()
              .filter(|s| s.pointure == pointure_chaussure)
              .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filtres_par_pointure() {
        let chaussures = vec![
            Chaussure {
                pointure: 10,
                style: String::from(&quot;baskets&quot;),
            },
            Chaussure {
                pointure: 13,
                style: String::from(&quot;sandale&quot;),
            },
            Chaussure {
                pointure: 10,
                style: String::from(&quot;bottes&quot;),
            },
        ];

        let a_ma_pointure = chaussures_a_la_pointure(chaussures, 10);

        assert_eq!(
            a_ma_pointure,
            vec![
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;baskets&quot;)
                },
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;bottes&quot;)
                },
            ]
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-19: Using the `filter` method with a closure
that captures `shoe_size`</span>
-->
<p><span class="caption">Encart 13-19¬†: utilisation de la m√©thode <code>filter</code> avec une
fermeture capturant <code>pointure_chaussure</code></span></p>
<!--
The `shoes_in_size` function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.
-->
<p>La fonction <code>chaussures_a_la_pointure</code> prend possession d'un vecteur de
chaussures et d'une pointure comme param√®tres. Il retourne un vecteur contenant
uniquement des chaussures de la pointure demand√©e.</p>
<!--
In the body of `shoes_in_size`, we call `into_iter` to create an iterator
that takes ownership of the vector. Then we call `filter` to adapt that
iterator into a new iterator that only contains elements for which the closure
returns `true`.
-->
<p>Dans le corps de <code>chaussures_a_la_pointure</code>, nous appelons <code>into_iter</code> pour
cr√©er un it√©rateur qui prend possession du vecteur. Ensuite, nous appelons
<code>filter</code> pour adapter cet it√©rateur dans un nouvel it√©rateur qui ne contient que
les √©l√©ments pour lesquels la fermeture retourne <code>true</code>.</p>
<!--
The closure captures the `shoe_size` parameter from the environment and
compares the value with each shoe‚Äôs size, keeping only shoes of the size
specified. Finally, calling `collect` gathers the values returned by the
adapted iterator into a vector that‚Äôs returned by the function.
-->
<p>La fermeture capture le param√®tre <code>pointure_chaussure</code> de l'environnement et
compare la valeur avec la pointure de chaque chaussure, en ne gardant que les
chaussures de la pointure sp√©cifi√©e. Enfin, l'appel √† <code>collect</code> retourne un
vecteur qui regroupe les valeurs renvoy√©es par l'it√©rateur.</p>
<!--
The test shows that when we call `shoes_in_size`, we get back only shoes
that have the same size as the value we specified.
-->
<p>Le test confirme que lorsque nous appelons <code>chaussures_a_la_pointure</code>, nous
n'obtenons que des chaussures qui ont la m√™me pointure que la valeur que nous
avons demand√©e.</p>
<!--
### Creating Our Own Iterators with the `Iterator` Trait
-->
<h3 id="cr√©er-nos-propres-it√©rateurs-avec-le-trait-iterator"><a class="header" href="#cr√©er-nos-propres-it√©rateurs-avec-le-trait-iterator">Cr√©er nos propres it√©rateurs avec le trait <code>Iterator</code></a></h3>
<!--
We‚Äôve shown that you can create an iterator by calling `iter`, `into_iter`, or
`iter_mut` on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the `Iterator` trait on your own
types. As previously mentioned, the only method you‚Äôre required to provide a
definition for is the `next` method. Once you‚Äôve done that, you can use all
other methods that have default implementations provided by the `Iterator`
trait!
-->
<p>Nous avons vu que nous pouvons cr√©er un it√©rateur en appelant <code>iter</code>,
<code>into_iter</code> ou <code>iter_mut</code> sur un vecteur. Nous pouvons cr√©er des it√©rateurs √†
partir d'autres types de collections de la biblioth√®que standard, comme les
tables de hachage. Nous pouvons aussi cr√©er des it√©rateurs qui font tout ce que
nous voulons en impl√©mentant le trait <code>Iterator</code> sur nos propres types. Comme
nous l'avons mentionn√© pr√©c√©demment, la seule m√©thode pour laquelle nous devons
fournir une d√©finition est la m√©thode <code>next</code>. Une fois que nous avons fait cela,
nous pouvons utiliser toutes les autres m√©thodes qui ont des impl√©mentations par
d√©faut fournies par le trait <code>Iterator</code>¬†!</p>
<!--
To demonstrate, let‚Äôs create an iterator that will only ever count from 1 to 5.
First, we‚Äôll create a struct to hold some values. Then we‚Äôll make this struct
into an iterator by implementing the `Iterator` trait and using the values in
that implementation.
-->
<p>Pour preuve, cr√©ons un it√©rateur qui ne comptera que de 1 √† 5. D'abord, nous
allons cr√©er une structure contenant quelques valeurs. Ensuite nous
transformerons cette structure en it√©rateur en impl√©mentant le trait <code>Iterator</code>
et nous utiliserons les valeurs de cette impl√©mentation.</p>
<!--
Listing 13-20 has the definition of the `Counter` struct and an associated
`new` function to create instances of `Counter`:
-->
<p>L'encart 13-20 montre la d√©finition de la structure <code>Compteur</code> et une fonction
associ√©e <code>new</code> pour cr√©er des instances de <code>Compteur</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```
-->
<pre><code class="language-rust noplayground">struct Compteur {
    compteur: u32,
}

impl Compteur {
    fn new() -&gt; Compteur {
        Compteur { compteur: 0 }
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-20: Defining the `Counter` struct and a `new`
function that creates instances of `Counter` with an initial value of 0 for
`count`</span>
-->
<p><span class="caption">Encart 13-20¬†: d√©finition de la structure <code>Compteur</code> et
d'une fonction <code>new</code> qui cr√©e des instances de <code>Compteur</code> avec une valeur
initiale de 0 pour le champ <code>compteur</code>.</span></p>
<!--
The `Counter` struct has one field named `count`. This field holds a `u32`
value that will keep track of where we are in the process of iterating from 1
to 5. The `count` field is private because we want the implementation of
`Counter` to manage its value. The `new` function enforces the behavior of
always starting new instances with a value of 0 in the `count` field.
-->
<p>La structure <code>Compteur</code> a un champ <code>compteur</code>. Ce champ contient une valeur
<code>u32</code> qui gardera la trace de l'endroit o√π nous sommes dans le processus
d'it√©ration de 1 √† 5. Le champ <code>compteur</code> est priv√© car nous voulons que ce soit
l'impl√©mentation de <code>Compteur</code> qui g√®re sa valeur. La fonction <code>new</code> impose de
toujours d√©marrer de nouvelles instances avec une valeur de 0 pour le champ
<code>compteur</code>.</p>
<!--
Next, we‚Äôll implement the `Iterator` trait for our `Counter` type by defining
the body of the `next` method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:
-->
<p>Ensuite, nous allons impl√©menter le trait <code>Iterator</code> sur notre type <code>Compteur</code>
en d√©finissant le corps de la m√©thode <code>next</code> pour pr√©ciser ce que nous voulons
qu'il se passe quand cet it√©rateur est utilis√©, comme dans l'encart 13-21¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.compteur &lt; 5 {
            self.compteur += 1;
            Some(self.compteur)
        } else {
            None
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-21: Implementing the `Iterator` trait on our
`Counter` struct</span>
-->
<p><span class="caption">Encart 13-21¬†: impl√©mentation du trait <code>Iterator</code> sur
notre structure <code>Compteur</code></span></p>
<!--
We set the associated `Item` type for our iterator to `u32`, meaning the
iterator will return `u32` values. Again, don‚Äôt worry about associated types
yet, we‚Äôll cover them in Chapter 19.
-->
<p>Nous avons d√©fini le type associ√© <code>Item</code> pour notre it√©rateur √† <code>u32</code>, ce qui
signifie que l'it√©rateur renverra des valeurs <code>u32</code>. Encore une fois, ne vous
pr√©occupez pas des types associ√©s, nous les aborderons au chapitre 19.</p>
<!--
We want our iterator to add 1 to the current state, so we initialized `count`
to 0 so it would return 1 first. If the value of `count` is less than 5, `next`
will increment `count` and return the current value wrapped in `Some`. Once
`count` is 5, our iterator will stop incrementing `count` and always return
`None`.
-->
<p>Nous voulons que notre it√©rateur ajoute 1 √† l'√©tat courant, donc nous avons
initialis√© <code>compteur</code> √† 0 pour qu'il retourne 1 lors du premier appel √† <code>next</code>.
Si la valeur de <code>compteur</code> est strictement inf√©rieure √† 5, <code>next</code> va incr√©menter
<code>compteur</code> puis va retourner la valeur courante int√©gr√©e dans un <code>Some</code>. Une fois
que <code>compteur</code> vaudra 5, notre it√©rateur va arr√™ter d'incr√©menter <code>compteur</code> et
retournera toujours <code>None</code>.</p>
<!--
#### Using Our `Counter` Iterator‚Äôs `next` Method
-->
<h3 id="utiliser-la-m√©thode-next-de-notre-it√©rateur-compteur"><a class="header" href="#utiliser-la-m√©thode-next-de-notre-it√©rateur-compteur">Utiliser la m√©thode <code>next</code> de notre It√©rateur <code>Compteur</code></a></h3>
<!--
Once we‚Äôve implemented the `Iterator` trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
`Counter` struct by calling the `next` method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.
-->
<p>Une fois que nous avons impl√©ment√© le trait <code>Iterator</code>, nous avons un
it√©rateur¬†! L'encart 13-22 montre un test d√©montrant que nous pouvons utiliser
la fonctionnalit√© d'it√©ration de notre structure <code>Compteur</code> en appelant
directement la m√©thode <code>next</code>, comme nous l'avons fait avec l'it√©rateur cr√©√© √†
partir d'un vecteur dans l'encart 13-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_direct_a_next() {
        let mut compteur = Compteur::new();

        assert_eq!(compteur.next(), Some(1));
        assert_eq!(compteur.next(), Some(2));
        assert_eq!(compteur.next(), Some(3));
        assert_eq!(compteur.next(), Some(4));
        assert_eq!(compteur.next(), Some(5));
        assert_eq!(compteur.next(), None);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-22: Testing the functionality of the `next`
method implementation</span>
-->
<p><span class="caption">Encart 13-22¬†: test de l'impl√©mentation de la m√©thode
<code>next</code></span></p>
<!--
This test creates a new `Counter` instance in the `counter` variable and then
calls `next` repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.
-->
<p>Ce test cr√©e une nouvelle instance de <code>Compteur</code> dans la variable <code>compteur</code> et
appelle ensuite <code>next</code> √† plusieurs reprises, en v√©rifiant que nous avons
impl√©ment√© le comportement que nous voulions que cet it√©rateur suive¬†: renvoyer
les valeurs de 1 √† 5.</p>
<!--
#### Using Other `Iterator` Trait Methods
-->
<h4 id="utiliser-dautres-m√©thodes-du-trait-iterator"><a class="header" href="#utiliser-dautres-m√©thodes-du-trait-iterator">Utiliser d'autres m√©thodes du trait <code>Iterator</code></a></h4>
<!--
We implemented the `Iterator` trait by defining the `next` method, so we
can now use any `Iterator` trait method‚Äôs default implementations as defined in
the standard library, because they all use the `next` method‚Äôs functionality.
-->
<p>Maintenant que nous avons impl√©ment√© le trait <code>Iterator</code> en d√©finissant la
m√©thode <code>next</code>, nous pouvons maintenant utiliser les impl√©mentations par d√©faut
de n'importe quelle m√©thode du trait <code>Iterator</code> telles que d√©finies dans la
biblioth√®que standard, car elles utilisent toutes la m√©thode <code>next</code>.</p>
<!--
For example, if for some reason we wanted to take the values produced by an
instance of `Counter`, pair them with values produced by another `Counter`
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:
-->
<p>Par exemple, si pour une raison quelconque nous voulions prendre les valeurs
produites par une instance de <code>Compteur</code>, les coupler avec des valeurs produites
par une autre instance de <code>Compteur</code> apr√®s avoir saut√© la premi√®re valeur,
multiplier chaque paire ensemble, ne garder que les r√©sultats qui sont
divisibles par 3 et additionner toutes les valeurs r√©sultantes ensemble, nous
pourrions le faire, comme le montre le test dans l'encart 13-23¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn calling_next_directly() {
#         let mut counter = Counter::new();
# 
#         assert_eq!(counter.next(), Some(1));
#         assert_eq!(counter.next(), Some(2));
#         assert_eq!(counter.next(), Some(3));
#         assert_eq!(counter.next(), Some(4));
#         assert_eq!(counter.next(), Some(5));
#         assert_eq!(counter.next(), None);
#     }
# 
    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn appel_direct_a_next() {
</span><span class="boring">        let mut compteur = Compteur::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(compteur.next(), Some(1));
</span><span class="boring">        assert_eq!(compteur.next(), Some(2));
</span><span class="boring">        assert_eq!(compteur.next(), Some(3));
</span><span class="boring">        assert_eq!(compteur.next(), Some(4));
</span><span class="boring">        assert_eq!(compteur.next(), Some(5));
</span><span class="boring">        assert_eq!(compteur.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn utilisation_des_autres_methodes_du_trait_iterator() {
        let somme: u32 = Compteur::new()
            .zip(Compteur::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, somme);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-23: Using a variety of `Iterator` trait
methods on our `Counter` iterator</span>
-->
<p><span class="caption">Encart 13-23¬†: utilisation d'une gamme de m√©thodes du
trait <code>Iterator</code> sur notre it√©rateur <code>Compteur</code> </span></p>
<!--
Note that `zip` produces only four pairs; the theoretical fifth pair `(5,
None)` is never produced because `zip` returns `None` when either of its input
iterators return `None`.
-->
<p>Notez que <code>zip</code> ne produit que quatre paires¬†; la cinqui√®me paire th√©orique
<code>(5, None)</code> n'est jamais produite car <code>zip</code> retourne <code>None</code> lorsque l'un de
ses it√©rateurs d'entr√©e retourne <code>None</code>.</p>
<!--
All of these method calls are possible because we specified how the `next`
method works, and the standard library provides default implementations for
other methods that call `next`.
-->
<p>Tous ces appels de m√©thode sont possibles car nous avons renseign√© comment
la m√©thode <code>next</code> fonctionne et la biblioth√®que standard fournit des
impl√©mentations par d√©faut pour les autres m√©thodes qui appellent <code>next</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Improving Our I/O Project
-->
<h2 id="am√©lioration-de-notre-projet-dentr√©esortie"><a class="header" href="#am√©lioration-de-notre-projet-dentr√©esortie">Am√©lioration de notre projet d'entr√©e/sortie</a></h2>
<!--
With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let‚Äôs look at how iterators can improve our implementation of the
`Config::new` function and the `search` function.
-->
<p>Gr√¢ce √† ces nouvelles connaissances sur les it√©rateurs, nous pouvons am√©liorer
le projet d'entr√©e/sortie du chapitre 12 en utilisant des it√©rateurs pour
rendre certains endroits du code plus clairs et plus concis. Voyons comment les
it√©rateurs peuvent am√©liorer notre impl√©mentation de la fonction <code>Config::new</code>
et de la fonction <code>rechercher</code>.</p>
<!--
### Removing a `clone` Using an Iterator
-->
<h3 id="supprimer-lappel-√†-clone-√†-laide-dun-it√©rateur"><a class="header" href="#supprimer-lappel-√†-clone-√†-laide-dun-it√©rateur">Supprimer l'appel √† <code>clone</code> √† l'aide d'un it√©rateur</a></h3>
<!--
In Listing 12-6, we added code that took a slice of `String` values and created
an instance of the `Config` struct by indexing into the slice and cloning the
values, allowing the `Config` struct to own those values. In Listing 13-24,
we‚Äôve reproduced the implementation of the `Config::new` function as it was in
Listing 12-23:
-->
<p>Dans l'encart 12-6, nous avions ajout√© du code qui prenait une <em>slice</em> de
<code>String</code> et qui cr√©ait une instance de la structure <code>Config</code> en utilisant les
indices de la <em>slice</em> et en clonant les valeurs, permettant ainsi √† la
structure <code>Config</code> de poss√©der ces valeurs. Dans l'encart 13-24, nous avons
reproduit l'impl√©mentation de la fonction <code>Config::new</code> telle qu'elle √©tait dans
l'encart 12-23 √† la fin du chapitre 12¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-24: Reproduction of the `Config::new` function
from Listing 12-23</span>
-->
<p><span class="caption">Encart 13-24¬†: reproduction de la fonction <code>Config::new</code>
de la fin du chapitre 12</span></p>
<!--
At the time, we said not to worry about the inefficient `clone` calls because
we would remove them in the future. Well, that time is now!
-->
<p>√Ä ce moment-l√†, nous avions dit de ne pas s'inqui√©ter des appels inefficaces √†
<code>clone</code> parce que nous les supprimerions √† l'avenir. Et bien, ce moment est
venu¬†!</p>
<!--
We needed `clone` here because we have a slice with `String` elements in the
parameter `args`, but the `new` function doesn‚Äôt own `args`. To return
ownership of a `Config` instance, we had to clone the values from the `query`
and `filename` fields of `Config` so the `Config` instance can own its values.
-->
<p>Nous avions besoin de <code>clone</code> ici parce que nous avons une slice d'√©l√©ments
<code>String</code> dans le param√®tre <code>args</code>, mais la fonction <code>new</code> ne poss√®de pas <code>args</code>.
Pour renvoyer la propri√©t√© d'une instance de <code>Config</code>, nous avons d√ª cloner les
valeurs des champs <code>recherche</code> et <code>nom_fichier</code> de <code>Config</code> afin que cette instance
de <code>Config</code> puisse prendre possession de ces valeurs.</p>
<!--
With our new knowledge about iterators, we can change the `new` function to
take ownership of an iterator as its argument instead of borrowing a slice.
We‚Äôll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
`Config::new` function is doing because the iterator will access the values.
-->
<p>Avec nos nouvelles connaissances sur les it√©rateurs, nous pouvons changer la
fonction <code>new</code> pour prendre possession d'un it√©rateur pass√© en argument au lieu
d'emprunter une <em>slice</em>. Nous utiliserons les fonctionnalit√©s des it√©rateurs √†
la place du code qui v√©rifie la taille de la slice et qui utilise les indices
des √©l√©ments pr√©cis. Cela clarifiera ce que la fonction <code>Config::new</code> fait car
c'est l'it√©rateur qui acc√©dera aux valeurs.</p>
<!--
Once `Config::new` takes ownership of the iterator and stops using indexing
operations that borrow, we can move the `String` values from the iterator into
`Config` rather than calling `clone` and making a new allocation.
-->
<p>Une fois que <code>Config::new</code> prend possession de l'it√©rateur et cesse d'utiliser
les op√©rations avec les indices et d'emprunter les donn√©es, nous pouvons
d√©placer les valeurs <code>String</code> de l'iterator dans <code>Config</code> plut√¥t que de faire
appel √† <code>clone</code> et de cr√©er par cons√©quent de nouvelles allocations.</p>
<!--
#### Using the Returned Iterator Directly
-->
<h4 id="utiliser-directement-lit√©rateur-retourn√©"><a class="header" href="#utiliser-directement-lit√©rateur-retourn√©">Utiliser directement l'it√©rateur retourn√©</a></h4>
<!--
Open your I/O project‚Äôs *src/main.rs* file, which should look like this:
-->
<p>Ouvrez le fichier <em>src/main.rs</em> de votre projet d'entr√©e/sortie, qui devrait
ressembler √† ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Probl√®me rencontr√© lors de l'interpr√©tation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masqu√©e ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
We‚Äôll change the start of the `main` function that we had in Listing 12-24 to
the code in Listing 13-25. This won‚Äôt compile until we update `Config::new` as
well.
-->
<p>Nous allons changer le d√©but de la fonction <code>main</code> que nous avions dans l'encart
12-24 pour le code dans l'encart 13-25. Ceci ne compilera pas encore jusqu'√† ce
que nous mettions √©galement √† jour <code>Config::new</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("Probl√®me rencontr√© lors de l'interpr√©tation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masqu√©e ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Probl√®me rencontr√© lors de l'interpr√©tation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 13-25: Passing the return value of `env::args` to
`Config::new`</span>
-->
<p><span class="caption">Encart 13-25¬†: on passe directement la valeur de retour de
<code>env::args</code> √† <code>Config::new</code>.</span></p>
<!--
The `env::args` function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to `Config::new`, now
we‚Äôre passing ownership of the iterator returned from `env::args` to
`Config::new` directly.
-->
<p>La fonction <code>env::args</code> retourne un it√©rateur¬†! Plut√¥t que de collecter les
valeurs de l'it√©rateur dans un vecteur et de passer ensuite une <em>slice</em> √†
<code>Config::new</code>, nous passons maintenant la possession de l'it√©rateur de
<code>env::args</code> directement √† <code>Config::new</code>.</p>
<!--
Next, we need to update the definition of `Config::new`. In your I/O project‚Äôs
*src/lib.rs* file, let‚Äôs change the signature of `Config::new` to look like
Listing 13-26. This still won‚Äôt compile because we need to update the function
body.
-->
<p>Ensuite, nous devons mettre √† jour la d√©finition de <code>Config::new</code>. Dans le
fichier <em>src/lib.rs</em> de votre projet d'entr√©e/sortie, modifions la signature de
<code>Config::new</code> pour qu'elle ressemble √† l'encart 13-26. Ceci ne compilera pas
encore car nous devons mettre √† jour le corps de la fonction.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        // -- partie masqu√©e ici --
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masqu√©e ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-26: Updating the signature of `Config::new` to
expect an iterator</span>
-->
<p><span class="caption">Encart 13-26¬†: mise √† jour de la signature de
<code>Config::new</code> pour recevoir un it√©rateur</span></p>
<!--
The standard library documentation for the `env::args` function shows that the
type of the iterator it returns is `std::env::Args`. We‚Äôve updated the
signature of the `Config::new` function so the parameter `args` has the type
`std::env::Args` instead of `&[String]`. Because we‚Äôre taking ownership of
`args` and we‚Äôll be mutating `args` by iterating over it, we can add the `mut`
keyword into the specification of the `args` parameter to make it mutable.
-->
<p>La documentation de la biblioth√®que standard de la fonction <code>env::args</code>
indique que le type de l'it√©rateur qu'elle renvoie est <code>std::env::Args</code>. Nous
avons mis √† jour la signature de la fonction <code>Config::new</code> pour que le
param√®tre <code>args</code> ait le type <code>std::env::Args</code> au lieu de <code>&amp;[String]</code>. Etant
donn√© que nous prenons possession de <code>args</code> et que nous allons muter <code>args</code>
en it√©rant dessus, nous pouvons ajouter le mot-cl√© <code>mut</code> dans la sp√©cification
du param√®tre <code>args</code> pour le rendre mutable.</p>
<!--
#### Using `Iterator` Trait Methods Instead of Indexing
-->
<h4 id="utilisation-des-m√©thodes-du-trait-iterator-au-lieu-des-indices"><a class="header" href="#utilisation-des-m√©thodes-du-trait-iterator-au-lieu-des-indices">Utilisation des m√©thodes du trait <code>Iterator</code> au lieu des indices</a></h4>
<!--
Next, we‚Äôll fix the body of `Config::new`. The standard library documentation
also mentions that `std::env::Args` implements the `Iterator` trait, so we know
we can call the `next` method on it! Listing 13-27 updates the code from
Listing 12-23 to use the `next` method:
-->
<p>Corrigeons ensuite le corps de <code>Config::new</code>. La documentation de la biblioth√®que
standard explique aussi que <code>std::env::Args</code> impl√©mente le trait <code>Iterator</code>, donc
nous savons que nous pouvons appeler la m√©thode <code>next</code> dessus¬†! L'encart 13-27
met √† jour le code de l'encart 12-23 afin d'utiliser la m√©thode <code>next</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        args.next();

        let recherche = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de cha√Æne de caract√®res"),
        };

        let nom_fichier = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de nom de fichier"),
        };

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let recherche = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de cha√Æne de caract√®res&quot;),
        };

        let nom_fichier = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
        };

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-27: Changing the body of `Config::new` to use
iterator methods</span>
-->
<p><span class="caption">Encart 13-27¬†: changement du corps de <code>Config::new</code> afin
d'utiliser les m√©thodes d'it√©ration</span></p>
<!--
Remember that the first value in the return value of `env::args` is the name of
the program. We want to ignore that and get to the next value, so first we call
`next` and do nothing with the return value. Second, we call `next` to get the
value we want to put in the `query` field of `Config`. If `next` returns a
`Some`, we use a `match` to extract the value. If it returns `None`, it means
not enough arguments were given and we return early with an `Err` value. We do
the same thing for the `filename` value.
-->
<p>Rappelez-vous que la premi√®re valeur de ce qui est retourn√© par <code>env::args</code> est
le nom du programme. Nous voulons ignorer cette valeur et passer √† la suivante,
donc d'abord nous appelons une fois <code>next</code> et nous ne faisons rien avec sa
valeur de retour. Ensuite, nous appelons <code>next</code> pour obtenir la valeur que nous
voulons mettre dans le champ <code>recherche</code> de <code>Config</code>. Si <code>next</code> renvoie un
<code>Some</code>, nous utilisons un <code>match</code> pour extraire sa valeur. S'il retourne <code>None</code>,
cela signifie que pas assez d'arguments ont √©t√© fournis, si bien que nous quittons
aussit√¥t la fonction en retournant une valeur <code>Err</code>. Nous proc√©dons de m√™me
pour la valeur <code>nom_fichier</code>.</p>
<!--
### Making Code Clearer with Iterator Adaptors
-->
<h3 id="rendre-le-code-plus-clair-avec-des-adaptateurs-dit√©ration"><a class="header" href="#rendre-le-code-plus-clair-avec-des-adaptateurs-dit√©ration">Rendre le code plus clair avec des adaptateurs d'it√©ration</a></h3>
<!--
We can also take advantage of iterators in the `search` function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:
-->
<p>Nous pouvons √©galement tirer parti des it√©rateurs dans la fonction <code>rechercher</code>
de notre projet d'entr√©e/sortie, qui est reproduite ici dans l'encart 13-28,
telles qu'elle √©tait dans l'encart 12-19 √† la fin du chapitre 12¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_resultat() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# s√©curit√©, rapidit√©, productivit√©.
# Obtenez les trois en m√™me temps.";
# 
#         assert_eq!(vec!["s√©curit√©, rapidit√©, productivit√©."], rechercher(recherche, contenu));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-28: The implementation of the `search`
function from Listing 12-19</span>
-->
<p><span class="caption">Encart 13-28¬†: La mise en oeuvre de la fonction
<code>rechercher</code> de l'encart 12-19</span></p>
<!--
We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate `results` vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn‚Äôt have to manage
concurrent access to the `results` vector. Listing 13-29 shows this change:
-->
<p>Nous pouvons √©crire ce code de fa√ßon plus concise en utilisant des m√©thodes
des adaptateurs d'it√©ration. Ce faisant, nous √©vitons ainsi d'avoir le vecteur
mutable¬†<code>resultats</code>. Le style de programmation fonctionnelle pr√©f√®re minimiser
la quantit√© d'√©tats modifiables pour rendre le code plus clair. Supprimer l'√©tat
mutable pourrait nous aider √† faire une am√©lioration future afin que la recherche
se fasse en parall√®le, car nous n'aurions pas √† g√©rer l'acc√®s concurrent au
vecteur <code>resultats</code>. L'encart 13-29 montre ce changement¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
#         args.next();
# 
#         let recherche = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de cha√Æne de caract√®res"),
#         };
# 
#         let nom_fichier = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de nom de fichier"),
#         };
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let recherche = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de cha√Æne de caract√®res&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let nom_fichier = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the `search` function</span>
-->
<p><span class="caption">Encart 13-29¬†: utilisation des m√©thodes des adaptateurs
d'it√©ration dans l'impl√©mentation de la fonction <code>rechercher</code></span></p>
<!--
Recall that the purpose of the `search` function is to return all lines in
`contents` that contain the `query`. Similar to the `filter` example in Listing
13-19, this code uses the `filter` adaptor to keep only the lines that
`line.contains(query)` returns `true` for. We then collect the matching lines
into another vector with `collect`. Much simpler! Feel free to make the same
change to use iterator methods in the `search_case_insensitive` function as
well.
-->
<p>Souvenez-vous que le but de la fonction <code>rechercher</code> est de renvoyer toutes
les lignes dans <code>contenu</code> qui contiennent <code>recherche</code>. Comme dans l'exemple de
<code>filter</code> dans l'encart 13-19, nous pouvons utiliser l'adaptateur <code>filter</code>
pour garder uniquement les lignes pour lesquelles <code>ligne.contains(recherche)</code>
renvoie <code>true</code>. Nous collectons ensuite les lignes correspondantes dans un
autre vecteur avec <code>collect</code>. C'est bien plus simple¬†! N'h√©sitez pas √† faire
le m√™me changement pour utiliser les m√©thodes d'it√©ration dans la fonction
<code>rechercher_insensible_casse</code>.</p>
<!--
The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It‚Äôs a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it‚Äôs easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.
-->
<p>Logiquement la question suivante est de savoir quel style utiliser dans votre
propre code et pourquoi¬†: l'impl√©mentation originale de l'encart 13-28 ou la
version utilisant l'it√©rateur dans l'encart 13-29. La plupart des d√©veloppeurs
Rust pr√©f√®rent utiliser le style avec l'it√©rateur. C'est un peu plus difficile
√† comprendre au d√©but, mais une fois que vous avez compris les diff√©rents
adaptateurs d'it√©ration et ce qu'ils font, les it√©rateurs peuvent devenir
plus faciles √† comprendre. Au lieu de jongler avec diff√©rentes boucles et de
construire de nouveaux vecteurs, ce code se concentre sur l'objectif de haut
niveau de la boucle. Cette abstraction permet d'√©liminer une partie du code
trivial, de sorte qu'il soit plus facile de d√©gager les concepts propres √† ce
code, comme le filtrage de chaque √©l√©ment de l'it√©rateur qui est appliqu√©.</p>
<!--
But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let‚Äôs talk about
performance.
-->
<p>Mais ces deux impl√©mentations sont-elles r√©ellement √©quivalentes¬†? L'hypoth√®se
intuitive pourrait √™tre que la boucle de plus bas niveau sera plus rapide.
Int√©ressons nous donc maintenant √† leurs performances.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Comparing Performance: Loops vs. Iterators
-->
<h2 id="comparaison-des-performances--les-boucles-et-les-it√©rateurs"><a class="header" href="#comparaison-des-performances--les-boucles-et-les-it√©rateurs">Comparaison des performances¬†: les boucles et les it√©rateurs</a></h2>
<!--
To determine whether to use loops or iterators, you need to know which
implementation is faster: the version of the `search` function with an explicit
`for` loop or the version with iterators.
-->
<p>Pour d√©terminer s'il faut utiliser des boucles ou des it√©rateurs, nous devons
savoir quelle impl√©mentation est la plus rapide¬†: la version de la fonction
<code>rechercher</code> avec une boucle <code>for</code> explicite, ou la version avec des
it√©rateurs.</p>
<!--
We ran a benchmark by loading the entire contents of *The Adventures of
Sherlock Holmes* by Sir Arthur Conan Doyle into a `String` and looking for the
word *the* in the contents. Here are the results of the benchmark on the
version of `search` using the `for` loop and the version using iterators:
-->
<p>Nous avons lanc√© un benchmark en chargeant tout le contenu de <em>The Adventures
of Sherlock Holmes</em> de Sir Arthur Conan Doyle dans une <code>String</code> et en cherchant
le mot &quot;the&quot; dans le contenu. Voici les r√©sultats du benchmark sur la version
de <code>rechercher</code> avec une boucle <code>for</code> et avec un it√©rateur¬†:</p>
<!--
```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```
-->
<pre><code class="language-text">test benchmark_rechercher_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test benchmark_rechercher_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<!--
The iterator version was slightly faster! We won‚Äôt explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.
-->
<p>La version avec l'it√©rateur √©tait un peu plus rapide¬†! Nous n'expliquerons pas
le code du benchmark ici, car il ne s'agit pas de prouver que les deux versions
sont √©quivalentes, mais d'avoir une id√©e g√©n√©rale de la diff√©rence de
performances entre les deux.</p>
<!--
For a more comprehensive benchmark, you should check using various texts of
various sizes as the `contents`, different words and words of different lengths
as the `query`, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you‚Äôd written the lower-level code yourself. Iterators are one
of Rust‚Äôs *zero-cost abstractions*, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
*zero-overhead* in ‚ÄúFoundations of C++‚Äù (2012):
-->
<p>Pour un benchmark plus complet, nous vous conseillons d'utiliser des textes de
diff√©rentes tailles pour <code>contenu</code>, des mots diff√©rents et de diff√©rentes
longueurs pour <code>recherche</code>, ainsi que tout autre type de variation que vous
pourriez trouver. Le point important est le suivant¬†: les it√©rateurs, bien qu'il
s'agisse d'une abstraction de haut niveau, sont compil√©s √† peu pr√®s comme si
vous aviez √©crit vous-m√™me le code un niveau plus bas. Les it√©rateurs sont l'une
des abstractions √† <em>co√ªt z√©ro</em> de Rust, c'est-√†-dire que l'utilisation de
l'abstraction n'impose aucun surco√ªt lors de l'ex√©cution. C'est la m√™me notion
que celle que Bjarne Stroustrup, le concepteur et d√©veloppeur original de C++,
d√©finit en tant que <em>co√ªt z√©ro</em> dans ‚ÄúFoundations of C++‚Äù (2012)¬†:</p>
<!--
> In general, C++ implementations obey the zero-overhead principle: What you
> don‚Äôt use, you don‚Äôt pay for. And further: What you do use, you couldn‚Äôt hand
> code any better.
-->
<blockquote>
<p>En g√©n√©ral, les impl√©mentations de C++ ob√©issent au principe du co√ªt z√©ro¬†:
ce que vous n'utilisez pas, vous ne le payez pas. Et plus encore¬†: ce que
vous utilisez, vous ne pourrez pas le coder mieux √† la main.</p>
</blockquote>
<!--
As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
`buffer` slice of data, an array of 12 `coefficients`, and an amount by which
to shift data in `qlp_shift`. We‚Äôve declared the variables within this example
but not given them any values; although this code doesn‚Äôt have much meaning
outside of its context, it‚Äôs still a concise, real-world example of how Rust
translates high-level ideas to low-level code.
-->
<p>Comme autre exemple, le code suivant est tir√© d'un d√©codeur audio. L'algorithme
de d√©codage utilise l'op√©ration math√©matique de pr√©diction lin√©aire pour
estimer les valeurs futures √† partir d'une fonction lin√©aire des √©chantillons
pr√©c√©dents. Ce code utilise une cha√Æne d'it√©rateurs pour faire quelques calculs
sur trois variables dans la port√©e¬†: une slice de donn√©es <code>tampon</code>, un tableau
de 12 <code>coefficients</code> et une valeur de d√©calage des donn√©es dans <code>decalage</code>.
Nous avons d√©clar√© les variables dans cet exemple, mais nous ne leur avons pas
donn√© de valeurs¬†; bien que ce code n'ait pas beaucoup de signification en
dehors de son contexte, c'est toutefois un exemple concis et concret de la fa√ßon
dont Rust traduit des id√©es de haut niveau en code de plus bas niveau.</p>
<!--
```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```
-->
<pre><code class="language-rust ignore">let tampon: &amp;mut [i32];
let coefficients: [i64; 12];
let decalage: i16;

for i in 12..tampon.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;tampon[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; decalage;
    let delta = tampon[i];
    tampon[i] = prediction as i32 + delta;
}
</code></pre>
<!--
To calculate the value of `prediction`, this code iterates through each of the
12 values in `coefficients` and uses the `zip` method to pair the coefficient
values with the previous 12 values in `buffer`. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum `qlp_shift` bits to the right.
-->
<p>Pour calculer la valeur de <code>prediction</code>, ce code it√®re sur chacune des 12
valeurs dans <code>coefficients</code> et utilise la m√©thode <code>zip</code> pour appairer la
valeur de coefficient avec les 12 valeurs pr√©c√©dentes, pr√©sentes dans <code>tampon</code>.
Ensuite, pour chaque paire, nous multiplions les valeurs ensemble, nous
additionnons tous les r√©sultats et nous d√©calons les bits de l'addition de la
valeur de <code>decalage</code> vers la droite.</p>
<!--
Calculations in applications like audio decoders often prioritize performance
most highly. Here, we‚Äôre creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you‚Äôd write by hand.
There‚Äôs no loop at all corresponding to the iteration over the values in
`coefficients`: Rust knows that there are 12 iterations, so it ‚Äúunrolls‚Äù the
loop. *Unrolling* is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.
-->
<p>Les calculs dans des applications comme les d√©codeurs audio donnent souvent la
priorit√© aux performances. Ici, nous cr√©ons un it√©rateur √† l'aide de deux
adaptateurs, puis nous en consommons la valeur. A quel code d'assemblage
ce code Rust ressemblera-t-il une fois compil√©¬†? Et bien, √† l'heure
o√π nous √©crivons ces lignes, il donne le m√™me code assembleur que vous
√©cririez √† la main. Il n'y a pas du tout de boucle correspondant √† l'it√©ration
sur les valeurs dans <code>coefficients</code>¬†: Rust sait qu'il y a 12 it√©rations, donc il
‚Äúd√©roule‚Äù la boucle. Le <em>d√©roulage</em> est une optimisation qui supprime la
surcharge du code de contr√¥le de boucle et g√©n√®re √† la place du code r√©p√©t√© pour
chaque it√©ration de la boucle.</p>
<!--
All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like it‚Äôs higher level but don‚Äôt impose a
runtime performance penalty for doing so.
-->
<p>Tous les coefficients sont stock√©s dans des registres, ce qui signifie qu'il
est tr√®s rapide d'acc√©der √† ces valeurs. Il n'y a pas de v√©rification des bornes
sur les acc√®s au tableau √† l'ex√©cution. Toutes ces optimisations que Rust est
capable d'appliquer rendent le code produit extr√™mement efficace. Maintenant
que vous savez cela, vous pouvez utiliser des it√©rateurs et des fermetures
sans crainte ! Ils font en sorte que le code soit de haut niveau, mais n'entra√Ænent
pas de p√©nalit√© de performance √† l'ex√©cution.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-12"><a class="header" href="#r√©sum√©-12">R√©sum√©</a></h2>
<!--
Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust‚Äôs capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust‚Äôs goal to strive to provide zero-cost abstractions.
-->
<p>Les fermetures et les it√©rateurs sont des fonctionnalit√©s de Rust inspir√©es par
des id√©es des langages de programmation fonctionnels. Ils contribuent √† la
capacit√© de Rust d'exprimer clairement des id√©es de haut niveau avec des
performances dignes d'un langage de bas niveau. Les impl√©mentations des
fermetures et des it√©rateurs sont telles que les performances √† l'ex√©cution n'en
sont pas affect√©es. Cela fait partie de l'objectif de Rust de s'efforcer √†
fournir des abstractions √† co√ªt z√©ro.</p>
<!--
Now that we‚Äôve improved the expressiveness of our I/O project, let‚Äôs look at
some more features of `cargo` that will help us share the project with the
world.
-->
<p>Maintenant que nous avons am√©lior√© l'expressivit√© de notre projet
d'entr√©e/sortie, regardons d'autres fonctionnalit√©s fournies par <code>cargo</code> qui
nous aideront √† partager notre projet avec le monde entier.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# More About Cargo and Crates.io
-->
<h1 id="en-savoir-plus-sur-cargo-et-cratesio"><a class="header" href="#en-savoir-plus-sur-cargo-et-cratesio">En savoir plus sur cargo et crates.io</a></h1>
<!--
So far we‚Äôve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. In this chapter, we‚Äôll discuss some of its
other, more advanced features to show you how to do the following:
-->
<p>Pr√©c√©demment, nous avons utilis√© les fonctionnalit√©s les plus basiques de cargo
pour compiler, ex√©cuter et tester notre code, mais il peut faire bien plus.
Dans ce chapitre, nous allons voir d'autres fonctionnalit√©s avanc√©es pour vous
apprendre √† faire ceci¬†:</p>
<!--
* Customize your build through release profiles
* Publish libraries on [crates.io](https://crates.io/)<!-- ignore -- >
* Organize large projects with workspaces
* Install binaries from [crates.io](https://crates.io/)<!-- ignore -- >
* Extend Cargo using custom commands
-->
<ul>
<li>Personnaliser votre compilation gr√¢ce aux profils de publication</li>
<li>Publier des biblioth√®ques sur <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organiser des gros projets avec les espaces de travail</li>
<li>Installer des binaires √† partir de
<a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Am√©liorer cargo en utilisant des commandes personnalis√©es</li>
</ul>
<!--
Cargo can do even more than what we cover in this chapter, so for a full
explanation of all its features, see [its
documentation](https://doc.rust-lang.org/cargo/).
-->
<p>Cargo peut faire encore plus de choses que ce que nous allons voir dans ce
chapitre, donc pour une explication plus compl√®te vous avez √† votre disposition
<a href="https://doc.rust-lang.org/cargo/">sa documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Customizing Builds with Release Profiles
-->
<h2 id="personnaliser-les-compilations-avec-les-profils-de-publication"><a class="header" href="#personnaliser-les-compilations-avec-les-profils-de-publication">Personnaliser les compilations avec les profils de publication</a></h2>
<!--
In Rust, *release profiles* are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.
-->
<p>Dans Rust, les <em>profils de publication</em> sont des profils pr√©d√©finis et
personnalisables avec diff√©rentes configurations qui permettent au d√©veloppeur
d'avoir plus de contr√¥le sur diff√©rentes options de compilation du code. Chaque
profil est configur√© ind√©pendamment des autres.</p>
<!--
Cargo has two main profiles: the `dev` profile Cargo uses when you run `cargo
build` and the `release` profile Cargo uses when you run `cargo build
--release`. The `dev` profile is defined with good defaults for development,
and the `release` profile has good defaults for release builds.
-->
<p>Cargo a deux profils principaux¬†: le profil <code>dev</code> que cargo utilise lorsque vous
lancez <code>cargo build</code> et le profil <code>release</code> (NdT¬†: publication) que cargo
utilise lorsque vous lancez <code>cargo build --release</code>. Le profil <code>dev</code> est d√©fini
avec de bons r√©glages par d√©faut pour le d√©veloppement, et le profil <code>release</code> a
de bons r√©glages par d√©faut de compilation pour la publication.</p>
<!--
These profile names might be familiar from the output of your builds:
-->
<p>Ces noms de profils vous rappellent peut-√™tre quelque chose sur la sortie
standard de vos compilations¬†:</p>
<!--
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-- >
-->
<!--
```console
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
```
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<!--
The `dev` and `release` shown in this build output indicate that the compiler
is using different profiles.
-->
<p>Les profils <code>dev</code> et <code>release</code> sont mentionn√©s dans cette sortie de compilation,
pour indiquer les diff√©rents profils qu'utilise le compilateur.</p>
<!--
Cargo has default settings for each of the profiles that apply when there
aren‚Äôt any `[profile.*]` sections in the project‚Äôs *Cargo.toml* file. By adding
`[profile.*]` sections for any profile you want to customize, you can override
any subset of the default settings. For example, here are the default values
for the `opt-level` setting for the `dev` and `release` profiles:
-->
<p>Cargo a des r√©glages par d√©faut pour chacun des profils qui s'appliquent
lorsqu'il n'y a pas de section <code>[profile.*]</code> dans le fichier <em>Cargo.toml</em> du
projet. En ajoutant les sections <code>[profile.*]</code> pour chaque profil que vous
souhaitez personnaliser, vous pouvez remplacer n'importe quel param√®tre par
d√©faut. Par exemple, voici les valeurs par d√©faut pour le param√®tre <code>opt-level</code>
des profils <code>dev</code> et <code>release</code>¬†:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```
-->
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<!--
The `opt-level` setting controls the number of optimizations Rust will apply to
your code, with a range of 0 to 3. Applying more optimizations extends
compiling time, so if you‚Äôre in development and compiling your code often,
you‚Äôll want faster compiling even if the resulting code runs slower. That is
the reason the default `opt-level` for `dev` is `0`. When you‚Äôre ready to
release your code, it‚Äôs best to spend more time compiling. You‚Äôll only compile
in release mode once, but you‚Äôll run the compiled program many times, so
release mode trades longer compile time for code that runs faster. That is why
the default `opt-level` for the `release` profile is `3`.
-->
<p>Le param√®tre <code>opt-level</code> contr√¥le le nombre d'optimisations que Rust va
appliquer √† votre code, sur une √©chelle allant de 0 √† 3. L'application d'un
niveau plus haut d'optimisation signifie un allongement de la dur√©e de
compilation, donc si vous √™tes en train de d√©velopper et que vous compilez
souvent votre code, vous pr√©f√©rerez certainement avoir une compilation rapide
m√™me si le code qui en r√©sulte s'ex√©cute plus lentement. C'est la raison pour
laquelle la valeur par d√©faut de <code>opt-level</code> pour <code>dev</code> est √† <code>0</code>. Lorsque vous
serez pr√™t √† publier votre code, il sera pr√©f√©rable de passer un peu plus de
temps √† le compiler. Vous ne compilerez en mode publication (NdT¬†: release)
qu'une seule fois, mais vous ex√©cuterez le programme compil√© plusieurs fois,
donc le mode publication opte pour un temps de compilation plus long afin que le
code s'ex√©cute plus rapidement. C'est pourquoi le param√®tre <code>opt-level</code> par
d√©faut pour le profil <code>release</code> est √† <code>3</code>.</p>
<!--
You can override any default setting by adding a different value for it in
*Cargo.toml*. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our project‚Äôs *Cargo.toml*
file:
-->
<p>Vous pouvez remplacer n'importe quel param√®tre par d√©faut en ajoutant une valeur
diff√©rente dans <em>Cargo.toml</em>. Par exemple, si nous voulons utiliser le niveau 1
d'optimisation dans le profil de d√©veloppement, nous pouvons ajouter ces deux
lignes √† notre fichier <em>Cargo.toml</em>¬†:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[profile.dev]
opt-level = 1
```
-->
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<!--
This code overrides the default setting of `0`. Now when we run `cargo build`,
Cargo will use the defaults for the `dev` profile plus our customization to
`opt-level`. Because we set `opt-level` to `1`, Cargo will apply more
optimizations than the default, but not as many as in a release build.
-->
<p>Ce code remplace le param√®tre par d√©faut √† <code>0</code>. Maintenant, lorsque nous lan√ßons
<code>cargo build</code>, cargo va utiliser les r√©glages par d√©faut du profil <code>dev</code> ainsi
que notre valeur personnalis√©e de <code>opt-level</code>. Comme nous avons r√©gl√©
<code>opt-level</code> √† <code>1</code>, Cargo va appliquer plus d'optimisation que par d√©faut, mais
pas autant que dans une compilation de publication.</p>
<!--
For the full list of configuration options and defaults for each profile, see
[Cargo‚Äôs documentation](https://doc.rust-lang.org/cargo/reference/profiles.html).
-->
<p>Pour la liste compl√®te des options de configuration et leurs valeurs par d√©faut
pour chaque profil, r√©f√©rez-vous √† la
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">documentation de cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Publishing a Crate to Crates.io
-->
<h2 id="publier-une-crate-sur-cratesio"><a class="header" href="#publier-une-crate-sur-cratesio">Publier une crate sur crates.io</a></h2>
<!--
We‚Äôve used packages from [crates.io](https://crates.io/)<!-- ignore -- > as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
[crates.io](https://crates.io/)<!-- ignore -- > distributes the source code of
your packages, so it primarily hosts code that is open source.
-->
<p>Nous avons d√©j√† utilis√© des paquets provenant de
<a href="https://crates.io/">crates.io</a><!-- ignore --> comme d√©pendance de notre projet,
mais vous pouvez aussi partager votre code avec d'autres personnes en publiant
vos propres paquets. Le registre des crates disponible sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> distribue le code source de vos
paquets, donc il h√©berge principalement du code qui est open source.</p>
<!--
Rust and Cargo have features that help make your published package easier for
people to use and to find in the first place. We‚Äôll talk about some of these
features next and then explain how to publish a package.
-->
<p>Rust et cargo ont des fonctionnalit√©s qui aident les d√©veloppeurs √† trouver et
utiliser les paquets que vous publiez. Nous allons voir certaines de ces
fonctionnalit√©s puis nous allons expliquer comment publier un paquet.</p>
<!--
### Making Useful Documentation Comments
-->
<h3 id="cr√©er-des-commentaires-de-documentation-utiles"><a class="header" href="#cr√©er-des-commentaires-de-documentation-utiles">Cr√©er des commentaires de documentation utiles</a></h3>
<!--
Accurately documenting your packages will help other users know how and when to
use them, so it‚Äôs worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, `//`. Rust also has
a particular kind of comment for documentation, known conveniently as a
*documentation comment*, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to *use* your crate as opposed to how
your crate is *implemented*.
-->
<p>Documenter correctement vos paquets aidera les autres utilisateurs √† savoir
comment et quand les utiliser, donc √ßa vaut la peine de consacrer du temps √† la
r√©daction de la documentation. Dans le chapitre 3, nous avons vu comment
commenter du code Rust en utilisant deux barres obliques <code>//</code>. Rust a aussi un
type particulier de commentaire pour la documentation, aussi connu sous le nom
de <em>commentaire de documentation</em>, qui va g√©n√©rer de la documentation en HTML.
Le HTML affiche le contenu des commentaires de documentation pour les √©l√©ments
public de votre API √† destination des d√©veloppeurs qui s'int√©ressent √† la
mani√®re <em>d'utiliser</em> votre crate et non pas √† la mani√®re dont elle est
<em>impl√©ment√©e</em>.</p>
<!--
Documentation comments use three slashes, `///`, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they‚Äôre documenting. Listing 14-1 shows documentation comments
for an `add_one` function in a crate named `my_crate`.
-->
<p>Les commentaires de documentation utilisent trois barres obliques <code>///</code> au lieu
de deux et prend en charge la notation Markdown pour mettre en forme le texte.
Placez les commentaires de documentation juste avant l'√©l√©ment qu'ils
documentent. L'encart 14-1 montre des commentaires de documentation pour une
fonction <code>ajouter_un</code> dans une crate nomm√©e <code>ma_crate</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><code class="language-rust ignore">/// Ajoute 1 au nombre donn√©.
///
/// # Exemples
///
/// ```
/// let argument = 5;
/// let reponse = ma_crate::ajouter_un(argument);
///
/// assert_eq!(6, reponse);
/// ```
pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<!--
<span class="caption">Listing 14-1: A documentation comment for a
function</span>
-->
<p><span class="caption">Encart 14-1¬†: un commentaire de documentation pour une
fonction</span></p>
<!--
Here, we give a description of what the `add_one` function does, start a
section with the heading `Examples`, and then provide code that demonstrates
how to use the `add_one` function. We can generate the HTML documentation from
this documentation comment by running `cargo doc`. This command runs the
`rustdoc` tool distributed with Rust and puts the generated HTML documentation
in the *target/doc* directory.
-->
<p>Ici nous avons √©crit une description de ce que fait la fonction <code>ajouter_un</code>,
d√©but√© une section avec le titre <code>Exemples</code> puis fourni du code qui
montre comment utiliser la fonction <code>ajouter_un</code>. Nous pouvons g√©n√©rer la
documentation HTML √† partir de ces commentaires de documentation en lan√ßant
<code>cargo doc</code>. Cette commande lance l'outil <code>rustdoc</code> qui est distribu√© avec Rust
et place la documentation HTML g√©n√©r√©e dans le dossier <em>target/doc</em>.</p>
<!--
For convenience, running `cargo doc --open` will build the HTML for your
current crate‚Äôs documentation (as well as the documentation for all of your
crate‚Äôs dependencies) and open the result in a web browser. Navigate to the
`add_one` function and you‚Äôll see how the text in the documentation comments is
rendered, as shown in Figure 14-1:
-->
<p>Pour plus de facilit√©, lancer <code>cargo doc --open</code> va g√©n√©rer le HTML pour la
documentation de votre crate courante (ainsi que la documentation pour toutes
les d√©pendances de la crate) et ouvrir le r√©sultat dans un navigateur web.
Rendez-vous √† la fonction <code>ajouter_one</code> et vous d√©couvrirez comment le texte
dans les commentaires de la documentation a √©t√© interpr√©t√©, ce qui devrait
ressembler √† l'illustration 14-1¬†:</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Documentation HTML g√©n√©r√©e pour la fonction `ajouter_un` de `ma_crate`"
    src="img/trpl14-01.png"
    class="center" /></p>
<!--
<span class="caption">Figure 14-1: HTML documentation for the `add_one`
function</span>
-->
<p><span class="caption">Illustration 14-1¬†: documentation HTML pour la fonction
<code>ajouter_un</code></span></p>
<!--
#### Commonly Used Sections
-->
<h4 id="les-sections-utilis√©es-fr√©quemment"><a class="header" href="#les-sections-utilis√©es-fr√©quemment">Les sections utilis√©es fr√©quemment</a></h4>
<!--
We used the `# Examples` Markdown heading in Listing 14-1 to create a section
in the HTML with the title ‚ÄúExamples.‚Äù Here are some other sections that crate
authors commonly use in their documentation:
-->
<p>Nous avons utilis√© le titre en Markdown <code># Exemples</code> dans l'encart 14-1 afin de
cr√©er une section dans le HTML avec le titre ‚ÄúExemples‚Äù. Voici d'autres sections
que les auteurs de crate utilisent fr√©quemment dans leur documentation¬†:</p>
<!--
* **Panics**: The scenarios in which the function being documented could
  panic. Callers of the function who don‚Äôt want their programs to panic should
  make sure they don‚Äôt call the function in these situations.
* **Errors**: If the function returns a `Result`, describing the kinds of
  errors that might occur and what conditions might cause those errors to be
  returned can be helpful to callers so they can write code to handle the
  different kinds of errors in different ways.
* **Safety**: If the function is `unsafe` to call (we discuss unsafety in
  Chapter 19), there should be a section explaining why the function is unsafe
  and covering the invariants that the function expects callers to uphold.
-->
<ul>
<li><strong>Panics</strong>¬†: les sc√©narios dans lesquels la fonction qui est document√©e peut paniquer.
Ceux qui utilisent la fonction et qui ne veulent pas que leur programme
panique doivent s'assurer qu'ils n'appellent pas la fonction dans ce genre de
situation.</li>
<li><strong>Errors</strong>¬†: si la fonction retourne un <code>Result</code>, documenter les types
d'erreurs qui peuvent survenir ainsi que les conditions qui m√®nent √† ces
erreurs sera tr√®s utile pour ceux qui utilisent votre API afin qu'ils
puissent √©crire du code pour g√©rer ces diff√©rents types d'erreurs de mani√®re √†
ce que cela leur convienne.</li>
<li><strong>Safety</strong>¬†: si la fonction fait un appel √† <code>unsafe</code> (que nous verrons au
chapitre 19), il devrait exister une section qui explique pourquoi la fonction
fait appel √† <em>unsafe</em> et quels sont les param√®tres que la fonction s'attend √†
recevoir des utilisateurs de l'API.</li>
</ul>
<!--
Most documentation comments don‚Äôt need all of these sections, but this is a
good checklist to remind you of the aspects of your code that people calling
your code will be interested in knowing about.
-->
<p>La plupart des commentaires sur la documentation n'ont pas besoin de ces
sections, mais c'est une bonne liste de v√©rifications √† avoir pour vous rappeler
les √©l√©ments importants √† signaler aux utilisateurs.</p>
<!--
#### Documentation Comments as Tests
-->
<h4 id="les-commentaires-de-documentation-pour-faire-des-tests"><a class="header" href="#les-commentaires-de-documentation-pour-faire-des-tests">Les commentaires de documentation pour faire des tests</a></h4>
<!--
Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running `cargo
test` will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don‚Äôt work because the code has changed since the documentation was
written. If we run `cargo test` with the documentation for the `add_one`
function from Listing 14-1, we will see a section in the test results like this:
-->
<p>L'ajout des blocs de code d'exemple dans vos commentaires de documentation
peut vous aider √† montrer comment utiliser votre biblioth√®que, et faire ceci
apporte un bonus suppl√©mentaire¬†: l'ex√©cution de <code>cargo test</code> va lancer les
codes d'exemples pr√©sents dans votre documentation comme √©tant des tests¬†! Il
n'y a rien de mieux que de la documentation avec des exemples. Mais il n'y a
rien de pire que des exemples qui ne fonctionnent plus car le code a chang√©
depuis que la documentation a √©t√© √©crite. Si nous lan√ßons <code>cargo test</code> avec la
documentation de la fonction <code>ajouter_un</code> de l'encart 14-1, nous verrons une
section dans les r√©sultats de tests comme celle-ci¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-- >
-->
<!--
```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
```
-->
<pre><code class="language-text">   Doc-tests ma_crate

running 1 test
test src/lib.rs - ajouter_un (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<!--
Now if we change either the function or the example so the `assert_eq!` in the
example panics and run `cargo test` again, we‚Äôll see that the doc tests catch
that the example and the code are out of sync with each other!
-->
<p>Maintenant, si nous changeons la fonction ou l'exemple de telle sorte que le
<code>assert_eq!</code> de l'exemple panique et que nous lan√ßons <code>cargo test</code> √†
nouveau, nous verrons que les tests de documentation vont d√©couvrir que
l'exemple et le code sont d√©synchronis√©s l'un de l'autre¬†!</p>
<!--
#### Commenting Contained Items
-->
<h4 id="commenter-l√©l√©ment-qui-contient-l√©l√©ment-courant"><a class="header" href="#commenter-l√©l√©ment-qui-contient-l√©l√©ment-courant">Commenter l'√©l√©ment qui contient l'√©l√©ment courant</a></h4>
<!--
Another style of doc comment, `//!`, adds documentation to the item that
contains the comments rather than adding documentation to the items following
the comments. We typically use these doc comments inside the crate root file
(*src/lib.rs* by convention) or inside a module to document the crate or the
module as a whole.
-->
<p>Un autre style de commentaire de documentation, <code>//!</code>, ajoute de la
documentation √† l'√©l√©ment qui contient ce commentaire plut√¥t que d'ajouter la
documentation √† l'√©l√©ment qui suit ce commentaire. Nous utilisons
habituellement ces commentaires de documentation dans le fichier de la crate
racine (qui est <em>src/lib.rs</em> par convention) ou √† l'int√©rieur d'un module afin
de documenter la crate ou le module dans son ensemble.</p>
<!--
For example, if we want to add documentation that describes the purpose of the
`my_crate` crate that contains the `add_one` function, we can add documentation
comments that start with `//!` to the beginning of the *src/lib.rs* file, as
shown in Listing 14-2:
-->
<p>Par exemple, si nous souhaitons ajouter de la documentation qui d√©crit le r√¥le
de la crate <code>ma_crate</code> qui contient la fonction <code>ajouter_un</code>, nous pouvons
ajouter des commentaires de documentation qui commencent par <code>//!</code> au d√©but du
fichier <em>src/lib.rs</em>, comme dans l'encart 14-2¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
# ///
# /// # Examples
# ///
# /// ```
# /// let arg = 5;
# /// let answer = my_crate::add_one(arg);
# ///
# /// assert_eq!(6, answer);
# /// ```
# pub fn add_one(x: i32) -> i32 {
#     x + 1
# }
```
-->
<pre><code class="language-rust ignore">//! # Ma crate
//!
//! `ma_crate` est un regroupement d'utilitaires pour rendre plus pratique
//! certains calculs.

/// Ajoute 1 au nombre donn√©.
// -- partie masqu√©e ici --
<span class="boring">///
</span><span class="boring">/// # Exemples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let argument = 5;
</span><span class="boring">/// let reponse = ma_crate::ajouter_un(argument);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, reponse);
</span><span class="boring">/// ```
</span><span class="boring">pub fn ajouter_un(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 14-2: Documentation for the `my_crate` crate as a
whole</span>
-->
<p><span class="caption">Encart 14-2¬†: documentation portant sur la crate
<code>ma_crate</code></span></p>
<!--
Notice there isn‚Äôt any code after the last line that begins with `//!`. Because
we started the comments with `//!` instead of `///`, we‚Äôre documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the *src/lib.rs* file, which
is the crate root. These comments describe the entire crate.
-->
<p>Remarquez qu'il n'y a pas de code apr√®s la derni√®re ligne qui commence par
<code>//!</code>. Comme nous commen√ßons les commentaires par <code>//!</code> au lieu de <code>///</code>, nous
documentons l'√©l√©ment qui contient ce commentaire plut√¥t que l'√©l√©ment qui suit
ce commentaire. Dans notre cas, l'√©l√©ment qui contient ce commentaire est le
fichier <em>src/lib.rs</em>, qui est la racine de la crate. Ces commentaires vont
d√©crire l'int√©gralit√© de la crate.</p>
<!--
When we run `cargo doc --open`, these comments will display on the front
page of the documentation for `my_crate` above the list of public items in the
crate, as shown in Figure 14-2:
-->
<p>Lorsque nous lan√ßons <code>cargo doc --open</code>, ces commentaires vont s'afficher sur la
page d'accueil de la documentation de <code>ma_crate</code>, au-dessus de la liste des
√©l√©ments publics de la crate, comme montr√© dans l'illustration 14-2¬†:</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Documentation HTML g√©n√©r√©e avec un commentaire pour toute la crate"
    src="img/trpl14-02.png"
    class="center" /></p>
<!--
<span class="caption">Figure 14-2: Rendered documentation for `my_crate`,
including the comment describing the crate as a whole</span>
-->
<p><span class="caption">Illustration 14-2¬†: Documentation g√©n√©r√©e pour <code>ma_crate</code>,
qui contient le commentaire qui d√©crit l'int√©gralit√© de la crate</span></p>
<!--
Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your users understand the crate‚Äôs organization.
-->
<p>Les commentaires de la documentation plac√©s √† l'int√©rieur des √©l√©ments sont
particuli√®rement utiles pour d√©crire les crates et les modules. Utilisez-les
pour expliquer globalement le r√¥le du conteneur pour aider vos utilisateurs √†
comprendre l'organisation de votre crate.</p>
<!--
### Exporting a Convenient Public API with `pub use`
-->
<h3 id="exporter-une-api-publique-conviviale-avec-pub-use"><a class="header" href="#exporter-une-api-publique-conviviale-avec-pub-use">Exporter une API publique conviviale avec <code>pub use</code></a></h3>
<!--
In Chapter 7, we covered how to organize our code into modules using the `mod`
keyword, how to make items public using the `pub` keyword, and how to bring
items into a scope with the `use` keyword. However, the structure that makes
sense to you while you‚Äôre developing a crate might not be very convenient for
your users. You might want to organize your structs in a hierarchy containing
multiple levels, but then people who want to use a type you‚Äôve defined deep in
the hierarchy might have trouble finding out that type exists. They might also
be annoyed at having to enter `use`
`my_crate::some_module::another_module::UsefulType;` rather than `use`
`my_crate::UsefulType;`.
-->
<p>Dans le chapitre 7, nous avons vu comment organiser notre code en modules en
utilisant le mot-cl√© <code>mod</code>, comment faire pour rendre des √©l√©ments publics en
utilisant le mot-cl√© <code>pub</code>, et comment importer des √©l√©ments dans la port√©e en
utilisant le mot-cl√© <code>use</code>. Cependant, la structure qui a un sens pour vous
pendant que vous d√©veloppez une crate peut ne pas √™tre pratique pour vos
utilisateurs. Vous pourriez vouloir organiser vos structures dans une hi√©rarchie
qui a plusieurs niveaux, mais les personnes qui veulent utiliser un type que
vous avez d√©fini dans un niveau profond de la hi√©rarchie pourraient rencontrer
des difficult√©s pour savoir que ce type existe. Ils peuvent aussi √™tre agac√©s
d'avoir √† √©crire <code>use ma_crate::un_module::un_autre_module::TypeUtile;</code> plut√¥t
que <code>use ma_crate::TypeUtile;</code>.</p>
<!--
The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.
-->
<p>La structure de votre API publique est une question importante lorsque vous
publiez une crate. Les personnes qui utilisent votre crate sont moins familiers
avec la structure que vous l'√™tes et pourraient avoir des difficult√©s √† trouver
les √©l√©ments qu'ils souhaitent utiliser si votre crate a une hi√©rarchie de
module imposante.</p>
<!--
The good news is that if the structure *isn‚Äôt* convenient for others to use
from another library, you don‚Äôt have to rearrange your internal organization:
instead, you can re-export items to make a public structure that‚Äôs different
from your private structure by using `pub use`. Re-exporting takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.
-->
<p>La bonne nouvelle est que si la structure <em>n'est pas</em> pratique pour ceux qui
l'utilisent dans une autre biblioth√®que, vous n'avez pas √† r√©organiser votre
organisation interne¬†: √† la place, vous pouvez r√©-exporter les √©l√©ments pour
cr√©er une structure publique qui est diff√©rente de votre structure priv√©e en
utilisant <code>pub use</code>. R√©-exporter prend un √©l√©ment public d'un endroit et le
rend public dans un autre endroit, comme s'il √©tait d√©fini dans l'autre endroit.</p>
<!--
For example, say we made a library named `art` for modeling artistic concepts.
Within this library are two modules: a `kinds` module containing two enums
named `PrimaryColor` and `SecondaryColor` and a `utils` module containing a
function named `mix`, as shown in Listing 14-3:
-->
<p>Par exemple, disons que nous avons cr√©√© une biblioth√®que <code>art</code> pour mod√©liser
des concepts artistiques. A l'int√©rieur de cette biblioth√®que nous avons deux
modules¬†: un module <code>types</code> qui contient deux √©num√©rations <code>CouleurPrimaire</code> et
<code>CouleurSecondaire</code>, et un module <code>utilitaires</code> qui contient une fonction
<code>mixer</code>, comme dans l'encart 14-3¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
#         unimplemented!();
    }
}
```
-->
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! Une biblioth√®que pour mod√©liser des concepts artistiques.

pub mod types {
    /// Les couleurs primaires du mod√®le RJB.
    pub enum CouleurPrimaire {
        Rouge,
        Jaune,
        Bleu,
    }

    /// Les couleurs secondaires du mod√®le RJB.
    pub enum CouleurSecondaire {
        Orange,
        Vert,
        Violet,
    }
}

pub mod utilitaires {
    use crate::types::*;

    /// Combine deux couleurs primaires dans les m√™mes quantit√©s pour
    /// cr√©er une couleur secondaire.
    pub fn mixer(c1: CouleurPrimaire, c2: CouleurPrimaire) -&gt; CouleurSecondaire {
        // -- partie masqu√©e ici --
<span class="boring">        unimplemented!();
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 14-3: An `art` library with items organized into
`kinds` and `utils` modules</span>
-->
<p><span class="caption">Encart 14-3¬†: une biblioth√®que <code>art</code> avec des √©l√©ments
organis√©s selon les modules <code>types</code> et <code>utilitaires</code></span></p>
<!--
Figure 14-3 shows what the front page of the documentation for this crate
generated by `cargo doc` would look like:
-->
<p>L'illustration 14-3 montre la page d'accueil de la documentation de cette crate
g√©n√©r√©e par <code>cargo doc</code> qui devrait ressembler √† cela¬†:</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
-->
<p><img
    alt="Documentation g√©n√©r√©e pour la crate `art` qui liste les modules `types` et `utilitaires`"
    src="img/trpl14-03.png"
    class="center" /></p>
<!-- markdownlint-restore -->
<!--
<span class="caption">Figure 14-3: Front page of the documentation for `art`
that lists the `kinds` and `utils` modules</span>
-->
<p><span class="caption">Illustration 14-3¬†: Page d'accueil de la documentation de
<code>art</code> qui liste les modules <code>types</code> et <code>utilitaires</code></span></p>
<!--
Note that the `PrimaryColor` and `SecondaryColor` types aren‚Äôt listed on the
front page, nor is the `mix` function. We have to click `kinds` and `utils` to
see them.
-->
<p>Notez que les types <code>CouleurPrimaire</code> et <code>CouleurSecondaire</code> ne sont pas list√©s
sur la page d'accueil, pas plus que la fonction <code>mixer</code>. Nous devons cliquer
sur <code>types</code> et <code>utilitaires</code> pour les voir.</p>
<!--
Another crate that depends on this library would need `use` statements that
bring the items from `art` into scope, specifying the module structure that‚Äôs
currently defined. Listing 14-4 shows an example of a crate that uses the
`PrimaryColor` and `mix` items from the `art` crate:
-->
<p>Une autre crate qui d√©pend de cette biblioth√®que va avoir besoin d'utiliser
l'instruction <code>use</code> pour importer les √©l√©ments de <code>art</code> dans sa port√©e, en
suivant la structure du module qui est actuellement d√©finie. L'encart 14-4
montre un exemple d'une crate qui utilise les √©l√©ments <code>CouleurPrimaire</code> et
<code>mixer</code> de la crate <code>art</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```
-->
<pre><code class="language-rust ignore">use art::types::CouleurPrimaire;
use art::utilitaires::mixer;

fn main() {
    let rouge = CouleurPrimaire::Rouge;
    let jaune = CouleurPrimaire::Jaune;
    mixer(rouge, jaune);
}
</code></pre>
<!--
<span class="caption">Listing 14-4: A crate using the `art` crate‚Äôs items with
its internal structure exported</span>
-->
<p><span class="caption">Encart 14-4¬†: une crate qui utilise les √©l√©ments de la
crate <code>art</code> avec sa structure interne export√©e</span></p>
<!--
The author of the code in Listing 14-4, which uses the `art` crate, had to
figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the
`utils` module. The module structure of the `art` crate is more relevant to
developers working on the `art` crate than to developers using the `art` crate.
The internal structure that organizes parts of the crate into the `kinds`
module and the `utils` module doesn‚Äôt contain any useful information for
someone trying to understand how to use the `art` crate. Instead, the `art`
crate‚Äôs module structure causes confusion because developers have to figure out
where to look, and the structure is inconvenient because developers must
specify the module names in the `use` statements.
-->
<p>L'auteur du code de l'encart 14-4, qui utilise la crate <code>art</code>, doit comprendre
que <code>CouleurPrimaire</code> est dans le module <code>types</code> et que <code>mixer</code> est dans le
module <code>utilitaires</code>. La structure du module de la crate <code>art</code> est bien plus
pratique pour les d√©veloppeurs qui travaillent sur la crate <code>art</code> que pour les
d√©veloppeurs qui utilisent la crate <code>art</code>. La structure interne qui divise les
√©l√©ments de la crate dans le module <code>types</code> et le module <code>utilitaires</code> ne
contient aucune information utile √† quelqu'un qui essaye de comprendre comment
utiliser la crate <code>art</code>. Au lieu de cela, la structure du module de la crate
<code>art</code> g√©n√®re de la confusion car les d√©veloppeurs doivent d√©couvrir o√π trouver
les √©l√©ments, et la structure n'est pas pratique car les d√©veloppeurs doivent
renseigner les noms des modules dans les instructions <code>use</code>.</p>
<!--
To remove the internal organization from the public API, we can modify the
`art` crate code in Listing 14-3 to add `pub use` statements to re-export the
items at the top level, as shown in Listing 14-5:
-->
<p>Pour masquer l'organisation interne de l'API publique, nous pouvons modifier le
code de la crate <code>art</code> de l'encart 14-3 pour ajouter l'instruction <code>pub use</code>
pour r√©-exporter les √©l√©ments au niveau sup√©rieur, comme montr√© dans l'encart
14-5¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
#     /// The primary colors according to the RYB color model.
#     pub enum PrimaryColor {
#         Red,
#         Yellow,
#         Blue,
#     }
# 
#     /// The secondary colors according to the RYB color model.
#     pub enum SecondaryColor {
#         Orange,
#         Green,
#         Purple,
#     }
}

pub mod utils {
    // --snip--
#     use crate::kinds::*;
# 
#     /// Combines two primary colors in equal amounts to create
#     /// a secondary color.
#     pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
#         SecondaryColor::Orange
#     }
}
```
-->
<pre><code class="language-rust ignore">//! # Art
//!
//! Une biblioth√®que pour mod√©liser des concepts artistiques.

pub use self::types::CouleurPrimaire;
pub use self::types::CouleurSecondaire;
pub use self::utilitaires::mixer;

pub mod types {
    // -- partie masqu√©e ici --
<span class="boring">    /// Les couleurs primaires du mod√®le RJB.
</span><span class="boring">    pub enum CouleurPrimaire {
</span><span class="boring">        Rouge,
</span><span class="boring">        Jaune,
</span><span class="boring">        Bleu,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Les couleurs secondaires du mod√®le RJB.
</span><span class="boring">    pub enum CouleurSecondaire {
</span><span class="boring">        Orange,
</span><span class="boring">        Vert,
</span><span class="boring">        Violet,
</span><span class="boring">    }
</span>}

pub mod utilitaires {
    // -- partie masqu√©e ici --
<span class="boring">    use crate::types::*;
</span><span class="boring">
</span><span class="boring">    /// Combine deux couleurs primaires dans les m√™mes quantit√©s pour
</span><span class="boring">    /// cr√©er une couleur secondaire.
</span><span class="boring">    pub fn mixer(c1: CouleurPrimaire, c2: CouleurPrimaire) -&gt; CouleurSecondaire {
</span><span class="boring">        CouleurSecondaire::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 14-5: Adding `pub use` statements to re-export
items</span>
-->
<p><span class="caption">Encart 14-5¬†: ajout de l'instruction <code>pub use</code> pour
r√©-exporter les √©l√©ments</span></p>
<!--
The API documentation that `cargo doc` generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
`PrimaryColor` and `SecondaryColor` types and the `mix` function easier to find.
-->
<p>La documentation de l'API que <code>cargo doc</code> a g√©n√©r√©e pour cette crate va
maintenant lister et lier les r√©-exportations sur la page d'accueil, comme dans
l'illustration 14-4, ce qui rend les types <code>CouleurPrimaire</code> et
<code>CouleurSecondaire</code> plus faciles √† trouver.</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
-->
<p><img
    alt="Documentation g√©n√©r√©e pour la crate `art` avec les r√©-exports sur la page d'accueil"
    src="img/trpl14-04.png"
    class="center" /></p>
<!-- markdownlint-restore -->
<!--
<span class="caption">Figure 14-4: The front page of the documentation for `art`
that lists the re-exports</span>
-->
<p><span class="caption">Illustration 14-4¬†: la page d'accueil de la documentation
pour <code>art</code> qui liste les r√©-exports</span></p>
<!--
The `art` crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6:
-->
<p>Les utilisateurs de la crate <code>art</code> peuvent toujours voir et utiliser la
structure interne de l'encart 14-3 comme ils l'utilisaient dans l'encart 14-4,
mais ils peuvent maintenant utiliser la structure plus pratique de l'encart
14-5, comme montr√© dans l'encart 14-6¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
#     let red = PrimaryColor::Red;
#     let yellow = PrimaryColor::Yellow;
#     mix(red, yellow);
}
```
-->
<pre><code class="language-rust ignore">use art::mixer;
use art::CouleurPrimaire;

fn main() {
    // -- partie masqu√©e ici --
<span class="boring">    let rouge = CouleurPrimaire::Rouge;
</span><span class="boring">    let jaune = CouleurPrimaire::Jaune;
</span><span class="boring">    mixer(rouge, jaune);
</span>}
</code></pre>
<!--
<span class="caption">Listing 14-6: A program using the re-exported items from
the `art` crate</span>
-->
<p><span class="caption">Encart 14-6¬†: un programme qui utilise les √©l√©ments
r√©-export√©s de la crate <code>art</code></span></p>
<!--
In cases where there are many nested modules, re-exporting the types at the top
level with `pub use` can make a significant difference in the experience of
people who use the crate.
-->
<p>Dans les cas o√π il y a de nombreux modules imbriqu√©s, r√©-exporter les types au
niveau le plus haut avec <code>pub use</code> peut faire une diff√©rence significative dans
l'exp√©rience utilisateur de ceux qui utilisent cette crate.</p>
<!--
Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing `pub
use` gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates you‚Äôve installed to see if their internal structure
differs from their public API.
-->
<p>Cr√©er une structure d'API publique utile est plus un art qu'une science, et vous
pouvez it√©rer plusieurs fois pour trouver une API qui fonctionne mieux pour vos
utilisateurs. Choisir <code>pub use</code> vous donne de la flexibilit√© pour l'organisation
interne de votre crate et d√©couple la structure interne de ce que vous pr√©sentez
aux utilisateurs. N'h√©sitez pas √† regarder le code source des crates que vous
avez install√©es pour voir si leur structure interne est diff√©rente de leur API
publique.</p>
<!--
### Setting Up a Crates.io Account
-->
<h3 id="mise-en-place-dun-compte-cratesio"><a class="header" href="#mise-en-place-dun-compte-cratesio">Mise en place d'un compte crates.io</a></h3>
<!--
Before you can publish any crates, you need to create an account on
[crates.io](https://crates.io/)<!-- ignore -- > and get an API token. To do so,
visit the home page at [crates.io](https://crates.io/)<!-- ignore -- > and log in
via a GitHub account. (The GitHub account is currently a requirement, but the
site might support other ways of creating an account in the future.) Once
you‚Äôre logged in, visit your account settings at
[https://crates.io/me/](https://crates.io/me/)<!-- ignore -- > and retrieve your
API key. Then run the `cargo login` command with your API key, like this:
-->
<p>Avant de pouvoir publier une crate, vous devez cr√©er un compte sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> et obtenir un jeton d'API. Pour
pouvoir faire cela, visitez la page d'accueil de
<a href="https://crates.io/">crates.io</a><!-- ignore --> et connectez-vous avec votre
compte GitHub (le compte GitHub est actuellement une obligation, mais crates.io
pourra permettre de cr√©er un compte d'une autre mani√®re un jour). Une fois
identifi√©, consultez les r√©glages de votre compte √† l'adresse
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> et r√©cup√©rez votre
jeton d'API (NdT¬†: <em>API key</em>). Ensuite, lancez la commande <code>cargo login</code> avec
votre cl√© d'API, comme ceci¬†:</p>
<!--
```console
$ cargo login abcdefghijklmnopqrstuvwxyz012345
```
-->
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<!--
This command will inform Cargo of your API token and store it locally in
*~/.cargo/credentials*. Note that this token is a *secret*: do not share it
with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on [crates.io](https://crates.io/)<!-- ignore
-- >.
-->
<p>Cette commande informera cargo de votre jeton d'API et l'enregistrera localement
dans <em>~/.cargo/credentials</em>. Notez que ce jeton est un <em>secret</em>¬†: ne le partagez
avec personne d'autre. Si vous le donnez √† quelqu'un pour une quelconque raison,
vous devriez le r√©voquer et g√©n√©rer un nouveau jeton sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->.</p>
<!--
### Adding Metadata to a New Crate
-->
<h3 id="ajouter-des-m√©tadonn√©es-√†-une-nouvelle-crate"><a class="header" href="#ajouter-des-m√©tadonn√©es-√†-une-nouvelle-crate">Ajouter des m√©tadonn√©es √† une nouvelle crate</a></h3>
<!--
Now that you have an account, let‚Äôs say you have a crate you want to publish.
Before publishing, you‚Äôll need to add some metadata to your crate by adding it
to the `[package]` section of the crate‚Äôs *Cargo.toml* file.
-->
<p>Maintenant que vous avez un compte, imaginons que vous avez une crate que vous
souhaitez publier. Avant de la publier, vous aurez besoin d'ajouter quelques
m√©tadonn√©es √† votre crate en les ajoutant √† la section <code>[package]</code> du fichier
<em>Cargo.toml</em> de votre crate.</p>
<!--
Your crate will need a unique name. While you‚Äôre working on a crate locally,
you can name a crate whatever you‚Äôd like. However, crate names on
[crates.io](https://crates.io/)<!-- ignore -- > are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Before attempting to publish a crate, search for the name you
want to use on the site. If the name has been used by another crate, you will
need to find another name and edit the `name` field in the *Cargo.toml* file
under the `[package]` section to use the new name for publishing, like so:
-->
<p>Votre crate va avoir besoin d'un nom unique. Tant que vous travaillez en local,
vous pouvez nommer un crate comme vous le souhaitez. Cependant, les noms des
crates sur <a href="https://crates.io/">crates.io</a><!-- ignore --> sont accord√©s selon le
principe du <em>premier arriv√©, premier servi</em>. Une fois qu'un nom de crate est
accord√©, personne d'autre ne peut publier une crate avec ce nom. Avant d'essayer
de publier une crate, recherchez sur le site le nom que vous souhaitez utiliser.
Si le nom a √©t√© utilis√© par une autre crate, vous allez devoir trouver un autre
nom et modifier le champ <code>name</code> dans le fichier <em>Cargo.toml</em> sous la section
<code>[package]</code> pour utiliser le nouveau nom pour la publication, comme ceci¬†:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
</code></pre>
<!--
Even if you‚Äôve chosen a unique name, when you run `cargo publish` to publish
the crate at this point, you‚Äôll get a warning and then an error:
-->
<p>M√™me si vous avez choisi un nom unique, lorsque vous lancez <code>cargo publish</code> pour
publier la crate √† ce stade, vous allez avoir un avertissement suivi par une
erreur¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-- >
-->
<!--
```console
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
```
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
-- partie masqu√©e ici --
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<!--
The reason is that you‚Äôre missing some crucial information: a description and
license are required so people will know what your crate does and under what
terms they can use it. To rectify this error, you need to include this
information in the *Cargo.toml* file.
-->
<p>La raison est qu'il manque quelques informations essentielles¬†: une description
et une licence sont n√©cessaires pour que les gens puissent savoir ce que fait
votre crate et sous quelles conditions ils peuvent l'utiliser. Pour corriger
cette erreur, vous devez rajouter ces informations dans le fichier <em>Cargo.toml</em>.</p>
<!--
Add a description that is just a sentence or two, because it will appear with
your crate in search results. For the `license` field, you need to give a
*license identifier value*. The [Linux Foundation‚Äôs Software Package Data
Exchange (SPDX)][spdx] lists the identifiers you can use for this value. For
example, to specify that you‚Äôve licensed your crate using the MIT License, add
the `MIT` identifier:
-->
<p>Ajoutez une description qui ne fait qu'une phrase ou deux, car elle va
s'afficher √† proximit√© de votre crate dans les r√©sultats de recherche. Pour le
champ <code>license</code>, vous devez donner une <em>valeur d'identification de la licence</em>.
La <a href="http://spdx.org/licenses/">Linux Foundation‚Äôs Software Package Data Exchange (SPDX)</a> liste les
identifications que vous pouvez utiliser pour cette valeur. Par exemple, pour
stipuler que votre crate est sous la licence MIT, ajoutez l'identifiant
<code>MIT</code>¬†:</p>
<!--
[spdx]: http://spdx.org/licenses/
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
license = "MIT"
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
license = &quot;MIT&quot;
</code></pre>
<!--
If you want to use a license that doesn‚Äôt appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use `license-file` to specify the name of that file instead of using the
`license` key.
-->
<p>Si vous voulez utiliser une licence qui n'appara√Æt pas dans le SPDX, vous devez
placer le texte de cette licence dans un fichier, inclure ce fichier dans votre
projet puis utiliser <code>licence-file</code> pour renseigner le nom de ce fichier
plut√¥t que d'utiliser la cl√© <code>licence</code>.</p>
<!--
Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of `MIT OR Apache-2.0`. This practice
demonstrates that you can also specify multiple license identifiers separated
by `OR` to have multiple licenses for your project.
-->
<p>Les conseils sur le choix de la licence appropri√©e pour votre projet sortent du
cadre de ce livre. De nombreuses personnes dans la communaut√© Rust appliquent √†
leurs projets la m√™me licence que Rust qui utilise la licence double
<code>MIT OR Apache-2.0</code>. Cette pratique montre que vous pouvez √©galement indiquer
plusieurs identificateurs de licence s√©par√©s par <code>OR</code> pour avoir plusieurs
licences pour votre projet.</p>
<!--
With a unique name, the version, your description, and a license added, the
*Cargo.toml* file for a project that is ready to publish might look like this:
-->
<p>Une fois le nom unique, la version, la description et la licence ajout√©s, le
fichier <em>Cargo.toml</em> de ce projet qui est pr√™t √† √™tre publi√© devrait ressembler
√† ceci :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;Un jeu o√π vous devez deviner quel nombre l'ordinateur a choisi.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<!--
[Cargo‚Äôs documentation](https://doc.rust-lang.org/cargo/) describes other
metadata you can specify to ensure others can discover and use your crate more
easily.
-->
<p>La <a href="https://doc.rust-lang.org/cargo/">documentation de cargo</a> d√©crit d'autres
m√©tadonn√©es que vous pouvez renseigner pour vous assurer que les autres
d√©veloppeurs puissent d√©couvrir et utiliser votre crate plus facilement.</p>
<!--
### Publishing to Crates.io
-->
<h3 id="publier-sur-cratesio"><a class="header" href="#publier-sur-cratesio">Publier sur crates.io</a></h3>
<!--
Now that you‚Äôve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you‚Äôre ready to publish!
Publishing a crate uploads a specific version to
[crates.io](https://crates.io/)<!-- ignore -- > for others to use.
-->
<p>Maintenant que vous avez cr√©√© un compte, sauvegard√© votre jeton de cl√©, choisi
un nom pour votre crate, et pr√©cis√© les m√©tadonn√©es requises, vous √™tes pr√™t √†
publier ! Publier une crate t√©l√©verse une version pr√©cise sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> pour que les autres puissent
l'utiliser.</p>
<!--
Be careful when publishing a crate because a publish is *permanent*. The
version can never be overwritten, and the code cannot be deleted. One major
goal of [crates.io](https://crates.io/)<!-- ignore -- > is to act as a permanent
archive of code so that builds of all projects that depend on crates from
[crates.io](https://crates.io/)<!-- ignore -- > will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.
-->
<p>Faites attention lorsque vous publiez une crate car une publication est
<em>permanente</em>. La version ne pourra jamais √™tre remplac√©e, et le code ne pourra
jamais √™tre effac√©. Le but majeur de
<a href="https://crates.io/">crates.io</a><!-- ignore --> est de fournir une archive
durable de code afin que les compilations de tous les projets qui d√©pendent des
crates de <a href="https://crates.io/">crates.io</a><!-- ignore --> puissent toujours
continuer √† fonctionner. Si la suppression de version √©tait autoris√©e, cela
rendrait ce but impossible. Cependant, il n'y a pas de limites au nombre de
versions de votre crate que vous pouvez publier.</p>
<!--
Run the `cargo publish` command again. It should succeed now:
-->
<p>Lancez la commande <code>cargo publish</code> √† nouveau. Elle devrait fonctionner √†
pr√©sent :</p>
<!--
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-- >
-->
<!--
```console
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
   Verifying jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
   Compiling jeu_du_plus_ou_du_moins v0.1.0
(file:///projects/jeu_du_plus_ou_du_moins/target/package/jeu_du_plus_ou_du_moins-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
</code></pre>
<!--
Congratulations! You‚Äôve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.
-->
<p>F√©licitations ! Vous venez de partager votre code avec la communaut√© Rust, et
d√©sormais tout le monde peut facilement ajouter votre crate comme une d√©pendance
de son projet.</p>
<!--
### Publishing a New Version of an Existing Crate
-->
<h3 id="publier-une-nouvelle-version-dune-crate-existante"><a class="header" href="#publier-une-nouvelle-version-dune-crate-existante">Publier une nouvelle version d'une crate existante</a></h3>
<!--
When you‚Äôve made changes to your crate and are ready to release a new version,
you change the `version` value specified in your *Cargo.toml* file and
republish. Use the [Semantic Versioning rules][semver] to decide what an
appropriate next version number is based on the kinds of changes you‚Äôve made.
Then run `cargo publish` to upload the new version.
-->
<p>Lorsque vous avez fait des changements sur votre crate et que vous √™tes pr√™t √†
publier une nouvelle version, vous devez changer la valeur de <code>version</code>
renseign√©e dans votre fichier <em>Cargo.toml</em> et la publier √† nouveau. Utilisez les
<a href="https://semver.org/lang/fr/">r√®gles de versionnage s√©mantique</a> pour choisir quelle sera la prochaine
version la plus appropri√©e en fonction des changements que vous avez faits.
Lancez ensuite <code>cargo publish</code> pour t√©l√©verser la nouvelle version.</p>
<!--
[semver]: http://semver.org/
-->
<!--
### Removing Versions from Crates.io with `cargo yank`
-->
<h3 id="retirer-des-versions-de-cratesio-avec-cargo-yank"><a class="header" href="#retirer-des-versions-de-cratesio-avec-cargo-yank">Retirer des versions de crates.io avec <code>cargo yank</code></a></h3>
<!--
Although you can‚Äôt remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports *yanking* a crate version.
-->
<p>Bien que vous ne puissiez pas enlever des versions pr√©c√©dentes d'une crate, vous
pouvez pr√©venir les futurs projets de ne pas l'ajouter comme une nouvelle
d√©pendance. Cela s'av√®re pratique lorsqu'une version de crate est d√©fectueuse
pour une raison ou une autre. Dans de telles circonstances, cargo permet de
<em>d√©pr√©cier</em> une version de crate.</p>
<!--
Yanking a version prevents new projects from starting to depend on that version
while allowing all existing projects that depend on it to continue to download
and depend on that version. Essentially, a yank means that all projects with a
*Cargo.lock* will not break, and any future *Cargo.lock* files generated will
not use the yanked version.
-->
<p>D√©pr√©cier une version √©vite que les nouveaux projets ajoutent une d√©pendance √†
cette version tout en permettant √† tous les projets existants de continuer √† en
d√©pendre en leur permettant toujours de t√©l√©charger et d√©pendre de cette
version. En gros, une version d√©pr√©ci√©e permet √† tous les projets avec un
<em>Cargo.lock</em> de ne pas √©chouer, mais tous les futurs fichiers <em>Cargo.lock</em>
g√©n√©r√©s n'utiliseront pas la version d√©pr√©ci√©e.</p>
<!--
To yank a version of a crate, run `cargo yank` and specify which version you
want to yank:
-->
<p>Pour d√©pr√©cier une version d'une crate, lancez <code>cargo yank</code> et renseignez quelle
version vous voulez d√©pr√©cier :</p>
<!--
```console
$ cargo yank --vers 1.0.1
```
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
</code></pre>
<!--
By adding `--undo` to the command, you can also undo a yank and allow projects
to start depending on a version again:
-->
<p>Si vous ajoutez <code>--undo</code> √† la commande, vous pouvez aussi annuler une
d√©pr√©ciation et permettre √† nouveaux aux projets de d√©pendre de cette version :</p>
<!--
```console
$ cargo yank --vers 1.0.1 --undo
```
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<!--
A yank *does not* delete any code. For example, the yank feature is not
intended for deleting accidentally uploaded secrets. If that happens, you must
reset those secrets immediately.
-->
<p>Une d√©pr√©ciation <em>ne supprime pas</em> du code. Par exemple, la fonctionnalit√© de
d√©pr√©ciation n'est pas con√ßue pour supprimer des <em>secrets</em> t√©l√©vers√©s par
m√©garde. Si cela arrive, vous devez r√©g√©n√©rer imm√©diatement ces secrets.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Cargo Workspaces
-->
<h2 id="les-espaces-de-travail-de-cargo"><a class="header" href="#les-espaces-de-travail-de-cargo">Les espaces de travail de cargo</a></h2>
<!--
In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split up your package further into
multiple library crates. In this situation, Cargo offers a feature called
*workspaces* that can help manage multiple related packages that are developed
in tandem.
-->
<p>Dans le chapitre 12, nous avons construit un paquet qui comprenait une crate
binaire et une crate de biblioth√®que. Au fur et √† mesure que votre projet se
d√©veloppe, vous pourrez constater que la crate de biblioth√®que continue de
s'agrandir et vous voudriez alors peut-√™tre diviser votre paquet en plusieurs
crates de biblioth√®que. Pour cette situation, cargo a une fonctionnalit√© qui
s'appelle <em>les espaces de travail</em> qui peuvent aider √† g√©rer plusieurs paquets
li√©s qui sont d√©velopp√©s en tandem.</p>
<!--
### Creating a Workspace
-->
<h3 id="cr√©er-un-espace-de-travail"><a class="header" href="#cr√©er-un-espace-de-travail">Cr√©er un espace de travail</a></h3>
<!--
A *workspace* is a set of packages that share the same *Cargo.lock* and output
directory. Let‚Äôs make a project using a workspace‚Äîwe‚Äôll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace; we‚Äôre going to show one common way. We‚Äôll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an `add_one` function, and a second library an `add_two` function.
These three crates will be part of the same workspace. We‚Äôll start by creating
a new directory for the workspace:
-->
<p>Un <em>espace de travail</em> est un jeu de paquets qui partagent tous le m√™me
<em>Cargo.lock</em> et le m√™me dossier de sortie. Cr√©ons donc un projet en utilisant un
espace de travail ‚Äî nous allons utiliser du code trivial afin de nous concentrer
sur la structure de l'espace de travail. Il existe plusieurs fa√ßons de
structurer un espace de travail¬†; nous allons vous montrer une mani√®re commune
d'organisation. Nous allons avoir un espace de travail contenant un binaire et
deux biblioth√®ques. Le binaire, qui devrait fournir les fonctionnalit√©s
principales, va d√©pendre des deux biblioth√®ques. Une biblioth√®que va fournir une
fonction <code>ajouter_un</code>, et la seconde biblioth√®que, une fonction <code>ajouter_deux</code>.
Ces trois crates feront partie du m√™me espace de travail. Nous allons commencer
par cr√©er un nouveau dossier pour cet espace de travail¬†:</p>
<!--
```console
$ mkdir add
$ cd add
```
-->
<pre><code class="language-console">$ mkdir ajout
$ cd ajout
</code></pre>
<!--
Next, in the *add* directory, we create the *Cargo.toml* file that will
configure the entire workspace. This file won‚Äôt have a `[package]` section or
the metadata we‚Äôve seen in other *Cargo.toml* files. Instead, it will start
with a `[workspace]` section that will allow us to add members to the workspace
by specifying the path to the package with our binary crate; in this case,
that path is *adder*:
-->
<p>Ensuite, dans le dossier <em>ajout</em>, nous cr√©ons le fichier <em>Cargo.toml</em> qui va
configurer l'int√©gralit√© de l'espace de travail. Ce fichier n'aura pas de
section <code>[package]</code> ou les m√©tadonn√©es que nous avons vues dans les autres
fichiers <em>Cargo.toml</em>. A la place, il commencera par une section <code>[workspace]</code>
qui va nous permettre d'ajouter des membres √† l'espace de travail en
renseignant le chemin vers le paquet qui contient notre crate binaire¬†; dans ce
cas, ce chemin est <em>additioneur</em>¬†:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[workspace]

members = [
    "adder",
]
```
-->
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
]
</code></pre>
<!--
Next, we‚Äôll create the `adder` binary crate by running `cargo new` within the
*add* directory:
-->
<p>Ensuite, nous allons cr√©er la crate binaire <code>additioneur</code> en lan√ßant <code>cargo new</code>
dans le dossier <em>ajout</em>¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-- >
-->
<!--
```console
$ cargo new adder
     Created binary (application) `adder` package
```
-->
<pre><code class="language-console">$ cargo new additioneur
     Created binary (application) `additioneur` package
</code></pre>
<!--
At this point, we can build the workspace by running `cargo build`. The files
in your *add* directory should look like this:
-->
<p>A partir de ce moment, nous pouvons compiler l'espace de travail en lan√ßant
<code>cargo build</code>. Les fichiers dans votre dossier <em>ajout</em> devraient ressembler √†
ceci¬†:</p>
<!--
```text
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ adder
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
```
-->
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ additioneur
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<!--
The workspace has one *target* directory at the top level for the compiled
artifacts to be placed into; the `adder` package doesn‚Äôt have its own *target*
directory. Even if we were to run `cargo build` from inside the *adder*
directory, the compiled artifacts would still end up in *add/target* rather
than *add/adder/target*. Cargo structures the *target* directory in a workspace
like this because the crates in a workspace are meant to depend on each other.
If each crate had its own *target* directory, each crate would have to
recompile each of the other crates in the workspace to have the artifacts in
its own *target* directory. By sharing one *target* directory, the crates can
avoid unnecessary rebuilding.
-->
<p>L'espace de travail a un dossier <em>target</em> au niveau le plus haut pour y placer
les artefacts compil√©s¬†; le paquet <code>additioneur</code> n'a pas son propre dossier
<em>target</em>. M√™me si nous lancions <code>cargo build</code> √† l'int√©rieur du dossier
<em>additioneur</em>, les artefacts compil√©s finirons toujours dans <em>ajout/target</em>
plut√¥t que dans <em>ajout/additioneur/target</em>. Cargo organise ainsi le dossier
<em>target</em> car les crates d'un espace de travail sont cens√©s d√©pendre l'une de
l'autre. Si chaque crate avait son propre dossier <em>target</em>, chaque crate
devrait recompiler chacune des autres crates pr√©sentes dans l'espace de
travail pour avoir les artefacts dans son propre dossier <em>target</em>. En
partageant un seul dossier <em>target</em>, les crates peuvent √©viter des
re-compilations inutiles.</p>
<!--
### Creating the Second Package in the Workspace
-->
<h3 id="cr√©er-le-second-paquet-dans-lespace-de-travail"><a class="header" href="#cr√©er-le-second-paquet-dans-lespace-de-travail">Cr√©er le second paquet dans l'espace de travail</a></h3>
<!--
Next, let‚Äôs create another member package in the workspace and call it `add_one`.
Change the top-level *Cargo.toml* to specify the *add_one* path in the
`members` list:
-->
<p>Ensuite, cr√©ons un autre paquet, membre de l'espace de travail et appelons-le
<code>ajouter_un</code>. Changeons le <em>Cargo.toml</em> du niveau le plus haut pour renseigner
le chemin vers <em>ajouter_un</em> dans la liste <code>members</code>¬†:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: Cargo.toml</span></p>
<!--
```toml
[workspace]

members = [
    "adder",
    "add_one",
]
```
-->
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
    &quot;ajouter_un&quot;,
]
</code></pre>
<!--
Then generate a new library crate named `add_one`:
-->
<p>Ensuite, g√©n√©rons une nouvelle crate de biblioth√®que <code>ajouter_un</code>¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-- >
-->
<!--
```console
$ cargo new add_one --lib
     Created library `add_one` package
```
-->
<pre><code class="language-console">$ cargo new ajouter_un --lib
     Created library `ajouter_un` package
</code></pre>
<!--
Your *add* directory should now have these directories and files:
-->
<p>Votre dossier <em>ajout</em> devrait maintenant avoir ces dossiers et fichiers¬†:</p>
<!--
```text
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ add_one
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ adder
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
```
-->
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ ajouter_un
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ additioneur
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<!--
In the *add_one/src/lib.rs* file, let‚Äôs add an `add_one` function:
-->
<p>Dans le fichier <em>ajouter_un/src/lib.rs</em>, ajoutons une fonction <code>ajouter_un</code>¬†:</p>
<!--
<span class="filename">Filename: add_one/src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: ajouter_un/src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<!--
Now that we have another package in the workspace, we can have the `adder`
package with our binary depend on the `add_one` package, that has our
library. First, we‚Äôll need to add a path dependency on `add_one` to
*adder/Cargo.toml*.
-->
<p>Maintenant que nous avons un autre paquet dans l'espace de travail, nous pouvons
faire en sorte que le paquet <code>additioneur</code> qui contient notre binaire d√©pende du
paquet <code>ajouter_un</code>, qui contient notre biblioth√®que. D'abord, nous devons
ajouter un chemin de d√©pendance √† <code>ajouter_un</code> dans <em>additioneur/Cargo.toml</em>.</p>
<!--
<span class="filename">Filename: adder/Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: additioneur/Cargo.toml</span></p>
<!--
```toml
[dependencies]
add_one = { path = "../add_one" }
```
-->
<pre><code class="language-toml">[dependencies]
ajouter_un = { path = &quot;../ajouter_un&quot; }
</code></pre>
<!--
Cargo doesn‚Äôt assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships between the crates.
-->
<p>Cargo ne fait pas la supposition que les crates d'un espace de travail
d√©pendent l'une de l'autre, donc vous devez √™tre explicites sur les relations
de d√©pendance entre les crates.</p>
<!--
Next, let‚Äôs use the `add_one` function from the `add_one` crate in the `adder`
crate. Open the *adder/src/main.rs* file and add a `use` line at the top to
bring the new `add_one` library crate into scope. Then change the `main`
function to call the `add_one` function, as in Listing 14-7.
-->
<p>Ensuite, utilisons la fonction <code>ajouter_un</code> de la crate <code>ajouter_un</code> dans la
crate <code>additioneur</code>. Ouvrez le fichier <em>additioneur/src/main.rs</em> et ajoutez une
ligne <code>use</code> tout en haut pour importer la biblioth√®que <code>ajouter_un</code> dans la
port√©e. Changez ensuite la fonction <code>main</code> pour appeler la fonction
<code>ajouter_un</code>, comme dans l'encart 14-7.</p>
<!--
<span class="filename">Filename: adder/src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: additioneur/src/main.rs</span></p>
<!--
```rust,ignore
use add_one;

fn main() {
    let num = 10;
    println!(
        "Hello, world! {} plus one is {}!",
        num,
        add_one::add_one(num)
    );
}
```
-->
<pre><code class="language-rust ignore">use ajouter_un;

fn main() {
    let nombre = 10;
    println!(
        &quot;Hello, world¬†! {} plus un vaut {}¬†!&quot;,
        nombre,
        ajouter_un::ajouter_un(nombre)
    );
}
</code></pre>
<!--
<span class="caption">Listing 14-7: Using the `add_one` library crate from the
 `adder` crate</span>
-->
<p><span class="caption">Encart 14-7¬†: utilisation de la biblioth√®que <code>ajouter_un</code>
dans la crate <code>additioneur</code></span></p>
<!--
Let‚Äôs build the workspace by running `cargo build` in the top-level *add*
directory!
-->
<p>Compilons l'espace de travail en lan√ßant <code>cargo build</code> dans le niveau le plus
haut du dossier <em>ajout</em>¬†!</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling ajouter_un v0.1.0 (file:///projects/ajout/ajouter_un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<!--
To run the binary crate from the *add* directory, we can specify which
package in the workspace we want to run by using the `-p` argument and the
package name with `cargo run`:
-->
<p>Pour lancer la crate binaire √† partir du dossier <em>ajout</em>, nous pouvons
pr√©ciser quel paquet nous souhaitons ex√©cuter dans l'espace de travail en
utilisant l'argument <code>-p</code> suivi du nom du paquet avec <code>cargo run</code>¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```
-->
<pre><code class="language-console">$ cargo run -p additioneur
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/additioneur`
Hello, world¬†! 10 plus un vaut 11¬†!
</code></pre>
<!--
This runs the code in *adder/src/main.rs*, which depends on the `add_one` crate.
-->
<p>Cela ex√©cute le code de <em>additioneur/src/main.rs</em>, qui d√©pend de la crate
<code>ajouter_un</code>.</p>
<!--
#### Depending on an External Package in a Workspace
-->
<h4 id="d√©pendre-dun-paquet-externe-dans-un-espace-de-travail"><a class="header" href="#d√©pendre-dun-paquet-externe-dans-un-espace-de-travail">D√©pendre d'un paquet externe dans un espace de travail</a></h4>
<!--
Notice that the workspace has only one *Cargo.lock* file at the top level of
the workspace rather than having a *Cargo.lock* in each crate‚Äôs directory. This
ensures that all crates are using the same version of all dependencies. If we
add the `rand` package to the *adder/Cargo.toml* and *add_one/Cargo.toml*
files, Cargo will resolve both of those to one version of `rand` and record
that in the one *Cargo.lock*. Making all crates in the workspace use the same
dependencies means the crates in the workspace will always be compatible with
each other. Let‚Äôs add the `rand` crate to the `[dependencies]` section in the
*add_one/Cargo.toml* file to be able to use the `rand` crate in the `add_one`
crate:
-->
<p>Notez que l'espace de travail a un seul fichier <em>Cargo.lock</em> dans le niveau le
plus haut de l'espace de travail plut√¥t que d'avoir un <em>Cargo.lock</em> dans chaque
dossier de chaque crate. Cela garantit que toutes les crates utilisent la m√™me
version de toutes les d√©pendances. Si nous ajoutons le paquet <code>rand</code> aux
fichiers <em>additioneur/Cargo.toml</em> et <em>ajouter_un/Cargo.toml</em>, cargo va r√©unir
les deux en une seule version de <code>rand</code> et enregistrer cela dans un seul
<em>Cargo.lock</em>. Faire en sorte que toutes les crates de l'espace de travail
utilisent la m√™me d√©pendance signifie que les crates dans l'espace de travail
seront toujours compatibles l'une avec l'autre. Ajoutons la crate <code>rand</code> √† la
section <code>[dependencies]</code> du fichier <em>ajouter_un/Cargo.toml</em> pour pouvoir
utiliser la crate <code>rand</code> dans la crate <code>ajouter_un</code>¬†:</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-- >
-->
<!--
<span class="filename">Filename: add_one/Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: ajouter_un/Cargo.toml</span></p>
<!--
```toml
[dependencies]
rand = "0.8.3"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.3&quot;
</code></pre>
<!--
We can now add `use rand;` to the *add_one/src/lib.rs* file, and building the
whole workspace by running `cargo build` in the *add* directory will bring in
and compile the `rand` crate. We will get one warning because we aren‚Äôt
referring to the `rand` we brought into scope:
-->
<p>Nous pouvons maintenant ajouter <code>use rand;</code> au fichier <em>ajouter_un/src/lib.rs</em>
et compiler l'ensemble de l'espace de travail en lan√ßant <code>cargo build</code> dans le
dossier <em>ajout</em>, ce qui va importer et compiler la crate <code>rand</code>. Nous devrions
avoir un avertissement car nous n'avons pas utilis√© le <code>rand</code> que nous avons
introduit dans la port√©e¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
   --snip--
   Compiling rand v0.8.3
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 -- > add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: 1 warning emitted

   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
```
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
   -- partie masqu√©e ici --
   Compiling rand v0.8.3
   Compiling ajouter_un v0.1.0 (file:///projects/ajout/ajouter_un)
warning: unused import: `rand`
 --&gt; ajouter_un/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: 1 warning emitted

   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<!--
The top-level *Cargo.lock* now contains information about the dependency of
`add_one` on `rand`. However, even though `rand` is used somewhere in the
workspace, we can‚Äôt use it in other crates in the workspace unless we add
`rand` to their *Cargo.toml* files as well. For example, if we add `use rand;`
to the *adder/src/main.rs* file for the `adder` package, we‚Äôll get an error:
-->
<p>Le <em>Cargo.lock</em> du niveau le plus haut contient maintenant les informations
de d√©pendance √† <code>rand</code> pour <code>ajouter_un</code>. Cependant, m√™me si <code>rand</code> est
utilis√© quelque part dans l'espace de travail, nous ne pouvons pas l'utiliser
dans d'autres crates de l'espace de travail tant que nous n'ajoutons pas
<code>rand</code> dans leurs fichiers <em>Cargo.toml</em>. Par exemple, si nous ajoutons
<code>use rand;</code> dans le fichier <em>additioneur/src/main.rs</em> pour le paquet
<code>additioneur</code>, nous allons avoir une erreur¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 -- > adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
```
-->
<pre><code class="language-console">$ cargo build
  -- partie masqu√©e ici --
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
error[E0432]: unresolved import `rand`
 --&gt; additioneur/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<!--
To fix this, edit the *Cargo.toml* file for the `adder` package and indicate
that `rand` is a dependency for it as well. Building the `adder` package will
add `rand` to the list of dependencies for `adder` in *Cargo.lock*, but no
additional copies of `rand` will be downloaded. Cargo has ensured that every
crate in every package in the workspace using the `rand` package will be
using the same version. Using the same version of `rand` across the workspace
saves space because we won‚Äôt have multiple copies and ensures that the crates
in the workspace will be compatible with each other.
-->
<p>Pour corriger cela, modifiez le fichier <em>Cargo.toml</em> pour le paquet
<code>additioneur</code> et indiquez que <code>rand</code> est une d√©pendance de cette crate aussi.
La compilation du paquet <code>additioneur</code> va rajouter <code>rand</code> √† la liste des
d√©pendances pour <code>additioneur</code> dans <em>Cargo.lock</em>, mais aucune copie
suppl√©mentaire de <code>rand</code> ne sera t√©l√©charg√©e. Cargo s'est assur√© que toutes les
crates de chaque paquet de l'espace de travail qui utilise le paquet <code>rand</code>
seraient de la m√™me version. Utiliser la m√™me version de <code>rand</code> dans les
espaces de travail √©conomise de l'espace car nous n'avons pas √† multiplier les
copies, ni √† nous assurer que les crates dans l'espace de travail sont
compatibles les unes avec les autres.</p>
<!--
#### Adding a Test to a Workspace
-->
<h4 id="ajouter-un-test-√†-lespace-de-travail"><a class="header" href="#ajouter-un-test-√†-lespace-de-travail">Ajouter un test √† l'espace de travail</a></h4>
<!--
For another enhancement, let‚Äôs add a test of the `add_one::add_one` function
within the `add_one` crate:
-->
<p>Afin de proc√©der √† une autre am√©lioration, ajoutons un test de la fonction
<code>ajouter_un::ajouter_un</code> dans la crate <code>ajouter_un</code>¬†:</p>
<!--
<span class="filename">Filename: add_one/src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: add_one/src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_fonctionne() {
        assert_eq!(3, ajouter_un(2));
    }
}
</code></pre>
<!--
Now run `cargo test` in the top-level *add* directory:
-->
<p>Lancez maintenant <code>cargo test</code> dans le niveau le plus haut du
dossier <em>ajout</em>¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
-->
<pre><code class="language-console">$ cargo test
   Compiling ajouter_un v0.1.0 (file:///projects/ajout/ajouter_un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/ajouter_un-f0253159197f7841

running 1 test
test tests::cela_fonctionne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running target/debug/deps/additioneur-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests ajouter_un

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<!--
The first section of the output shows that the `it_works` test in the `add_one`
crate passed. The next section shows that zero tests were found in the `adder`
crate, and then the last section shows zero documentation tests were found in
the `add_one` crate. Running `cargo test` in a workspace structured like this
one will run the tests for all the crates in the workspace.
-->
<p>La premi√®re section de la sortie indique que le test <code>cela_fonctionne</code> de la
crate <code>ajouter_un</code> a r√©ussi. La section suivante indique qu'aucun test n'a √©t√©
trouv√© dans la crate <code>additioneur</code>, puis la derni√®re section indique elle
aussi qu'aucun test de documentation n'a √©t√© trouv√© dans la crate <code>ajouter_un</code>.
Lancer <code>cargo test</code> dans un espace de travail structur√© comme celui-ci va
ex√©cuter les tests pour toutes les crates de cet espace de travail.</p>
<!--
We can also run tests for one particular crate in a workspace from the
top-level directory by using the `-p` flag and specifying the name of the crate
we want to test:
-->
<p>Nous pouvons aussi lancer des tests pour une crate en particulier dans un
espace de travail √† partir du dossier du plus haut niveau en utilisant le
drapeau <code>-p</code> et en renseignant le nom de la crate que nous voulons tester¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
-->
<pre><code class="language-console">$ cargo test -p ajouter_un
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/ajouter_un-b3235fea9a156f74

running 1 test
test tests::cela_fonctionne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests ajouter_un

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<!--
This output shows `cargo test` only ran the tests for the `add_one` crate and
didn‚Äôt run the `adder` crate tests.
-->
<p>Cette sortie montre que <code>cargo test</code> a lanc√© les tests uniquement pour la
crate <code>ajouter_un</code> et n'a pas lanc√© les tests de la crate <code>additioneur</code>.</p>
<!--
If you publish the crates in the workspace to [crates.io](https://crates.io/),
each crate in the workspace will need to be published separately. The `cargo
publish` command does not have an `--all` flag or a `-p` flag, so you must
change to each crate‚Äôs directory and run `cargo publish` on each crate in the
workspace to publish the crates.
-->
<p>Si vous publiez les crates pr√©sentes dans l'espace de travail sur
<a href="https://crates.io/">crates.io</a>, chaque crate de l'espace de travail va avoir
besoin d'√™tre publi√©e de mani√®re s√©par√©e. La commande <code>cargo publish</code> n'a pas
de drapeau <code>--all</code> ou <code>-p</code>, donc vous devrez vous rendre dans chaque dossier de
chaque crate et lancer <code>cargo publish</code> sur chaque crate pr√©sente dans l'espace
de travail pour publier les crates.</p>
<!--
For additional practice, add an `add_two` crate to this workspace in a similar
way as the `add_one` crate!
-->
<p>En guise d'entrainement suppl√©mentaire, ajoutez une crate <code>ajouter_deux</code> dans
cet espace de travail de la m√™me mani√®re que nous l'avons fait pour la crate
<code>ajouter_un</code>¬†!</p>
<!--
As your project grows, consider using a workspace: it‚Äôs easier to understand
smaller, individual components than one big blob of code. Furthermore, keeping
the crates in a workspace can make coordination between them easier if they are
often changed at the same time.
-->
<p>Au fur et √† mesure que votre projet se d√©veloppe, pensez √† utiliser un espace
de travail¬†: il est plus facile de comprendre des composants individuels, plus
petits, plut√¥t qu'un gros tas de code. De plus, garder les crates dans un
espace de travail peut am√©liorer la coordination entre elles si elles sont souvent
modifi√©es ensemble.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Installing Binaries from Crates.io with `cargo install`
-->
<h2 id="installer-des-binaires-√†-partir-de-cratesio-avec-cargo-install"><a class="header" href="#installer-des-binaires-√†-partir-de-cratesio-avec-cargo-install">Installer des binaires √† partir de crates.io avec <code>cargo install</code></a></h2>
<!--
The `cargo install` command allows you to install and use binary crates
locally. This isn‚Äôt intended to replace system packages; it‚Äôs meant to be a
convenient way for Rust developers to install tools that others have shared on
[crates.io](https://crates.io/)<!-- ignore -- >. Note that you can only install
packages that have binary targets. A *binary target* is the runnable program
that is created if the crate has a *src/main.rs* file or another file specified
as a binary, as opposed to a library target that isn‚Äôt runnable on its own but
is suitable for including within other programs. Usually, crates have
information in the *README* file about whether a crate is a library, has a
binary target, or both.
-->
<p>La commande <code>cargo install</code> vous permet d'installer et utiliser des crates de
binaires localement. Cela n'est pas con√ßu pour remplacer les paquets syst√®mes¬†;
c'est plut√¥t un moyen pratique pour les d√©veloppeurs Rust d'installer
des outils que les autres ont partag√© sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->. Notez que vous ne pouvez
installer que des paquets qui ont des destinations binaires. Une <em>destination
binaire</em> est le programme ex√©cutable qui est cr√©√© si la crate a un fichier
<em>src/main.rs</em> ou un autre fichier d√©sign√© comme binaire, par opposition
√† une destination de biblioth√®que qui n'est pas ex√©cutable en tant que telle
mais qu'il est possible d'int√©grer √† d'autres programmes. Habituellement,
l'information permettant de savoir si une crate est une biblioth√®que, poss√®de
plut√¥t une destination binaire ou les deux √† la fois figure dans le
fichier <em>README</em>.</p>
<!--
All binaries installed with `cargo install` are stored in the installation
root‚Äôs *bin* folder. If you installed Rust using *rustup.rs* and don‚Äôt have any
custom configurations, this directory will be *$HOME/.cargo/bin*. Ensure that
directory is in your `$PATH` to be able to run programs you‚Äôve installed with
`cargo install`.
-->
<p>Tous les binaires install√©s avec <code>cargo install</code> sont stock√©s dans le dossier
<em>bin</em> de la racine. Si vous installez Rust avec <em>rustup.rs</em> et que vous n'avez
pas personnalis√© la configuration, ce dossier sera <em>$HOME/.cargo/bin</em>.
Assurez-vous que ce dossier est dans votre <code>$PATH</code> pour pouvoir ex√©cuter des
programmes que vous avez install√©s avec <code>cargo install</code>.</p>
<!--
For example, in Chapter 12 we mentioned that there‚Äôs a Rust implementation of
the `grep` tool called `ripgrep` for searching files. If we want to install
`ripgrep`, we can run the following:
-->
<p>Par exemple, dans le chapitre 12, nous avions mentionn√© le fait qu'il existait
une impl√©mentation de l'outil <code>grep</code> en Rust qui s'appelait <code>ripgrep</code> et qui
permettait de rechercher dans des fichiers. Si nous voulons installer
<code>ripgrep</code>, nous pouvons faire comme ceci¬†:</p>
<!--
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-- >
-->
<!--
```console
$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
```
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
-- partie masqu√©e ici --
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre>
<!--
The second-to-last line of the output shows the location and the name of the
installed binary, which in the case of `ripgrep` is `rg`. As long as the
installation directory is in your `$PATH`, as mentioned previously, you can
then run `rg --help` and start using a faster, rustier tool for searching files!
-->
<p>L'avant-derni√®re ligne de la sortie nous montre l'emplacement et le nom du
binaire install√©, qui est <code>rg</code> dans le cas de <code>ripgrep</code>. Tel que mentionn√©
pr√©c√©demment, du moment que le dossier d'installation est dans votre <code>$PATH</code>,
vous pouvez ensuite lancer <code>rg --help</code> et commencer √† utiliser un outil en Rust
plus rapide pour rechercher dans des fichiers¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Extending Cargo with Custom Commands
-->
<h2 id="etendre-les-fonctionnalit√©s-de-cargo-avec-des-commandes-personnalis√©es"><a class="header" href="#etendre-les-fonctionnalit√©s-de-cargo-avec-des-commandes-personnalis√©es">Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></h2>
<!--
Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you can
run it as if it was a Cargo subcommand by running `cargo something`. Custom
commands like this are also listed when you run `cargo --list`. Being able to
use `cargo install` to install extensions and then run them just like the
built-in Cargo tools is a super convenient benefit of Cargo‚Äôs design!
-->
<p>Cargo est con√ßu pour que vous puissiez √©tendre ses fonctionnalit√©s avec des
nouvelles sous-commandes sans avoir √† modifier cargo. Si un binaire dans votre
<code>$PATH</code> est nomm√© selon <code>cargo-quelquechose</code>, vous pouvez le lancer comme s'il
√©tait une sous-commande de cargo en lan√ßant <code>cargo quelquechose</code>. Les commandes
personnalis√©es comme celle-ci  sont aussi list√©es lorsque vous lancez
<code>cargo --list</code>. Pouvoir utiliser <code>cargo install</code> pour installer des extensions
et ensuite les lancer comme √©tant un outil int√©gr√© √† cargo est un avantage
super pratique de la conception de cargo¬†!</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-13"><a class="header" href="#r√©sum√©-13">R√©sum√©</a></h2>
<!--
Sharing code with Cargo and [crates.io](https://crates.io/)<!-- ignore -- > is
part of what makes the Rust ecosystem useful for many different tasks. Rust‚Äôs
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from that of the language. Don‚Äôt be shy about
sharing code that‚Äôs useful to you on [crates.io](https://crates.io/)<!-- ignore
-- >; it‚Äôs likely that it will be useful to someone else as well!
-->
<p>Le partage de code avec cargo et <a href="https://crates.io/">crates.io</a><!-- ignore -->
fait partie de ce qui rend l'√©cosyst√®me de Rust tr√®s utile pour de nombreuses
t√¢ches. La biblioth√®que standard de Rust est compacte et stable, et les crates
sont faciles √† partager, √† utiliser et √† am√©liorer √† un rythme diff√©rent
de celui du langage. N'h√©sitez pas √† partager du code qui vous est utile sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->¬†; il est fort probable qu'il
sera aussi utile √† quelqu'un d'autre¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Smart Pointers
-->
<h1 id="les-pointeurs-intelligents"><a class="header" href="#les-pointeurs-intelligents">Les pointeurs intelligents</a></h1>
<!--
A *pointer* is a general concept for a variable that contains an address in
memory. This address refers to, or ‚Äúpoints at,‚Äù some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the `&` symbol and borrow the value they
point to. They don‚Äôt have any special capabilities other than referring to
data. Also, they don‚Äôt have any overhead and are the kind of pointer we use
most often.
-->
<p>Un <em>pointeur</em> est un concept g√©n√©ral pour une variable qui contient une adresse
vers la m√©moire. Cette adresse pointe vers d'autres donn√©es. Le type de pointeur
le plus courant en Rust est la r√©f√©rence, que vous avez appris au chapitre 4.
Les r√©f√©rences sont marqu√©es par le symbole <code>&amp;</code> et empruntent la valeur sur
laquelle elles pointent. Elles n'ont pas d'autres fonctionnalit√©s que celle de
pointer sur une donn√©e. De plus, elles n'ont aucun co√ªt sur les performances et
c'est le type de pointeur que nous utilisons le plus souvent.</p>
<!--
*Smart pointers*, on the other hand, are data structures that not only act like
a pointer but also have additional metadata and capabilities. The concept of
smart pointers isn‚Äôt unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide functionality beyond that provided by references.
One example that we‚Äôll explore in this chapter is the *reference counting*
smart pointer type. This pointer enables you to have multiple owners of data by
keeping track of the number of owners and, when no owners remain, cleaning up
the data.
-->
<p>Les <em>pointeurs intelligents</em>, d'un autre c√¥t√©, sont des structures de donn√©es
qui, non seulement se comportent comme un pointeur, mais ont aussi des
fonctionnalit√©s et m√©tadonn√©es suppl√©mentaires. Le concept de pointeur
intelligent n'est pas propre √† Rust¬†: les pointeurs intelligents sont
originaires du C++ et existent aussi dans d'autres langages. En Rust, les
diff√©rents pointeurs intelligents d√©finis dans la biblioth√®que standard
fournissent des fonctionnalit√©s suppl√©mentaires √† celles des r√©f√©rences.
Un exemple que nous allons explorer dans ce chapitre est le type de pointeur
intelligent <em>compteur de r√©f√©rences</em>. Ce pointeur vous permet d'avoir
plusieurs propri√©taires d'une donn√©e tout en gardant une trace de leur nombre et,
lorsqu'il n'y en a plus, de nettoyer cette donn√©e.</p>
<!--
In Rust, which uses the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
*own* the data they point to.
-->
<p>En Rust, qui utilise le concept de propri√©t√© et d'emprunt, une diff√©rence
suppl√©mentaire entre les r√©f√©rences et les pointeurs intelligents est que les
r√©f√©rences sont des pointeurs qui empruntent seulement la donn√©e¬†; alors qu'au
contraire, dans de nombreux cas, les pointeurs intelligents sont
<em>propri√©taires</em> des donn√©es sur lesquelles ils pointent.</p>
<!--
We‚Äôve already encountered a few smart pointers in this book, such as `String`
and `Vec<T>` in Chapter 8, although we didn‚Äôt call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with `String` ensuring its data
will always be valid UTF-8).
-->
<p>Nous avons d√©j√† rencontr√© quelques pointeurs intelligents au cours de ce
livre, comme <code>String</code> et <code>Vec&lt;T&gt;</code> au chapitre 8, m√™me si nous ne les avons pas
d√©sign√©s comme √©tant des pointeurs intelligents √† ce moment-l√†. Ces deux types
sont consid√©r√©s comme des pointeurs intelligents car ils sont propri√©taires de
donn√©es et vous permettent de les manipuler. Ils ont aussi des m√©tadonn√©es
(comme leur capacit√©) et certaines fonctionnalit√©s ou garanties (comme <code>String</code>
qui s'assure que ses donn√©es soient toujours en UTF-8 valide).</p>
<!--
Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the `Deref` and `Drop` traits. The `Deref` trait allows an instance
of the smart pointer struct to behave like a reference so you can write code
that works with either references or smart pointers. The `Drop` trait allows
you to customize the code that is run when an instance of the smart pointer
goes out of scope. In this chapter, we‚Äôll discuss both traits and demonstrate
why they‚Äôre important to smart pointers.
-->
<p>Les pointeurs intelligents sont souvent impl√©ment√©s en utilisant des
structures. Les caract√©ristiques qui distinguent un pointeur intelligent d'une
structure classique est que les pointeurs intelligents impl√©mentent les traits
<code>Deref</code> et <code>Drop</code>. Le trait <code>Deref</code> permet √† une instance d'un pointeur
intelligent de se comporter comme une r√©f√©rence afin que vous puissiez √©crire
du code qui fonctionne aussi bien avec des r√©f√©rences qu'avec des pointeurs
intelligents. Le trait <code>Drop</code> vous permet de personnaliser le code qui est
ex√©cut√© lorsqu'une instance d'un pointeur intelligent sort de la port√©e. Dans
ce chapitre, nous verrons ces deux traits et expliquerons pourquoi ils sont
importants pour les pointeurs intelligents.</p>
<!--
Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won‚Äôt cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We‚Äôll
cover the most common smart pointers in the standard library:
-->
<p>Vu que le motif des pointeurs intelligents est un motif de conception g√©n√©ral
fr√©quemment utilis√© en Rust, ce chapitre ne couvrira pas tous les pointeurs
intelligents existants. De nombreuses biblioth√®ques ont leurs propres pointeurs
intelligents, et vous pouvez m√™me √©crire le v√¥tre. Nous allons voir les
pointeurs intelligents les plus courants de la biblioth√®que standard¬†:</p>
<!--
* `Box<T>` for allocating values on the heap
* `Rc<T>`, a reference counting type that enables multiple ownership
* `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces
  the borrowing rules at runtime instead of compile time
-->
<ul>
<li><code>Box&lt;T&gt;</code> pour l'allocation de valeurs sur le tas</li>
<li><code>Rc&lt;T&gt;</code>, un type comptant les r√©f√©rences, qui permet d'avoir plusieurs
propri√©taires</li>
<li><code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>, auxquels on acc√®de via <code>RefCell&lt;T&gt;</code>, un type
qui permet d'appliquer les r√®gles d'emprunt au moment de l'ex√©cution plut√¥t
qu'au moment de la compilation</li>
</ul>
<!--
In addition, we‚Äôll cover the *interior mutability* pattern where an immutable
type exposes an API for mutating an interior value. We‚Äôll also discuss
*reference cycles*: how they can leak memory and how to prevent them.
-->
<p>En outre, nous allons voir le motif de <em>mutabilit√© interne</em> dans lequel un
type immuable propose une API pour modifier une valeur interne. Nous allons aussi
parler des <em>boucles de r√©f√©rences</em>¬†: comment elles peuvent provoquer des fuites
de m√©moire et comment les √©viter.</p>
<!--
Let‚Äôs dive in!
-->
<p>Allons-y¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using `Box<T>` to Point to Data on the Heap
-->
<h2 id="utiliser-boxt-pour-pointer-sur-des-donn√©es-pr√©sentes-sur-le-tas"><a class="header" href="#utiliser-boxt-pour-pointer-sur-des-donn√©es-pr√©sentes-sur-le-tas">Utiliser <code>Box&lt;T&gt;</code> pour pointer sur des donn√©es pr√©sentes sur le tas</a></h2>
<!--
The most straightforward smart pointer is a *box*, whose type is written
`Box<T>`. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.
-->
<p>Le pointeur intelligent le plus simple est la <em>boite</em>, dont le type s'√©crit
<code>Box&lt;T&gt;</code>. Les boites vous permettent de stocker des donn√©es sur le tas plut√¥t
que sur la pile. La seule chose qui reste sur la pile est le pointeur vers les
donn√©es sur le tas. Revenez au chapitre 4 pour vous rappeler la diff√©rence entre
la pile et le tas.</p>
<!--
Boxes don‚Äôt have performance overhead, other than storing their data on the
heap instead of on the stack. But they don‚Äôt have many extra capabilities
either. You‚Äôll use them most often in these situations:
-->
<p>Les boites ne provoquent pas de surcharge au niveau des performances, si ce
n'est le stockage de leurs donn√©es sur le tas plut√¥t que sur la pile. Mais elles
n'ont pas non plus beaucoup plus de fonctionnalit√©s. Vous allez les utiliser
principalement dans les situations suivantes¬†:</p>
<!--
* When you have a type whose size can‚Äôt be known at compile time and you want
  to use a value of that type in a context that requires an exact size
* When you have a large amount of data and you want to transfer ownership but
  ensure the data won‚Äôt be copied when you do so
* When you want to own a value and you care only that it‚Äôs a type that
  implements a particular trait rather than being of a specific type
-->
<ul>
<li>Lorsque vous avez un type dont la taille ne peut pas √™tre connu au moment de
la compilation et que vous souhaitez une valeur d'un certain type dans un
contexte qui n√©cessite de savoir exactement sa taille</li>
<li>Lorsque vous avez une grosse quantit√© de donn√©es et que vous souhaitez
transf√©rer la possession tout en assurant que les donn√©es ne seront pas
copi√©es lorsque vous le ferez</li>
<li>Lorsque vous voulez prendre possession d'une valeur et que vous souhaitez
seulement qu'elle soit d'un type qui impl√©mente un trait particulier plut√¥t
que d'√™tre d'un type sp√©cique</li>
</ul>
<!--
We‚Äôll demonstrate the first situation in the [‚ÄúEnabling Recursive Types with
Boxes‚Äù](#enabling-recursive-types-with-boxes)<!-- ignore -- > section. In the
second case, transferring ownership of a large amount of data can take a long
time because the data is copied around on the stack. To improve performance in
this situation, we can store the large amount of data on the heap in a box.
Then, only the small amount of pointer data is copied around on the stack,
while the data it references stays in one place on the heap. The third case is
known as a *trait object*, and Chapter 17 devotes an entire section, [‚ÄúUsing
Trait Objects That Allow for Values of Different Types,‚Äù][trait-objects]<!--
ignore -- > just to that topic. So what you learn here you‚Äôll apply again in
Chapter 17!
-->
<p>Nous allons exp√©rimenter la premi√®re situation dans la section <a href="ch15-01-box.html#pouvoir-utiliser-des-types-r%C3%A9cursifs-gr%C3%A2ce-aux-boites">‚ÄúPouvoir
utiliser des types r√©cursifs gr√¢ce aux
boites‚Äù</a><!-- ignore -->.
Pour la seconde situation, le transfert de possession d'une grosse quantit√© de
donn√©es peut prendre beaucoup de temps car les donn√©es sont recopi√©es sur la
pile. Pour am√©liorer les performances dans cette situation, nous pouvons stocker
ces donn√©es sur le tas gr√¢ce √† une boite. Ainsi, seul le petit pointeur vers les
donn√©es est copi√© sur la pile, alors que les donn√©es qu'il pointe restent √† leur
place sur le tas. La troisi√®me situation d√©cris ce qu'on appelle un
<em>objet de trait</em> et le <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore --> d√©die une
section enti√®re √† ce sujet. Donc ce que vous apprenez ici, vous le retrouverez √†
nouveau au chapitre 17¬†!</p>
<!--
### Using a `Box<T>` to Store Data on the Heap
-->
<h3 id="utiliser-une-boxt-pour-stocker-des-donn√©es-sur-le-tas"><a class="header" href="#utiliser-une-boxt-pour-stocker-des-donn√©es-sur-le-tas">Utiliser une <code>Box&lt;T&gt;</code> pour stocker des donn√©es sur le tas</a></h3>
<!--
Before we discuss this use case for `Box<T>`, we‚Äôll cover the syntax and how to
interact with values stored within a `Box<T>`.
-->
<p>Avant de parler de ce cas d'usage de <code>Box&lt;T&gt;</code>, nous devons voir sa syntaxe et
comment interagir avec les valeurs stock√©es dans un <code>Box&lt;T&gt;</code>.</p>
<!--
Listing 15-1 shows how to use a box to store an `i32` value on the heap:
-->
<p>L'encart 15-1 nous montre comment utiliser une boite pour stocker une valeur
<code>i32</code> sur le tas¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-1: Storing an `i32` value on the heap using a
box</span>
-->
<p><span class="caption">Encart 15-1¬†: stocker une valeur <code>i32</code> sur le tas en
utilisant une bo√Æte</span></p>
<!--
We define the variable `b` to have the value of a `Box` that points to the
value `5`, which is allocated on the heap. This program will print `b = 5`; in
this case, we can access the data in the box similar to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as `b` does at the end of `main`, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).
-->
<p>Nous avons d√©fini la variable <code>b</code> pour avoir la valeur d'une <code>Box</code> qui pointe
sur la valeur <code>5</code>, qui est donc allou√©e sur le tas. Ce programme va afficher
<code>b = 5</code>¬†; dans ce cas, nous pouvons acc√©der √† la donn√©e pr√©sente dans la boite
de la m√™me mani√®re que nous le ferrions si elle √©tait sur la pile. Comme toute
valeur poss√©d√©e, lorsque une boite sort de la port√©e, comme lorsque <code>b</code> le fait
√† la fin du <code>main</code>, elle sera d√©sallou√©e. Ce sera la boite qui sera d√©sallou√©e
en premier (elle est stock√©e sur la pile), puis ce sera au tour des donn√©es sur
lesquelles elle pointait (qui sont stock√©es sur le tas).</p>
<!--
Putting a single value on the heap isn‚Äôt very useful, so you won‚Äôt use boxes by
themselves in this way very often. Having values like a single `i32` on the
stack, where they‚Äôre stored by default, is more appropriate in the majority of
situations. Let‚Äôs look at a case where boxes allow us to define types that we
wouldn‚Äôt be allowed to if we didn‚Äôt have boxes.
-->
<p>D√©poser une seule valeur sur le tas n'est pas tr√®s utile, donc vous n'utiliserez
que tr√®s rarement les boites de cette mani√®re. Laisser les valeurs comme des <code>i32</code>
ind√©pendantes sur la pile, o√π elles sont stock√©es par d√©faut, reste plus
appropri√© dans la majeure partie des situations. Regardons un cas o√π les boites
nous permettent de d√©finir des types que nous ne pourrions pas d√©finir si nous
n'avions pas les boites.</p>
<!--
### Enabling Recursive Types with Boxes
-->
<h3 id="pouvoir-utiliser-des-types-r√©cursifs-gr√¢ce-aux-boites"><a class="header" href="#pouvoir-utiliser-des-types-r√©cursifs-gr√¢ce-aux-boites">Pouvoir utiliser des types r√©cursifs gr√¢ce aux boites</a></h3>
<!--
At compile time, Rust needs to know how much space a type takes up. One type
whose size can‚Äôt be known at compile time is a *recursive type*, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesn‚Äôt know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, you can have recursive types.
-->
<p>Au moment de la compilation, Rust a besoin de savoir combien d'espace prend un
type. Un des types dont la taille ne peut pas √™tre connu au moment de la
compilation est le <em>type r√©cursif</em>, dans lequel une valeur peut avoir une partie
de sa d√©finition qui a une valeur du m√™me type qu'elle-m√™me. Comme cet embo√Ætement
de valeurs pourrait th√©oriquement se poursuivre √† l'infini, Rust ne sait pas
combien d'espace une valeur d'un type r√©cursif peut avoir besoin. Cependant, les
boites ont une taille connue, donc en utilisant une boite dans la d√©finition
d'un type r√©cursif, vous pouvez cr√©er des types r√©cursifs.</p>
<!--
Let‚Äôs explore the *cons list*, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
we‚Äôll define is straightforward except for the recursion; therefore, the
concepts in the example we‚Äôll work with will be useful any time you get into
more complex situations involving recursive types.
-->
<p>D√©couvrons maintenant la <em>liste de construction</em> (NdT¬†: cons list), qui est un
type de donn√©e courant dans les langages de programmation fonctionnels, comme
√©tant un exemple de type r√©cursif. Le type liste de construction que nous allons
d√©finir est plut√¥t simple, sauf pour les cas de r√©cursivit√©¬†; par cons√©quent,
les concepts dans l'exemple avec lequel nous allons travailler vous seront
utiles √† chaque fois que vous vous retrouverez dans des situations plus
complexes qui impliquent des types r√©cursifs.</p>
<!--
#### More Information About the Cons List
-->
<h4 id="en-savoir-plus-sur-les-listes-de-construction"><a class="header" href="#en-savoir-plus-sur-les-listes-de-construction">En savoir plus sur les listes de construction</a></h4>
<!--
A *cons list* is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the `cons` function (short for ‚Äúconstruct function‚Äù)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.
-->
<p>Une <em>liste de construction</em> est une structure de donn√©e qui provient du langage
de programmation Lisp et de ses d√©riv√©s. En Lisp, la fonction <code>cons</code> (qui est
une forme contract√©e de ‚Äúfonction de construction‚Äù) construit une nouvelle paire
√† partir de ses deux arguments, qui sont souvent une valeur individuelle et une
autre paire. Ces paires qui contiennent des paires forment des listes.</p>
<!--
The cons function concept has made its way into more general functional
programming jargon: ‚Äúto cons *x* onto *y*‚Äù informally means to construct a new
container instance by putting the element *x* at the start of this new
container, followed by the container *y*.
-->
<p>Le concept de la fonction cons a fait son chemin dans le jargon plus g√©n√©ral de
la programmation fonctionnelle¬†: &quot;to cons <em>x</em> onto <em>y</em>&quot; signifie de mani√®re
informelle de construire une nouvelle instance de conteneur en mettant l'√©l√©ment
<em>x</em> au d√©but de ce nouveau conteneur, suivi du conteneur <em>y</em>.</p>
<!--
Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called `Nil`
without a next item. A cons list is produced by recursively calling the `cons`
function. The canonical name to denote the base case of the recursion is `Nil`.
Note that this is not the same as the ‚Äúnull‚Äù or ‚Äúnil‚Äù concept in Chapter 6,
which is an invalid or absent value.
-->
<p>Chaque √©l√©ment dans une liste de construction contient deux √©l√©ments¬†: la valeur
de l'√©l√©ment courant et celle de l'√©l√©ment suivant. Le dernier √©l√©ment dans la
liste contient seulement une valeur <code>Nil</code> sans aucun √©l√©ment suivant. Une
liste de construction est produite de mani√®re r√©cursive en appelant la fonction
<code>cons</code>. Le nom canonique pour indiquer le cas de base de la r√©cursion est <code>Nil</code>.
Notez que ce n'est pas la m√™me chose que les concepts ‚Äúnull‚Äù ou ‚Äúnil‚Äù du
chapitre 6, qui signale une valeur invalide ou absente.</p>
<!--
Although functional programming languages use cons lists frequently, the cons
list isn‚Äôt a commonly used data structure in Rust. Most of the time when you
have a list of items in Rust, `Vec<T>` is a better choice to use. Other, more
complex recursive data types *are* useful in various situations, but by
starting with the cons list, we can explore how boxes let us define a recursive
data type without much distraction.
-->
<p>Bien que les langages de programmation fonctionnels utilisent les listes de
construction fr√©quemment, la liste de construction n'est pas une structure de
donn√©e utilis√©e couramment en Rust. La plupart du temps lorsque vous avez une
liste d'√©l√©ments en Rust, <code>Vec&lt;T&gt;</code> s'av√®re √™tre un meilleur choix √† faire.
Autrement, il existe des types de donn√©es r√©cursifs plus complexes <em>qui sont</em>
utiles dans d'autres situations, mais en commen√ßant avec les listes de
construction, nous pouvons d√©couvrir comment les boites nous permettent de
d√©finir un type de donn√©es r√©cursif sans √™tre trop perturb√© par la complexit√©.</p>
<!--
Listing 15-2 contains an enum definition for a cons list. Note that this code
won‚Äôt compile yet because the `List` type doesn‚Äôt have a known size, which
we‚Äôll demonstrate.
-->
<p>L'encart 15-2 propose une d√©finition d'une √©num√©ration pour une liste de
construction. Notez que ce code ne se compile pas encore car le type <code>List</code> n'a
pas encore de taille connue, ce que nous allons voir ensuite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, List),
    Nil,
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of `i32` values</span>
-->
<p><span class="caption">Encart 15-2¬†: premi√®re tentative de d√©finition d'une
√©num√©ration pour repr√©senter une structure de donn√©es de liste de construction
de valeurs <code>i32</code></span></p>
<!--
> Note: We‚Äôre implementing a cons list that holds only `i32` values for the
> purposes of this example. We could have implemented it using generics, as we
> discussed in Chapter 10, to define a cons list type that could store values of
> any type.
-->
<blockquote>
<p>Remarque¬†: nous impl√©mentons une liste de construction qui stocke uniquement
des valeurs <code>i32</code> pour les besoins de cet exemple. Nous aurions pu
l'impl√©menter en utilisant des g√©n√©riques, que nous avons vu chapitre 10, afin
de d√©finir une liste de construction qui pourrait stocker n'importe quel type.</p>
</blockquote>
<!--
Using the `List` type to store the list `1, 2, 3` would look like the code in
Listing 15-3:
-->
<p>L'utilisation du type <code>List</code> pour stocker la liste <code>1, 2, 3</code> ressemblerait au
code dans l'encart 15-3¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# enum List {
#     Cons(i32, List),
#     Nil,
# }
# 
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<!--
<span class="caption">Listing 15-3: Using the `List` enum to store the list `1,
2, 3`</span>
-->
<p><span class="caption">Encart 15-3¬†: utilisation de l'√©num√©ration <code>List</code> pour
stocker la liste <code>1, 2, 3</code></span></p>
<!--
The first `Cons` value holds `1` and another `List` value. This `List` value is
another `Cons` value that holds `2` and another `List` value. This `List` value
is one more `Cons` value that holds `3` and a `List` value, which is finally
`Nil`, the non-recursive variant that signals the end of the list.
-->
<p>La premi√®re valeur <code>Cons</code> stocke <code>1</code> et une autre valeur de <code>List</code>. Cette
valeur <code>List</code> est une autre valeur <code>Cons</code> qui stocke <code>2</code> et une autre valeur de
<code>List</code>. Cette valeur <code>List</code> n'est rien d'autre qu'une valeur <code>Cons</code> qui stocke
<code>3</code> et une valeur <code>List</code>, qui finalement est <code>Nil</code>, la variante non r√©cursive
qui signale la fin de la liste.</p>
<!--
If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:
-->
<p>Si nous essayons de compiler le code de l'encart 15-3, nous avons l'erreur de
l'encart 15-4¬†:</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 -- > src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 -- > src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<!--
<span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span>
-->
<p><span class="caption">Encart 15-4¬†: l'erreur que nous obtenons lorsque nous
essayons de d√©finir une √©num√©ration r√©cursive</span></p>
<!--
The error shows this type ‚Äúhas infinite size.‚Äù The reason is that we‚Äôve defined
`List` with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can‚Äôt figure out how much space it needs to store a
`List` value. Let‚Äôs break down why we get this error a bit. First, let‚Äôs look
at how Rust decides how much space it needs to store a value of a non-recursive
type.
-->
<p>L'erreur explique que ce type ‚Äúa une taille infinie‚Äù. La raison est que nous
avons d√©fini <code>List</code> avec une variante qui est r√©cursive¬†: elle stocke
directement une autre valeur d'elle-m√™me. Au final, Rust ne peut pas savoir
combien de place il a besoin pour stocker une valeur <code>List</code>. Analysons
pourquoi nous obtenons cette erreur. D'abord, regardons comment Rust d√©cide de
l'espace dont il a besoin pour stocker une valeur d'un type non r√©cursif.</p>
<!--
#### Computing the Size of a Non-Recursive Type
-->
<h4 id="calculer-la-taille-dun-type-non-r√©cursif"><a class="header" href="#calculer-la-taille-dun-type-non-r√©cursif">Calculer la taille d'un type non r√©cursif</a></h4>
<!--
Recall the `Message` enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:
-->
<p>Rappelez-vous de l'√©num√©ration <code>Message</code> que nous avons d√©fini dans
l'encart 6-2 lorsque nous avons abord√© les d√©finitions des √©num√©rations au
chapitre 6¬†:</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
To determine how much space to allocate for a `Message` value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that `Message::Quit` doesn‚Äôt need any space, `Message::Move` needs enough
space to store two `i32` values, and so forth. Because only one variant will be
used, the most space a `Message` value will need is the space it would take to
store the largest of its variants.
-->
<p>Pour d√©terminer combien d'espace allouer pour une valeur <code>Message</code>, Rust
parcourt chaque variante pour voir quelle variante a besoin le plus d'espace.
Rust voit que <code>Message::Quitter</code> n'a pas besoin d'espace, <code>Message::Deplacer</code> a
besoin de suffisamment d'espace pour stocker deux valeurs <code>i32</code>, et ainsi de
suite. Comme une seule variante sera utilis√©e, le plus grand espace dont une
valeur de <code>Message</code> aura besoin sera l'espace que cela prendra de stocker la
plus grosse de ses variantes.</p>
<!--
Contrast this with what happens when Rust tries to determine how much space a
recursive type like the `List` enum in Listing 15-2 needs. The compiler starts
by looking at the `Cons` variant, which holds a value of type `i32` and a value
of type `List`. Therefore, `Cons` needs an amount of space equal to the size of
an `i32` plus the size of a `List`. To figure out how much memory the `List`
type needs, the compiler looks at the variants, starting with the `Cons`
variant. The `Cons` variant holds a value of type `i32` and a value of type
`List`, and this process continues infinitely, as shown in Figure 15-1.
-->
<p>Comparez cela avec ce qui se passe lorsque Rust essaye de d√©terminer combien
d'espace un type r√©cursif comme l'√©num√©ration <code>List</code> de l'encart 15-2 aurait
besoin. Le compilateur commence par regarder la variante <code>Cons</code>, qui stocke une
valeur de type <code>i32</code> et une valeur de type <code>List</code>. Ainsi, <code>Cons</code> a besoin d'une
quantit√© d'espace √©gale √† la taille d'un <code>i32</code> plus la taille d'une valeur
<code>List</code>. Pour savoir combien de m√©moire le type <code>List</code> a besoin, le compilateur
va regarder ses variantes, en commen√ßant avec la variante <code>Cons</code>. La variante
<code>Cons</code> stocke une valeur de type <code>i32</code> et une valeur de type <code>List</code>, et ce
processus continue √† l'infini, comme l'illustration 15-1.</p>
<!-- markdownlint-disable -->
<!--
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une liste de construction infinie"
    src="img/trpl15-01.svg"
    class="center"
    style="width: 50%;" /></p>
<!--
<span class="caption">Figure 15-1: An infinite `List` consisting of infinite
`Cons` variants</span>
-->
<p><span class="caption">Illustration 15-1¬†: une <code>List</code> infinie qui contient des
variantes <code>Cons</code> infinies</span></p>
<!--
#### Using `Box<T>` to Get a Recursive Type with a Known Size
-->
<h4 id="utiliser-boxt-pour-cr√©er-un-type-r√©cursif-avec-une-taille-finie"><a class="header" href="#utiliser-boxt-pour-cr√©er-un-type-r√©cursif-avec-une-taille-finie">Utiliser <code>Box&lt;T&gt;</code> pour cr√©er un type r√©cursif avec une taille finie</a></h4>
<!--
Rust can‚Äôt figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:
-->
<p>Rust ne peut pas calculer la quantit√© d'espace √† allouer pour les types
d√©finis r√©cursivement, donc le compilateur d√©clenche l'erreur de l'encart
15-4. Mais l'erreur renferme cette suggestion tr√®s utile¬†:</p>
<!--
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-- >
-->
<!--
```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ^^^^    ^
```
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ^^^^    ^
</code></pre>
<!--
In this suggestion, ‚Äúindirection‚Äù means that instead of storing a value
directly, we‚Äôll change the data structure to store the value indirectly by
storing a pointer to the value instead.
-->
<p>Dans cette suggestion, ‚Äúindirection‚Äù (NdT¬†: redirection) signifie qu'au lieu de
stocker une valeur directement, nous devrions changer la structure des donn√©es
pour stocker √† la place un pointeur vers la valeur.</p>
<!--
Because a `Box<T>` is a pointer, Rust always knows how much space a `Box<T>`
needs: a pointer‚Äôs size doesn‚Äôt change based on the amount of data it‚Äôs
pointing to. This means we can put a `Box<T>` inside the `Cons` variant instead
of another `List` value directly. The `Box<T>` will point to the next `List`
value that will be on the heap rather than inside the `Cons` variant.
Conceptually, we still have a list, created with lists ‚Äúholding‚Äù other lists,
but this implementation is now more like placing the items next to one another
rather than inside one another.
-->
<p>Comme <code>Box&lt;T&gt;</code> est un pointeur, Rust conna√Æt toujours combien d'espace un
<code>Box&lt;T&gt;</code> a besoin¬†: la taille d'un pointeur ne change pas, peu importe la
quantit√© de donn√©es sur lesquelles il pointe. Cela signifie que nous pouvons
ins√©rer un <code>Box&lt;T&gt;</code> √† l'int√©rieur d'une variante <code>Cons</code> au lieu d'y mettre
directement une autre valeur <code>List</code>. Le <code>Box&lt;T&gt;</code> va pointer sur la prochaine
valeur <code>List</code> qui sera sur le tas plut√¥t que d'√™tre dans la variante <code>Cons</code>.
Th√©oriquement, nous avons toujours une liste, cr√©√©e avec des listes qui
‚Äúcontiennent‚Äù d'autres listes, mais cette impl√©mentation ressemble plus √†
pr√©sent √† des √©l√©ments plac√©s les uns √† c√¥t√© des autres plut√¥t que les uns dans
les autres.</p>
<!--
We can change the definition of the `List` enum in Listing 15-2 and the usage
of the `List` in Listing 15-3 to the code in Listing 15-5, which will compile:
-->
<p>Nous pouvons changer la d√©finition de l'√©num√©ration <code>List</code> de l'encart 15-2 et
l'utilisation de <code>List</code> dans l'encart 15-3 pour le code de l'encart 15-5, qui
va se compiler¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Filename¬†: src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-5: Definition of `List` that uses `Box<T>` in
order to have a known size</span>
-->
<p><span class="caption">Encart 15-5¬†: d√©finition de <code>List</code> qui utilise <code>Box&lt;T&gt;</code>
dans le but d'avoir une taille connue</span></p>
<!--
The `Cons` variant will need the size of an `i32` plus the space to store the
box‚Äôs pointer data. The `Nil` variant stores no values, so it needs less space
than the `Cons` variant. We now know that any `List` value will take up the
size of an `i32` plus the size of a box‚Äôs pointer data. By using a box, we‚Äôve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a `List` value. Figure 15-2 shows what the `Cons` variant
looks like now.
-->
<p>La variante <code>Cons</code> va avoir besoin de l'espace d'un <code>i32</code> plus l'espace pour
stocker le pointeur vers la donn√©e de la boite. La variante <code>Nil</code> ne stocke pas
de valeurs, donc elle a besoin de moins d'espace que la variante <code>Cons</code>. Nous
savons maintenant que chaque valeur <code>List</code> va prendre la taille d'un <code>i32</code>
plus la taille d'un pointeur vers la donn√©e de la boite. En utilisant une boite,
vous avez arr√™t√© la chaine infinie et r√©cursive, donc le compilateur peut
savoir l'espace dont il a besoin pour stocker une valeur <code>List</code>. L'illustration
15-2 montre √† quoi ressemble maintenant la variante <code>Cons</code>.</p>
<!--
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
-->
<p><img
    alt="Une liste de construction finie"
    src="img/trpl15-02.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-2: A `List` that is not infinitely sized
because `Cons` holds a `Box`</span>
-->
<p><span class="caption">Illustration 15-2¬†: une <code>List</code> qui n'a pas de taille
infinie car <code>Cons</code> est une <code>Box</code></span></p>
<!--
Boxes provide only the indirection and heap allocation; they don‚Äôt have any
other special capabilities, like those we‚Äôll see with the other smart pointer
types. They also don‚Äôt have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We‚Äôll look at more use cases for boxes
in Chapter 17, too.
-->
<p>Les boites fournissent uniquement la redirection et l'allocation sur le tas¬†;
elles n'ont pas d'autres fonctionnalit√©s, comme celles que nous verrons sur
d'autres types de pointeurs intelligents. Elles n'ont pas non plus de surco√ªt
sur les performances autre que ce qu'offrent ces capacit√©s sp√©ciales, donc
elles sont utiles dans des cas comme les listes de construction o√π la
redirection est la seule fonctionnalit√© que nous avons besoin. Nous verrons
aussi plus de cas d'usages pour les boites dans le chapitre 17.</p>
<!--
The `Box<T>` type is a smart pointer because it implements the `Deref` trait,
which allows `Box<T>` values to be treated like references. When a `Box<T>`
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the `Drop` trait implementation. Let‚Äôs explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types we‚Äôll discuss in the
rest of this chapter.
-->
<p>Le type <code>Box&lt;T&gt;</code> est un pointeur intelligent car il impl√©mente le trait
<code>Deref</code>, qui permet aux valeurs <code>Box&lt;T&gt;</code> d'√™tre trait√©es comme des
r√©f√©rences. Lorsque une valeur <code>Box&lt;T&gt;</code> sort de la port√©e, les donn√©es sur le
tas point√©es par la boite seront √©galement nettoy√©es gr√¢ce √† l'impl√©mentation
du trait <code>Drop</code>. Explorons plus en d√©tail ces deux traits. Ces deux traits
deviendrons encore plus importants pour les fonctionnalit√©s offertes par les
autres pointeurs intelligents que nous verrons dans le reste de ce chapitre.</p>
<!-- markdownlint-disable -->
<!--
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## Treating Smart Pointers Like Regular References with the `Deref` Trait
-->
<h2 id="consid√©rer-les-pointeurs-intelligents-comme-des-r√©f√©rences-gr√¢ce-au-trait-deref"><a class="header" href="#consid√©rer-les-pointeurs-intelligents-comme-des-r√©f√©rences-gr√¢ce-au-trait-deref">Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait <code>Deref</code></a></h2>
<!--
Implementing the `Deref` trait allows you to customize the behavior of the
*dereference operator*, `*` (as opposed to the multiplication or glob
operator). By implementing `Deref` in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.
-->
<p>L'impl√©mentation du trait <code>Deref</code> vous permet de personnaliser le comportement
de <em>l'op√©rateur de d√©r√©f√©rencement</em> <code>*</code> (qui n'est pas l'op√©rateur de
multiplication ou le joker global). En impl√©mentant <code>Deref</code> de mani√®re √† ce
qu'un pointeur intelligent puisse √™tre consid√©r√© comme une r√©f√©rence classique,
vous pouvez √©crire du code qui fonctionne avec des r√©f√©rences mais aussi avec
des pointeurs intelligents.</p>
<!--
Let‚Äôs first look at how the dereference operator works with regular references.
Then we‚Äôll try to define a custom type that behaves like `Box<T>`, and see why
the dereference operator doesn‚Äôt work like a reference on our newly defined
type. We‚Äôll explore how implementing the `Deref` trait makes it possible for
smart pointers to work in ways similar to references. Then we‚Äôll look at
Rust‚Äôs *deref coercion* feature and how it lets us work with either references
or smart pointers.
-->
<p>Regardons d'abord comment l'op√©rateur de d√©r√©f√©rencement fonctionne avec des
r√©f√©rences classiques. Ensuite nous essayerons de d√©finir un type personnalis√©
qui se comporte comme <code>Box&lt;T&gt;</code> et voir pourquoi l'op√©rateur de d√©r√©f√©rencement
ne fonctionne pas comme une r√©f√©rence sur notre type fra√Æchement d√©fini. Nous
allons d√©couvrir comment impl√©menter le trait <code>Deref</code> de mani√®re √† ce qu'il soit
possible que les pointeurs intelligents fonctionnent comme les r√©f√©rences.
Ensuite nous verrons la fonctionnalit√© d'<em>extrapolation de d√©r√©f√©rencement</em> de
Rust et comment elle nous permet de travailler √† la fois avec des
r√©f√©rences et des pointeurs intelligents.</p>
<!--
> Note: there‚Äôs one big difference between the `MyBox<T>` type we‚Äôre about to
> build and the real `Box<T>`: our version will not store its data on the heap.
> We are focusing this example on `Deref`, so where the data is actually stored
> is less important than the pointer-like behavior.
-->
<blockquote>
<p>Remarque¬†: il y a une grosse diff√©rence entre le type <code>MaBoite&lt;T&gt;</code> que nous
allons construire et la vraie <code>Box&lt;T&gt;</code>¬†: notre version ne va pas stocker ses
donn√©es sur le tas. Nous allons concentrer cet exemple sur <code>Deref</code>, donc
l'endroit o√π est concr√®tement stock√© la donn√©e est moins important que le
comportement similaire aux pointeurs.</p>
</blockquote>
<!--
### Following the Pointer to the Value with the Dereference Operator
-->
<h3 id="suivre-le-pointeur-vers-la-valeur-gr√¢ce-√†-lop√©rateur-de-d√©r√©f√©rencement"><a class="header" href="#suivre-le-pointeur-vers-la-valeur-gr√¢ce-√†-lop√©rateur-de-d√©r√©f√©rencement">Suivre le pointeur vers la valeur gr√¢ce √† l'op√©rateur de d√©r√©f√©rencement</a></h3>
<!--
A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an `i32` value and then use the dereference operator to follow the
reference to the data:
-->
<p>Une r√©f√©rence classique est un type de pointeur, et une mani√®re de mod√©liser un
pointeur est d'imaginer une fl√®che pointant vers une valeur stock√©e autre part.
Dans l'encart 15-6, nous cr√©ons une r√©f√©rence vers une valeur <code>i32</code> et utilisons
ensuite l'op√©rateur de d√©r√©f√©rencement pour suivre la r√©f√©rence vers la donn√©e¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an `i32` value</span>
-->
<p><span class="caption">Encart 15-6¬†: utiliser l'op√©rateur de d√©r√©f√©rencement pour
suivre une r√©f√©rence vers une valeur <code>i32</code></span></p>
<!--
The variable `x` holds an `i32` value, `5`. We set `y` equal to a reference to
`x`. We can assert that `x` is equal to `5`. However, if we want to make an
assertion about the value in `y`, we have to use `*y` to follow the reference
to the value it‚Äôs pointing to (hence *dereference*). Once we dereference `y`,
we have access to the integer value `y` is pointing to that we can compare with
`5`.
-->
<p>La variable <code>x</code> stocke une valeur <code>i32</code>¬†: <code>5</code>. Nous avons assign√© √† <code>y</code> une
r√©f√©rence vers <code>x</code>. Nous pouvons faire une <code>assert</code> pour v√©rifier que <code>x</code> est
√©gal √† <code>5</code>. Cependant, si nous souhaitons faire une <code>assert</code> sur la valeur dans
<code>y</code>, nous devons utiliser <code>*y</code> pour suivre la r√©f√©rence vers la valeur sur
laquelle elle pointe (d'o√π le <em>d√©r√©f√©rencement</em>). Une fois que nous avons
d√©r√©f√©renc√© <code>y</code>, nous avons acc√®s √† la valeur de l'entier sur laquelle <code>y</code>
pointe afin que nous puissions la comparer avec <code>5</code>.</p>
<!--
If we tried to write `assert_eq!(5, y);` instead, we would get this compilation
error:
-->
<p>Si nous avions essay√© d'√©crire <code>assert_eq!(5, y);</code> √† la place, nous aurions
obtenu cette erreur de compilation¬†:</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 -- > src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
</code></pre>
<!--
Comparing a number and a reference to a number isn‚Äôt allowed because they‚Äôre
different types. We must use the dereference operator to follow the reference
to the value it‚Äôs pointing to.
-->
<p>Comparer un nombre et une r√©f√©rence vers un nombre n'est pas autoris√© car ils
sont de types diff√©rents. Nous devons utiliser l'op√©rateur de d√©r√©f√©rencement
pour suivre la r√©f√©rence vers la valeur sur laquelle elle pointe.</p>
<!--
### Using `Box<T>` Like a Reference
-->
<h3 id="utiliser-boxt-comme-√©tant-une-r√©f√©rence"><a class="header" href="#utiliser-boxt-comme-√©tant-une-r√©f√©rence">Utiliser <code>Box&lt;T&gt;</code> comme √©tant une r√©f√©rence</a></h3>
<!--
We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a
reference; the dereference operator will work as shown in Listing 15-7:
-->
<p>Nous pouvons r√©√©crire le code l'encart 15-6 pour utiliser une <code>Box&lt;T&gt;</code> au lieu
d'une r√©f√©rence¬†; l'op√©rateur de d√©r√©f√©rencement devrait fonctionner comme
montr√© dans l'encart 15-7¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-7: Using the dereference operator on a
`Box<i32>`</span>
-->
<p><span class="caption">Encart 15-7¬†: utilisation de l'op√©rateur de
d√©r√©f√©rencement sur un <code>Box&lt;i32&gt;</code></span></p>
<!--
The main difference between Listing 15-7 and Listing 15-6 is that here we set
`y` to be an instance of a box pointing to a copied value of `x` rather than a
reference pointing to the value of `x`. In the last assertion, we can use the
dereference operator to follow the box‚Äôs pointer in the same way that we did
when `y` was a reference. Next, we‚Äôll explore what is special about `Box<T>`
that enables us to use the dereference operator by defining our own box type.
-->
<p>La principale diff√©rence entre l'encart 15-7 et l'encart 15-6 est qu'ici nous
avons fait en sorte que <code>y</code> soit une instance de boite qui pointe sur une copie
de la valeur de <code>x</code> plut√¥t qu'avoir une r√©f√©rence vers la valeur de <code>x</code>. Dans
la derni√®re assertion, nous pouvons utiliser l'op√©rateur de d√©r√©f√©rencement
pour suivre le pointeur de la boite de la m√™me mani√®re que nous l'avons fait
lorsque <code>y</code> √©tait une r√©f√©rence. Maintenant, nous allons regarder ce qu'il y a
de si sp√©cial dans <code>Box&lt;T&gt;</code> qui nous permet d'utiliser l'op√©rateur de
d√©r√©f√©rencement en d√©finissant notre propre type de boite.</p>
<!--
### Defining Our Own Smart Pointer
-->
<h3 id="d√©finir-notre-propre-pointeur-intelligent"><a class="header" href="#d√©finir-notre-propre-pointeur-intelligent">D√©finir notre propre pointeur intelligent</a></h3>
<!--
Let‚Äôs build a smart pointer similar to the `Box<T>` type provided by the
standard library to experience how smart pointers behave differently from
references by default. Then we‚Äôll look at how to add the ability to use the
dereference operator.
-->
<p>Construisons un pointeur intelligent similaire au type <code>Box&lt;T&gt;</code> fourni par la
biblioth√®que standard pour apprendre comment les pointeurs intelligents se
comportent diff√©remment des r√©f√©rences classiques. Ensuite nous regarderons
comment lui ajouter la possibilit√© d'utiliser l'op√©rateur de d√©r√©f√©rencement.</p>
<!--
The `Box<T>` type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a `MyBox<T>` type in the same way. We‚Äôll also define a
`new` function to match the `new` function defined on `Box<T>`.
-->
<p>Le type <code>Box&lt;T&gt;</code> est essentiellement d√©fini comme √©tant une structure de tuple
d'un seul √©l√©ment, donc l'encart 15-8 d√©finit un type <code>MaBoite&lt;T&gt;</code> de la m√™me
mani√®re. Nous allons aussi d√©finir une fonction <code>new</code> pour correspondre √† la
fonction <code>new</code> d√©finie sur <code>Box&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MaBoite&lt;T&gt;(T);

impl&lt;T&gt; MaBoite&lt;T&gt; {
    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
        MaBoite(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-8: Defining a `MyBox<T>` type</span>
-->
<p><span class="caption">Encart 15-8¬†: d√©finition du type <code>MaBoite&lt;T&gt;</code></span></p>
<!--
We define a struct named `MyBox` and declare a generic parameter `T`, because
we want our type to hold values of any type. The `MyBox` type is a tuple struct
with one element of type `T`. The `MyBox::new` function takes one parameter of
type `T` and returns a `MyBox` instance that holds the value passed in.
-->
<p>Nous d√©finissons une structure <code>MaBoite</code> et on d√©clare un param√®tre g√©n√©rique
<code>T</code>, car nous souhaitons que notre type stocke des valeurs de n'importe quel
type. Le type <code>MaBoite</code> est une structure de tuple avec un seul √©l√©ment de type
<code>T</code>. La fonction <code>MaBoite::new</code> prend un param√®tre de type <code>T</code> et retourne une
instance <code>MaBoite</code> qui stocke la valeur qui lui est pass√©e.</p>
<!--
Let‚Äôs try adding the `main` function in Listing 15-7 to Listing 15-8 and
changing it to use the `MyBox<T>` type we‚Äôve defined instead of `Box<T>`. The
code in Listing 15-9 won‚Äôt compile because Rust doesn‚Äôt know how to dereference
`MyBox`.
-->
<p>Essayons d'ajouter la fonction <code>main</code> de l'encart 15-7 dans l'encart 15-8 et la
modifier pour utiliser le type <code>MaBoite&lt;T&gt;</code> que nous avons d√©fini √† la place de
<code>Box&lt;T&gt;</code>. Le code de l'encart 15-9 ne se compile pas car Rust ne sait pas
comment d√©r√©f√©rencer <code>MaBoite</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MaBoite::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<!--
<span class="caption">Listing 15-9: Attempting to use `MyBox<T>` in the same
way we used references and `Box<T>`</span>
-->
<p><span class="caption">Encart 15-9¬†: tentative d'utiliser <code>MaBoite&lt;T&gt;</code> de la m√™me
mani√®re que nous avions utilis√© les r√©f√©rences et <code>Box&lt;T&gt;</code></span></p>
<!--
Here‚Äôs the resulting compilation error:
-->
<p>Voici l'erreur de compilation qui en r√©sulte¬†:</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  -- > src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MaBoite&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
</code></pre>
<!--
Our `MyBox<T>` type can‚Äôt be dereferenced because we haven‚Äôt implemented that
ability on our type. To enable dereferencing with the `*` operator, we
implement the `Deref` trait.
-->
<p>Notre type <code>MaBoite&lt;T&gt;</code> ne peut pas √™tre d√©r√©f√©renc√©e car nous n'avons pas
impl√©ment√© cette fonctionnalit√© sur notre type. Pour permettre le
d√©r√©f√©rencement avec l'op√©rateur <code>*</code>, nous devons impl√©menter le trait <code>Deref</code>.</p>
<!--
### Treating a Type Like a Reference by Implementing the `Deref` Trait
-->
<h3 id="consid√©rer-un-type-comme-une-r√©f√©rence-en-impl√©mentant-le-trait-deref"><a class="header" href="#consid√©rer-un-type-comme-une-r√©f√©rence-en-impl√©mentant-le-trait-deref">Consid√©rer un type comme une r√©f√©rence en impl√©mentant le trait <code>Deref</code></a></h3>
<!--
As discussed in the [‚ÄúImplementing a Trait on a Type‚Äù][impl-trait]<!-- ignore
-- > section of Chapter 10, to implement a trait, we need to provide
implementations for the trait‚Äôs required methods. The `Deref` trait, provided
by the standard library, requires us to implement one method named `deref` that
borrows `self` and returns a reference to the inner data. Listing 15-10
contains an implementation of `Deref` to add to the definition of `MyBox`:
-->
<p>Comme nous l'avons vu dans une section du <a href="ch10-02-traits.html">chapitre 10</a><!-- ignore
-->, pour impl√©menter un trait, nous devons fournir les impl√©mentations des
m√©thodes n√©cessaires pour ce trait. Le trait <code>Deref</code>, fourni par la
biblioth√®que standard, n√©cessite que nous impl√©mentions une m√©thode <code>deref</code> qui
emprunte <code>self</code> et retourne une r√©f√©rence vers la donn√©e interne.
L'encart 15-10 contient une impl√©mentation de <code>Deref</code> √† ajouter √† la d√©finition
de <code>MaBoite</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn main() {
#     let x = 5;
#     let y = MyBox::new(x);
# 
#     assert_eq!(5, x);
#     assert_eq!(5, *y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MaBoite::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-10: Implementing `Deref` on `MyBox<T>`</span>
-->
<p><span class="caption">Encart 15-10¬†: impl√©mentation de <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code>
</span></p>
<!--
The `type Target = T;` syntax defines an associated type for the `Deref` trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don‚Äôt need to worry about them for now; we‚Äôll cover them in
more detail in Chapter 19.
-->
<p>La syntaxe <code>type Target = T;</code> d√©finit un type associ√© pour le trait <code>Deref</code> √†
utiliser. Les types associ√©s sont une mani√®re l√©g√®rement diff√©rente de d√©clarer
un param√®tre g√©n√©rique, mais vous n'avez pas √† vous pr√©occuper d'eux pour le
moment¬†; nous les verrons plus en d√©tail au chapitre 19.</p>
<!--
We fill in the body of the `deref` method with `&self.0` so `deref` returns a
reference to the value we want to access with the `*` operator. Recall from the
[‚ÄúUsing Tuple Structs without Named Fields to Create Different
Types‚Äù][tuple-structs]<!-- ignore -- > section of Chapter 5 that `.0` accesses
the first value in a tuple struct. The `main` function in Listing 15-9 that
calls `*` on the `MyBox<T>` value now compiles, and the assertions pass!
-->
<p>Nous renseignons le corps de la m√©thode <code>deref</code> avec <code>&amp;self.0</code> afin que <code>deref</code>
retourne une r√©f√©rence vers la valeur que nous souhaitons acc√©der avec
l'op√©rateur <code>*</code>. Rappellez-vous de la section du
<a href="ch05-01-defining-structs.html">chapitre 5</a><!-- ignore --> o√π nous avons appris que le <code>.0</code>
acc√®de √† la premi√®re valeur d'une structure tuple. La fonction <code>main</code> de
l'encart 15-9 qui appelle <code>*</code> sur la valeur <code>MaBoite&lt;T&gt;</code> se compile d√©sormais,
et le <code>assert</code> r√©ussit aussi¬†!</p>
<!--
Without the `Deref` trait, the compiler can only dereference `&` references.
The `deref` method gives the compiler the ability to take a value of any type
that implements `Deref` and call the `deref` method to get a `&` reference that
it knows how to dereference.
-->
<p>Sans le trait <code>Deref</code>, le compilateur peut seulement d√©r√©f√©rencer des r√©f√©rences
<code>&amp;</code>. La m√©thode <code>deref</code> donne la possibilit√© au compilateur d'obtenir la valeur
de n'importe quel type qui impl√©mente <code>Deref</code> en appelant la m√©thode <code>deref</code>
pour obtenir une r√©f√©rence <code>&amp;</code> qu'il sait comment d√©r√©f√©rencer.</p>
<!--
When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this
code:
-->
<p>Lorsque nous avons pr√©cis√© <code>*y</code> dans l'encart 15-9, Rust fait tourner ce code en
coulisses¬†:</p>
<!--
```rust,ignore
*(y.deref())
```
-->
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!--
Rust substitutes the `*` operator with a call to the `deref` method and then a
plain dereference so we don‚Äôt have to think about whether or not we need to
call the `deref` method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
`Deref`.
-->
<p>Rust remplace l'op√©rateur <code>*</code> par un appel √† la m√©thode <code>deref</code> suivi par un
simple d√©r√©f√©rencement afin que nous n'ayons pas √† nous demander si nous devons
ou non appeler la m√©thode <code>deref</code>. Cette fonctionnalit√© de Rust nous permet
d'√©crire du code qui fonctionne de mani√®re identique que nous ayons une
r√©f√©rence classique ou un type qui impl√©mente <code>Deref</code>.</p>
<!--
The reason the `deref` method returns a reference to a value, and that the plain
dereference outside the parentheses in `*(y.deref())` is still necessary, is the
ownership system. If the `deref` method returned the value directly instead of
a reference to the value, the value would be moved out of `self`. We don‚Äôt want
to take ownership of the inner value inside `MyBox<T>` in this case or in most
cases where we use the dereference operator.
-->
<p>La raison pour laquelle la m√©thode <code>deref</code> retourne une r√©f√©rence √† une valeur,
et que le d√©r√©f√©rencement du tout dans les parenth√®ses externes de
<code>*(y.deref())</code> reste n√©cessaire, est le syst√®me de possession. Si la m√©thode
<code>deref</code> retournait la valeur directement au lieu d'une r√©f√©rence √† cette valeur,
la valeur serait <em>d√©plac√©e</em> √† l'ext√©rieur de <code>self</code>. Nous ne souhaitons pas
prendre possession de la valeur √† l'int√©rieur de <code>MaBoite&lt;T&gt;</code> dans ce cas ainsi
que la plupart des cas o√π nous utilisons l'op√©rateur de d√©r√©f√©rencement.</p>
<!--
Note that the `*` operator is replaced with a call to the `deref` method and
then a call to the `*` operator just once, each time we use a `*` in our code.
Because the substitution of the `*` operator does not recurse infinitely, we
end up with data of type `i32`, which matches the `5` in `assert_eq!` in
Listing 15-9.
-->
<p>Notez que l'op√©rateur <code>*</code> est remplac√© par un appel √† la m√©thode <code>deref</code> suivi
par un appel √† l'op√©rateur <code>*</code> une seule fois, √† chaque fois que nous utilisons
un <code>*</code> dans notre code. Comme la substitution de l'op√©rateur <code>*</code> ne s'effectue
pas de mani√®re r√©cursive et infinie, nous r√©cup√®rerons une donn√©e de type <code>i32</code>,
qui correspond au <code>5</code> du <code>assert_eq!</code> de l'encart 15-9.</p>
<!--
### Implicit Deref Coercions with Functions and Methods
-->
<h3 id="extrapolation-de-d√©r√©f√©rencement-implicite-avec-les-fonctions-et-les-m√©thodes"><a class="header" href="#extrapolation-de-d√©r√©f√©rencement-implicite-avec-les-fonctions-et-les-m√©thodes">Extrapolation de d√©r√©f√©rencement implicite avec les fonctions et les m√©thodes</a></h3>
<!--
*Deref coercion* is a convenience that Rust performs on arguments to functions
and methods. Deref coercion works only on types that implement the `Deref`
trait. Deref coercion converts a reference to such a type into a reference to
another type. For example, deref coercion can convert `&String` to `&str`
because `String` implements the `Deref` trait such that it returns `&str`.
Deref coercion happens automatically when we pass a reference to a particular
type‚Äôs value as an argument to a function or method that doesn‚Äôt match the
parameter type in the function or method definition. A sequence of calls to the
`deref` method converts the type we provided into the type the parameter needs.
-->
<p>L'<em>extrapolation de d√©r√©f√©rencement</em> est une commodit√© que Rust applique sur les
arguments des fonctions et des m√©thodes. L'extrapolation de d√©r√©f√©rencement
fonctionne uniquement avec un type qui impl√©mente le trait <code>Deref</code>.
L'extrapolation de d√©r√©f√©rencement convertit une r√©f√©rence vers ce type en une
r√©f√©rence vers un autre type. Par exemple, l'extrapolation de d√©r√©f√©rencement
peut convertir <code>&amp;String</code> en <code>&amp;str</code> car <code>String</code> impl√©mente le trait <code>Deref</code> de
sorte qu'il puisse retourner <code>&amp;str</code>. L'extrapolation de d√©r√©f√©rencement
s'applique automatiquement lorsque nous passons une r√©f√©rence vers une valeur
d'un type particulier en argument d'une fonction ou d'une m√©thode qui ne
correspond pas √† ce type de param√®tre dans la d√©finition de la fonction ou de
la m√©thode. Une s√©rie d'appels √† la m√©thode <code>deref</code> convertit le type que nous
donnons dans le type que le param√®tre n√©cessite.</p>
<!--
Deref coercion was added to Rust so that programmers writing function and
method calls don‚Äôt need to add as many explicit references and dereferences
with `&` and `*`. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.
-->
<p>L'extrapolation de d√©r√©f√©rencement a √©t√© ajout√©e √† Rust afin de permettre aux
d√©veloppeurs d'√©crire des appels de fonctions et de m√©thodes qui n'ont pas
besoin d'indiquer explicitement les r√©f√©rences et les d√©r√©f√©rencements avec <code>&amp;</code>
et <code>*</code>. La fonctionnalit√© d'extrapolation de d√©r√©f√©rencement nous permet aussi
d'√©crire plus de code qui peut fonctionner √† la fois pour les r√©f√©rences et pour
les pointeurs intelligents.</p>
<!--
To see deref coercion in action, let‚Äôs use the `MyBox<T>` type we defined in
Listing 15-8 as well as the implementation of `Deref` that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:
-->
<p>Pour voir l'extrapolation de d√©r√©f√©rencement en action, utilisons le type
<code>MaBoite&lt;T&gt;</code> que nous avons d√©fini dans l'encart 15-8 ainsi que l'impl√©mentation
de <code>Deref</code> que nous avons ajout√©e dans l'encart 15-10. L'encart 15-11 montre la
d√©finition d'une fonction qui a un param√®tre qui est une slice de cha√Æne de
caract√®res¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn saluer(nom: &amp;str) {
    println!(&quot;Salutations, {}¬†!&quot;, nom);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-11: A `hello` function that has the parameter
`name` of type `&str`</span>
-->
<p><span class="caption">Encart 15-11¬†: une fonction <code>saluer</code> qui prend en
param√®tre <code>nom</code> du type <code>&amp;str</code></span></p>
<!--
We can call the `hello` function with a string slice as an argument, such as
`hello("Rust");` for example. Deref coercion makes it possible to call `hello`
with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12:
-->
<p>Nous pouvons appeler la fonction <code>saluer</code> avec une slice de cha√Æne de caract√®res
en argument, comme par exemple <code>saluer(&quot;Rust&quot;);</code>. L'extrapolation de
d√©r√©f√©rencement rend possible l'appel de <code>saluer</code> avec une r√©f√©rence √† une
valeur du type <code>MaBoite&lt;String&gt;</code>, comme dans l'encart 15-12¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {}¬†!&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-12: Calling `hello` with a reference to a
`MyBox<String>` value, which works because of deref coercion</span>
-->
<p><span class="caption">Encart 15-12¬†: appel √† <code>saluer</code> avec une r√©f√©rence √† une
valeur du type <code>MaBoite&lt;String&gt;</code>, qui fonctionne gr√¢ce √† l'extrapolation de
d√©r√©f√©rencement</span></p>
<!--
Here we‚Äôre calling the `hello` function with the argument `&m`, which is a
reference to a `MyBox<String>` value. Because we implemented the `Deref` trait
on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String`
by calling `deref`. The standard library provides an implementation of `Deref`
on `String` that returns a string slice, and this is in the API documentation
for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which
matches the `hello` function‚Äôs definition.
-->
<p>Ici nous appelons la fonction <code>saluer</code> avec l'argument <code>&amp;m</code>, qui est une
r√©f√©rence vers une valeur de type <code>MaBoite&lt;String&gt;</code>. Comme nous avons impl√©ment√©
le trait <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code> dans l'encart 15-10, Rust peut transformer le
<code>&amp;MaBoite&lt;String&gt;</code> en <code>&amp;String</code> en appelant <code>deref</code>. La biblioth√®que standard
fournit une impl√©mentation de <code>Deref</code> sur <code>String</code> qui retourne une slice de
cha√Æne de caract√®res, comme expliqu√© dans la documentation de l'API de <code>Deref</code>.
Rust appelle √† nouveau <code>deref</code> pour transformer le <code>&amp;String</code> en <code>&amp;str</code>, qui
correspond √† la d√©finition de la fonction <code>saluer</code>.</p>
<!--
If Rust didn‚Äôt implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value
of type `&MyBox<String>`.
-->
<p>Si Rust n'avait pas impl√©ment√© l'extrapolation de d√©r√©f√©rencement, nous aurions
d√ª √©crire le code de l'encart 15-13 au lieu du code de l'encart 15-12 pour
appeler <code>saluer</code> avec une valeur du type <code>&amp;MaBoite&lt;String&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {}¬†!&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;(*m)[..]);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-13: The code we would have to write if Rust
didn‚Äôt have deref coercion</span>
-->
<p><span class="caption">Encart 15-13¬†: le code que nous aurions d√ª √©crire si Rust
n'avait pas d'extrapolation de d√©r√©f√©rencement</span></p>
<!--
The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and
`[..]` take a string slice of the `String` that is equal to the whole string to
match the signature of `hello`. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.
-->
<p>Le <code>(*m)</code> d√©r√©f√©rence la <code>MaBoite&lt;String&gt;</code> en une <code>String</code>. Ensuite le <code>&amp;</code> et le
<code>[..]</code> cr√©ent une slice de cha√Æne de caract√®res √† partir de la <code>String</code> qui est
√©gale √† l'int√©gralit√© du contenu de la <code>String</code>, ceci afin de correspondre √† la
signature de <code>saluer</code>. Le code sans l'extrapolation de d√©r√©f√©rencement est bien
plus difficile √† lire, √©crire et comprendre avec la pr√©sence de tous ces
symboles. L'extrapolation de d√©r√©f√©rencement permet √† Rust d'automatiser ces
convertions pour nous.</p>
<!--
When the `Deref` trait is defined for the types involved, Rust will analyze the
types and use `Deref::deref` as many times as necessary to get a reference to
match the parameter‚Äôs type. The number of times that `Deref::deref` needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!
-->
<p>Lorsque le trait <code>Deref</code> est d√©fini pour les types concern√©s, Rust va analyser
les types et utiliser <code>Deref::deref</code> autant de fois que n√©cessaire pour obtenir
une r√©f√©rence qui correspond au type du param√®tre. Le nombre de fois qu'il est
n√©cessaire d'ins√©rer <code>Deref::deref</code> est r√©solu au moment de la compilation,
ainsi il n'y a pas de surco√ªt au moment de l'ex√©cution pour b√©n√©ficier de
l'extrapolation de d√©r√©f√©rencement¬†!</p>
<!--
### How Deref Coercion Interacts with Mutability
-->
<h3 id="linteraction-de-lextrapolation-de-d√©r√©f√©rencement-avec-la-mutabilit√©"><a class="header" href="#linteraction-de-lextrapolation-de-d√©r√©f√©rencement-avec-la-mutabilit√©">L'interaction de l'extrapolation de d√©r√©f√©rencement avec la mutabilit√©</a></h3>
<!--
Similar to how you use the `Deref` trait to override the `*` operator on
immutable references, you can use the `DerefMut` trait to override the `*`
operator on mutable references.
-->
<p>De la m√™me mani√®re que vous pouvez utiliser le trait <code>Deref</code> pour remplacer le
comportement de l'op√©rateur <code>*</code> sur les r√©f√©rences immuables, vous pouvez
utiliser le trait <code>DerefMut</code> pour remplacer le comportement de l'op√©rateur <code>*</code>
sur les r√©f√©rences mutables.</p>
<!--
Rust does deref coercion when it finds types and trait implementations in three
cases:
-->
<p>Rust proc√®de √† l'extrapolation de d√©r√©f√©rencement lorsqu'il trouve des types et
des impl√©mentations de traits dans trois cas¬†:</p>
<!--
* From `&T` to `&U` when `T: Deref<Target=U>`
* From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`
* From `&mut T` to `&U` when `T: Deref<Target=U>`
-->
<ul>
<li>Passer de <code>&amp;T</code> √† <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> √† <code>&amp;mut U</code> lorsque <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> √† <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<!--
The first two cases are the same except for mutability. The first case states
that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can
get a `&U` transparently. The second case states that the same deref coercion
happens for mutable references.
-->
<p>Les deux premiers cas sont exactement les m√™mes, sauf pour la mutabilit√©. Le
premier cas signifie que si vous avez un <code>&amp;T</code> et que <code>T</code> impl√©mente <code>Deref</code> pour
le type <code>U</code>, vous pouvez obtenir un <code>&amp;U</code> de mani√®re transparente. Le deuxi√®me cas
signifie que la m√™me extrapolation de d√©r√©f√©rencement se d√©roule pour les
r√©f√©rences mutables.</p>
<!--
The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is *not* possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn‚Äôt compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules don‚Äôt guarantee that. Therefore, Rust can‚Äôt make the
assumption that converting an immutable reference to a mutable reference is
possible.
-->
<p>Le troisi√®me cas est plus ardu¬†: Rust va aussi proc√©der √† une extrapolation de
d√©r√©f√©rencement d'une r√©f√©rence mutable vers une r√©f√©rence immuable. Mais
l'inverse n'est <em>pas</em> possible: une extrapolation de d√©r√©f√©rencement d'une
valeur immuable ne donnera jamais une r√©f√©rence mutable. A cause des r√®gles
d'emprunt, si vous avez une r√©f√©rence mutable, cette r√©f√©rence mutable doit
√™tre la seule r√©f√©rence vers cette donn√©e (autrement, le programme ne peut pas
√™tre compil√©). Convertir une r√©f√©rence mutable vers une r√©f√©rence immuable ne
va jamais casser les r√®gles d'emprunt. Convertir une r√©f√©rence immuable vers
une r√©f√©rence mutable n√©cessite que la r√©f√©rence immuable initiale soit la
seule r√©f√©rence immuable vers cette donn√©e, mais les r√®gles d'emprunt ne
garantissent pas cela. Rust ne peut donc pas d√©duire que la conversion d'une
r√©f√©rence immuable vers une r√©f√©rence mutable est possible.</p>
<!--
[impl-trait]: ch10-02-traits.html#implementing-a-trait-on-a-type
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Running Code on Cleanup with the `Drop` Trait
-->
<h2 id="ex√©cuter-du-code-lors-du-nettoyage-avec-le-trait-drop"><a class="header" href="#ex√©cuter-du-code-lors-du-nettoyage-avec-le-trait-drop">Ex√©cuter du code lors du nettoyage avec le trait <code>Drop</code></a></h2>
<!--
The second trait important to the smart pointer pattern is `Drop`, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the `Drop` trait on any type, and the code you
specify can be used to release resources like files or network connections.
We‚Äôre introducing `Drop` in the context of smart pointers because the
functionality of the `Drop` trait is almost always used when implementing a
smart pointer. For example, when a `Box<T>` is dropped it will deallocate the space
on the heap that the box points to.
-->
<p>Le second trait important pour les pointeurs intelligents est <code>Drop</code>, qui vous
permet de personnaliser ce qui se passe lorsqu'une valeur est en train de sortir
d'une port√©e. Vous pouvez fournir une impl√©mentation du trait <code>Drop</code> sur
n'importe quel type, et le code que vous renseignez peut √™tre utilis√© pour
lib√©rer des ressources comme des fichiers ou des connections r√©seau. Nous
pr√©sentons <code>Drop</code> dans le contexte des pointeurs intelligents car la
fonctionnalit√© du trait <code>Drop</code> est quasiment syst√©matiquement utilis√©e
lorsque nous impl√©mentons un pointeur intelligent. Par exemple, lorsqu'une
<code>Box&lt;T&gt;</code> est lib√©r√©e, elle va d√©sallouer l'espace occup√© sur le tas sur lequel
la boite pointe.</p>
<!--
In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, you can specify that a
particular bit of code be run whenever a value goes out of scope, and the
compiler will insert this code automatically. As a result, you don‚Äôt need to be
careful about placing cleanup code everywhere in a program that an instance of
a particular type is finished with‚Äîyou still won‚Äôt leak resources!
-->
<p>Dans certains langages, le d√©veloppeur doit appeler du code pour lib√©rer la
m√©moire ou des ressources √† chaque fois qu'il finit d'utiliser une instance ou
un pointeur intelligent. S'il oublie de le faire, le syst√®me peut surcharger et
planter. Avec Rust, vous pouvez renseigner du code qui sera ex√©cut√© √† chaque
fois qu'une valeur sort de la port√©e, et le compilateur va ins√©rer
automatiquement ce code. Au final, vous n'avez pas besoin de concentrer votre
attention √† placer du code de nettoyage √† chaque fois qu'une instance d'un type
particulier n'est plus utilis√©e ‚Äî vous ne risquez pas d'avoir des fuites de
ressources¬†!</p>
<!--
Specify the code to run when a value goes out of scope by implementing the
`Drop` trait. The `Drop` trait requires you to implement one method named
`drop` that takes a mutable reference to `self`. To see when Rust calls `drop`,
let‚Äôs implement `drop` with `println!` statements for now.
-->
<p>Vous renseignez le code √† ex√©cuter lorsqu'une valeur sort de la port√©e en
impl√©mentant le trait <code>Drop</code>. Le trait <code>Drop</code> n√©cessite que vous impl√©mentiez
une m√©thode <code>drop</code> qui prend en param√®tre une r√©f√©rence mutable √† <code>self</code>. Pour
voir quand Rust appelle <code>drop</code>, impl√©mentons <code>drop</code> avec une instruction
<code>println!</code> √† l'int√©rieur, pour le moment.</p>
<!--
Listing 15-14 shows a `CustomSmartPointer` struct whose only custom
functionality is that it will print `Dropping CustomSmartPointer!` when the
instance goes out of scope. This example demonstrates when Rust runs the `drop`
function.
-->
<p>L'encart 15-14 montre une structure <code>PointeurPerso</code> dont la seule fonctionnalit√©
personnalis√©e est qu'elle va √©crire <code>Nettoyage d'un PointeurPerso¬†!</code> lorsque
l'instance sort de la port√©e. Cet exemple signale quand Rust ex√©cute la
fonction <code>drop</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct PointeurPerso {
    donnee: String,
}

impl Drop for PointeurPerso {
    fn drop(&amp;mut self) {
        println!(&quot;Nettoyage d'un PointeurPerso avec la donn√©e `{}`¬†!&quot;, self.donnee);
    }
}

fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    let d = PointeurPerso {
        donnee: String::from(&quot;d'autres trucs&quot;),
    };
    println!(&quot;PointeurPersos cr√©√©s.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-14: A `CustomSmartPointer` struct that
implements the `Drop` trait where we would put our cleanup code</span>
-->
<p><span class="caption">Encart 15-14¬†: Une structure <code>PointeurPerso</code> qui
impl√©mente le trait <code>Drop</code> dans lequel nous pla√ßons notre code de nettoyage
</span></p>
<!--
The `Drop` trait is included in the prelude, so we don‚Äôt need to bring it into
scope. We implement the `Drop` trait on `CustomSmartPointer` and provide an
implementation for the `drop` method that calls `println!`. The body of the
`drop` function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. We‚Äôre printing some text here to
demonstrate when Rust will call `drop`.
-->
<p>Le trait <code>Drop</code> est import√© dans l'√©tape pr√©liminaire, donc nous n'avons pas
besoin de l'importer dans la port√©e. Nous impl√©mentons le trait <code>Drop</code> sur
<code>PointeurPerso</code> et nous fournissons une impl√©mentation de la m√©thode <code>drop</code> qui
appelle <code>println!</code>. Le corps de la fonction <code>drop</code> est l'endroit o√π vous placez
la logique que vous souhaitez ex√©cuter lorsqu'une instance du type concern√© sort
de la port√©e. Ici nous affichons un petit texte pour voir quand Rust
appelle <code>drop</code>.</p>
<!--
In `main`, we create two instances of `CustomSmartPointer` and then print
`CustomSmartPointers created`. At the end of `main`, our instances of
`CustomSmartPointer` will go out of scope, and Rust will call the code we put
in the `drop` method, printing our final message. Note that we didn‚Äôt need to
call the `drop` method explicitly.
-->
<p>Dans le <code>main</code>, nous cr√©ons deux instances de <code>PointeurPerso</code> et ensuite on
affiche <code>PointeurPersos cr√©√©s</code>. A la fin du <code>main</code>, nos instances de
<code>PointeurPerso</code> vont sortir de la port√©e, et Rust va appeler le code que nous
avons plac√© dans la m√©thode <code>drop</code> et qui va afficher notre message final.
Notez que nous n'avons pas besoin d'appeler explicitement la m√©thode <code>drop</code>.</p>
<!--
When we run this program, we‚Äôll see the following output:
-->
<p>Lorsque nous ex√©cutons ce programme, nous devrions voir la sortie suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
PointeurPersos cr√©√©s.
Nettoyage d'un PointeurPerso avec la donn√©e `d'autres trucs`!
Nettoyage d'un PointeurPerso avec la donn√©e `des trucs`!
</code></pre>
<!--
Rust automatically called `drop` for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so `d` was dropped before `c`. This example gives you a visual
guide to how the `drop` method works; usually you would specify the cleanup
code that your type needs to run rather than a print message.
-->
<p>Rust a appel√© automatiquement <code>drop</code> pour nous lorsque nos instances sont
sorties de la port√©e, appelant ainsi le code que nous y avions mis. Les variables
sont lib√©r√©es dans l'ordre inverse de leur cr√©ation, donc <code>d</code> a √©t√© lib√©r√© avant
<code>c</code>. Cet exemple vous fournit une illustration de la fa√ßon dont la m√©thode <code>drop</code>
fonctionne¬†; normalement vous devriez y mettre le code de nettoyage dont votre
type a besoin d'ex√©cuter plut√¥t que d'afficher simplement un message.</p>
<!--
### Dropping a Value Early with `std::mem::drop`
-->
<h3 id="lib√©rer-pr√©matur√©ment-une-valeur-avec-stdmemdrop"><a class="header" href="#lib√©rer-pr√©matur√©ment-une-valeur-avec-stdmemdrop">Lib√©rer pr√©matur√©ment une valeur avec <code>std::mem::drop</code></a></h3>
<!--
Unfortunately, it‚Äôs not straightforward to disable the automatic `drop`
functionality. Disabling `drop` isn‚Äôt usually necessary; the whole point of the
`Drop` trait is that it‚Äôs taken care of automatically. Occasionally, however,
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the `drop` method that
releases the lock so that other code in the same scope can acquire the lock.
Rust doesn‚Äôt let you call the `Drop` trait‚Äôs `drop` method manually; instead
you have to call the `std::mem::drop` function provided by the standard library
if you want to force a value to be dropped before the end of its scope.
-->
<p>Malheureusement, il n'est pas simple de d√©sactiver la fonctionnalit√© automatique
<code>drop</code>. La d√©sactivation de <code>drop</code> n'est g√©n√©ralement pas n√©cessaire¬†; tout
l'int√©r√™t du trait <code>Drop</code> est qu'il est pris en charge automatiquement.
Occasionnellement, cependant, vous pourriez avoir besoin de nettoyer
pr√©matur√©ment une valeur. Un exemple est lorsque vous utilisez des pointeurs
intelligents qui g√®rent un syst√®me de verrouillage¬†: vous pourriez vouloir
forcer la m√©thode <code>drop</code> qui lib√®re le verrou afin qu'un autre code dans la m√™me
port√©e puisse prendre ce verrou. Rust ne vous autorise pas √† appeler
manuellement la m√©thode <code>drop</code> du trait <code>Drop</code>¬†; √† la place vous devez appeler
la fonction <code>std::mem::drop</code>, fournie par la biblioth√®que standard, si vous
souhaitez forcer une valeur √† √™tre lib√©r√©e avant la fin de sa port√©e.</p>
<!--
If we try to call the `Drop` trait‚Äôs `drop` method manually by modifying the
`main` function from Listing 15-14, as shown in Listing 15-15, we‚Äôll get a
compiler error:
-->
<p>Si nous essayons d'appeler manuellement la m√©thode <code>drop</code> du trait <code>Drop</code> en
modifiant la fonction <code>main</code> de l'encart 15-14, comme dans l'encart 15-15, nous
aurons une erreur de compilation¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct CustomSmartPointer {
#     data: String,
# }
# 
# impl Drop for CustomSmartPointer {
#     fn drop(&mut self) {
#         println!("Dropping CustomSmartPointer with data `{}`!", self.data);
#     }
# }
# 
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct PointeurPerso {
</span><span class="boring">    donnee: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for PointeurPerso {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Nettoyage d'un PointeurPerso avec la donn√©e `{}` !&quot;, self.donnee);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    println!(&quot;PointeurPerso cr√©√©.&quot;);
    c.drop();
    println!(&quot;PointeurPerso lib√©r√© avant la fin du main.&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 15-15: Attempting to call the `drop` method from
the `Drop` trait manually to clean up early</span>
-->
<p><span class="caption">Encart 15-15¬†: tentative d'appel manuel de la m√©thode
<code>drop</code> du trait <code>Drop</code> afin de nettoyer pr√©matur√©ment</span></p>
<!--
When we try to compile this code, we‚Äôll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  -- > src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre>
<!--
This error message states that we‚Äôre not allowed to explicitly call `drop`. The
error message uses the term *destructor*, which is the general programming term
for a function that cleans up an instance. A *destructor* is analogous to a
*constructor*, which creates an instance. The `drop` function in Rust is one
particular destructor.
-->
<p>Ce message d'erreur signifie que nous ne sommes pas autoris√©s √† appeler
explicitement <code>drop</code>. Le message d'erreur utilise le terme de <em>destructeur</em>
(<code>destructor</code>) qui est un terme g√©n√©ral de programmation qui d√©signe une
fonction qui nettoie une instance. Un <em>destructeur</em> est analogue √† un
<em>constructeur</em>, qui construit une instance. La fonction <code>drop</code> en Rust est un
destructeur particulier.</p>
<!--
Rust doesn‚Äôt let us call `drop` explicitly because Rust would still
automatically call `drop` on the value at the end of `main`. This would be a
*double free* error because Rust would be trying to clean up the same value
twice.
-->
<p>Rust ne nous laisse pas appeler explicitement <code>drop</code> car Rust appellera toujours
automatiquement <code>drop</code> sur la valeur √† la fin du <code>main</code>. Cela serait une erreur
de <em>double lib√©ration</em> car Rust essayerait de nettoyer la m√™me valeur deux fois.</p>
<!--
We can‚Äôt disable the automatic insertion of `drop` when a value goes out of
scope, and we can‚Äôt call the `drop` method explicitly. So, if we need to force
a value to be cleaned up early, we can use the `std::mem::drop` function.
-->
<p>Nous ne pouvons pas d√©sactiver l'ajout automatique de <code>drop</code> lorsqu'une valeur
sort de la port√©e, et nous ne pouvons pas d√©sactiver explicitement la m√©thode
<code>drop</code>. Donc, si nous avons besoin de forcer une valeur √† √™tre nettoy√©e
pr√©matur√©ment, nous pouvons utiliser la fonction <code>std::mem::drop</code>.</p>
<!--
The `std::mem::drop` function is different from the `drop` method in the `Drop`
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify `main` in Listing
15-15 to call the `drop` function, as shown in Listing 15-16:
-->
<p>La fonction <code>std::mem::drop</code> est diff√©rente de la m√©thode <code>drop</code> du trait
<code>Drop</code>. Nous pouvons l'appeler en lui passant en argument la valeur que nous
souhaitons lib√©rer pr√©matur√©ment. La fonction est pr√©sente dans l'√©tape
pr√©liminaire, donc nous pouvons modifier <code>main</code> de l'encart 15-15 pour appeler
la fonction <code>drop</code>, comme dans l'encart 15-16¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# struct CustomSmartPointer {
#     data: String,
# }
# 
# impl Drop for CustomSmartPointer {
#     fn drop(&mut self) {
#         println!("Dropping CustomSmartPointer with data `{}`!", self.data);
#     }
# }
# 
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct PointeurPerso {
</span><span class="boring">    donnee: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for PointeurPerso {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Nettoyage d'un PointeurPerso avec la donn√©e `{}` !&quot;, self.donnee);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    println!(&quot;PointeurPerso cr√©√©.&quot;);
    drop(c);
    println!(&quot;PointeurPerso lib√©r√© avant la fin du main.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-16: Calling `std::mem::drop` to explicitly
drop a value before it goes out of scope</span>
-->
<p><span class="caption">Encart 15-16¬†: appel √† <code>std::mem::drop</code> pour lib√©rer
explicitement une valeur avant qu'elle sorte de la port√©e</span></p>
<!--
Running this code will print the following:
-->
<p>L'ex√©cution de code va afficher ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
PointeurPerso cr√©√©.
Nettoyage d'un PointeurPerso avec la donn√©e `des trucs` !
PointeurPerso lib√©r√© avant la fin du main.
</code></pre>
<!--
The text ```Dropping CustomSmartPointer with data `some data`!``` is printed
between the `CustomSmartPointer created.` and `CustomSmartPointer dropped
before the end of main.` text, showing that the `drop` method code is called to
drop `c` at that point.
-->
<p>Le texte <code>Nettoyage d'un PointeurPerso avec la donn√©e `des trucs`¬†!</code>
est affich√© entre <code>PointeurPerso cr√©√©</code> et
<code>PointeurPerso lib√©r√© avant la fin du main</code>, ce qui d√©montre que la m√©thode
<code>drop</code> a √©t√© appel√©e pour lib√©rer <code>c</code> √† cet endroit.</p>
<!--
You can use code specified in a `Drop` trait implementation in many ways to
make cleanup convenient and safe: for instance, you could use it to create your
own memory allocator! With the `Drop` trait and Rust‚Äôs ownership system, you
don‚Äôt have to remember to clean up because Rust does it automatically.
-->
<p>Vous pouvez utiliser le code renseign√© dans une impl√©mentation du trait <code>Drop</code>
de plusieurs mani√®res afin de rendre le nettoyage pratique et s√ªr¬†: par exemple,
vous pouvez l'utiliser pour cr√©er votre propre alloueur de m√©moire¬†! Gr√¢ce au
trait <code>Drop</code> et le syst√®me de possession de Rust, vous n'avez pas √† vous
souvenir de nettoyer car Rust le fait automatiquement.</p>
<!--
You also don‚Äôt have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that `drop` gets called only once when
the value is no longer being used.
-->
<p>Vous n'avez pas non plus √† vous soucier des probl√®mes r√©sultant du nettoyage
accidentel de valeurs toujours utilis√©es¬†: le syst√®me de possession garantit que
les r√©f√©rences restent toujours en vigueur, et garantit √©galement que <code>drop</code>
n'est appel√©e qu'une seule fois lorsque la valeur n'est plus utilis√©e.</p>
<!--
Now that we‚Äôve examined `Box<T>` and some of the characteristics of smart
pointers, let‚Äôs look at a few other smart pointers defined in the standard
library.
-->
<p>Maintenant que nous avons examin√© <code>Box&lt;T&gt;</code> et certaines des caract√©ristiques des
pointeurs intelligents, d√©couvrons d'autres pointeurs intelligents d√©finis dans
la biblioth√®que standard.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## `Rc<T>`, the Reference Counted Smart Pointer
-->
<h2 id="rct-le-pointeur-intelligent-qui-compte-les-r√©f√©rences"><a class="header" href="#rct-le-pointeur-intelligent-qui-compte-les-r√©f√©rences"><code>Rc&lt;T&gt;</code>, le pointeur intelligent qui compte les r√©f√©rences</a></h2>
<!--
In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn‚Äôt be cleaned up unless it doesn‚Äôt have any
edges pointing to it.
-->
<p>Dans la majorit√© des cas, la possession est claire¬†: vous savez exactement
quelle variable poss√®de une valeur donn√©e. Cependant, il existe des cas o√π une
valeur peut √™tre poss√©d√©e par plusieurs propri√©taires. Par exemple, dans des
structures de donn√©es de graphes, plusieurs extr√©mit√©s peuvent pointer vers le
m√™me noeud, et ce noeud est par conception poss√©d√© par toutes les extr√©mit√©s qui
pointent vers lui. Un noeud ne devrait pas √™tre nettoy√©, √† moins qu'il n'ait plus
d'extr√©mit√©s qui pointent vers lui.</p>
<!--
To enable multiple ownership, Rust has a type called `Rc<T>`, which is an
abbreviation for *reference counting*. The `Rc<T>` type keeps track of the
number of references to a value to determine whether or not the value is still
in use. If there are zero references to a value, the value can be cleaned up
without any references becoming invalid.
-->
<p>Pour permettre la possession multiple, Rust dispose du type <code>Rc&lt;T&gt;</code>, qui est une
abr√©viation pour <code>Reference Counting</code> <em>(compteur de r√©f√©rences)</em>. Le type
<code>Rc&lt;T&gt;</code> assure le suivi du nombre de r√©f√©rences vers une valeur, afin de
d√©terminer si la valeur est toujours utilis√©e ou non. S'il y a z√©ro r√©f√©rences
vers une valeur, la valeur peut √™tre nettoy√©e sans qu'aucune r√©f√©rence ne devienne
invalide.</p>
<!--
Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it‚Äôs no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!
-->
<p>Imaginez que <code>Rc&lt;T&gt;</code> est comme une t√©l√©vision dans une salle commune. Lorsqu'une
personne entre pour regarder la t√©l√©vision, elle l'allume. Une autre entre dans
la salle et regarde la t√©l√©vision. Lorsque la derni√®re personne quitte la salle,
elle √©teint la t√©l√©vision car elle n'est plus utilis√©e. Si quelqu'un √©teint la
t√©l√©vision alors que d'autres continuent √† la regarder, cela va provoquer du
chahut !</p>
<!--
We use the `Rc<T>` type when we want to allocate some data on the heap for
multiple parts of our program to read and we can‚Äôt determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data‚Äôs owner, and the normal ownership
rules enforced at compile time would take effect.
-->
<p>Nous utilisons le type <code>Rc&lt;T&gt;</code> lorsque nous souhaitons allouer une donn√©e sur
le tas pour que plusieurs √©l√©ments de notre programme puissent la lire et que
nous ne pouvons pas d√©terminer au moment de la compilation quel √©l√©ment cessera
de l'utiliser en dernier. Si nous savions quel √©l√©ment finirait en dernier,
nous pourrions simplement faire en sorte que cet √©l√©ment prenne possession de
la donn√©e, et les r√®gles de possession classiques qui s'appliquent au moment de
la compilation prendraient effet.</p>
<!--
Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we‚Äôll cover how to do reference counting in
multithreaded programs.
-->
<p>Notez que <code>Rc&lt;T&gt;</code> fonctionne uniquement dans des sc√©narios √† un seul processus.
Lorsque nous verrons la concurrence au chapitre 16, nous verrons comment
proc√©der au comptage de r√©f√©rences dans des programmes multi-processus.</p>
<!--
### Using `Rc<T>` to Share Data
-->
<h3 id="utiliser-rct-pour-partager-une-donn√©e"><a class="header" href="#utiliser-rct-pour-partager-une-donn√©e">Utiliser <code>Rc&lt;T&gt;</code> pour partager une donn√©e</a></h3>
<!--
Let‚Äôs return to our cons list example in Listing 15-5. Recall that we defined
it using `Box<T>`. This time, we‚Äôll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:
-->
<p>Retournons √† notre exemple de liste de construction de l'encart 15-5.
Souvenez-vous que nous l'avons d√©fini en utilisant <code>Box&lt;T&gt;</code>. Cette fois-ci, nous
allons cr√©er deux listes qui partagent toutes les deux la propri√©t√© d'une
troisi√®me liste. Th√©oriquement, cela ressemblera √† l'illustration 15-3¬†:</p>
<!-- markdownlint-disable -->
<!--
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Deux listes qui se partagent la propri√©t√© d'une troisi√®me liste"
    src="img/trpl15-03.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of
a third list, `a`</span>
-->
<p><span class="caption">Illustration 15-3¬†: deux listes, <code>b</code> et <code>c</code>, qui se
partagent la possession d'une troisi√®me liste, <code>a</code></span></p>
<!--
We‚Äôll create list `a` that contains 5 and then 10. Then we‚Äôll make two more
lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`
lists will then continue on to the first `a` list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.
-->
<p>Nous allons cr√©er une liste <code>a</code> qui contient <code>5</code> et ensuite <code>10</code>. Ensuite, nous
allons cr√©er deux autres listes¬†: <code>b</code> qui d√©marre avec <code>3</code> et <code>c</code> qui d√©marre
avec <code>4</code>. Les deux listes <code>b</code> et <code>c</code> vont ensuite continuer sur la premi√®re
liste <code>a</code> qui contient d√©j√† <code>5</code> et <code>10</code>. Autrement dit, les deux listes vont se
partager la premi√®re liste contenant <code>5</code> et <code>10</code>.</p>
<!--
Trying to implement this scenario using our definition of `List` with `Box<T>`
won‚Äôt work, as shown in Listing 15-17:
-->
<p>Si nous essayons d'impl√©menter ce sc√©nario en utilisant les d√©finitions de
<code>List</code> avec <code>Box&lt;T&gt;</code>, comme dans l'encart 15-17, cela ne va pas fonctionner¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<!--
<span class="caption">Listing 15-17: Demonstrating we‚Äôre not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>
-->
<p><span class="caption">Encart 15-17¬†: d√©monstration que nous ne sommes pas
autoris√©s √† avoir deux listes qui utilisent <code>Box&lt;T&gt;</code> pour partager la propri√©t√©
d'une troisi√®me liste</span></p>
<!--
When we compile this code, we get this error:
-->
<p>Lorsque nous compilons ce code, nous obtenons cette erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  -- > src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
</code></pre>
<!--
The `Cons` variants own the data they hold, so when we create the `b` list, `a`
is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when
creating `c`, we‚Äôre not allowed to because `a` has been moved.
-->
<p>Les variantes <code>Cons</code> prennent possession des donn√©es qu'elles obtiennent, donc
lorsque nous avons cr√©√© la liste <code>b</code>, <code>a</code> a √©t√© d√©plac√©e dans <code>b</code> et <code>b</code> poss√®de
d√©sormais <code>a</code>. Ensuite, lorsque nous essayons d'utiliser <code>a</code> √† nouveau lorsque
nous cr√©ons <code>c</code>, nous ne sommes pas autoris√©s √† le faire car <code>a</code> a √©t√© d√©plac√©.</p>
<!--
We could change the definition of `Cons` to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. This is the case for the elements and lists
in Listing 15-17, but not in every scenario.
-->
<p>Nous pourrions changer la d√©finition de <code>Cons</code> pour stocker des r√©f√©rences √† la
place, mais ensuite nous aurions besoin de renseigner des param√®tres de dur√©e
de vie. En renseignant les param√®tres de dur√©e de vie, nous devrions pr√©ciser
que chaque √©l√©ment dans la liste vivra au moins aussi longtemps que la liste
enti√®re. C'est le cas pour les √©l√©ments et les listes dans l'encart 15-17, mais
pas dans tous les cas.</p>
<!--
Instead, we‚Äôll change our definition of `List` to use `Rc<T>` in place of
`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value
and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking
ownership of `a`, we‚Äôll clone the `Rc<List>` that `a` is holding, thereby
increasing the number of references from one to two and letting `a` and `b`
share ownership of the data in that `Rc<List>`. We‚Äôll also clone `a` when
creating `c`, increasing the number of references from two to three. Every time
we call `Rc::clone`, the reference count to the data within the `Rc<List>` will
increase, and the data won‚Äôt be cleaned up unless there are zero references to
it.
-->
<p>A la place, nous allons changer la d√©finition de <code>List</code> pour utiliser <code>Rc&lt;T&gt;</code> √†
la place de <code>Box&lt;T&gt;</code>, comme dans l'encart 15-18. Chaque variante <code>Cons</code> va
maintenant poss√©der une valeur et un <code>Rc&lt;T&gt;</code> pointant sur une <code>List</code>. Lorsque
nous cr√©ons <code>b</code>, au lieu de prendre possession de <code>a</code>, nous allons cloner le
<code>Rc&lt;List&gt;</code> que <code>a</code> poss√®de, augmentant ainsi le nombre de r√©f√©rences de un √†
deux et permettant √† <code>a</code> et <code>b</code> de partager la propri√©t√© des donn√©es dans
<code>Rc&lt;List&gt;</code>. Nous allons aussi cloner <code>a</code> lorsque nous cr√©ons <code>c</code>, augmentant le
nombre de r√©f√©rences de deux √† trois. Chaque fois que nous appelons <code>Rc::clone</code>,
le compteur de r√©f√©rences des donn√©es pr√©sentes dans le <code>Rc&lt;List&gt;</code> va augmenter,
et les donn√©es ne seront pas nettoy√©es tant qu'il n'y aura pas z√©ro r√©f√©rence
vers elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Filename¬†: src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>
-->
<p><span class="caption">Encart 15-18¬†: une d√©finition de <code>List</code> qui utilise
<code>Rc&lt;T&gt;</code></span></p>
<!--
We need to add a `use` statement to bring `Rc<T>` into scope because it‚Äôs not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.
-->
<p>Nous devons ajouter une instruction <code>use</code> pour importer <code>Rc&lt;T&gt;</code> dans la port√©e
car il n'est pas pr√©sent dans l'√©tape pr√©liminaire. Dans le <code>main</code>, nous cr√©ons
la liste qui stocke <code>5</code> et <code>10</code> et la stocke dans une nouvelle <code>Rc&lt;List&gt;</code> dans
<code>a</code>. Ensuite, lorsque nous cr√©ons <code>b</code> et <code>c</code>, nous appelons la fonction
<code>Rc::clone</code> et nous passons une r√©f√©rence vers le <code>Rc&lt;List&gt;</code> de <code>a</code> en argument.</p>
<!--
We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust‚Äôs
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesn‚Äôt make a deep copy of all the data like most types‚Äô
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesn‚Äôt take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
`Rc::clone`.
-->
<p>Nous aurions pu appeler <code>a.clone()</code> plut√¥t que <code>Rc::clone(&amp;a)</code>, mais la
convention en Rust est d'utiliser <code>Rc::clone</code> dans cette situation.
L'impl√©mentation de <code>Rc::clone</code> ne fait pas une copie profonde de toutes les
donn√©es comme le fait la plupart des impl√©mentations de <code>clone</code>. L'appel √†
<code>Rc:clone</code> augmente uniquement le compteur de r√©f√©rences, ce qui ne prend pas
beaucoup de temps. Les copies profondes des donn√©es peuvent prendre beaucoup de
temps. En utilisant <code>Rc::clone</code> pour les compteurs de r√©f√©rences, nous pouvons
distinguer visuellement un clonage qui fait une copie profonde d'un clonage qui
augmente uniquement le compteur de r√©f√©rences. Lorsque vous enqu√™tez sur des
probl√®mes de performances dans le code, vous pouvez ainsi √©carter les appels √†
<code>Rc::clone</code> pour ne vous int√©resser qu'aux clonages √† copie profonde que vous
recherchez probablement.</p>
<!--
### Cloning an `Rc<T>` Increases the Reference Count
-->
<h3 id="cloner-une-rct-augmente-le-compteur-de-r√©f√©rence"><a class="header" href="#cloner-une-rct-augmente-le-compteur-de-r√©f√©rence">Cloner une <code>Rc&lt;T&gt;</code> augmente le compteur de r√©f√©rence</a></h3>
<!--
Let‚Äôs change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.
-->
<p>Changeons notre exemple de l'encart 15-18 pour que nous puissions voir le
compteur de r√©f√©rences changer au fur et √† mesure que nous cr√©ons et lib√©rons
des r√©f√©rences dans le <code>Rc&lt;List&gt;</code> pr√©sent dans <code>a</code>.</p>
<!--
In Listing 15-19, we‚Äôll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope.
-->
<p>Dans l'encart 15-19, nous allons changer le <code>main</code> afin qu'il ait une port√©e
en son sein autour de <code>c</code>¬†; ainsi nous pourrons voir comment le compteur de
r√©f√©rences change lorsque <code>c</code> sort de la port√©e.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
# 
# use crate::List::{Cons, Nil};
# use std::rc::Rc;
# 
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;compteur apr√®s la cr√©ation de a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;compteur apr√®s la cr√©ation de b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;compteur apr√®s la cr√©ation de c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;compteur apr√®s que c est sorti de la port√©e = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-19: Printing the reference count</span>
-->
<p><span class="caption">Encart 15-19¬†: affichage du compteur de r√©f√©rences</span></p>
<!--
At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; we‚Äôll see what `weak_count` is used for in the
[‚ÄúPreventing Reference Cycles: Turning an `Rc<T>` into a
`Weak<T>`‚Äù][preventing-ref-cycles]<!-- ignore -- > section.
-->
<p>A chaque √©tape du programme o√π le compteur de r√©f√©rences change, nous affichons
le compteur de r√©f√©rences, que nous pouvons obtenir en faisant appel √† la
fonction <code>Rc::strong_count</code>. Cette fonction s'appelle <code>strong_count</code> plut√¥t que
<code>count</code> car le type <code>Rc&lt;T&gt;</code> a aussi un <code>weak_count</code>¬†; nous verrons √† quoi sert
ce <code>weak_count</code> dans
<a href="ch15-06-reference-cycles.html">la derni√®re section de ce chapitre</a><!-- ignore -->.</p>
<!--
This code prints the following:
-->
<p>Ce code affiche ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
compteur apr√®s la cr√©ation de a = 1
compteur apr√®s la cr√©ation de b = 2
compteur apr√®s la cr√©ation de c = 3
compteur apr√®s que c est sorti de la port√©e = 2
</code></pre>
<!--
We can see that the `Rc<List>` in `a` has an initial reference count of 1; then
each time we call `clone`, the count goes up by 1. When `c` goes out of scope,
the count goes down by 1. We don‚Äôt have to call a function to decrease the
reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.
-->
<p>Nous pouvons voir clairement que le <code>Rc&lt;List&gt;</code> dans <code>a</code> a un compteur de
r√©f√©rences initial √† <code>1</code>¬†; puis √† chaque fois que nous appelons <code>clone</code>, le
compteur augmente de 1. Nous n'avons pas √† appeler une fonction pour r√©duire le
compteur de r√©f√©rences, comme nous avons d√ª le faire avec <code>Rc::clone</code> pour
augmenter compteur¬†: l'impl√©mentation du trait <code>Drop</code> r√©duit le compteur de
r√©f√©rences automatiquement lorsqu'une valeur de <code>Rc&lt;T&gt;</code> sort de la port√©e.</p>
<!--
What we can‚Äôt see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.
-->
<p>Ce que nous ne voyons pas dans cet exemple, c'est que lorsque <code>b</code> et <code>a</code>
sortent de la port√©e √† la fin du <code>main</code>, le compteur vaut alors 0 et que le
<code>Rc&lt;List&gt;</code> est nettoy√© compl√®tement √† ce moment. L'utilisation de <code>Rc&lt;T&gt;</code>
permet √† une valeur d'avoir plusieurs propri√©taires, et le compteur garantit
que la valeur reste en vigueur tant qu'au moins un propri√©taire existe encore.</p>
<!--
Via immutable references, `Rc<T>` allows you to share data between multiple
parts of your program for reading only. If `Rc<T>` allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we‚Äôll discuss the interior mutability pattern and the `RefCell<T>`
type that you can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
-->
<p>Gr√¢ce aux r√©f√©rences immuables, <code>Rc&lt;T&gt;</code> vous permet de partager des donn√©es
entre plusieurs √©l√©ments de votre programme pour uniquement les lire. Si <code>Rc&lt;T&gt;</code>
vous avait aussi permis d'avoir des r√©f√©rences mutables, vous auriez alors
viol√© une des r√®gles d'emprunt vues au chapitre 4¬†: les emprunts mutables
multiples √† une m√™me donn√©e peuvent causer des acc√®s concurrents et des
incoh√©rences. Cependant, pouvoir modifier des donn√©es reste tr√®s utile¬†! Dans la
section suivante, nous allons voir le motif de mutabilit√© interne et le type
<code>RefCell&lt;T&gt;</code> que vous pouvez utiliser conjointement avec un <code>Rc&lt;T&gt;</code> pour pouvoir
travailler avec cette contrainte d'immuabilit√©.</p>
<!-- markdownlint-disable -->
<!--
[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## `RefCell<T>` and the Interior Mutability Pattern
-->
<h2 id="refcellt-et-le-motif-de-mutabilit√©-interne"><a class="header" href="#refcellt-et-le-motif-de-mutabilit√©-interne"><code>RefCell&lt;T&gt;</code> et le motif de mutabilit√© interne</a></h2>
<!--
*Interior mutability* is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
`unsafe` code inside a data structure to bend Rust‚Äôs usual rules that govern
mutation and borrowing. We haven‚Äôt yet covered unsafe code; we will in Chapter
19. We can use types that use the interior mutability pattern when we can
ensure that the borrowing rules will be followed at runtime, even though the
compiler can‚Äôt guarantee that. The `unsafe` code involved is then wrapped in a
safe API, and the outer type is still immutable.
-->
<p>La <em>mutabilit√© interne</em> est un motif de conception en Rust qui vous permet de
muter une donn√©e m√™me s'il existe des r√©f√©rences immuables¬†; normalement, cette
action n'est pas autoris√©e par les r√®gles d'emprunt. Pour muter des donn√©es, le
motif utilise du code <code>unsafe</code> dans une structure de donn√©es pour contourner les
r√®gles courantes de Rust qui gouvernent la mutation et l'emprunt. Nous n'avons
pas encore parl√© du code unsafe¬†; nous le ferons au chapitre 19. Nous pouvons
utiliser des types qui utilisent le motif de mutabilit√© interne lorsque nous
pouvons √™tre s√ªr que les r√®gles d'emprunt seront suivies au moment de
l'ex√©cution, m√™me si le compilateur ne peut pas en √™tre s√ªr. Le code <code>unsafe</code>
concern√© est ensuite incorpor√© dans une API s√ªre, et le type externe reste
immuable.</p>
<!--
Let‚Äôs explore this concept by looking at the `RefCell<T>` type that follows the
interior mutability pattern.
-->
<p>D√©couvrons ce concept en examinant le type <code>RefCell&lt;T&gt;</code> qui applique le motif
de mutabilit√© interne.</p>
<!--
### Enforcing Borrowing Rules at Runtime with `RefCell<T>`
-->
<h3 id="appliquer-les-r√®gles-demprunt-au-moment-de-lex√©cution-avec-refcellt"><a class="header" href="#appliquer-les-r√®gles-demprunt-au-moment-de-lex√©cution-avec-refcellt">Appliquer les r√®gles d'emprunt au moment de l'ex√©cution avec <code>RefCell&lt;T&gt;</code></a></h3>
<!--
Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the data
it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`?
Recall the borrowing rules you learned in Chapter 4:
-->
<p>Contrairement √† <code>Rc&lt;T&gt;</code>, le type <code>RefCell&lt;T&gt;</code> repr√©sente une propri√©t√© unique
de la donn√©e qu'il contient. Qu'est-ce qui rend donc <code>RefCell&lt;T&gt;</code> diff√©rent
d'un type comme <code>Box&lt;T&gt;</code>¬†? Souvenez-vous des r√®gles d'emprunt que vous avez
apprises au chapitre 4¬†:</p>
<!--
* At any given time, you can have *either* (but not both of) one mutable
  reference or any number of immutable references.
* References must always be valid.
-->
<ul>
<li>A un instant donn√©, vous pouvez avoir <em>soit</em> (mais pas les deux) une
r√©f√©rence mutable, soit n'importe quel nombre de r√©f√©rences immuables</li>
<li>Les r√©f√©rences doivent toujours √™tre en vigueur.</li>
</ul>
<!--
With references and `Box<T>`, the borrowing rules‚Äô invariants are enforced at
compile time. With `RefCell<T>`, these invariants are enforced *at runtime*.
With references, if you break these rules, you‚Äôll get a compiler error. With
`RefCell<T>`, if you break these rules, your program will panic and exit.
-->
<p>Avec les r√©f√©rences et <code>Box&lt;T&gt;</code>, les r√®gles d'emprunt obligatoires sont
appliqu√©es au moment de la compilation. Avec <code>RefCell&lt;T&gt;</code>, ces obligations
sont appliqu√©es <em>au moment de l'ex√©cution</em>. Avec les r√©f√©rences, si vous ne
respectez pas ces r√®gles, vous allez obtenir une erreur de compilation. Avec
<code>RefCell&lt;T&gt;</code>, si vous ne les respectez pas, votre programme va paniquer et se
fermer.</p>
<!--
The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust‚Äôs default.
-->
<p>Les avantages de v√©rifier les r√®gles d'emprunt au moment de la compilation est
que les erreurs vont se produire plus t√¥t dans le processus de d√©veloppement
et qu'il n'y a pas d'impact sur les performances √† l'ex√©cution car toute l'analyse
a d√©j√† √©t√© faite au pr√©alable. Pour ces raisons, la v√©rification des r√®gles
d'emprunt au moment de compilation est le meilleur choix √† faire dans la
majorit√© des cas, ce qui explique pourquoi c'est le choix par d√©faut de Rust.</p>
<!--
The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.
-->
<p>L'avantage de v√©rifier les r√®gles d'emprunt plut√¥t √† l'ex√©cution est que cela
permet certains sc√©narios qui restent s√ªrs pour la m√©moire, bien qu'interdits
√† cause des v√©rifications √† la compilation. L'analyse statique, comme le
compilateur Rust, est de nature prudente. Certaines propri√©t√©s du code sont
impossibles √† d√©tecter en analysant le code¬†: l'exemple le plus connu est le
<em>probl√®me de l'arr√™t</em>, qui d√©passe le cadre de ce livre mais qui reste un
sujet int√©ressant √† √©tudier.</p>
<!--
Because some analysis is impossible, if the Rust compiler can‚Äôt be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it‚Äôs conservative. If Rust accepted an incorrect program, users
wouldn‚Äôt be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The `RefCell<T>` type is useful when you‚Äôre sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.
-->
<p>Comme certaines analyses sont impossibles, si le compilateur Rust ne peut pas
s'assurer que le code respecte les r√®gles d'emprunt, il risque de rejeter un
programme valide¬†; dans ce sens, il est prudent. Si Rust accepte un programme
incorrect, les utilisateurs ne pourront pas avoir confiance dans les
garanties qu'apporte Rust. Cependant, si Rust rejette un programme valide, le
d√©veloppeur sera importun√©, mais rien de catastrophique ne va se passer. Le
type <code>RefCell&lt;T&gt;</code> est utile lorsque vous √™tes s√ªr que votre code suit bien
les r√®gles d'emprunt mais que le compilateur est incapable de comprendre et
de garantir cela.</p>
<!--
Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We‚Äôll talk about how to get the functionality of `RefCell<T>` in a
multithreaded program in Chapter 16.
-->
<p>De la m√™me mani√®re que <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> sert uniquement pour des
sc√©narios √† une seule t√¢che et va vous donner une erreur √† la compilation si
vous essayez de l'utiliser dans un contexte multit√¢ches. Nous verrons
comment b√©n√©ficier des fonctionnalit√©s de <code>RefCell&lt;T&gt;</code> dans un programme
multi-processus au chapitre 16.</p>
<!--
Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:
-->
<p>Voici un r√©sum√© des raisons de choisir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> ou <code>RefCell&lt;T&gt;</code>¬†:</p>
<!--
* `Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>`
  have single owners.
* `Box<T>` allows immutable or mutable borrows checked at compile time; `Rc<T>`
  allows only immutable borrows checked at compile time; `RefCell<T>` allows
  immutable or mutable borrows checked at runtime.
* Because `RefCell<T>` allows mutable borrows checked at runtime, you can
  mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is
  immutable.
-->
<ul>
<li><code>Rc&lt;T&gt;</code> permet d'avoir plusieurs propri√©taires pour une m√™me donn√©e¬†;
<code>Box&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code> n'ont qu'un seul propri√©taire.</li>
<li><code>Box&lt;T&gt;</code> permet des emprunts immuables ou mutables √† la compilation¬†;
<code>Rc&lt;T&gt;</code> permet uniquement des emprunts immuables, v√©rifi√©s √† la
compilation¬†; <code>RefCell&lt;T&gt;</code> permet des emprunts immuables ou mutables,
v√©rifi√©s √† l'ex√©cution.</li>
<li>Comme <code>RefCell&lt;T&gt;</code> permet des emprunts mutables, v√©rifi√©s √† l'ex√©cution,
vous pouvez muter la valeur √† l'int√©rieur du <code>RefCell&lt;T&gt;</code> m√™me si le
<code>RefCell&lt;T&gt;</code> est immuable.</li>
</ul>
<!--
Mutating the value inside an immutable value is the *interior mutability*
pattern. Let‚Äôs look at a situation in which interior mutability is useful and
examine how it‚Äôs possible.
-->
<p>Modifer une valeur √† l'int√©rieur d'une valeur immuable est ce qu'on appelle
le motif de <em>mutabilit√© interne</em>. D√©couvrons une situation pour laquelle la
mutabilit√© interne s'av√®re utile, puis examinons comment cela est rendu
possible.</p>
<!--
### Interior Mutability: A Mutable Borrow to an Immutable Value
-->
<h3 id="mutabilit√©-interne--un-emprunt-mutable-dune-valeur-immuable"><a class="header" href="#mutabilit√©-interne--un-emprunt-mutable-dune-valeur-immuable">Mutabilit√© interne¬†: un emprunt mutable d'une valeur immuable</a></h3>
<!--
A consequence of the borrowing rules is that when you have an immutable value,
you can‚Äôt borrow it mutably. For example, this code won‚Äôt compile:
-->
<p>Une des cons√©quences des r√®gles d'emprunt est que lorsque vous avez une valeur
immuable, vous ne pouvez pas emprunter sa mutabilit√©. Par exemple, ce code ne
va pas se compiler¬†:</p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    let y = &mut x;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<!--
If you tried to compile this code, you‚Äôd get the following error:
-->
<p>Si vous essayez de compiler ce code, vous allez obtenir l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 -- > src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<!--
However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value‚Äôs methods would not be able to mutate the value. Using `RefCell<T>` is
one way to get the ability to have interior mutability. But `RefCell<T>`
doesn‚Äôt get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you‚Äôll get a `panic!` instead of
a compiler error.
-->
<p>Cependant, il existe des situations pour lesquelles il serait utile qu'une
valeur puisse se modifier elle-m√™me dans ses propres m√©thodes mais qui semble
√™tre immuable pour le reste du code. Le code √† l'ext√©rieur des m√©thodes de la
valeur n'est pas capable de modifier la valeur. L'utilisation de <code>RefCell&lt;T&gt;</code>
est une mani√®re de pouvoir proc√©der √† des mutations internes. Mais
<code>RefCell&lt;T&gt;</code> ne contourne pas compl√®tement les r√®gles d'emprunt¬†: le
v√©rificateur d'emprunt du compilateur permet cette mutabilit√© interne, et les
r√®gles d'emprunt sont plut√¥t v√©rifi√©es √† l'ex√©cution. Si vous violez les
r√®gles, vous allez provoquer un <code>panic!</code> plut√¥t que d'avoir une erreur de
compilation.</p>
<!--
Let‚Äôs work through a practical example where we can use `RefCell<T>` to mutate
an immutable value and see why that is useful.
-->
<p>Voyons un exemple pratique dans lequel nous pouvons utiliser <code>RefCell&lt;T&gt;</code> pour
modifier une valeur immuable et voir en quoi cela est utile.</p>
<!--
#### A Use Case for Interior Mutability: Mock Objects
-->
<h4 id="un-cas-dutilisation-de-la-mutabilit√©-interne--le-mock-object"><a class="header" href="#un-cas-dutilisation-de-la-mutabilit√©-interne--le-mock-object">Un cas d'utilisation de la mutabilit√© interne¬†: le mock object</a></h4>
<!--
A *test double* is the general programming concept for a type used in place of
another type during testing. *Mock objects* are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.
-->
<p>Un <em>double de test</em> est un concept g√©n√©ral de programmation consistant √† utiliser
un type √† la place d'un autre pendant des tests. Un <em>mock object</em> est un
type particulier de double de test qui enregistre ce qui se passe lors d'un
test afin que vous puissiez v√©rifier que les actions se sont pass√©es
correctement.</p>
<!--
Rust doesn‚Äôt have objects in the same sense as other languages have objects,
and Rust doesn‚Äôt have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.
-->
<p>Rust n'a pas d'objets au sens o√π l'entendent les autres langages qui en ont, et
Rust n'offre pas non plus de fonctionnalit√© de mock object dans la biblioth√®que
standard comme le font d'autres langages. Cependant, vous pouvez tr√®s bien
cr√©er une structure qui va r√©pondre aux m√™mes besoins qu'un mock object.</p>
<!--
Here‚Äôs the scenario we‚Äôll test: we‚Äôll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user‚Äôs quota for the number of API calls they‚Äôre allowed to make, for example.
-->
<p>Voici le sc√©nario que nous allons tester¬†: nous allons cr√©er une biblioth√®que
qui surveillera la proximit√© d'une valeur par rapport √† une valeur maximale et
enverra des messages en fonction de cette limite. Par exemple, cette
biblioth√®que peut √™tre utilis√©e pour suivre le quota d'un utilisateur afin de
suivre le nombre d'appels aux API qu'il est autoris√© √† faire.</p>
<!--
Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn‚Äôt need to know
that detail. All it needs is something that implements a trait we‚Äôll provide
called `Messenger`. Listing 15-20 shows the library code:
-->
<p>Notre biblioth√®que fournira uniquement la fonctionnalit√© de suivi en fonction de
la proximit√© d'une valeur avec la maximale et d√©finiera quels seront les
messages associ√©s. Les applications qui utiliseront notre biblioth√®que devront
fournir un m√©canisme pour envoyer les messages¬†: l'application peut afficher le
message dans l'application, l'envoyer par email, l'envoyer par SMS ou autre
chose. La biblioth√®que n'a pas √† se charger de ce d√©tail. Tout ce que ce
m√©canisme doit faire est d'impl√©menter un trait <code>Messager</code> que nous allons
fournir. L'encart 15-20 propose le code pour cette biblioth√®que¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">pub trait Messager {
    fn envoyer(&amp;self, msg: &amp;str);
}

pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
    messager: &amp;'a T,
    valeur: usize,
    max: usize,
}

impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
where
    T: Messager,
{
    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
        TraqueurDeLimite {
            messager,
            valeur: 0,
            max,
        }
    }

    pub fn set_valeur(&amp;mut self, valeur: usize) {
        self.valeur = valeur;

        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;

        if pourcentage_du_maximum &gt;= 1.0 {
            self.messager.envoyer(&quot;Erreur¬†: vous avez d√©pass√© votre quota¬†!&quot;);
        } else if pourcentage_du_maximum &gt;= 0.9 {
            self.messager
                .envoyer(&quot;Avertissement urgent¬†: vous avez utilis√© 90% de votre quota¬†!&quot;);
        } else if pourcentage_du_maximum &gt;= 0.75 {
            self.messager
                .envoyer(&quot;Avertissement¬†: vous avez utilis√© 75% de votre quota¬†!&quot;);
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span>
-->
<p><span class="caption">Encart 15-20¬†: une biblioth√®que qui suit la proximit√©
d'une valeur avec une valeur maximale et avertit lorsque cette valeur atteint
un certain seuil</span></p>
<!--
One important part of this code is that the `Messenger` trait has one method
called `send` that takes an immutable reference to `self` and the text of the
message. This trait is the interface our mock object needs to implement so that
the mock can be used in the same way a real object is. The other important part
is that we want to test the behavior of the `set_value` method on the
`LimitTracker`. We can change what we pass in for the `value` parameter, but
`set_value` doesn‚Äôt return anything for us to make assertions on. We want to be
able to say that if we create a `LimitTracker` with something that implements
the `Messenger` trait and a particular value for `max`, when we pass different
numbers for `value`, the messenger is told to send the appropriate messages.
-->
<p>La partie la plus importante de ce code est celle o√π le trait <code>Messager</code> a une
m√©thode qui fait appel √† <code>envoyer</code> en prenant une r√©f√©rence immuable √† <code>self</code>
ainsi que le texte du message. Ce trait est l'interface que notre mock object
doit impl√©menter afin que le mock puisse √™tre utilis√© de la m√™me mani√®re que
l'objet r√©el. L'autre partie importante est lorsque nous souhaitons tester le
comportement de la m√©thode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code>. Nous pouvons
changer ce que nous envoyons dans le param√®tre <code>valeur</code>, mais <code>set_valeur</code> ne
nous retourne rien qui nous permettrait de le v√©rifier. Nous voulons pouvoir
dire que si nous cr√©ons un <code>TraqueurDeLimite</code> avec quelque chose qui impl√©mente
le trait <code>Messager</code> et une valeur pr√©cise pour <code>max</code>, lorsque nous passons
diff√©rents nombres pour <code>valeur</code>, le messager re√ßoit bien l'instruction
d'envoyer les messages correspondants.</p>
<!--
We need a mock object that, instead of sending an email or text message when we
call `send`, will only keep track of the messages it‚Äôs told to send. We can
create a new instance of the mock object, create a `LimitTracker` that uses the
mock object, call the `set_value` method on `LimitTracker`, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won‚Äôt allow it:
-->
<p>Nous avons besoin d'un mock object qui, au lieu d'envoyer un email ou un SMS
lorsque nous faisons appel √† <code>envoyer</code>, va seulement enregistrer les messages
qu'on lui demande d'envoyer. Nous pouvons cr√©er une nouvelle instance du mock
object, cr√©er un <code>TraqueurDeLimite</code> qui utilise le mock object, faire appel √† la
m√©thode <code>set_value</code> sur le <code>TraqueurDeLimite</code> et ensuite v√©rifier que le mock
object a bien les messages que nous attendions. L'encart 15-21 montre une
tentative d'impl√©mentation d'un mock object qui fait ceci, mais le v√©rificateur
d'emprunt ne nous autorise pas √† le faire¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;Erreur¬†: vous avez d√©pass√© votre quota¬†!&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgent¬†: vous avez utilis√© 90% de votre quota¬†!&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement¬†: vous avez utilis√© 75% de votre quota¬†!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MessagerMock {
        messages_envoyes: Vec&lt;String&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: vec![],
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        let messager_mock = MessagerMock::new();
        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);

        traqueur.set_valeur(80);

        assert_eq!(messager_mock.messages_envoyes.len(), 1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-21: An attempt to implement a `MockMessenger`
that isn‚Äôt allowed by the borrow checker</span>
-->
<p><span class="caption">Encart 15-21¬†: une tentative d'impl√©mentation d'un
<code>MessagerMock</code> qui n'est pas autoris√©e par le v√©rificateur d'emprunt</span></p>
<!--
This test code defines a `MockMessenger` struct that has a `sent_messages`
field with a `Vec` of `String` values to keep track of the messages it‚Äôs told
to send. We also define an associated function `new` to make it convenient to
create new `MockMessenger` values that start with an empty list of messages. We
then implement the `Messenger` trait for `MockMessenger` so we can give a
`MockMessenger` to a `LimitTracker`. In the definition of the `send` method, we
take the message passed in as a parameter and store it in the `MockMessenger`
list of `sent_messages`.
-->
<p>Ce code de test d√©finit une structure <code>MessagerMock</code> qui a un champ
<code>messages_envoyes</code> qui est un <code>Vec</code> de valeurs <code>String</code>, afin d'y enregistrer
les messages qui lui sont envoy√©s. Nous d√©finissons √©galement une fonction
associ√©e <code>new</code> pour faciliter la cr√©ation de valeurs <code>MessagerMock</code> qui
commencent avec une liste vide de messages. Nous impl√©mentons ensuite le trait
<code>Messager</code> sur <code>MessagerMock</code> afin de donner un <code>MessagerMock</code> √† un
<code>TraqueurDeLimite</code>. Dans la d√©finition de la m√©thode <code>envoyer</code>, nous prenons
le message envoy√© en param√®tre et nous le stockons dans la liste
<code>messages_envoyes</code> du <code>MessagerMock</code>.</p>
<!--
In the test, we‚Äôre testing what happens when the `LimitTracker` is told to set
`value` to something that is more than 75 percent of the `max` value. First, we
create a new `MockMessenger`, which will start with an empty list of messages.
Then we create a new `LimitTracker` and give it a reference to the new
`MockMessenger` and a `max` value of 100. We call the `set_value` method on the
`LimitTracker` with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the `MockMessenger` is keeping track
of should now have one message in it.
-->
<p>Dans le test, nous v√©rifions ce qui se passe lorsque le <code>TraqueurDeLimite</code>
doit atteindre une valeur qui est sup√©rieure √† 75 pourcent de la valeur <code>max</code>.
D'abord, nous cr√©ons un nouveau <code>MessagerMock</code>, qui va d√©marrer avec une liste
vide de messages. Ensuite, nous cr√©ons un nouveau <code>TraqueurDeLimite</code> et nous
lui donnons une r√©f√©rence vers ce <code>MessagerMock</code> et une valeur <code>max</code> de 100.
Nous appelons la m√©thode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code> avec une
valeur de 80, qui est plus grande que 75 pourcents de 100. Enfin, nous
v√©rifions que la liste de messages qu'a enregistr√©e le <code>MessagerMock</code> contient
bien d√©sormais un message.</p>
<!--
However, there‚Äôs one problem with this test, as shown here:
-->
<p>Cependant, il reste un probl√®me avec ce test, probl√®me qui est montr√©
ci-dessous¬†:</p>
<!--
```console
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference
  -- > src/lib.rs:58:13
   |
2  |     fn send(&self, msg: &str);
   |             ----- help: consider changing that to be a mutable reference: `&mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed
```
-->
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.messages_envoyes` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn envoyer(&amp;self, message: &amp;str);
   |                ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.messages_envoyes.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed
</code></pre>
<!--
We can‚Äôt modify the `MockMessenger` to keep track of the messages, because the
`send` method takes an immutable reference to `self`. We also can‚Äôt take the
suggestion from the error text to use `&mut self` instead, because then the
signature of `send` wouldn‚Äôt match the signature in the `Messenger` trait
definition (feel free to try and see what error message you get).
-->
<p>Nous ne pouvons pas modifier le <code>MessagerMock</code> pour enregistrer les messages,
car la m√©thode <code>envoyer</code> utilise une r√©f√©rence immuable √† <code>self</code>. Nous ne
pouvons pas non plus suivre la suggestion du texte d'erreur pour utiliser
<code>&amp;mut self</code> √† la place, car ensuite la signature de <code>envoyer</code> ne va pas
correspondre √† la signature de la d√©finition du trait <code>Messager</code> (essayez et
vous constaterez le message d'erreur que vous obtiendrez).</p>
<!--
This is a situation in which interior mutability can help! We‚Äôll store the
`sent_messages` within a `RefCell<T>`, and then the `send` method will be
able to modify `sent_messages` to store the messages we‚Äôve seen. Listing 15-22
shows what that looks like:
-->
<p>C'est une situation dans laquelle la mutabilit√© interne peut nous aider¬†!
Nous allons stocker <code>messages_envoyes</code> dans une <code>RefCell&lt;T&gt;</code>, et ensuite la
m√©thode <code>envoyer</code> pourra modifier <code>messages_envoyes</code> pour stocker les
messages que nous avons avons vus. L'encart 15-22 montre √† quoi cela peut
ressembler¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;Erreur¬†: vous avez d√©pass√© votre quota¬†!&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgent¬†: vous avez utilis√© 90% de votre quota¬†!&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement¬†: vous avez utilis√© 75% de votre quota¬†!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MessagerMock {
        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: RefCell::new(vec![]),
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        // -- partie masqu√©e ici --
<span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span>
        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-22: Using `RefCell<T>` to mutate an inner
value while the outer value is considered immutable</span>
-->
<p><span class="caption">Encart 15-22¬†: utilisation du <code>RefCell&lt;T&gt;</code> pour muter
une valeur interne que les valeurs externes consid√®rent comme immuable
</span></p>
<!--
The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of
`Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>`
instance around the empty vector.
-->
<p>Le champ <code>messages_envoyes</code> est maintenant du type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> au
lieu de <code>Vec&lt;String&gt;</code>. Dans la fonction <code>new</code>, nous cr√©ons une nouvelle
instance de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> autour du vecteur vide.</p>
<!--
For the implementation of the `send` method, the first parameter is still an
immutable borrow of `self`, which matches the trait definition. We call
`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a
mutable reference to the value inside the `RefCell<Vec<String>>`, which is
the vector. Then we can call `push` on the mutable reference to the vector to
keep track of the messages sent during the test.
-->
<p>En ce qui concerne l'impl√©mentation de la m√©thode <code>envoyer</code>, le premier
param√®tre est toujours un emprunt immuable de <code>self</code>, ce qui correspond √† la
d√©finition du trait. Nous appelons la m√©thode <code>borrow_mut</code> sur le
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> pr√©sent dans <code>self.messages_envoyes</code> pour obtenir une
r√©f√©rence mutable vers la valeur pr√©sente dans le <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, qui
correspond au vecteur. Ensuite, nous appelons <code>push</code> sur la r√©f√©rence mutable
vers le vecteur pour enregistrer le message envoy√© pendant le test.</p>
<!--
The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get an
immutable reference to the vector.
-->
<p>Le dernier changement que nous devons appliquer se trouve dans la v√©rification¬†:
pour savoir combien d'√©l√©ments sont pr√©sents dans le vecteur, nous faisons
appel √† <code>borrow</code> de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> pour obtenir une r√©f√©rence
immuable vers le vecteur.</p>
<!--
Now that you‚Äôve seen how to use `RefCell<T>`, let‚Äôs dig into how it works!
-->
<p>Maintenant que vous avez appris √† utiliser <code>RefCell&lt;T&gt;</code>, regardons comment il
fonctionne¬†!</p>
<!--
#### Keeping Track of Borrows at Runtime with `RefCell<T>`
-->
<h4 id="suivre-les-emprunts-√†-lex√©cution-avec-refcellt"><a class="header" href="#suivre-les-emprunts-√†-lex√©cution-avec-refcellt">Suivre les emprunts √† l'ex√©cution avec <code>RefCell&lt;T&gt;</code></a></h4>
<!--
When creating immutable and mutable references, we use the `&` and `&mut`
syntax, respectively. With `RefCell<T>`, we use the `borrow` and `borrow_mut`
methods, which are part of the safe API that belongs to `RefCell<T>`. The
`borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut`
returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so we
can treat them like regular references.
-->
<p>Lorsque nous cr√©ons des r√©f√©rences immuables et mutables, nous utilisons
respectivement les syntaxes <code>&amp;</code> et <code>&amp;mut</code>. Avec <code>RefCell&lt;T&gt;</code>, nous utilisons
les m√©thodes <code>borrow</code> et <code>borrow_mut</code>, qui font partie de l'API stable de
<code>RefCell&lt;T&gt;</code>. La m√©thode <code>borrow</code> retourne un pointeur intelligent du type
<code>Ref&lt;T&gt;</code> et <code>borrow_mut</code> retourne un pointeur intelligent du type <code>RefMut&lt;T&gt;</code>.
Les deux impl√©mentent <code>Deref</code>, donc nous pouvons les consid√©rer comme des
r√©f√©rences classiques.</p>
<!--
The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart
pointers are currently active. Every time we call `borrow`, the `RefCell<T>`
increases its count of how many immutable borrows are active. When a `Ref<T>`
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, `RefCell<T>` lets us have many immutable
borrows or one mutable borrow at any point in time.
-->
<p>Le <code>RefCell&lt;T&gt;</code> suit combien de pointeurs intelligents <code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>
sont actuellement actifs. A chaque fois que nous faisons appel √† <code>borrow</code>, le
<code>RefCell&lt;T&gt;</code> augmente son compteur du nombre d'emprunts immuables qui existent.
Lorsqu'une valeur <code>Ref&lt;T&gt;</code> sort de la port√©e, le compteur d'emprunts immuables
est d√©cr√©ment√© de un. A tout moment <code>RefCell&lt;T&gt;</code> nous permet d'avoir plusieurs emprunts
immuables ou bien un seul emprunt mutable, tout comme le font les
r√®gles d'emprunt au moment de la compilation.</p>
<!--
If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of `RefCell<T>` will panic at
runtime. Listing 15-23 shows a modification of the implementation of `send` in
Listing 15-22. We‚Äôre deliberately trying to create two mutable borrows active
for the same scope to illustrate that `RefCell<T>` prevents us from doing this
at runtime.
-->
<p>Si nous ne respectons pas ces r√®gles, l'impl√©mentation de <code>RefCell&lt;T&gt;</code> va
paniquer √† l'ex√©cution plut√¥t que de provoquer une erreur de compilation comme nous
l'aurions eu en utilisant des r√©f√©rences classiques. L'encart 15-23 nous montre une
modification apport√©e √† l'impl√©mentation de <code>envoyer</code> de l'encart 15-22. Nous
essayons d√©lib√©r√©ment de cr√©er deux emprunts mutables actifs dans la m√™me
port√©e pour montrer que <code>RefCell&lt;T&gt;</code> nous emp√™che de faire ceci √† l'ex√©cution.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,panics
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
#     use std::cell::RefCell;
# 
#     struct MockMessenger {
#         sent_messages: RefCell<Vec<String>>,
#     }
# 
#     impl MockMessenger {
#         fn new() -> MockMessenger {
#             MockMessenger {
#                 sent_messages: RefCell::new(vec![]),
#             }
#         }
#     }
# 
    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
# 
#     #[test]
#     fn it_sends_an_over_75_percent_warning_message() {
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);
# 
#         assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
#     }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;Erreur¬†: vous avez d√©pass√© votre quota¬†!&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgent¬†: vous avez utilis√© 90% de votre quota¬†!&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement¬†: vous avez utilis√© 75% de votre quota¬†!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MessagerMock {
</span><span class="boring">        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MessagerMock {
</span><span class="boring">        fn new() -&gt; MessagerMock {
</span><span class="boring">            MessagerMock {
</span><span class="boring">                messages_envoyes: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            let mut premier_emprunt = self.messages_envoyes.borrow_mut();
            let mut second_emprunt = self.messages_envoyes.borrow_mut();

            premier_emprunt.push(String::from(message));
            second_emprunt.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
</span><span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that `RefCell<T>` will panic</span>
-->
<p><span class="caption">Encart 15-23¬†: cr√©ation de deux r√©f√©rences mutables dans
la m√™me port√©e pour voir si <code>RefCell&lt;T&gt;</code> va paniquer</span></p>
<!--
We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned
from `borrow_mut`. Then we create another mutable borrow in the same way in the
variable `two_borrow`. This makes two mutable references in the same scope,
which isn‚Äôt allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:
-->
<p>Nous cr√©ons une variable <code>premier_emprunt</code> pour le pointeur intelligent
<code>RefMut&lt;T&gt;</code> retourn√© par <code>borrow_mut</code>. Ensuite nous cr√©ons un autre emprunt de
la m√™me mani√®re, qui s'appelle <code>second_emprunt</code>. Cela fait deux r√©f√©rences
mutables dans la m√™me port√©e, ce qui n'est pas autoris√©. Lorsque nous lan√ßons
les tests sur notre biblioth√®que, le code de l'encart 15-23 va se compiler
sans erreur, mais les tests vont √©chouer¬†:</p>
<!--
```console
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent ... FAILED

failures:

---- tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Notice that the code panicked with the message `already borrowed:
BorrowMutError`. This is how `RefCell<T>` handles violations of the borrowing
rules at runtime.
-->
<p>Remarquez que le code a paniqu√© avec le message
<code>already borrowed: BorrowMutError</code> (NdT¬†: <code>d√©j√† emprunt√©</code>). C'est ainsi que
<code>RefCell&lt;T&gt;</code> g√®re les violations des r√®gles d'emprunt √† l'ex√©cution.</p>
<!--
Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until your code was deployed to production. Also, your code would incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using `RefCell<T>` makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while you‚Äôre using it in a context where only immutable
values are allowed. You can use `RefCell<T>` despite its trade-offs to get more
functionality than regular references provide.
-->
<p>La d√©tection des erreurs d'emprunt √† l'ex√©cution plut√¥t qu'√† la compilation
signifie que vous pourriez d√©couvrir une erreur dans votre code plus tard dans le
processus de d√©veloppement et peut-√™tre m√™me pas avant que votre code ne soit
d√©ploy√© en production. De plus, votre code va subir une petite perte de
performances √† l'ex√©cution en raison du contr√¥le des emprunts √† l'ex√©cution
plut√¥t qu'√† la compilation. Cependant, l'utilisation de <code>RefCell&lt;T&gt;</code> rend
possible l'√©criture d'un mock object qui peut se modifier lui-m√™me afin
d'enregistrer les messages qu'il a vu passer alors que vous l'utilisez dans un
contexte o√π seules les valeurs immuables sont permises. Vous pouvez utiliser
<code>RefCell&lt;T&gt;</code> malgr√© ses inconv√©nients pour obtenir plus de fonctionnalit√©s
que celles qu'offre une r√©f√©rence classique.</p>
<!--
### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>`
-->
<h3 id="permettre-plusieurs-propri√©taires-de-donn√©es-mutables-en-combinant-rct-et-refcellt"><a class="header" href="#permettre-plusieurs-propri√©taires-de-donn√©es-mutables-en-combinant-rct-et-refcellt">Permettre plusieurs propri√©taires de donn√©es mutables en combinant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code></a></h3>
<!--
A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that
`Rc<T>` lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you can
get a value that can have multiple owners *and* that you can mutate!
-->
<p>Il est courant d'utiliser <code>RefCell&lt;T&gt;</code> en tandem avec <code>Rc&lt;T&gt;</code>. Rappelez-vous
que <code>Rc&lt;T&gt;</code> vous permet d'avoir plusieurs propri√©taires d'une m√™me donn√©e, mais
qu'il ne vous donne qu'un seul acc√®s immuable √† cette donn√©e. Si vous avez un
<code>Rc&lt;T&gt;</code> qui contient un <code>RefCell&lt;T&gt;</code>, vous pouvez obtenir une valeur qui peut
avoir plusieurs propri√©taires <em>et</em> que vous pouvez modifier¬†!</p>
<!--
For example, recall the cons list example in Listing 15-18 where we used
`Rc<T>` to allow multiple lists to share ownership of another list. Because
`Rc<T>` holds only immutable values, we can‚Äôt change any of the values in the
list once we‚Äôve created them. Let‚Äôs add in `RefCell<T>` to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
`RefCell<T>` in the `Cons` definition, we can modify the value stored in all
the lists:
-->
<p>Souvenez-vous de l'exemple de la liste de construction de l'encart 15-18 o√π nous
avions utilis√© <code>Rc&lt;T&gt;</code> pour permettre √† plusieurs listes de se partager la
possession d'une autre liste. Comme <code>Rc&lt;T&gt;</code> stocke seulement des valeurs
immuables, nous ne pouvons changer aucune valeur dans la liste une fois que
nous l'avons cr√©√©e. Ajoutons un <code>RefCell&lt;T&gt;</code> pour pouvoir changer les valeurs
dans les listes. L'encart 15-24 nous montre ceci en ajoutant un <code>RefCell&lt;T&gt;</code>
dans la d√©finition de <code>Cons</code>, nous pouvons ainsi modifier les valeurs stock√©es
dans n'importe quelle liste¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let valeur = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valeur), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *valeur.borrow_mut() += 10;

    println!(&quot;a apr√®s les op√©rations = {:?}&quot;, a);
    println!(&quot;b apr√®s les op√©rations = {:?}&quot;, b);
    println!(&quot;c apr√®s les op√©rations = {:?}&quot;, c);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-24: Using `Rc<RefCell<i32>>` to create a
`List` that we can mutate</span>
-->
<p><span class="caption">Encart 15-24¬†: utilisation de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> pour
cr√©er une <code>List</code> que nous pouvons modifier</span></p>
<!--
We create a value that is an instance of `Rc<RefCell<i32>>` and store it in a
variable named `value` so we can access it directly later. Then we create a
`List` in `a` with a `Cons` variant that holds `value`. We need to clone
`value` so both `a` and `value` have ownership of the inner `5` value rather
than transferring ownership from `value` to `a` or having `a` borrow from
`value`.
-->
<p>Nous cr√©ons une valeur qui est une instance de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> et nous la
stockons dans une variable <code>valeur</code> afin que nous puissions y avoir acc√®s plus
tard. Ensuite, nous cr√©ons une <code>List</code> dans <code>a</code> avec une variante de <code>Cons</code> qui
utilise <code>valeur</code>. Nous devons utiliser clone sur <code>valeur</code> afin que <code>a</code> et
<code>valeur</code> soient toutes les deux propri√©taires de la valeur interne <code>5</code> plut√¥t
que d'avoir √† transf√©rer la possession de <code>valeur</code> √† <code>a</code> ou avoir <code>a</code> qui
emprunte <code>valeur</code>.</p>
<!--
We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, they
can both refer to `a`, which is what we did in Listing 15-18.
-->
<p>Nous ins√©rons la liste <code>a</code> dans un <code>Rc&lt;T&gt;</code> pour que, lorsque nous cr√©ons <code>b</code> et
<code>c</code>, elles puissent toutes les deux utiliser <code>a</code>, ce que nous avions d√©j√† fait
dans l'encart 15-18.</p>
<!--
After we‚Äôve created the lists in `a`, `b`, and `c`, we add 10 to the value in
`value`. We do this by calling `borrow_mut` on `value`, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
[‚ÄúWhere‚Äôs the `->` Operator?‚Äù][wheres-the---operator]<!-- ignore -- >) to
dereference the `Rc<T>` to the inner `RefCell<T>` value. The `borrow_mut`
method returns a `RefMut<T>` smart pointer, and we use the dereference operator
on it and change the inner value.
-->
<p>Apr√®s avoir cr√©√© les listes dans <code>a</code>, <code>b</code>, et <code>c</code>, nous ajoutons 10 √† la valeur
dans <code>valeur</code>. Nous faisons cela en appelant <code>borrow_mut</code> sur <code>valeur</code>, ce qui
utilise la fonctionnalit√© de d√©r√©f√©rencement automatique que nous avons vue au
chapitre 5 (voir la section
<a href="ch05-03-method-syntax.html#o%C3%B9-est-lop%C3%A9rateur---">‚ÄúO√π est l'op√©rateur -&gt; ?‚Äù</a><!-- ignore -->) pour
d√©r√©f√©rencer le <code>Rc&lt;T&gt;</code> dans la valeur interne <code>RefCell&lt;T&gt;</code>. La m√©thode
<code>borrow_mut</code> retourne un pointeur intelligent <code>RefMut&lt;T&gt;</code>, et nous utilisons
l'op√©rateur de d√©r√©f√©rencement sur lui pour changer sa valeur interne.</p>
<!--
When we print `a`, `b`, and `c`, we can see that they all have the modified
value of 15 rather than 5:
-->
<p>Lorsque nous affichons <code>a</code>, <code>b</code> et <code>c</code>, nous pouvons constater qu'elles ont
toutes la valeur modifi√©e de 15 au lieu de 5¬†:</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a apr√®s les op√©rations = Cons(RefCell { value: 15 }, Nil)
b apr√®s les op√©rations = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c apr√®s les op√©rations = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<!--
This technique is pretty neat! By using `RefCell<T>`, we have an outwardly
immutable `List` value. But we can use the methods on `RefCell<T>` that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it‚Äôs
sometimes worth trading a bit of speed for this flexibility in our data
structures.
-->
<p>Cette technique est plut√¥t ing√©nieuse¬†! En utilisant <code>RefCell&lt;T&gt;</code>, nous avons
une valeur <code>List</code> qui est immuable de l'ext√©rieur. Mais nous pouvons utiliser
les m√©thodes de <code>RefCell&lt;T&gt;</code> qui nous donne acc√®s √† sa mutabilit√© interne afin
que nous puissions modifier notre donn√©e lorsque nous en avons besoin. Les
v√©rifications des r√®gles d'emprunt √† l'ex√©cution nous prot√®gent des acc√®s
concurrents, et il est parfois int√©ressant de sacrifier un peu de vitesse pour
cette flexibilit√© dans nos structures de donn√©es.</p>
<!--
The standard library has other types that provide interior mutability, such as
`Cell<T>`, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the `Cell<T>`. There‚Äôs also
`Mutex<T>`, which offers interior mutability that‚Äôs safe to use across threads;
we‚Äôll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.
-->
<p>La biblioth√®que standard a d'autres types qui fournissent de la mutabilit√©
interne, comme <code>Cell&lt;T&gt;</code>, qui est similaire sauf qu'au lieu de fournir des
r√©f√©rences √† la valeur interne, la valeur est copi√©e √† l'int√©rieur et √†
l'ext√©rieur du <code>Cell&lt;T&gt;</code>. Il existe aussi <code>Mutex&lt;T&gt;</code> qui offre de la mutabilit√©
interne qui est s√©curis√©e pour une utilisation partag√©e entre plusieures
t√¢ches¬†; nous allons voir son utilisation au chapitre 16. Plongez-vous dans la
documentation de la biblioth√®que standard pour plus de d√©tails entre ces
diff√©rents types.</p>
<!--
[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Reference Cycles Can Leak Memory
-->
<h2 id="les-boucles-de-r√©f√©rences-qui-peuvent-provoquer-des-fuites-de-m√©moire"><a class="header" href="#les-boucles-de-r√©f√©rences-qui-peuvent-provoquer-des-fuites-de-m√©moire">Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></h2>
<!--
Rust‚Äôs memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a *memory leak*).
Preventing memory leaks entirely is not one of Rust‚Äôs guarantees, meaning
memory leaks are memory safe in Rust. We can see that Rust allows memory leaks
by using `Rc<T>` and `RefCell<T>`: it‚Äôs possible to create references where
items refer to each other in a cycle. This creates memory leaks because the
reference count of each item in the cycle will never reach 0, and the values
will never be dropped.
-->
<p>Les garanties de s√©curit√© de la m√©moire de Rust rendent difficile, mais pas
impossible, la cr√©ation accidentelle de m√©moire qui n'est jamais nettoy√©e
(aussi appel√©e <em>fuite de m√©moire</em>). Eviter totalement les fuites de m√©moire
n'est pas une des garanties de Rust, en tout cas pas comme pour l'acc√®s
concurrent au moment de la compilation, ce qui signifie que les fuites de
m√©moire sont sans risque pour la m√©moire avec Rust. Nous pouvons constater
que Rust permet les fuites de m√©moire en utilisant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code>¬†: il
est possible de cr√©er des r√©f√©rences o√π les √©l√©ments se r√©f√®rent entre eux de
mani√®re cyclique. Cela cr√©e des fuites de m√©moire car le compteur de r√©f√©rences
de chaque √©l√©ment dans la boucle de r√©f√©rences ne vaudra jamais 0, et les
valeurs ne seront jamais lib√©r√©es.</p>
<!--
### Creating a Reference Cycle
-->
<h3 id="cr√©er-une-boucle-de-r√©f√©rences"><a class="header" href="#cr√©er-une-boucle-de-r√©f√©rences">Cr√©er une boucle de r√©f√©rences</a></h3>
<!--
Let‚Äôs look at how a reference cycle might happen and how to prevent it,
starting with the definition of the `List` enum and a `tail` method in Listing
15-25:
-->
<p>Voyons comment une boucle de r√©f√©rences peut exister et comment l'√©viter, en
commen√ßant par la d√©finition de l'√©num√©ration <code>List</code> et la m√©thode <code>parcourir</code>
de l'encart 15-25¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 15-25: A cons list definition that holds a
`RefCell<T>` so we can modify what a `Cons` variant is referring to</span>
-->
<p><span class="caption">Encart 15-25¬†: une liste de construction qui stocke une
<code>RefCell&lt;T&gt;</code> pour que nous puissions modifier ce sur quoi une variante <code>Cons</code>
pointe</span></p>
<!--
We‚Äôre using another variation of the `List` definition from Listing 15-5. The
second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that
instead of having the ability to modify the `i32` value as we did in Listing
15-24, we want to modify which `List` value a `Cons` variant is pointing to.
We‚Äôre also adding a `tail` method to make it convenient for us to access the
second item if we have a `Cons` variant.
-->
<p>Nous utilisons une autre variation de la d√©finition de <code>List</code> de l'encart 15-5.
Le second √©l√©ment dans la variante <code>Cons</code> est maintenant un
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, ce qui signifie qu'au lieu de pouvoir modifier la valeur
<code>i32</code> comme nous l'avions fait dans l'encart 15-24, nous modifions ce sur quoi
une variante <code>Cons</code> pointe (qui reste une valeur <code>List</code>). Nous ajoutons
√©galement une m√©thode <code>parcourir</code> pour nous faciliter l'acc√®s au second √©l√©ment
si nous avons une variante <code>Cons</code>.</p>
<!--
In Listing 15-26, we‚Äôre adding a `main` function that uses the definitions in
Listing 15-25. This code creates a list in `a` and a list in `b` that points to
the list in `a`. Then it modifies the list in `a` to point to `b`, creating a
reference cycle. There are `println!` statements along the way to show what the
reference counts are at various points in this process.
-->
<p>Dans l'encart 15-26, nous ajoutons une fonction <code>main</code> qui utilise les
d√©finitions de l'encart 15-25. Ce code cr√©e une liste dans <code>a</code> et une liste
dans <code>b</code> qui pointe sur la liste de <code>a</code>. Ensuite, on modifie la liste de <code>a</code>
pour pointer sur <code>b</code>, ce qui cr√©e une boucle de r√©f√©rences. Il y a aussi des
instructions <code>println!</code> tout du long pour montrer la valeur des compteurs de
r√©f√©rences √† diff√©rents endroits du processus.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use crate::List::{Cons, Nil};
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell<Rc<List>>),
#     Nil,
# }
# 
# impl List {
#     fn tail(&self) -> Option<&RefCell<Rc<List>>> {
#         match self {
#             Cons(_, item) => Some(item),
#             Nil => None,
#         }
#     }
# }
# 
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;compteur initial de a = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;prochain √©l√©ment de a = {:?}&quot;, a.parcourir());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;compteur de a apr√®s cr√©ation de b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;compteur initial de b = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;prochain √©l√©ment de b = {:?}&quot;, b.parcourir());

    if let Some(lien) = a.parcourir() {
        *lien.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;compteur de b apr√®s avoir chang√© a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;compteur de a apr√®s avoir chang√© a = {}&quot;, Rc::strong_count(&amp;a));

    // D√©commentez la ligne suivante pour constater que nous sommes dans
    // une boucle de r√©f√©rences, cela fera d√©border la pile
    // println!(&quot;prochain √©l√©ment de a = {:?}&quot;, a.parcourir());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-26: Creating a reference cycle of two `List`
values pointing to each other</span>
-->
<p><span class="caption">Encart 15-26¬†: cr√©ation d'une boucle de r√©f√©rences de
deux valeurs <code>List</code> qui se pointent mutuellement dessus</span></p>
<!--
We create an `Rc<List>` instance holding a `List` value in the variable `a`
with an initial list of `5, Nil`. We then create an `Rc<List>` instance
holding another `List` value in the variable `b` that contains the value 10 and
points to the list in `a`.
-->
<p>Nous cr√©ons une instance <code>Rc&lt;List&gt;</code> qui stocke une valeur <code>List</code> dans la
variable <code>a</code> avec une valeur initiale de <code>5, Nil</code>. Nous cr√©ons ensuite une
instance <code>Rc&lt;List&gt;</code> qui stocke une autre valeur <code>List</code> dans la variable <code>b</code>
qui contient la valeur 10 et pointe vers la liste dans <code>a</code>.</p>
<!--
We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We
do that by using the `tail` method to get a reference to the
`RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use
the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside
from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`.
-->
<p>Nous modifions <code>a</code> afin qu'elle pointe sur <code>b</code> au lieu de <code>Nil</code>, ce qui cr√©e
une boucle. Nous faisons ceci en utilisant la m√©thode <code>parcourir</code> pour obtenir
une r√©f√©rence au <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> pr√©sent dans <code>a</code>, que nous pla√ßons dans la
variable <code>lien</code>. Ensuite nous utilisons la m√©thode <code>borrow_mut</code> sur le
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> pour remplacer la valeur actuellement pr√©sente en son sein,
la <code>Rc&lt;List&gt;</code> contenant <code>Nil</code>, par la <code>Rc&lt;List&gt;</code> pr√©sente dans <code>b</code>.</p>
<!--
When we run this code, keeping the last `println!` commented out for the
moment, we‚Äôll get this output:
-->
<p>Lorsque nous ex√©cutons ce code, en gardant le dernier <code>println!</code> comment√©
pour le moment, nous obtenons ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
compteur initial de a = 1
prochain √©l√©ment de a = Some(RefCell { value: Nil })
compteur de a apr√®s cr√©ation de b = 2
compteur initial de b = 1
prochain √©l√©ment de b = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
compteur de b apr√®s avoir chang√© a = 2
compteur de a apr√®s avoir chang√© a = 2
</code></pre>
<!--
The reference count of the `Rc<List>` instances in both `a` and `b` are 2 after
we change the list in `a` to point to `b`. At the end of `main`, Rust drops the
variable `b`, which decreases the reference count of the `Rc<List>` instance
from 2 to 1. The memory that `Rc<List>` has on the heap won‚Äôt be dropped at
this point, because its reference count is 1, not 0. Then Rust drops `a`, which
decreases the reference count of the `a` `Rc<List>` instance from 2 to 1 as
well. This instance‚Äôs memory can‚Äôt be dropped either, because the other
`Rc<List>` instance still refers to it. The memory allocated to the list will
remain uncollected forever. To visualize this reference cycle, we‚Äôve created a
diagram in Figure 15-4.
-->
<p>Les compteurs de r√©f√©rences des instances de <code>Rc&lt;List&gt;</code> valent tous les deux 2
pour <code>a</code> et <code>b</code> apr√®s avoir modifi√© <code>a</code> pour qu'elle pointe sur <code>b</code>. A la fin
du <code>main</code>, Rust nettoie d'abord la variable <code>b</code>, ce qui d√©cr√©mente le compteur
de r√©f√©rences dans l'instance <code>Rc&lt;List&gt;</code> de 2 √† 1. La m√©moire utilis√©e sur le
tas par <code>Rc&lt;List&gt;</code> ne sera pas lib√©r√©e √† ce moment, car son compteur de
r√©f√©rences est √† 1, et non pas 0. Puis, Rust lib√®re <code>a</code>, ce qui d√©cr√©mente le
compteur <code>a</code> de r√©f√©rences <code>Rc&lt;List&gt;</code> de 2 √† 1, √©galement. La m√©moire de cette
instance ne peut pas non plus √™tre lib√©r√©e car l'autre instance <code>Rc&lt;List&gt;</code> y
fait toujours r√©f√©rence. La m√©moire alou√©e √† la liste ne sera jamais lib√©r√©e.
Pour repr√©senter cette boucle de r√©f√©rences, nous avons cr√©√© un diagramme dans
l'illustration 15-4.</p>
<!--
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
-->
<p><img
    alt="Une boucle de r√©f√©rences de listes"
    src="img/trpl15-04.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-4: A reference cycle of lists `a` and `b`
pointing to each other</span>
-->
<p><span class="caption">Illustration 15-4¬†: une boucle de r√©f√©rences entre les
listes <code>a</code> et <code>b</code> qui se pointent mutuellement dessus</span></p>
<!--
If you uncomment the last `println!` and run the program, Rust will try to
print this cycle with `a` pointing to `b` pointing to `a` and so forth until it
overflows the stack.
-->
<p>Si vous d√©commentez le dernier <code>println!</code> et que vous ex√©cutez le programme,
Rust va essayer d'afficher cette boucle avec <code>a</code> qui pointe sur <code>b</code> qui pointe
sur <code>a</code> ... et ainsi de suite jusqu'√† ce que cela fasse d√©border la pile.</p>
<!--
In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle aren‚Äôt very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.
-->
<p>Dans ce cas, juste apr√®s que nous avons cr√©√© la boucle de r√©f√©rences, le
programme se termine. Les cons√©quences de cette boucle ne sont pas
d√©sastreuses. Cependant, si un programme plus complexe alloue beaucoup de
m√©moire dans une boucle de r√©f√©rences et la garde pendant longtemps, le
programme va utiliser bien plus de m√©moire qu'il n'en a besoin et pourrait
surcharger le syst√®me en consommant ainsi toute la m√©moire disponible.</p>
<!--
Creating reference cycles is not easily done, but it‚Äôs not impossible either.
If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don‚Äôt create cycles; you can‚Äôt rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.
-->
<p>La cr√©ation de boucles de r√©f√©rences n'est pas facile √† r√©aliser, mais n'est pas
non plus impossible. Si vous avez des valeurs <code>RefCell&lt;T&gt;</code> qui contiennent des
valeurs <code>Rc&lt;T&gt;</code> ou des combinaisons similaires de types embo√Æt√©s avec de la
mutabilit√© interne et du comptage de r√©f√©rences, vous devez vous assurer que
vous ne cr√©ez pas de boucles¬†; vous ne pouvez pas compter sur Rust pour les
d√©tecter. La cr√©ation de boucle de r√©f√©rences devrait √™tre un bogue de logique
de votre programme dont vous devriez r√©duire le risque en pratiquant des tests
automatis√©s, des revues de code, ainsi que d'autres pratiques de d√©veloppement.</p>
<!--
Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don‚Äôt.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want `Cons`
variants to own their list, so reorganizing the data structure isn‚Äôt possible.
Let‚Äôs look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.
-->
<p>Une autre solution pour √©viter les boucles de r√©f√©rences est de r√©organiser vos
structures de donn√©es afin que certaines r√©f√©rences prennent possession et
d'autres non. Par cons√©quent, vous pouvez obtenir des boucles de certaines
r√©f√©rences qui prennent possession ou d'autres r√©f√©rences qui ne prennent pas
possession, et seules celles qui prennent possession d√©cident si oui ou non une
valeur peut √™tre lib√©r√©e. Dans l'encart 15-25, nous voulons toujours que les
variantes <code>Cons</code> poss√®dent leur propre liste, donc il est impossible de
r√©organiser la structure des donn√©es. Voyons maintenant un exemple qui utilise
des graphes constitu√©s de n≈ìuds parents et de n≈ìuds enfants pour voir quand
des relations sans possessions constituent un moyen appropri√© d'√©viter les
boucles de r√©f√©rences.</p>
<!--
### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`
-->
<h3 id="eviter-les-boucles-de-r√©f√©rences--transformer-un-rct-en-weakt"><a class="header" href="#eviter-les-boucles-de-r√©f√©rences--transformer-un-rct-en-weakt">Eviter les boucles de r√©f√©rences¬†: transformer un <code>Rc&lt;T&gt;</code> en <code>Weak&lt;T&gt;</code></a></h3>
<!--
So far, we‚Äôve demonstrated that calling `Rc::clone` increases the
`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned
up if its `strong_count` is 0. You can also create a *weak reference* to the
value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a
reference to the `Rc<T>`. When you call `Rc::downgrade`, you get a smart
pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the
`Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1.
The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>`
references exist, similar to `strong_count`. The difference is the `weak_count`
doesn‚Äôt need to be 0 for the `Rc<T>` instance to be cleaned up.
-->
<p>Pr√©c√©demment, nous avons d√©montr√© que l'appel √† <code>Rc::clone</code> augmente le
<code>strong_count</code> d'une instance de <code>Rc&lt;T&gt;</code>, et une instance <code>Rc&lt;T&gt;</code> est nettoy√©e
seulement si son <code>strong_count</code> est √† 0. Vous pouvez aussi cr√©er une <em>r√©f√©rence
faible</em> (NdT¬†: d'o√π le <code>weak</code>) vers la valeur pr√©sente dans une instance <code>Rc&lt;T&gt;</code>
en appelant <code>Rc::downgrade</code> et en lui passant une r√©f√©rence vers le <code>Rc&lt;T&gt;</code>.
Lorsque vous faites appel √† <code>Rc::downgrade</code>, vous obtenez un pointeur
intelligent du type <code>Weak&lt;T&gt;</code>. Plut√¥t que d'augmenter le <code>strong_count</code> de
l'instance de 1, l'appel √† <code>Rc::downgrade</code> augmente le <code>weak_count</code> de 1. Le
type <code>Rc&lt;T&gt;</code> utilise le <code>weak_count</code> pour compter combien de r√©f√©rences
<code>Weak&lt;T&gt;</code> existent, de la m√™me mani√®re que <code>strong_count</code>. La diff√©rence r√©side
dans le fait que <code>weak_count</code> n'a pas besoin d'√™tre √† 0 pour que l'instance
<code>Rc&lt;T&gt;</code> soit nettoy√©e.</p>
<!--
Strong references are how you can share ownership of an `Rc<T>` instance. Weak
references don‚Äôt express an ownership relationship. They won‚Äôt cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.
-->
<p>Les r√©f√©rences fortes d√©signent la mani√®re de partager la propri√©t√© d'une
instance <code>Rc&lt;T&gt;</code>. Les r√©f√©rences faibles n'expriment pas de relation de
possession. Ils ne provoqueront pas de boucle de r√©f√©rences car n'importe quelle
boucle impliquant des r√©f√©rences faibles sera d√©truite une fois que le compteur de
r√©f√©rences fortes des valeurs impliqu√©es vaudra 0.</p>
<!--
Because the value that `Weak<T>` references might have been dropped, to do
anything with the value that a `Weak<T>` is pointing to, you must make sure the
value still exists. Do this by calling the `upgrade` method on a `Weak<T>`
instance, which will return an `Option<Rc<T>>`. You‚Äôll get a result of `Some`
if the `Rc<T>` value has not been dropped yet and a result of `None` if the
`Rc<T>` value has been dropped. Because `upgrade` returns an `Option<Rc<T>>`,
Rust will ensure that the `Some` case and the `None` case are handled, and
there won‚Äôt be an invalid pointer.
-->
<p>Comme la valeur contenue dans une r√©f√©rence <code>Weak&lt;T&gt;</code> peut √™tre lib√©r√©e, pour
pouvoir faire quelque chose avec cette valeur, vous devez vous assurer qu'elle
existe toujours. Vous pouvez faire ceci en appelant la m√©thode <code>upgrade</code> sur
une instance <code>Weak&lt;T&gt;</code>, qui va retourner une <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Ce r√©sultat
retournera <code>Some</code> si la valeur <code>Rc&lt;T&gt;</code> n'a pas encore √©t√© lib√©r√©e, et un <code>None</code>
si la valeur <code>Rc&lt;T&gt;</code> a √©t√© lib√©r√©e. Comme <code>upgrade</code> retourne une
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust va s'assurer que les cas de <code>Some</code> et de <code>None</code> sont bien
g√©r√©s, et qu'il n'existe pas de pointeur invalide.</p>
<!--
As an example, rather than using a list whose items know only about the next
item, we‚Äôll create a tree whose items know about their children items *and*
their parent items.
-->
<p>Par exemple, plut√¥t que d'utiliser une liste dont les √©l√©ments ne connaissent
que les √©l√©ments suivants, nous allons cr√©er un arbre dont les √©l√©ments
connaissent les √©l√©ments enfants <em>et</em> leurs √©l√©ments parents.</p>
<!--
#### Creating a Tree Data Structure: a `Node` with Child Nodes
-->
<h4 id="cr√©er-une-structure-darbre-de-donn√©es--un-noeud-avec-des-n≈ìuds-enfants"><a class="header" href="#cr√©er-une-structure-darbre-de-donn√©es--un-noeud-avec-des-n≈ìuds-enfants">Cr√©er une structure d'arbre de donn√©es¬†: un <code>Noeud</code> avec des n≈ìuds enfants</a></h4>
<!--
To start, we‚Äôll build a tree with nodes that know about their child nodes.
We‚Äôll create a struct named `Node` that holds its own `i32` value as well as
references to its children `Node` values:
-->
<p>Pour commencer, nous allons cr√©er un arbre avec des n≈ìuds qui connaissent
leurs n≈ìuds enfants. Nous allons cr√©er une structure <code>Noeud</code> qui contient sa
propre valeur ainsi que les r√©f√©rences vers ses <code>Noeud</code> enfants¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         children: RefCell::new(vec![]),
#     });
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<!--
We want a `Node` to own its children, and we want to share that ownership with
variables so we can access each `Node` in the tree directly. To do this, we
define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to
modify which nodes are children of another node, so we have a `RefCell<T>` in
`children` around the `Vec<Rc<Node>>`.
-->
<p>Nous souhaitons qu'un <code>Noeud</code> prenne possession de ses enfants, et nous
souhaitons partager la possession avec des variables afin d'acc√©der directement
√† chaque <code>Noeud</code> de l'arbre. Pour pouvoir faire ceci, nous d√©finissons les
√©l√©ments du <code>Vec&lt;T&gt;</code> comme √©tant des valeurs du type <code>Rc&lt;Noeud&gt;</code>. Nous
souhaitons √©galement pouvoir modifier le fait que tel n≈ìud soit enfant de tel
autre, donc, dans <code>enfants</code>, nous englobons le <code>Vec&lt;Rc&lt;Noeud&gt;&gt;</code> dans un
<code>RefCell&lt;T&gt;</code>.</p>
<!--
Next, we‚Äôll use our struct definition and create one `Node` instance named
`leaf` with the value 3 and no children, and another instance named `branch`
with the value 5 and `leaf` as one of its children, as shown in Listing 15-27:
-->
<p>Ensuite, nous allons utiliser notre d√©finition de structure et cr√©er une
instance de <code>Noeud</code> qui s'appellera <code>feuille</code> avec la valeur <code>3</code> et sans
enfant, comme dans l'encart 15-27¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Filename¬†: src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        enfants: RefCell::new(vec![]),
    });

    let branche = Rc::new(Noeud {
        valeur: 5,
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-27: Creating a `leaf` node with no children
and a `branch` node with `leaf` as one of its children</span>
-->
<p><span class="caption">Encart 15-27¬†: cr√©ation d'un n≈ìud <code>feuille</code> sans aucun
enfant et un n≈ìud <code>branche</code> avec <code>feuille</code> comme enfant</span></p>
<!--
We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the
`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from
`branch` to `leaf` through `branch.children`, but there‚Äôs no way to get from
`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and
doesn‚Äôt know they‚Äôre related. We want `leaf` to know that `branch` is its
parent. We‚Äôll do that next.
-->
<p>Nous cr√©ons un clone du <code>Rc&lt;Noeud&gt;</code> dans <code>feuille</code> et nous le stockons dans
<code>branche</code>, ce qui signifie que le <code>Noeud</code> dans <code>feuille</code> a maintenant deux
propri√©taires¬†: <code>feuille</code> et <code>branche</code>. Nous pouvons obtenir <code>feuille</code> √† partir
de <code>branche</code> en utilisant <code>branche.feuille</code>, mais il n'y a pas de moyen
d'obtenir <code>branche</code> √† partir de <code>feuille</code>. La raison est que <code>feuille</code> n'a pas
de r√©f√©rence vers <code>branche</code> et ne sait pas s'ils sont li√©s. Nous voulons que
<code>feuille</code> sache quelle <code>branche</code> est son parent. C'est ce que nous allons faire
d√®s maintenant.</p>
<!--
#### Adding a Reference from a Child to Its Parent
-->
<h4 id="ajouter-une-r√©f√©rence-√†-un-enfant-vers-son-parent"><a class="header" href="#ajouter-une-r√©f√©rence-√†-un-enfant-vers-son-parent">Ajouter une r√©f√©rence √† un enfant vers son parent</a></h4>
<!--
To make the child node aware of its parent, we need to add a `parent` field to
our `Node` struct definition. The trouble is in deciding what the type of
`parent` should be. We know it can‚Äôt contain an `Rc<T>`, because that would
create a reference cycle with `leaf.parent` pointing to `branch` and
`branch.children` pointing to `leaf`, which would cause their `strong_count`
values to never be 0.
-->
<p>Pour que le n≈ìud enfant connaisse son parent, nous devons ajouter un champ
<code>parent</code> vers notre d√©finition de structure <code>Noeud</code>. La difficult√© ici est de
choisir quel sera le type de <code>parent</code>. Nous savons qu'il ne peut pas contenir
de <code>Rc&lt;T&gt;</code>, car cela cr√©era une boucle de r√©f√©rence avec <code>feuille.parent</code> qui
pointe sur <code>branche</code> et <code>branche.enfant</code> qui pointe sur <code>feuille</code>, ce qui va
faire que leurs valeurs <code>strong_count</code> ne seront jamais √† 0.</p>
<!--
Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!
-->
<p>En concevant le lien d'une autre mani√®re, un n≈ìud parent devrait prendre
possession de ses enfants¬†: si un n≈ìud parent est lib√©r√©, ses n≈ìuds enfants
devraient aussi √™tre lib√©r√©s. Cependant, un enfant ne devrait pas prendre
possession de son parent¬†: si nous lib√©rons un n≈ìud enfant, le parent doit
toujours exister. C'est donc un cas d'emploi pour les r√©f√©rences faibles¬†!</p>
<!--
So instead of `Rc<T>`, we‚Äôll make the type of `parent` use `Weak<T>`,
specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks
like this:
-->
<p>Donc, plut√¥t qu'un <code>Rc&lt;T&gt;</code>, nous allons faire en sorte que le type de <code>parent</code>
soit un <code>Weak&lt;T&gt;</code>, plus pr√©cis√©ment un <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code>. Maintenant,
la d√©finition de notre structure <code>Noeud</code> devrait ressembler √† ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![]),
#     });
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# 
#     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<!--
A node will be able to refer to its parent node but doesn‚Äôt own its parent.
In Listing 15-28, we update `main` to use this new definition so the `leaf`
node will have a way to refer to its parent, `branch`:
-->
<p>Un n≈ìud devrait pouvoir avoir une r√©f√©rence vers son n≈ìud parent, mais il ne
devrait pas prendre possession de son parent. Dans l'encart 15-28, nous mettons
√† jour cette nouvelle d√©finition pour que le n≈ìud <code>feuille</code> puisse avoir un
moyen de pointer vers son parent, <code>branche</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());

    let branche = Rc::new(Noeud {
        valeur: 5,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });

    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-28: A `leaf` node with a weak reference to its
parent node `branch`</span>
-->
<p><span class="caption">Encart 15-28¬†: un n≈ìud <code>feuille</code> avec une r√©f√©rence faible
vers son n≈ìud parent, <code>branche</code></span></p>
<!--
Creating the `leaf` node looks similar to how creating the `leaf` node looked
in Listing 15-27 with the exception of the `parent` field: `leaf` starts out
without a parent, so we create a new, empty `Weak<Node>` reference instance.
-->
<p>La cr√©ation du n≈ìud <code>feuille</code> semble √™tre identique √† la cr√©ation du n≈ìud
<code>feuille</code> de l'encart 15-27, sauf pour le champ <code>parent</code>¬†: <code>feuille</code> commence
sans parent, donc nous cr√©ons une nouvelle instance de r√©f√©rence de type
<code>Weak&lt;Noeud&gt;</code>, qui est vide.</p>
<!--
At this point, when we try to get a reference to the parent of `leaf` by using
the `upgrade` method, we get a `None` value. We see this in the output from the
first `println!` statement:
-->
<p>A ce moment-l√†, lorsque nous essayons d'obtenir une r√©f√©rence vers le parent de
<code>feuille</code> en utilisant la m√©thode <code>upgrade</code>, nous obtenons une valeur <code>None</code>.
Nous constatons cela dans la premi√®re instruction <code>println!</code> sur la sortie¬†:</p>
<!--
```text
leaf parent = None
```
-->
<pre><code class="language-text">parent de la feuille = None
</code></pre>
<!--
When we create the `branch` node, it will also have a new `Weak<Node>`
reference in the `parent` field, because `branch` doesn‚Äôt have a parent node.
We still have `leaf` as one of the children of `branch`. Once we have the
`Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>`
reference to its parent. We use the `borrow_mut` method on the
`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the
`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from
the `Rc<Node>` in `branch.`
-->
<p>Lorsque nous cr√©ons le n≈ìud <code>branche</code>, il va aussi avoir une nouvelle
r√©f√©rence <code>Weak&lt;Noeud&gt;</code> dans le champ <code>parent</code>, car <code>branche</code> n'a pas de n≈ìud
parent. Nous avons n√©anmoins <code>feuille</code> dans <code>enfants</code> de <code>branche</code>. Une fois
que nous avons l'instance de <code>Noeud</code> dans <code>branche</code>, nous pouvons modifier
<code>feuille</code> pour lui donner une r√©f√©rence <code>Weak&lt;Noeud&gt;</code> vers son parent. Nous
utilisons la m√©thode <code>borrow_mut</code> sur la <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code> du champ
<code>parent</code> de <code>feuille</code>, et ensuite nous utilisons la fonction <code>Rc::downgrade</code>
pour cr√©er une r√©f√©rence de type <code>Weak&lt;Node&gt;</code> vers <code>branche</code> √† partir du
<code>Rc&lt;Noeud&gt;</code> pr√©sent dans <code>branche</code>.</p>
<!--
When we print the parent of `leaf` again, this time we‚Äôll get a `Some` variant
holding `branch`: now `leaf` can access its parent! When we print `leaf`, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:
-->
<p>Lorsque nous affichons √† nouveau le parent de <code>feuille</code>, cette fois nous
obtenons la variante <code>Some</code> qui contient <code>branche</code>¬†: d√©sormais, <code>feuille</code> peut
acc√©der √† son parent¬†! Lorsque nous affichons <code>feuille</code>, nous avons aussi √©vit√©
la boucle qui aurait probablement fini en d√©bordement de pile comme nous
l'avions exp√©riment√© dans l'encart 15-26¬†; les r√©f√©rences <code>Weak&lt;Noeud&gt;</code>
s'√©crivent <code>(Weak)</code>¬†:</p>
<!--
```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```
-->
<pre><code class="language-text">parent de la feuille = Some(Noeud { valeur: 5, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [Noeud { valeur: 3, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [] } }] } })
</code></pre>
<!--
The lack of infinite output indicates that this code didn‚Äôt create a reference
cycle. We can also tell this by looking at the values we get from calling
`Rc::strong_count` and `Rc::weak_count`.
-->
<p>L'absence d'une sortie infinie nous confirme que ce code ne cr√©e pas de boucle
de r√©f√©rences. Nous pouvons aussi le constater en affichant les valeurs que
nous pouvons obtenir en faisant appel √† <code>Rc::strong_count</code> et <code>Rc::weak_count</code>.</p>
<!--
#### Visualizing Changes to `strong_count` and `weak_count`
-->
<h4 id="visualiser-les-modifications-de-strong_count-et-weak_count"><a class="header" href="#visualiser-les-modifications-de-strong_count-et-weak_count">Visualiser les modifications de <code>strong_count</code> et <code>weak_count</code></a></h4>
<!--
Let‚Äôs look at how the `strong_count` and `weak_count` values of the `Rc<Node>`
instances change by creating a new inner scope and moving the creation of
`branch` into that scope. By doing so, we can see what happens when `branch` is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:
-->
<p>Regardons comment changent les valeurs <code>strong_count</code> et <code>weak_count</code> des
instances de <code>Rc&lt;Noeud&gt;</code> en cr√©ant une port√©e interne et en d√©pla√ßant la
cr√©ation de <code>branche</code> dans cette port√©e. En faisant ceci, nous pourrons
constater ce qui se passe lorsque <code>branche</code> est cr√©√©e et lorsqu'elle sera
lib√©r√©e lorsqu'elle sortira de la port√©e. Ces modifications sont pr√©sent√©es
dans l'encart 15-29¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );

    {
        let branche = Rc::new(Noeud {
            valeur: 5,
            parent: RefCell::new(Weak::new()),
            enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
        });

        *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

        println!(
            &quot;branche strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branche),
            Rc::weak_count(&amp;branche),
        );

        println!(
            &quot;feuille strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;feuille),
            Rc::weak_count(&amp;feuille),
        );
    }

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-29: Creating `branch` in an inner scope and
examining strong and weak reference counts</span>
-->
<p><span class="caption">Encart 15-29¬†: cr√©ation de <code>branche</code> dans une port√©e
interne et v√©rification des compteurs de r√©f√©rences strong et weak</span></p>
<!--
After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak
count of 0. In the inner scope, we create `branch` and associate it with
`leaf`, at which point when we print the counts, the `Rc<Node>` in `branch`
will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing
to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, we‚Äôll see
it will have a strong count of 2, because `branch` now has a clone of the
`Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak
count of 0.
-->
<p>Apr√®s la cr√©ation de <code>feuille</code>, son <code>Rc&lt;Noeud&gt;</code> a le compteur strong √† 1 et le
compteur weak √† 0. Dans la port√©e interne, nous cr√©ons <code>branche</code> et l'associons
√† <code>feuille</code>, et √† partir de l√†, lorsque nous affichons les compteurs, le
<code>Rc&lt;Noeud&gt;</code> dans <code>branche</code> aura le compteur strong √† 1 et le compteur weak √† 1
(pour que <code>feuille.parent</code> pointe sur <code>branche</code> avec un <code>Weak&lt;Noeud&gt;</code>). Lorsque
nous affichons les compteurs dans <code>feuille</code> nous constatons qu'il a le compteur
strong √† 2, car <code>branche</code> a maintenant un clone du <code>Rc&lt;Noeud&gt;</code> de <code>feuille</code>
stock√© dans <code>branche.enfants</code>, mais a toujours le compteur weak √† 0.</p>
<!--
When the inner scope ends, `branch` goes out of scope and the strong count of
the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1
from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we
don‚Äôt get any memory leaks!
-->
<p>Lorsque la port√©e interne se termine, <code>branche</code> sort de la port√©e et le
compteur strong de <code>Rc&lt;Noeud&gt;</code> d√©cro√Æt √† 0, donc son <code>Noeud</code> est lib√©r√©. Le
compteur weak √† 1 de <code>feuille.parent</code> n'a aucune r√©percussion suite √† la
lib√©ration ou non du <code>Noeud</code>, donc nous ne sommes pas dans une situation de
fuite de m√©moire¬†!</p>
<!--
If we try to access the parent of `leaf` after the end of the scope, we‚Äôll get
`None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong
count of 1 and a weak count of 0, because the variable `leaf` is now the only
reference to the `Rc<Node>` again.
-->
<p>Si nous essayons d'acc√©der au parent de <code>feuille</code> apr√®s la fin de la port√©e,
nous allons √† nouveau obtenir <code>None</code>. A la fin du programme, le <code>Rc&lt;Noeud&gt;</code>
dans <code>feuille</code> a son compteur strong √† 1 et son compteur weak √† 0, car la
variable <code>feuille</code> est √† nouveau la seule r√©f√©rence au <code>Rc&lt;Noeud&gt;</code>.</p>
<!--
All of the logic that manages the counts and value dropping is built into
`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By
specifying that the relationship from a child to its parent should be a
`Weak<T>` reference in the definition of `Node`, you‚Äôre able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.
-->
<p>Toute cette logique qui g√®re les compteurs et les lib√©rations des valeurs est
int√©gr√©e dans <code>Rc&lt;T&gt;</code> et <code>Weak&lt;T&gt;</code> et leurs impl√©mentations du trait <code>Drop</code>. En
pr√©cisant dans la d√©finition de <code>Noeud</code> que le lien entre un enfant et son
parent doit √™tre une r√©f√©rence <code>Weak&lt;T&gt;</code>, vous pouvez avoir des n≈ìuds parents
qui pointent sur des n≈ìuds enfants et vice versa sans risquer de cr√©er des
boucles de r√©f√©rences et des fuites de m√©moire.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-14"><a class="header" href="#r√©sum√©-14">R√©sum√©</a></h2>
<!--
This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
`Box<T>` type has a known size and points to data allocated on the heap. The
`Rc<T>` type keeps track of the number of references to data on the heap so
that data can have multiple owners. The `RefCell<T>` type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.
-->
<p>Ce chapitre a expliqu√© l'utilisation des pointeurs intelligents pour appliquer
des garanties et des compromis diff√©rents de ceux qu'applique Rust par d√©faut avec
les r√©f√©rences classiques. Le type <code>Box&lt;T&gt;</code> a une taille connue et pointe sur
une donn√©e allou√©e sur le tas. Le type <code>Rc&lt;T&gt;</code> compte le nombre de r√©f√©rences
vers une donn√©e pr√©sente sur le tas afin que cette donn√©e puisse avoir
plusieurs propri√©taires. Le type <code>RefCell&lt;T&gt;</code> nous permet de l'utiliser lorsque
nous avons besoin d'un type immuable mais que nous avons besoin de changer une
valeur interne √† ce type, gr√¢ce √† sa fonctionnalit√© de mutabilit√© interne¬†;
elle nous permet aussi d'appliquer les r√®gles d'emprunt √† l'ex√©cution plut√¥t
qu'√† la compilation.</p>
<!--
Also discussed were the `Deref` and `Drop` traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using `Weak<T>`.
-->
<p>Nous avons aussi vu les traits <code>Deref</code> et <code>Drop</code>, qui offrent des
fonctionnalit√©s tr√®s importantes aux pointeurs intelligents. Nous avons
exp√©riment√© les boucles de r√©f√©rences qui peuvent causer des fuites de m√©moire
et nous avons vu comment les √©viter en utilisant <code>Weak&lt;T&gt;</code>.</p>
<!--
If this chapter has piqued your interest and you want to implement your own
smart pointers, check out [‚ÄúThe Rustonomicon‚Äù][nomicon] for more useful
information.
-->
<p>Si ce chapitre a √©veill√© votre curiosit√© et que vous souhaitez mettre en ≈ìuvre
vos propres pointeurs intelligents, visitez <a href="https://doc.rust-lang.org/nomicon/index.html">‚ÄúThe Rustonomicon‚Äù</a> pour
en savoir plus.</p>
<!--
Next, we‚Äôll talk about concurrency in Rust. You‚Äôll even learn about a few new
smart pointers.
-->
<p>Au chapitre suivant, nous allons parler de concurrence en Rust. Vous
d√©couvrirez peut-√™tre m√™me quelques nouveaux pointeurs intelligents ...</p>
<!--
[nomicon]: ../nomicon/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Fearless Concurrency
-->
<h1 id="la-concurrence-sans-craintes"><a class="header" href="#la-concurrence-sans-craintes">La concurrence sans craintes</a></h1>
<!--
Handling concurrent programming safely and efficiently is another of Rust‚Äôs
major goals. *Concurrent programming*, where different parts of a program
execute independently, and *parallel programming*, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.
-->
<p>Le d√©veloppement s√©curis√© et efficace dans des contextes de concurrence est un
autre objectif majeur de Rust. La <em>programmation concurrente</em>, dans laquelle
diff√©rentes parties d'un programme s'ex√©cutent de mani√®re ind√©pendante, et le
<em>parall√©lisme</em>, dans lequel diff√©rentes parties d'un programme s'ex√©cutent en
m√™me temps, sont devenus des pratiques de plus en plus importantes au fur et √†
mesure que les ordinateurs tirent parti de leurs processeurs multiples.
Historiquement, le d√©veloppement dans ces contextes √©tait difficile et favorisait
les erreurs¬†: Rust compte bien changer la donne.</p>
<!--
Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety *and* concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you‚Äôre working on it rather than potentially after it has been
shipped to production. We‚Äôve nicknamed this aspect of Rust *fearless*
*concurrency*. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.
-->
<p>Au d√©but, l'√©quipe de Rust pensait que garantir la s√©curit√© de la m√©moire et
√©viter les probl√®mes de concurrence √©taient deux challenges distincts qui
devaient √™tre r√©solus de mani√®res diff√©rentes. Avec le temps, l'√©quipe a
d√©couvert que les syst√®mes de possession et de type sont des jeux d'outils
puissants qui aident √† s√©curiser la m√©moire <em>et</em> √† r√©gler des probl√®mes de
concurrence¬†! En exploitant la possession et la v√©rification de type, de
nombreuses erreurs de concurrence deviennent des erreurs √† la compilation en
Rust plut√¥t que des erreurs √† l'ex√©cution. Ainsi, plut√¥t que d'avoir √† passer
beaucoup de votre temps √† tenter de reproduire les circonstances exactes dans
lesquelles un bogue de concurrence s'est produit √† l'ex√©cution, le code
incorrect va refuser de se compiler et va vous afficher une erreur expliquant
le probl√®me. Au final, vous pouvez corriger votre code pendant que vous
travaillez dessus plut√¥t que d'avoir √† le faire a posteriori apr√®s qu'il ait
potentiellement √©t√© livr√© en production. Nous avons surnomm√© cet aspect de Rust
la <em>concurrence sans craintes</em>. La concurrence sans craintes vous permet
d'√©crire du code d√©pourvu de bogues subtils et qu'il sera facile de remanier
sans risquer d'introduire de nouveaux bogues.</p>
<!--
> Note: For simplicity‚Äôs sake, we‚Äôll refer to many of the problems as
> *concurrent* rather than being more precise by saying *concurrent and/or
> parallel*. If this book were about concurrency and/or parallelism, we‚Äôd be
> more specific. For this chapter, please mentally substitute *concurrent
> and/or parallel* whenever we use *concurrent*.
-->
<blockquote>
<p>Remarque¬†: pour des raisons de simplicit√©, nous allons d√©signer la plupart
des probl√®mes par <em>des probl√®mes de concurrence</em> plut√¥t que d'√™tre trop
pr√©cis en disant <em>des probl√®mes de concurrence et/ou de parall√©lisme</em>. Si ce
livre traitait sp√©cifiquement de concurrence et/ou de parall√©lisme, nous
serions plus pr√©cis. Pour ce chapitre, veuillez garder √† l'esprit que nous
parlons de <em>concurrence et/ou de parall√©lisme</em> √† chaque fois que nous
parlerons de <em>concurrence</em>.</p>
</blockquote>
<!--
Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages, because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.
-->
<p>De nombreux langages sont dogmatiques sur les solutions qu'ils offrent pour
g√©rer les probl√®mes de concurrence. Par exemple, Erlang a une fonctionnalit√©
√©l√©gante de passage de messages pour la concurrence mais a une fa√ßon √©trange
de partager un √©tat entre les t√¢ches. Ne proposer qu'un sous-ensemble de
solutions possibles est une strat√©gie acceptable pour les langages de haut
niveau, car un langage de haut niveau offre des avantages en sacrifiant
certains contr√¥les afin d'√™tre plus accessible. Cependant, les langages de bas
niveau sont cens√©s fournir la solution la plus performante dans n'importe
quelle situation donn√©e et proposer moins d'abstraction vis-√†-vis du mat√©riel.
C'est pourquoi Rust offre toute une gamme d'outils pour r√©pondre aux probl√®mes
de mod√©lisation quelle que soit la mani√®re qui est adapt√©e √† la situation et
aux exigences.</p>
<!--
Here are the topics we‚Äôll cover in this chapter:
-->
<p>Voici les sujets que nous allons aborder dans ce chapitre¬†:</p>
<!--
* How to create threads to run multiple pieces of code at the same time
* *Message-passing* concurrency, where channels send messages between threads
* *Shared-state* concurrency, where multiple threads have access to some piece
  of data
* The `Sync` and `Send` traits, which extend Rust‚Äôs concurrency guarantees to
  user-defined types as well as types provided by the standard library
-->
<ul>
<li>Comment cr√©er des t√¢ches pour ex√©cuter plusieurs parties de code en m√™me temps</li>
<li>Le <em>passage de message</em> en concurrence, qui permet √† plusieurs t√¢ches
d'acc√©der √† la m√™me donn√©e</li>
<li>Les traits <code>Sync</code> et <code>Send</code>, qui √©tendent les garanties de Rust sur la
concurrence tant aux types d√©finis par les utilisateurs qu'√† ceux
fournis par la biblioth√®que standard</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using Threads to Run Code Simultaneously
-->
<h2 id="utiliser-les-t√¢ches-pour-ex√©cuter-simultan√©ment-du-code"><a class="header" href="#utiliser-les-t√¢ches-pour-ex√©cuter-simultan√©ment-du-code">Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></h2>
<!--
In most current operating systems, an executed program‚Äôs code is run in a
*process*, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called *threads*.
-->
<p>Dans la plupart des syst√®mes d'exploitation actuels, le code d'un programme
est ex√©cut√© dans un <em>processus</em>, et le syst√®me d'exploitation g√®re plusieurs
processus √† la fois. Dans votre programme, vous pouvez vous aussi avoir des
parties ind√©pendantes qui s'ex√©cutent simultan√©ment. Les √©l√©ments qui font
fonctionner ces parties ind√©pendantes sont appel√©s les <em>t√¢ches</em>.</p>
<!--
Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there‚Äôs no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:
-->
<p>Le d√©coupage des calculs de votre programme dans plusieurs t√¢ches peut
am√©liorer sa performance car le programme fait plusieurs choses √† la fois, mais
cela rajoute aussi de la complexit√©. Comme les t√¢ches peuvent s'ex√©cuter de
mani√®re simultan√©e, il n'y a pas de garantie absolue sur l'ordre d'ex√©cution
des diff√©rentes parties de votre code. Cela peut poser des probl√®mes,
tels que¬†:</p>
<!--
* Race conditions, where threads are accessing data or resources in an
  inconsistent order
* Deadlocks, where two threads are waiting for each other to finish using a
  resource the other thread has, preventing both threads from continuing
* Bugs that happen only in certain situations and are hard to reproduce and fix
  reliably
-->
<ul>
<li>Les situations de concurrence, durant lesquelles les t√¢ches acc√®dent √† des
donn√©es ou des ressources dans un ordre incoh√©rent</li>
<li>Des interblocages, durant lesquels deux t√¢ches attendent mutuellement que
l'autre finisse d'utiliser une ressource que l'autre t√¢che utilise, bloquant
la progression des deux t√¢ches</li>
<li>Des bogues qui surgissent uniquement dans certaines situations et qui sont
difficiles √† reproduire et corriger durablement</li>
</ul>
<!--
Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.
-->
<p>Rust cherche √† att√©nuer les effets ind√©sirables de l'utilisation des t√¢ches,
mais le d√©veloppement dans un contexte multit√¢ches exige toujours une attention
particuli√®re et n√©cessite une structure de code diff√©rente de celle des
programmes qui s'ex√©cutent dans une seule t√¢che.</p>
<!--
Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called *1:1*,
meaning one operating system thread per one language thread. The Rust standard
library only provides an implementation of 1:1 threading; there are crates that
implement other models of threading that make different tradeoffs.
-->
<p>Les langages de programmation impl√©mentent les t√¢ches de diff√©rentes mani√®res.
De nombreux syst√®mes d'exploitation offrent des API pour cr√©er de nouvelles
t√¢ches. L'appel √† cette API du syst√®me d'exploitation pour cr√©er des t√¢ches par
un langage est parfois qualifi√© de <em>1:1</em>, ce qui signifie une t√¢che du syst√®me
d'exploitation par t√¢che dans le langage de programmation. La biblioth√®que
standard de Rust fournit une seule impl√©mentation 1:1¬†; il existe des crates
qui impl√©mentent d'autres mod√®les qui font des choix diff√©rents.</p>
<!--
### Creating a New Thread with `spawn`
-->
<h3 id="cr√©er-une-nouvelle-t√¢che-avec-spawn"><a class="header" href="#cr√©er-une-nouvelle-t√¢che-avec-spawn">Cr√©er une nouvelle t√¢che avec <code>spawn</code></a></h3>
<!--
To create a new thread, we call the `thread::spawn` function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:
-->
<p>Pour cr√©er une nouvelle t√¢che, nous appelons la fonction <code>thread::spawn</code> et
nous lui passons une fermeture (nous avons vu les fermetures au chapitre 13)
qui contient le code que nous souhaitons ex√©cuter dans la nouvelle t√¢che.
L'exemple dans l'encart 16-1 affiche du texte √† partir de la t√¢che principale
et un autre texte √† partir d'une nouvelle t√¢che¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour n¬∞{} √† partir de la nouvelle t√¢che¬†!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour n¬∞{} √† partir de la t√¢che principale¬†!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span>
-->
<p><span class="caption">Encart 16-1¬†: cr√©ation d'une nouvelle t√¢che pour afficher
une chose pendant que la t√¢che principale affiche autre chose</span></p>
<!--
Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:
-->
<p>Remarquez qu'avec cette fonction, la nouvelle t√¢che s'arr√™tera lorsque la t√¢che
principale s'arr√™tera, qu'elle ait fini ou non de s'ex√©cuter. La sortie de ce
programme peut √™tre diff√©rente √† chaque fois, mais elle devrait ressembler √†
ceci¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour n¬∞1 √† partir de la t√¢che principale¬†!
Bonjour n¬∞1 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞2 √† partir de la t√¢che principale¬†!
Bonjour n¬∞2 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞3 √† partir de la t√¢che principale¬†!
Bonjour n¬∞3 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞4 √† partir de la t√¢che principale¬†!
Bonjour n¬∞4 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞5 √† partir de la nouvelle t√¢che¬†!
</code></pre>
<!--
The calls to `thread::sleep` force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn‚Äôt guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until `i` is 9, it only got to 5
before the main thread shut down.
-->
<p>L'appel √† <code>thread::sleep</code> force une t√¢che √† mettre en pause son ex√©cution
pendant une petite dur√©e, permettant √† une autre t√¢che de s'ex√©cuter. Les
t√¢ches se relaieront probablement, mais ce n'est pas garanti¬†: cela d√©pend de
comment votre syst√®me d'exploitation agence les t√¢ches. Lors de cette
ex√©cution, la t√¢che principale a √©crit en premier, m√™me si l'instruction
d'√©criture de la nouvelle t√¢che apparaissait d'abord dans le code. Et m√™me si
nous avons demand√© √† la nouvelle t√¢che d'√©crire jusqu'√† ce que <code>i</code> vaille <code>9</code>,
elle ne l'a fait que jusqu'√† <code>5</code>, moment o√π la t√¢che principale s'est arr√™t√©e.</p>
<!--
If you run this code and only see output from the main thread, or don‚Äôt see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.
-->
<p>Si vous ex√©cutez ce code et que vous ne voyez que du texte provenant de la
t√¢che principale, ou que vous ne voyez aucun chevauchement, essayez d'augmenter
les nombres dans les intervalles pour donner plus d'opportunit√©s au syst√®me
d'exploitation pour basculer entre les t√¢ches.</p>
<!--
### Waiting for All Threads to Finish Using `join` Handles
-->
<h3 id="attendre-que-toutes-les-t√¢ches-aient-fini-en-utilisant-join"><a class="header" href="#attendre-que-toutes-les-t√¢ches-aient-fini-en-utilisant-join">Attendre que toutes les t√¢ches aient fini en utilisant <code>join</code></a></h3>
<!--
The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also can‚Äôt guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!
-->
<p>Le code dans l'encart 16-1 non seulement stoppe la nouvelle t√¢che pr√©matur√©ment
la plupart du temps √† cause de la fin de la t√¢che principale, mais il ne
garantit pas non plus que la nouvelle t√¢che va s'ex√©cuter ne serait-ce qu'une
seule fois. La raison √† cela est qu'il n'y a pas de garantie sur l'ordre dans
lequel les t√¢ches vont s'ex√©cuter¬†!</p>
<!--
We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of `thread::spawn` in a variable.
The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned
value that, when we call the `join` method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we created
in Listing 16-1 and call `join` to make sure the spawned thread finishes before
`main` exits:
-->
<p>Nous pouvons r√©gler le probl√®me des nouvelles t√¢ches qui ne s'ex√©cutent pas, ou
pas compl√®tement, en sauvegardant la valeur de retour de <code>thread::spawn</code> dans
une variable. Le type de retour de <code>thread::spawn</code> est <code>JoinHandle</code>. Un
<code>JoinHandle</code> est une valeur poss√©d√©e qui, lorsque nous appelons la m√©thode
<code>join</code> sur elle, va attendre que ses t√¢ches finissent. L'encart 16-2 montre
comment utiliser le <code>JoinHandle</code> de la t√¢che que nous avons cr√©√©e dans l'encart
16-1 en appelant la m√©thode <code>join</code> pour s'assurer que la nouvelle t√¢che finit
bien avant que <code>main</code> ne se termine¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour n¬∞{} √† partir de la nouvelle t√¢che¬†!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour n¬∞{} √† partir de la t√¢che principale¬†!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-2: Saving a `JoinHandle` from `thread::spawn`
to guarantee the thread is run to completion</span>
-->
<p><span class="caption">Encart 16-2¬†: sauvegarde d'un <code>JoinHandle</code> d'un
<code>thread::spawn</code> pour garantir que la t√¢che est ex√©cut√©e jusqu'√† la fin</span></p>
<!--
Calling `join` on the handle blocks the thread currently running until the
thread represented by the handle terminates. *Blocking* a thread means that
thread is prevented from performing work or exiting. Because we‚Äôve put the call
to `join` after the main thread‚Äôs `for` loop, running Listing 16-2 should
produce output similar to this:
-->
<p>L'appel √† <code>join</code> sur le manipulateur bloque la t√¢che qui s'ex√©cute actuellement
jusqu'√† ce que la t√¢che repr√©sent√©e par le manipulateur se termine. <em>Bloquer</em>
une t√¢che signifie que cette t√¢che est emp√™ch√©e d'accomplir un quelconque travail
ou de se terminer. Comme nous avons ins√©r√© l'appel √† <code>join</code> apr√®s la boucle
<code>for</code> de la t√¢che principale, l'ex√©cution de l'encart 16-2 devrait produire un
r√©sultat similaire √† celui-ci¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour n¬∞1 √† partir de la t√¢che principale¬†!
Bonjour n¬∞2 √† partir de la t√¢che principale¬†!
Bonjour n¬∞1 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞3 √† partir de la t√¢che principale¬†!
Bonjour n¬∞2 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞4 √† partir de la t√¢che principale¬†!
Bonjour n¬∞3 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞4 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞5 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞6 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞7 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞8 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞9 √† partir de la nouvelle t√¢che¬†!
</code></pre>
<!--
The two threads continue alternating, but the main thread waits because of the
call to `handle.join()` and does not end until the spawned thread is finished.
-->
<p>Les deux t√¢ches continuent √† alterner, mais la t√¢che principale attend √† cause
de l'appel √† <code>manipulateur.join()</code> et ne se termine pas avant que la nouvelle
t√¢che ne soit finie.</p>
<!--
But let‚Äôs see what happens when we instead move `handle.join()` before the
`for` loop in `main`, like this:
-->
<p>Mais voyons maintenant ce qui se passe lorsque nous d√©pla√ßons le
<code>manipulateur.join()</code> avant la boucle <code>for</code> du <code>main</code> comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour n¬∞{} √† partir de la nouvelle t√¢che¬†!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    manipulateur.join().unwrap();

    for i in 1..5 {
        println!(&quot;Bonjour n¬∞{} √† partir de la t√¢che principale¬†!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
The main thread will wait for the spawned thread to finish and then run its
`for` loop, so the output won‚Äôt be interleaved anymore, as shown here:
-->
<p>La t√¢che principale va attendre que la nouvelle t√¢che se finisse et ensuite
ex√©cuter sa boucle <code>for</code>, ainsi la sortie ne sera plus chevauch√©e, comme
ci-dessous¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```
-->
<pre><code class="language-text">Bonjour n¬∞1 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞2 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞3 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞4 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞5 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞6 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞7 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞8 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞9 √† partir de la nouvelle t√¢che¬†!
Bonjour n¬∞1 √† partir de la t√¢che principale¬†!
Bonjour n¬∞2 √† partir de la t√¢che principale¬†!
Bonjour n¬∞3 √† partir de la t√¢che principale¬†!
Bonjour n¬∞4 √† partir de la t√¢che principale¬†!
</code></pre>
<!--
Small details, such as where `join` is called, can affect whether or not your
threads run at the same time.
-->
<p>Des petits d√©tails, comme l'endroit o√π <code>join</code> est appel√©, peuvent d√©terminer si
vos t√¢ches peuvent √™tre ex√©cut√©es ou non en m√™me temps.</p>
<!--
### Using `move` Closures with Threads
-->
<h3 id="utiliser-les-fermetures-move-avec-les-t√¢ches"><a class="header" href="#utiliser-les-fermetures-move-avec-les-t√¢ches">Utiliser les fermetures <code>move</code> avec les t√¢ches</a></h3>
<!--
The `move` keyword is often used with closures passed to `thread::spawn`
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another. In the [‚ÄúCapturing the Environment with Closures‚Äù][capture]<!-- ignore
-- > section of Chapter 13, we discussed `move` in the context of closures. Now,
we‚Äôll concentrate more on the interaction between `move` and `thread::spawn`
-->
<p>Le mot-cl√© <code>move</code> est souvent utilis√© avec des fermetures pass√©es √†
<code>thread::spawn</code> car la fermeture va alors prendre possession des valeurs de son
environnement qu'elle utilise, ce qui transf√®re la possession des valeurs d'une
t√¢che √† une autre. Dans <a href="ch13-01-closures.html">une section du chapitre 13</a><!-- ignore -->,
nous avons pr√©sent√© <code>move</code> dans le contexte des fermetures. A pr√©sent, nous
allons plus nous concentrer sur l'interaction entre <code>move</code> et <code>thread::spawn</code>.</p>
<!--
Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no
arguments: we‚Äôre not using any data from the main thread in the spawned
thread‚Äôs code. To use data from the main thread in the spawned thread, the
spawned thread‚Äôs closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won‚Äôt yet work, as you‚Äôll see in a moment.
-->
<p>Remarquez dans l'encart 16-1 que la fermeture que nous donnons √† <code>thread::spawn</code>
ne prend pas d'arguments¬†: nous n'utilisons aucune donn√©e de la t√¢che
principale dans le code de la nouvelle t√¢che. Pour utiliser des donn√©es de la
t√¢che principale dans la nouvelle t√¢che, la fermeture de la nouvelle t√¢che doit
capturer les valeurs dont elle a besoin. L'encart 16-3 montre une tentative de
cr√©ation d'un vecteur dans la t√¢che principale et son utilisation dans la
nouvelle t√¢che. Cependant, cela ne fonctionne pas encore, comme vous allez le
constater dans un moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteur¬†: {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span>
-->
<p><span class="caption">Encart 16-3¬†: tentative d'utilisation d'un vecteur cr√©√©
par la t√¢che principale dans une autre t√¢che</span></p>
<!--
The closure uses `v`, so it will capture `v` and make it part of the closure‚Äôs
environment. Because `thread::spawn` runs this closure in a new thread, we
should be able to access `v` inside that new thread. But when we compile this
example, we get the following error:
-->
<p>La fermeture utilise <code>v</code>, donc elle va capturer <code>v</code> et l'int√©grer dans son
environnement. Comme <code>thread::spawn</code> ex√©cute cette fermeture dans une nouvelle
t√¢che, nous devrions pouvoir acc√©der √† <code>v</code> dans cette nouvelle t√¢che. Mais
lorsque nous compilons cet exemple, nous obtenons l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 -- > src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 -- > src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let manipulateur = thread::spawn(|| {
  |                                      ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let manipulateur = thread::spawn(|| {
  |  ________________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<!--
Rust *infers* how to capture `v`, and because `println!` only needs a reference
to `v`, the closure tries to borrow `v`. However, there‚Äôs a problem: Rust can‚Äôt
tell how long the spawned thread will run, so it doesn‚Äôt know if the reference
to `v` will always be valid.
-->
<p>Rust <em>d√©duit</em> comment capturer <code>v</code>, et comme <code>println!</code> n'a besoin que d'une
r√©f√©rence √† <code>v</code>, la fermeture essaye d'emprunter <code>v</code>. Cependant, il y a un
probl√®me¬†: Rust ne peut pas savoir combien de temps la t√¢che va s'ex√©cuter,
donc il ne peut pas savoir si la r√©f√©rence √† <code>v</code> sera toujours valide.</p>
<!--
Listing 16-4 provides a scenario that‚Äôs more likely to have a reference to `v`
that won‚Äôt be valid:
-->
<p>L'encart 16-4 propose un sc√©nario qui est a plus de chance d'avoir une
r√©f√©rence √† <code>v</code> qui ne sera plus valide¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteur¬†: {:?}&quot;, v);
    });

    drop(v); // oh, non¬†!

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to `v` from a main thread that drops `v`</span>
-->
<p><span class="caption">Encart 16-4¬†: une t√¢che dont la fermeture essaye de
capturer une r√©f√©rence √† <code>v</code> √† partir de la t√¢che principale, qui va ensuite
lib√©rer <code>v</code></span></p>
<!--
If we were allowed to run this code, there‚Äôs a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to `v` inside, but the main thread immediately drops
`v`, using the `drop` function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, `v` is no longer valid, so a reference to it
is also invalid. Oh no!
-->
<p>Si nous √©tions autoris√©s √† ex√©cuter ce code, il y aurait une possibilit√© que
la nouvelle t√¢che soit imm√©diatement plac√©e en arri√®re-plan sans √™tre
ex√©cut√©e du tout. La nouvelle t√¢che a une r√©f√©rence √† <code>v</code> en son sein, mais la
t√¢che principale lib√®re imm√©diatement <code>v</code>, en utilisant la fonction <code>drop</code> que
nous avons vue au chapitre 15. Ensuite, lorsque la nouvelle t√¢che commence √†
s'ex√©cuter, <code>v</code> n'est plus en vigueur, donc une r√©f√©rence √† cette derni√®re est
elle aussi invalide¬†!</p>
<!--
To fix the compiler error in Listing 16-3, we can use the error message‚Äôs
advice:
-->
<p>Pour corriger l'erreur de compilation de l'encart 16-3, nous pouvons appliquer
le conseil du message d'erreur¬†:</p>
<!--
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-- >
-->
<!--
```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let manipulateur = thread::spawn(move || {
  |                                      ++++
</code></pre>
<!--
By adding the `move` keyword before the closure, we force the closure to take
ownership of the values it‚Äôs using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:
-->
<p>En ajoutant le mot-cl√© <code>move</code> avant la fermeture, nous for√ßons la fermeture √†
prendre possession des valeurs qu'elle utilise au lieu de laisser Rust d√©duire
qu'il doit emprunter les valeurs. Les modifications √† l'encart 16-3 propos√©es
dans l'encart 16-5 devraient se compiler et s'ex√©cuter comme pr√©vu¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(move || {
        println!(&quot;Voici un vecteur¬†: {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-5: Using the `move` keyword to force a closure
to take ownership of the values it uses</span>
-->
<p><span class="caption">Encart 16-5¬†: utilisation du mot-cl√© <code>move</code> pour forcer
une fermeture √† prendre possession des valeurs qu'elle utilise</span></p>
<!--
What would happen to the code in Listing 16-4 where the main thread called
`drop` if we use a `move` closure? Would `move` fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn‚Äôt allowed for a different reason. If we added `move` to the closure, we
would move `v` into the closure‚Äôs environment, and we could no longer call
`drop` on it in the main thread. We would get this compiler error instead:
-->
<p>Qu'est-ce qui arriverait au code de l'encart 16-4 dans lequel la t√¢che
principale fait appel √† <code>drop</code> si nous utilisions la fermeture avec <code>move</code>¬†?
Est-ce que le <code>move</code> r√©soudrait le probl√®me¬†? Malheureusement, non¬†; nous
obtiendrions une erreur diff√©rente parce que ce que l'encart 16-4 essaye de
faire n'est pas autoris√© pour une raison diff√©rente de la pr√©c√©dente. Si nous
ajoutions <code>move</code> √† la fermeture, nous d√©placerions <code>v</code> dans l'environnement de
la fermeture, et nous ne pourrions plus appeler <code>drop</code> sur <code>v</code> dans la t√¢che
principale. Nous obtiendrons √† la place cette erreur de compilation¬†:</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  -- > src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {:?}", v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let manipulateur = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Voici un vecteur¬†: {:?}&quot;, v);
   |                                             - variable moved due to use in closure
...
10 |     drop(v); // oh, non¬†!
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  -- &gt; src/main.rs:10:10
   |
6  |     let manipulateur = thread::spawn(move || {
   |                                      ------- value moved (into closure) here
...
10 |     drop(v); // oh non, le vecteur est lib√©r√©¬†!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<!--
Rust‚Äôs ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing `v` for the
thread, which meant the main thread could theoretically invalidate the spawned
thread‚Äôs reference. By telling Rust to move ownership of `v` to the spawned
thread, we‚Äôre guaranteeing Rust that the main thread won‚Äôt use `v` anymore. If
we change Listing 16-4 in the same way, we‚Äôre then violating the ownership
rules when we try to use `v` in the main thread. The `move` keyword overrides
Rust‚Äôs conservative default of borrowing; it doesn‚Äôt let us violate the
ownership rules.
-->
<p>Les r√®gles de possession de Rust nous ont encore sauv√© la mise¬†! Nous obtenions
une erreur avec le code de l'encart 16-3 car Rust a √©t√© conservateur et a juste emprunt√©
<code>v</code> pour la t√¢che, ce qui signifie que la t√¢che principale pouvait th√©oriquement
neutraliser la r√©f√©rence de la t√¢che cr√©√©e. En demandant √† Rust de d√©placer la
possession de <code>v</code> √† la nouvelle t√¢che, nous avons garanti √† Rust que la t√¢che
principale n'utiliserait plus <code>v</code>. Si nous changeons l'encart 16-4 de la m√™me
mani√®re, nous violons les r√®gles de possession lorsque nous essayons d'utiliser
<code>v</code> dans la t√¢che principale. Le mot-cl√© <code>move</code> remplace le comportement
d'emprunt conservateur par d√©faut¬†de Rust; il ne nous laisse pas enfreindre les r√®gles
de possession.</p>
<!--
With a basic understanding of threads and the thread API, let‚Äôs look at what we
can *do* with threads.
-->
<p>Arm√© de cette connaissance de base des t√¢ches et de leur API, d√©couvrons ce que
nous pouvons <em>faire</em> avec les t√¢ches.</p>
<!--
[capture]: ch13-01-closures.html#capturing-the-environment-with-closures
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Using Message Passing to Transfer Data Between Threads
-->
<h2 id="utiliser-lenvoi-de-messages-pour-transf√©rer-des-donn√©es-entre-les-t√¢ches"><a class="header" href="#utiliser-lenvoi-de-messages-pour-transf√©rer-des-donn√©es-entre-les-t√¢ches">Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></h2>
<!--
One increasingly popular approach to ensuring safe concurrency is *message
passing*, where threads or actors communicate by sending each other messages
containing data. Here‚Äôs the idea in a slogan from [the Go language
documentation](https://golang.org/doc/effective_go.html#concurrency):
‚ÄúDo not communicate by sharing memory; instead, share memory by communicating.‚Äù
-->
<p>Une approche de plus en plus populaire pour garantir la s√©curit√© de la
concurrence est l'<em>envoi de message</em>, avec lequel les t√¢ches ou les acteurs
communiquent en envoyant aux autres des messages contenant des donn√©es. Voici
l'id√©e r√©sum√©e, tir√©e d'un slogan provenant de <a href="https://golang.org/doc/effective_go.html#concurrency">la documentation du langage
Go</a>¬†: ‚ÄúNe communiquez pas
en partageant la m√©moire¬†; partagez plut√¥t la m√©moire en communiquant‚Äù.</p>
<!--
One major tool Rust has for accomplishing message-sending concurrency is the
*channel*, a programming concept that Rust‚Äôs standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or boat into a stream, it will travel downstream to the end of the
waterway.
-->
<p>Un des outils majeurs que Rust a pour accomplir l'envoi de messages pour la
concurrence est le <em>canal</em>, un concept de programmation dont la biblioth√®que
standard de Rust fournit une impl√©mentation. Vous pouvez imaginer un canal de
programmation comme √©tant un canal d'eau, comme un ruisseau ou une rivi√®re. Si
vous posez quelque chose comme un canard en plastique ou un bateau sur un
ruisseau, il se d√©placera en descendant le long de la voie d'eau.</p>
<!--
A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of your code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be *closed* if either the transmitter or receiver half is
dropped.
-->
<p>Un canal de programmation est divis√© en deux parties¬†: un transmetteur et un
receveur. La partie du transmetteur est le lieu en amont o√π vous d√©posez les
canards en plastique sur la rivi√®re et la partie du receveur est celle o√π les
canards en plastique finissent leur voyage. Une partie de votre code appelle
des m√©thodes du transmetteur en lui passant les donn√©es que vous souhaitez
envoyer, tandis qu'une autre partie attend que des messages arrivent. Un canal
est d√©clar√© <em>ferm√©</em> lorsque l'une des parties, le transmetteur ou le r√©cepteur,
est lib√©r√©e.</p>
<!--
Here, we‚Äôll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We‚Äôll be sending simple values between threads using a channel
to illustrate the feature. Once you‚Äôre familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.
-->
<p>Ici, nous allons concevoir un programme qui a une t√¢che pour g√©n√©rer des
valeurs et les envoyer dans un canal, et une autre t√¢che qui va recevoir les
valeurs et les afficher. Nous allons envoyer de simples valeurs entre les
t√¢ches en utilisant un canal pour illustrer cette fonctionnalit√©. Une fois que
vous serez familier avec cette technique, vous pourrez utiliser les canaux
pour cr√©er un syst√®me de dialogue en ligne ou un syst√®me o√π de nombreuses
t√¢ches font chacune une partie d'un gros calcul et envoient leur r√©sultat √† une
t√¢che charg√©e de les agr√©ger.</p>
<!--
First, in Listing 16-6, we‚Äôll create a channel but not do anything with it.
Note that this won‚Äôt compile yet because Rust can‚Äôt tell what type of values we
want to send over the channel.
-->
<p>Pour commencer, dans l'encart 16-6, nous allons cr√©er un canal mais nous
n'allons rien faire avec. Remarquez qu'il ne se compilera pas encore car Rust
ne peut pas savoir le type de valeurs que nous souhaitons envoyer dans le
canal.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<!--
<span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to `tx` and `rx`</span>
-->
<p><span class="caption">Encart 16-6¬†: cr√©ation d'un canal et assignation de ses
deux parties √† <code>tx</code> et <code>rx</code></span></p>
<!--
We create a new channel using the `mpsc::channel` function; `mpsc` stands for
*multiple producer, single consumer*. In short, the way Rust‚Äôs standard library
implements channels means a channel can have multiple *sending* ends that
produce values but only one *receiving* end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We‚Äôll start with a single
producer for now, but we‚Äôll add multiple producers when we get this example
working.
-->
<p>Nous cr√©ons un nouveau canal en utilisant la fonction <code>mpsc::channel</code>¬†; <code>mpsc</code>
signifie <em>multiple producer, single consumer</em>, c'est-√†-dire
<em>plusieurs producteurs, un seul consommateur</em>. En bref, la fa√ßon dont la
biblioth√®que standard de Rust a impl√©ment√© ces canaux permet d'avoir plusieurs
extr√©mit√©s <em>√©mettrices</em> qui produisent des valeurs, mais seulement une seule
extr√©mit√© <em>r√©ceptrice</em> qui consomme ces valeurs. Imaginez plusieurs ruisseaux
qui se rejoignent en une seule grosse rivi√®re¬†: tout ce qui est d√©pos√© sur les
ruisseaux va finir dans une seule rivi√®re √† la fin. Nous allons commencer avec
un seul producteur pour le moment, mais nous allons ajouter d'autres
producteurs lorsque notre exemple fonctionnera.</p>
<!--
The `mpsc::channel` function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations `tx`
and `rx` are traditionally used in many fields for *transmitter* and *receiver*
respectively, so we name our variables as such to indicate each end. We‚Äôre
using a `let` statement with a pattern that destructures the tuples; we‚Äôll
discuss the use of patterns in `let` statements and destructuring in Chapter
18. Using a `let` statement this way is a convenient approach to extract the
pieces of the tuple returned by `mpsc::channel`.
-->
<p>La fonction <code>mpsc::channel</code> retourne un tuple, le premier √©l√©ment est celui qui
permet d'envoyer et le second est celui qui re√ßoit. Les abr√©viations <code>tx</code> et
<code>rx</code> sont utilis√©s traditionnellement dans de nombreux domaines pour signifier
respectivement <em>transmetteur</em> et <em>r√©cepteur</em>, nous avons donc nomm√© nos
variables ainsi pour indiquer clairement le r√¥le de chaque √©l√©ment.  Nous
utilisons une instruction <code>let</code> avec un motif qui d√©structure les tuples¬†; nous
verrons l'utilisation des motifs dans les instructions <code>let</code> et la
d√©structuration au chapitre 18. L'utilisation d'une instruction <code>let</code> est une
fa√ßon d'extraire facilement les √©l√©ments du tuple retourn√© par <code>mpsc::channel</code>.</p>
<!--
Let‚Äôs move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.
-->
<p>D√©pla√ßons maintenant l'√©l√©ment de transmission dans une nouvelle t√¢che et
faisons-lui envoyer une cha√Æne de caract√®res afin que la nouvelle t√¢che
communique avec la t√¢che principale, comme dans l'encart 16-7. C'est comme
poser un canard en plastique sur l'amont de la rivi√®re ou envoyer un message
instantan√© d'une t√¢che √† une autre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-7: Moving `tx` to a spawned thread and sending
‚Äúhi‚Äù</span>
-->
<p><span class="caption">Encart 16-7¬†: d√©placement de <code>tx</code> dans la nouvelle t√¢che
et envoi de ‚Äúsalut‚Äù</span></p>
<!--
Again, we‚Äôre using `thread::spawn` to create a new thread and then using `move`
to move `tx` into the closure so the spawned thread owns `tx`. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.
-->
<p>Nous utilisons √† nouveau <code>thread::spawn</code> pour cr√©er une nouvelle t√¢che et
ensuite utiliser <code>move</code> pour d√©placer <code>tx</code> dans la fermeture afin que la
nouvelle t√¢che poss√®de d√©sormais <code>tx</code>. La nouvelle t√¢che a besoin de poss√©der
la partie √©mettrice du canal pour √™tre en capacit√© d'envoyer des messages
dans ce canal.</p>
<!--
The transmitting end has a `send` method that takes the value we want to send.
The `send` method returns a `Result<T, E>` type, so if the receiving end has
already been dropped and there‚Äôs nowhere to send a value, the send operation
will return an error. In this example, we‚Äôre calling `unwrap` to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.
-->
<p>La partie √©mettrice a une m√©thode <code>send</code> qui prend en argument la valeur que
nous souhaitons envoyer. La m√©thode <code>send</code> retourne un type <code>Result&lt;T, E&gt;</code>,
donc si la partie r√©ceptrice a d√©j√† √©t√© lib√©r√©e et qu'il n'y a nulle part o√π
envoyer la valeur, l'op√©ration d'envoi va retourner une erreur. Dans cet
exemple, nous faisons appel √† <code>unwrap</code> pour paniquer en cas d'erreur. Mais dans
un vrai programme, nous devrions g√©rer ce cas correctement¬†: retournez au
chapitre 9 pour revoir les strat√©gies permettant de g√©rer correctement les erreurs.</p>
<!--
In Listing 16-8, we‚Äôll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.
-->
<p>Dans l'encart 16-8, nous allons obtenir la valeur de l'extr√©mit√© r√©ceptrice du
canal dans la t√¢che principale. C'est comme r√©cup√©rer le canard en plastique
dans l'eau √† la fin de la rivi√®re, ou r√©cup√©rer un message instantan√©.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a re√ßu¬†: {}&quot;, recu);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-8: Receiving the value ‚Äúhi‚Äù in the main thread
and printing it</span>
-->
<p><span class="caption">Encart 16-8¬†: r√©ception de la valeur ‚Äúsalut‚Äù dans la
t√¢che principale pour l'afficher</span></p>
<!--
The receiving end of a channel has two useful methods: `recv` and `try_recv`.
We‚Äôre using `recv`, short for *receive*, which will block the main thread‚Äôs
execution and wait until a value is sent down the channel. Once a value is
sent, `recv` will return it in a `Result<T, E>`. When the sending end of the
channel closes, `recv` will return an error to signal that no more values will
be coming.
-->
<p>La partie r√©ception d'un canal a deux modes int√©ressants¬†: <code>recv</code> et
<code>try_recv</code>. Nous avons utilis√© <code>recv</code>, un raccourci pour <em>recevoir</em>, qui va
bloquer l'ex√©cution de la t√¢che principale et attendre jusqu'√† ce qu'une valeur
soit envoy√©e dans le canal. Une fois qu'une valeur est envoy√©e, <code>recv</code> va
la retourner dans un <code>Result&lt;T, E&gt;</code>. Lorsque la partie transmission du canal se
ferme, <code>recv</code> va retourner une erreur pour signaler qu'il n'y aura plus de
valeurs qui arriveront.</p>
<!--
The `try_recv` method doesn‚Äôt block, but will instead return a `Result<T, E>`
immediately: an `Ok` value holding a message if one is available and an `Err`
value if there aren‚Äôt any messages this time. Using `try_recv` is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls `try_recv` every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.
-->
<p>La m√©thode <code>try_recv</code> ne bloque pas, mais va plut√¥t retourner imm√©diatement un
<code>Result&lt;T, E&gt;</code>¬†: une valeur <code>Ok</code> qui contiendra un message s'il y en a un de
disponible, et une valeur <code>Err</code> s'il n'y a pas de message cette fois-ci.
L'utilisation de <code>try_recv</code> est pratique si cette t√¢che √† d'autres choses √†
faire pendant qu'elle attend les messages¬†: nous pouvons ainsi √©crire une
boucle qui appelle r√©guli√®rement <code>try_recv</code>, g√®re le message s'il y en a un, et
sinon fait d'autres choses avant de v√©rifier √† nouveau.</p>
<!--
We‚Äôve used `recv` in this example for simplicity; we don‚Äôt have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.
-->
<p>Nous avons utilis√© <code>recv</code> dans cet exemple pour des raisons de simplicit√©¬†;
nous n'avons rien d'autres √† faire dans la t√¢che principale que d'attendre les
messages, donc bloquer la t√¢che principale est acceptable.</p>
<!--
When we run the code in Listing 16-8, we‚Äôll see the value printed from the main
thread:
-->
<p>Lorsque nous ex√©cutons le code de l'encart 16-8, nous allons voir la valeur
s'afficher gr√¢ce √† la t√¢che principale¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
```
-->
<pre><code class="language-text">On a re√ßu¬†: salut
</code></pre>
<!--
Perfect!
-->
<p>C'est parfait ainsi¬†!</p>
<!--
### Channels and Ownership Transference
-->
<h3 id="les-canaux-et-le-transfert-de-possession"><a class="header" href="#les-canaux-et-le-transfert-de-possession">Les canaux et le transfert de possession</a></h3>
<!--
The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let‚Äôs do
an experiment to show how channels and ownership work together to prevent
problems: we‚Äôll try to use a `val` value in the spawned thread *after* we‚Äôve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn‚Äôt allowed:
-->
<p>Les r√®gles de possession jouent un r√¥le vital dans l'envoi de messages car
elles vous aident √† √©crire du code s√ªr et concurrent. R√©fl√©chir √† la possession
avec vos programmes Rust vous offre l'avantage d'√©viter des erreurs de
d√©veloppement avec la concurrence. Faisons une exp√©rience pour montrer comment
la possession et les canaux fonctionnent ensemble pour √©viter les probl√®mes¬†:
nous allons essayer d'utiliser la <code>valeur</code> dans la nouvelle t√¢che <em>apr√®s</em> que
nous l'avons envoy√©e dans le canal. Essayez de compiler le code de l'encart 16-9
pour d√©couvrir pourquoi ce code n'est pas autoris√©¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;hi&quot;);
        tx.send(valeur).unwrap();
        println!(&quot;valeur vaut {}&quot;, valeur);
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a re√ßu¬†: {}&quot;, recu);
}
</code></pre>
<!--
<span class="caption">Listing 16-9: Attempting to use `val` after we‚Äôve sent it
down the channel</span>
-->
<p><span class="caption">Encart 16-9¬†: tentative d'utiliser <code>valeur</code> apr√®s que
nous l'avons envoy√©e dans le canal</span></p>
<!--
Here, we try to print `val` after we‚Äôve sent it down the channel via `tx.send`.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread‚Äôs modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:
-->
<p>Ici, nous essayons d'afficher <code>valeur</code> apr√®s que nous l'avons envoy√©e dans le
canal avec <code>tx.send</code>. Ce serait une mauvaise id√©e de permettre cela¬†: une fois
que la valeur a √©t√© envoy√©e √† une autre t√¢che, cette t√¢che peut la modifier ou
la lib√©rer avant que nous essayions de l'utiliser √† nouveau. Il est possible que
des modifications faites par l'autre t√¢che puissent causer des erreurs ou des r√©sultats
inattendus √† cause de donn√©es incoh√©rentes ou manquantes. Toutefois, Rust nous
affiche une erreur si nous essayons de compiler le code de l'encart 16-9¬†:</p>
<!--
```console
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  -- > src/main.rs:10:31
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {}", val);
   |                               ^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `valeur`
  --&gt; src/main.rs:10:31
   |
8  |         let valeur = String::from(&quot;salut&quot;);
   |             ------ move occurs because `valeur` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(valeur).unwrap();
   |                 ------ value moved here
10 |         println!(&quot;valeur vaut {}&quot;, valeur);
   |                                    ^^^^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<!--
Our concurrency mistake has caused a compile time error. The `send` function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.
-->
<p>Notre erreur de concurrence a provoqu√© une erreur √† la compilation. La fonction
<code>send</code> prend possession de ses param√®tres, et lorsque la valeur est d√©plac√©e,
le r√©cepteur en prend possession. Cela nous √©vite d'utiliser √† nouveau
accidentellement la valeur apr√®s l'avoir envoy√©e¬†; le syst√®me de possession
v√©rifie que tout est en ordre.</p>
<!--
### Sending Multiple Values and Seeing the Receiver Waiting
-->
<h3 id="envoyer-plusieurs-valeurs-et-voir-le-r√©cepteur-les-attendre"><a class="header" href="#envoyer-plusieurs-valeurs-et-voir-le-r√©cepteur-les-attendre">Envoyer plusieurs valeurs et voir le r√©cepteur les attendre</a></h3>
<!--
The code in Listing 16-8 compiled and ran, but it didn‚Äôt clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we‚Äôve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.
-->
<p>Le code de l'encart 16-8 s'est compil√© et ex√©cut√©, mais il ne nous a pas
clairement indiqu√© que deux t√¢ches s√©par√©es communiquaient entre elles via le
canal. Dans l'encart 16-10 nous avons fait quelques modifications qui prouvent
que le code de l'encart 16-8 est ex√©cut√© avec de la concurrence¬†: la nouvelle
t√¢che va maintenant envoyer plusieurs messages et faire une pause d'une seconde
entre chaque message.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,noplayground
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;√† partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle t√¢che&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a re√ßu¬†: {}&quot;, recu);
    }
}
</code></pre>
<!--
<span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span>
-->
<p><span class="caption">Encart 16-10¬†: envoi de plusieurs messages en faisant une
pause entre chacun</span></p>
<!--
This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the `thread::sleep` function with a `Duration` value of
1 second.
-->
<p>Cette fois-ci, la nouvelle t√¢che a un vecteur de cha√Ænes de caract√®res que nous
souhaitons envoyer √† la t√¢che principale. Nous it√©rons sur celui-ci, on envoie
les cha√Ænes une par une en faisant une pause entre chaque envoi en appelant la
fonction <code>thread::sleep</code> avec une valeur <code>Duration</code> de 1 seconde.</p>
<!--
In the main thread, we‚Äôre not calling the `recv` function explicitly anymore:
instead, we‚Äôre treating `rx` as an iterator. For each value received, we‚Äôre
printing it. When the channel is closed, iteration will end.
-->
<p>Dans la t√¢che principale, nous n'appelons plus explicitement la fonction
<code>recv</code>¬†: √† la place, nous utilisons <code>rx</code> comme un it√©rateur. Pour chaque valeur
re√ßue, nous l'affichons. Lorsque le canal se fermera, l'it√©ration se terminera.</p>
<!--
When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:
-->
<p>Lorsque nous ex√©cutons le code de l'encart 16-10, nous devrions voir la sortie
suivante, avec une pause de 1 seconde entre chaque ligne¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: from
Got: the
Got: thread
```
-->
<pre><code class="language-text">On a re√ßu¬†: salutations
On a re√ßu¬†: √† partir
On a re√ßu¬†: de la
On a re√ßu¬†: nouvelle t√¢che
</code></pre>
<!--
Because we don‚Äôt have any code that pauses or delays in the `for` loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.
-->
<p>Comme nous n'avons pas de code qui met en pause ou retarde la boucle <code>for</code> de
la t√¢che principale, nous pouvons dire que la t√¢che principale est en attente
de r√©ception des valeurs de la part de la nouvelle t√¢che.</p>
<!--
### Creating Multiple Producers by Cloning the Transmitter
-->
<h3 id="cr√©er-plusieurs-producteurs-en-clonant-le-transmetteur"><a class="header" href="#cr√©er-plusieurs-producteurs-en-clonant-le-transmetteur">Cr√©er plusieurs producteurs en clonant le transmetteur</a></h3>
<!--
Earlier we mentioned that `mpsc` was an acronym for *multiple producer,
single consumer*. Let‚Äôs put `mpsc` to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:
-->
<p>Pr√©c√©demment, nous avions √©voqu√© que <code>mpsc</code> √©tait un acronyme pour
<em>multiple producer, single consumer</em>. Mettons <code>mpsc</code> en ≈ìuvre en √©largissant le
code de l'encart 16-10 pour cr√©er plusieurs t√¢ches qui vont toutes envoyer des
valeurs au m√™me r√©cepteur. Nous pouvons faire ceci en clonant la partie
√©mettrice du canal, comme dans l'encart 16-11¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,noplayground
# use std::sync::mpsc;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }

    // --snip--
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // -- partie masqu√©e ici --

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;√† partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle t√¢che&quot;),
        ];

        for valeur in valeurs {
            tx1.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;encore plus&quot;),
            String::from(&quot;de messages&quot;),
            String::from(&quot;pour&quot;),
            String::from(&quot;vous&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a re√ßu¬†: {}&quot;, recu);
    }

    // -- partie masqu√©e ici --
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span>
-->
<p><span class="caption">Encart 16-11¬†: envoi de plusieurs messages √† partir de
plusieurs producteurs</span></p>
<!--
This time, before we create the first spawned thread, we call `clone` on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.
-->
<p>Cette fois-ci, avant de cr√©er la premi√®re nouvelle t√¢che, nous appelons <code>clone</code>
sur la partie √©mettrice du canal. Cela va nous donner un nouveau transmetteur
que nous pourrons passer √† la premi√®re nouvelle t√¢che. Nous passons ensuite le
transmetteur original √† une seconde nouvelle t√¢che. Cela va nous donner deux
t√¢ches, chacune envoyant des messages diff√©rents √† la partie r√©ceptrice du
canal.</p>
<!--
When you run the code, your output should look something like this:
-->
<p>Lorsque vous ex√©cuterez ce code, votre sortie devrait ressembler √† ceci¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```
-->
<pre><code class="language-text">On a re√ßu¬†: salutations
On a re√ßu¬†: encore plus
On a re√ßu¬†: de messages
On a re√ßu¬†: pour
On a re√ßu¬†: √† partir
On a re√ßu¬†: de la
On a re√ßu¬†: nouvelle t√¢che
On a re√ßu¬†: pour vous
</code></pre>
<!--
You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
`thread::sleep`, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.
-->
<p>Vous pourrez peut-√™tre constater que les valeurs sont dans un autre ordre chez
vous¬†; cela d√©pend de votre syst√®me. C'est ce qui rend la concurrence aussi
int√©ressante que difficile. Si vous jouez avec la valeur de <code>thread::sleep</code> en
lui donnant diff√©rentes valeurs dans diff√©rentes t√¢ches, chaque ex√©cution sera
encore moins d√©terministe et cr√©era une sortie diff√©rente √† chaque fois.</p>
<!--
Now that we‚Äôve looked at how channels work, let‚Äôs look at a different method of
concurrency.
-->
<p>Maintenant que nous avons d√©couvert le fonctionnement des canaux, examinons un
autre genre de concurrence.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Shared-State Concurrency
-->
<h2 id="le-partage-d√©tat-en-concurrence"><a class="header" href="#le-partage-d√©tat-en-concurrence">Le partage d'√©tat en concurrence</a></h2>
<!--
Message passing is a fine way of handling concurrency, but it‚Äôs not the only
one. Consider this part of the slogan from the Go language documentation again:
‚Äúdo not communicate by sharing memory.‚Äù
-->
<p>L'envoi de messages est un assez bon moyen de gestion de la concurrence, mais il
n'y en a pas qu'un seul. Repensons √† cette partie du slogan de la documentation du
langage Go¬†: ‚Äúne communiquez pas en partageant la m√©moire‚Äù.</p>
<!--
What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?
-->
<p>A quoi ressemble la communication par partage de m√©moire¬†? De plus, pourquoi les
partisans de l'envoi de messages ne devraient-ils pas l'utiliser et faire plut√¥t
le contraire¬†?</p>
<!--
In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust‚Äôs type system
and ownership rules greatly assist in getting this management correct. For an
example, let‚Äôs look at mutexes, one of the more common concurrency primitives
for shared memory.
-->
<p>De mani√®re g√©n√©rale, les canaux dans les langages de programmation ressemblent √†
la possession exclusive, car une fois que vous avez transf√©r√© une valeur dans un
canal, vous ne pouvez plus utiliser cette valeur. Le partage de m√©moire en
concurrence est comme de la possession multiple¬†: plusieurs t√¢ches peuvent
acc√©der au m√™me endroit de la m√©moire en m√™me temps. Comme vous l'avez vu au
chapitre 15, dans lequel les pointeurs intelligents la rendent possible, la
possession multiple peut ajouter de la complexit√© car ses diff√©rents
propri√©taires ont besoin d'√™tre g√©r√©s. Le syst√®me de type de Rust et les r√®gles
de possession aident beaucoup √† les g√©rer correctement. Par exemple, d√©couvrons
les mutex, une des primitives les plus courantes pour partager la m√©moire.</p>
<!--
### Using Mutexes to Allow Access to Data from One Thread at a Time
-->
<h3 id="utiliser-les-mutex-pour-permettre-lacc√®s-√†-la-donn√©e-√†-une-seule-t√¢che-√†-la-fois"><a class="header" href="#utiliser-les-mutex-pour-permettre-lacc√®s-√†-la-donn√©e-√†-une-seule-t√¢che-√†-la-fois">Utiliser les mutex pour permettre l'acc√®s √† la donn√©e √† une seule t√¢che √† la fois</a></h3>
<!--
*Mutex* is an abbreviation for *mutual exclusion*, as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex‚Äôs *lock*. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as *guarding* the data it holds via the locking system.
-->
<p><em>Mutex</em> est une abr√©viation pour <em>mutual exclusion</em>, ce qui veut dire qu'un
mutex ne permet qu'√† une seule t√¢che d'acc√©der √† une donn√©e √† un instant donn√©. Pour
acc√©der √† la donn√©e dans un mutex, une t√¢che doit d'abord signaler qu'elle
souhaite y acc√©der en demandant l'obtention du <em>verrou</em> du mutex. Le verrou est
une structure de donn√©e qui fait partie du mutex et qui assure le suivi de qui a
actuellement acc√®s √† la donn√©e. Par cons√©quent, le mutex est qualifi√© de
<em>gardien</em> de la donn√©e qu'il renferme via le syst√®me de verrou.</p>
<!--
Mutexes have a reputation for being difficult to use because you have to
remember two rules:
-->
<p>Les mutex ont la r√©putation d'√™tre difficiles √† utiliser car vous devez veiller
√† deux r√®gles¬†:</p>
<!--
* You must attempt to acquire the lock before using the data.
* When you‚Äôre done with the data that the mutex guards, you must unlock the
  data so other threads can acquire the lock.
-->
<ul>
<li>Vous devez obtenir le verrou avant d'utiliser la donn√©e.</li>
<li>Lorsque vous avez fini avec la donn√©e que le mutex garde, vous devez
d√©verrouiller la donn√©e afin que d'autres t√¢ches puissent obtenir le verrou.</li>
</ul>
<!--
For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they‚Äôre finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won‚Äôt work
as planned!
-->
<p>Pour faire une m√©taphore de la vie courante d'un mutex, imaginez une table ronde
lors d'une conf√©rence avec un seul microphone. Avant qu'un participant ne puisse
parler, il doit demander ou signaler qu'il veut utiliser le micro. Lorsqu'il
obtient le micro, il peut parler aussi longtemps qu'il le souhaite et ensuite
passer le micro au prochain participant qui a demand√© √† pouvoir parler. Si un
participant oublie de rendre le micro apr√®s avoir fini de parler, personne
d'autre ne peut parler. Si la gestion du micro partag√© se passe mal, la table
ronde ne fonctionnera pas comme pr√©vu¬†!</p>
<!--
Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust‚Äôs type
system and ownership rules, you can‚Äôt get locking and unlocking wrong.
-->
<p>La gestion des mutex peut devenir incroyablement compliqu√©e, c'est pourquoi
tant de personnes sont partisanes des canaux. Cependant, gr√¢ce au syst√®me de
type de Rust et aux r√®gles de possession, vous ne pouvez pas vous tromper dans
le verrouillage et d√©verrouillage.</p>
<!--
#### The API of `Mutex<T>`
-->
<h4 id="lapi-des-mutext"><a class="header" href="#lapi-des-mutext">L'API des <code>Mutex&lt;T&gt;</code></a></h4>
<!--
As an example of how to use a mutex, let‚Äôs start by using a mutex in a
single-threaded context, as shown in Listing 16-12:
-->
<p>Pour illustrer l'utilisation d'un mutex, commen√ßons par utiliser un mutex dans
le contexte d'une seule t√¢che, comme dans l'encart 16-12¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut nombre = m.lock().unwrap();
        *nombre = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-12: Exploring the API of `Mutex<T>` in a
single-threaded context for simplicity</span>
-->
<p><span class="caption">Encart 16-12¬†: d√©couverte de l'API de <code>Mutex&lt;T&gt;</code> dans le
contexte d'une seule t√¢che pour raison de simplicit√©</span></p>
<!--
As with many types, we create a `Mutex<T>` using the associated function `new`.
To access the data inside the mutex, we use the `lock` method to acquire the
lock. This call will block the current thread so it can‚Äôt do any work until
it‚Äôs our turn to have the lock.
-->
<p>Comme avec beaucoup de types, nous cr√©ons un <code>Mutex&lt;T&gt;</code> en utilisant la
fonction associ√©e <code>new</code>. Pour acc√©der √† la donn√©e dans le mutex, nous utilisons
la m√©thode <code>lock</code> pour obtenir le verrou. Cela va bloquer la t√¢che courante,
donc elle ne s'ex√©cutera plus tant que ce ne sera pas √† notre tour d'avoir le verrou.</p>
<!--
The call to `lock` would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we‚Äôve chosen to
`unwrap` and have this thread panic if we‚Äôre in that situation.
-->
<p>L'appel √† <code>lock</code> √©chouera si une autre t√¢che qui avait le verrou a paniqu√©.
Dans ce cas, personne ne pourra obtenir le verrou, donc nous avons choisi
d'utiliser <code>unwrap</code> pour que notre t√¢che panique si nous nous retrouvons dans
une telle situation.</p>
<!--
After we‚Äôve acquired the lock, we can treat the return value, named `num` in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in `m`: `Mutex<i32>` is not an
`i32`, so we *must* acquire the lock to be able to use the `i32` value. We
can‚Äôt forget; the type system won‚Äôt let us access the inner `i32` otherwise.
-->
<p>Apr√®s avoir obtenu le verrou, nous pouvons utiliser la valeur de retour comme
une r√©f√©rence mutable vers la donn√©e, qui s'appellera <code>nombre</code> dans ce cas. Le
syst√®me de type s'assure que nous obtenons le verrou avant d'utiliser la valeur
pr√©sente dans <code>m</code>¬†: le <code>Mutex&lt;i32&gt;</code> n'est pas un <code>i32</code>, donc nous <em>devons</em>
obtenir le verrou pour pouvoir utiliser la valeur <code>i32</code>. Nous ne pouvons pas
l'oublier¬†; le syst√®me de type ne nous laissera pas acc√©der au <code>i32</code> √†
l'int√©rieur de toute fa√ßon.</p>
<!--
As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the call
to `lock` *returns* a smart pointer called `MutexGuard`, wrapped in a
`LockResult` that we handled with the call to `unwrap`. The `MutexGuard` smart
pointer implements `Deref` to point at our inner data; the smart pointer also
has a `Drop` implementation that releases the lock automatically when a
`MutexGuard` goes out of scope, which happens at the end of the inner scope in
Listing 16-12. As a result, we don‚Äôt risk forgetting to release the lock and
blocking the mutex from being used by other threads because the lock release
happens automatically.
-->
<p>Comme vous pouvez vous en douter, <code>Mutex&lt;T&gt;</code> est un pointeur intelligent. Plus
pr√©cis√©ment, l'appel √† <code>lock</code> <em>retourne</em> un pointeur intelligent <code>MutexGuard</code>,
int√©gr√© dans un <code>LockResult</code> que nous avons g√©r√© en faisant appel √† <code>unwrap</code>.
Le pointeur intelligent <code>MutexGuard</code> impl√©mente <code>Deref</code> pour pouvoir pointer
sur la donn√©e interne¬†; ce pointeur intelligent impl√©mente aussi <code>Drop</code> qui
lib√®re le verrou automatiquement lorsqu'un <code>MutexGuard</code> sort de la port√©e, ce
qui arrive √† la fin de la port√©e interne dans l'encart 16-12. Au final, nous ne
risquons pas d'oublier de rendre le verrou et ainsi bloquer l'utilisation du mutex
pour les autres t√¢ches car la lib√©ration du verrou se produit automatiquement.</p>
<!--
After dropping the lock, we can print the mutex value and see that we were able
to change the inner `i32` to 6.
-->
<p>Apr√®s avoir lib√©r√© le verrou, nous pouvons afficher la valeur dans le mutex et
constater que nous avons pu changer la valeur interne du <code>i32</code> √† <code>6</code>.</p>
<!--
#### Sharing a `Mutex<T>` Between Multiple Threads
-->
<h4 id="partager-un-mutext-entre-plusieurs-t√¢ches"><a class="header" href="#partager-un-mutext-entre-plusieurs-t√¢ches">Partager un <code>Mutex&lt;T&gt;</code> entre plusieurs t√¢ches</a></h4>
<!--
Now, let‚Äôs try to share a value between multiple threads using `Mutex<T>`.
We‚Äôll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. The next example in Listing 16-13 will have
a compiler error, and we‚Äôll use that error to learn more about using
`Mutex<T>` and how Rust helps us use it correctly.
-->
<p>Essayons maintenant de partager une valeur entre plusieurs t√¢ches en utilisant
<code>Mutex&lt;T&gt;</code>. Nous allons faire fonctionner 10 t√¢ches et faire en sorte que
chacune augmente la valeur du compteur de 1, donc le compteur va passer de 0
√† 10. Le prochain exemple dans l'encart 16-13 d√©bouchera sur une erreur de
compilation, et nous allons utiliser cette erreur pour en apprendre plus sur
l'utilisation de <code>Mutex&lt;T&gt;</code> et sur la fa√ßon dont Rust nous aide √† l'utiliser
correctement.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let compteur = Mutex::new(0);
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;Resultat¬†: {}&quot;, *compteur.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a `Mutex<T>`</span>
-->
<p><span class="caption">Encart 16-13¬†: dix t√¢ches qui augmentent chacune un
compteur gard√© par un <code>Mutex&lt;T&gt;</code></span></p>
<!--
We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we
did in Listing 16-12. Next, we create 10 threads by iterating over a range
of numbers. We use `thread::spawn` and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the `Mutex<T>`
by calling the `lock` method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, `num` will go out of scope and release the
lock so another thread can acquire it.
-->
<p>Nous avons cr√©√© une variable <code>compteur</code> pour stocker un <code>i32</code> dans un
<code>Mutex&lt;T&gt;</code>, comme nous l'avons fait dans l'encart 16-12. Ensuite, nous cr√©ons
10 t√¢ches en it√©rant sur un intervalle de nombres. Nous utilisons
<code>thread::spawn</code> et nous donnons √† toutes les t√¢ches la m√™me fermeture, qui
d√©place le compteur dans la t√¢che, obtient le verrou sur le <code>Mutex&lt;T&gt;</code> en
faisant appel √† la m√©thode <code>lock</code> et ajoute ensuite 1 √† la valeur pr√©sente
dans le mutex. Lorsqu'une t√¢che finit d'ex√©cuter sa fermeture, <code>nombre</code> va
sortir de la port√©e et va lib√©rer le verrou afin qu'une autre t√¢che puisse
l'obtenir.</p>
<!--
In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call `join` on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.
-->
<p>Dans la t√¢che principale, nous collectons tous les manipulateurs. Ensuite,
comme nous l'avions fait dans l'encart 16-2, nous faisons appel √† <code>join</code> sur
chaque manipulateur pour s'assurer que toutes les t√¢ches ont fini. Une fois que
c'est le cas, la t√¢che principale va obtenir le verrou et afficher le r√©sultat
de ce programme.</p>
<!--
We hinted that this example wouldn‚Äôt compile. Now let‚Äôs find out why!
-->
<p>Nous avions annonc√© que cet exemple ne se compilerait pas. D√©couvrons
maintenant pourquoi¬†!</p>
<!--
```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  -- > src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `compteur`
  --&gt; src/main.rs:9:36
   |
5  |     let compteur = Mutex::new(0);
   |         -------- move occurs because `compteur` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let manipulateur = thread::spawn(move || {
   |                                          ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut nombre = compteur.lock().unwrap();
   |                              -------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<!--
The error message states that the `counter` value was moved in the previous
iteration of the loop. So Rust is telling us that we can‚Äôt move the ownership
of lock `counter` into multiple threads. Let‚Äôs fix the compiler error with a
multiple-ownership method we discussed in Chapter 15.
-->
<p>Le message d'erreur signale que la valeur <code>compteur</code> a √©t√© d√©plac√©e dans
l'it√©ration pr√©c√©dente de la boucle. Donc Rust nous explique qu'il ne peut
pas d√©placer la possession du verrou de <code>compteur</code> dans plusieurs t√¢ches.
Corrigeons cette erreur de compilation avec une m√©thode permettant d'avoir plusieurs
propri√©taires et que nous avons vue au chapitre 15.</p>
<!--
#### Multiple Ownership with Multiple Threads
-->
<h4 id="plusieurs-propri√©taires-avec-plusieurs-t√¢ches"><a class="header" href="#plusieurs-propri√©taires-avec-plusieurs-t√¢ches">Plusieurs propri√©taires avec plusieurs t√¢ches</a></h4>
<!--
In Chapter 15, we gave a value multiple owners by using the smart pointer
`Rc<T>` to create a reference counted value. Let‚Äôs do the same here and see
what happens. We‚Äôll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and clone
the `Rc<T>` before moving ownership to the thread.
-->
<p>Dans le chapitre 15, nous avons assign√© plusieurs propri√©taires √† une valeur
en utilisant le pointeur intelligent <code>Rc&lt;T&gt;</code> pour cr√©er un compteur de
r√©f√©rence. Faisons la m√™me chose ici et voyons ce qui se passe. Nous allons
int√©grer le <code>Mutex&lt;T&gt;</code> dans un <code>Rc&lt;T&gt;</code> dans l'encart 16-14 et cloner le <code>Rc&lt;T&gt;</code>
avant de d√©placer sa possession √† la t√¢che.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let compteur = Rc::new(Mutex::new(0));
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let compteur = Rc::clone(&amp;compteur);
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;R√©sultat¬†: {}&quot;, *compteur.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-14: Attempting to use `Rc<T>` to allow
multiple threads to own the `Mutex<T>`</span>
-->
<p><span class="caption">Encart 16-14¬†: tentative d'utilisation d'un <code>Rc&lt;T&gt;</code> pour
nous permettre d'utiliser plusieurs t√¢ches qui poss√©deront le <code>Mutex&lt;T&gt;</code></span></p>
<!--
Once again, we compile and get... different errors! The compiler is teaching us
a lot.
-->
<p>A nouveau, nous compilons et nous obtenons ... une erreur diff√©rente¬†! Le
compilateur nous en apprend beaucoup.</p>
<!--
```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
   -- > src/main.rs:11:22
    |
11  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc<Mutex<i32>>` cannot be sent between threads safely
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
note: required by a bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |           let manipulateur = thread::spawn(move || {
    |  ____________________________^^^^^^^^^^^^^_-
    | |                            |
    | |                            `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
12  | |             let mut nombre = compteur.lock().unwrap();
13  | |
14  | |             *nombre += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
note: required by a bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<!--
Wow, that error message is very wordy! Here‚Äôs the important part to focus
on: `` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. The compiler
is also telling us the reason why: ``the trait `Send` is not implemented for
`Rc<Mutex<i32>>` ``. We‚Äôll talk about `Send` in the next section: it‚Äôs one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.
-->
<p>Ouah, ce message d'erreur est tr√®s verbeux¬†! Voici la partie la plus importante
sur laquelle se concentrer¬†:
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. Le compilateur
nous indique aussi pour quelle raison¬†:
<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>. Nous allons voir
<code>Send</code> dans la prochaine section¬†: c'est l'un des traits qui garantissent que le
type que nous utilisons avec les t√¢ches est pr√©vu pour √™tre utilis√© dans des
situations de concurrence.</p>
<!--
Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>`
manages the reference count, it adds to the count for each call to `clone` and
subtracts from the count when each clone is dropped. But it doesn‚Äôt use any
concurrency primitives to make sure that changes to the count can‚Äôt be
interrupted by another thread. This could lead to wrong counts‚Äîsubtle bugs that
could in turn lead to memory leaks or a value being dropped before we‚Äôre done
with it. What we need is a type exactly like `Rc<T>` but one that makes changes
to the reference count in a thread-safe way.
-->
<p>Malheureusement l'utilisation de <code>Rc&lt;T&gt;</code> n'est pas sure lorsqu'il est partag√©
entre plusieurs t√¢ches. Lorsque <code>Rc&lt;T&gt;</code> g√®re le compteur de r√©f√©rences, il
incr√©mente le compteur autant de fois que nous avons fait appel √† <code>clone</code> et
d√©cr√©mente le compteur √† chaque fois qu'un clone est lib√©r√©. Mais il n'utilise
pas de primitives de concurrence pour s'assurer que les changements faits au
compteur ne peuvent pas √™tre interrompus par une autre t√¢che. Cela pourrait
provoquer des bogues subtils induisant une mauvaise gestion du compteur, ce qui
pourrait provoquer des fuites de m√©moire ou faire qu'une valeur soit lib√©r√©e
avant que nous ayions fini de l'utiliser. Nous avons besoin d'un type
exactement comme <code>Rc&lt;T&gt;</code> mais qui proc√®de aux changements du compteur de
r√©f√©rences de mani√®re sure en situation de concurrence.</p>
<!--
#### Atomic Reference Counting with `Arc<T>`
-->
<h4 id="compteur-de-r√©f√©rence-atomique-avec-arct"><a class="header" href="#compteur-de-r√©f√©rence-atomique-avec-arct">Compteur de r√©f√©rence atomique avec <code>Arc&lt;T&gt;</code></a></h4>
<!--
Fortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in
concurrent situations. The *a* stands for *atomic*, meaning it‚Äôs an *atomically
reference counted* type. Atomics are an additional kind of concurrency
primitive that we won‚Äôt cover in detail here: see the standard library
documentation for [`std::sync::atomic`][atomic]<!-- ignore -- > for more
details. At this point, you just need to know that atomics work like primitive
types but are safe to share across threads.
-->
<p>Heureusement, <code>Arc&lt;T&gt;</code> <em>est</em> un type comme <code>Rc&lt;T&gt;</code> qui est s√ªr en
situation de concurrence. Le <em>A</em> signifie <em>atomique</em>, ce qui signifie que c'est
un type <em>compteur de r√©f√©rences atomique</em>. L'atome est une sorte de primitive
concurrente que nous n'allons pas aborder en d√©tails ici¬†: rendez-vous dans la
documentation de la biblioth√®que standard sur <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!--
ignore --> pour en savoir plus. Pour le moment, vous avez juste besoin de
retenir que les atomes fonctionnent comme les types primitifs mais qui sont
s√ªrs √† partager entre plusieurs t√¢ches.</p>
<!--
You might then wonder why all primitive types aren‚Äôt atomic and why standard
library types aren‚Äôt implemented to use `Arc<T>` by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you‚Äôre just performing operations on values within a
single thread, your code can run faster if it doesn‚Äôt have to enforce the
guarantees atomics provide.
-->
<p>Vous vous demandez pourquoi tous les types primitifs ne sont pas atomiques et
pourquoi les types de la biblioth√®que standard ne sont pas impl√©ment√©s en
utilisant <code>Arc&lt;T&gt;</code> par d√©faut. La raison √† cela est que la s√©curit√© entre les
t√¢ches a un co√ªt sur les performances que vous n'√™tes pr√™t √† payer que lorsque
vous en avez besoin. Si vous proc√©dez √† des op√©rations sur des valeurs
uniquement dans une seule t√¢che, votre code va s'ex√©cuter plus vite car il n'a
pas besoin d'appliquer les garanties fournies par les types atomiques.</p>
<!--
Let‚Äôs return to our example: `Arc<T>` and `Rc<T>` have the same API, so we fix
our program by changing the `use` line, the call to `new`, and the call to
`clone`. The code in Listing 16-15 will finally compile and run:
-->
<p>Retournons √† notre exemple¬†: <code>Arc&lt;T&gt;</code> et <code>Rc&lt;T&gt;</code> ont la m√™me API, donc
corrigeons notre programme en changeant la ligne <code>use</code>, l'appel √† <code>new</code> et
l'appel √† <code>clone</code>. Le code dans l'encart 16-15 va finalement se compiler et
s'ex√©cuter¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let compteur = Arc::new(Mutex::new(0));
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let compteur = Arc::clone(&amp;compteur);
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;R√©sultat¬†: {}&quot;, *compteur.lock().unwrap());
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-15: Using an `Arc<T>` to wrap the `Mutex<T>`
to be able to share ownership across multiple threads</span>
-->
<p><span class="caption">Encart 16-15¬†: utilisation d'un <code>Arc&lt;T&gt;</code> pour englober
le <code>Mutex&lt;T&gt;</code> afin de partager la possession entre plusieurs t√¢ches</span></p>
<!--
This code will print the following:
-->
<p>Ce code va finalement afficher ceci¬†:</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Result: 10
```
-->
<pre><code class="language-text">Resultat¬†: 10
</code></pre>
<!--
We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about `Mutex<T>` and thread safety. You could also use this
program‚Äôs structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a `Mutex<T>` to have each
thread update the final result with its part.
-->
<p>Nous y sommes arriv√©s¬†! Nous avons compt√© de 0 √† 10, ce qui ne semble pas tr√®s
impressionnant, mais cela nous a appris beaucoup sur <code>Mutex&lt;T&gt;</code> et la s√ªret√©
des t√¢ches. Vous pouvez aussi utiliser cette structure de programme pour
proc√©der √† des op√©rations plus complexes que simplement incr√©menter un
compteur. En utilisant cette strat√©gie, vous pouvez diviser un calcul en
diff√©rentes parties, r√©partir ces parties sur des t√¢ches, et ensuite utiliser
un <code>Mutex&lt;T&gt;</code> pour faire en sorte que chaque t√¢che mette √† jour le r√©sultat
final avec sa propre partie.</p>
<!--
### Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`
-->
<h3 id="similarit√©s-entre-refcelltrct-et-mutextarct"><a class="header" href="#similarit√©s-entre-refcelltrct-et-mutextarct">Similarit√©s entre <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> et <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<!--
You might have noticed that `counter` is immutable but we could get a mutable
reference to the value inside it; this means `Mutex<T>` provides interior
mutability, as the `Cell` family does. In the same way we used `RefCell<T>` in
Chapter 15 to allow us to mutate contents inside an `Rc<T>`, we use `Mutex<T>`
to mutate contents inside an `Arc<T>`.
-->
<p>Vous avez peut-√™tre constat√© que <code>compteur</code> est immuable mais que nous pouvons
obtenir une r√©f√©rence mutable vers la valeur qu'il renferme¬†; cela signifie que
<code>Mutex&lt;T&gt;</code> a une mutabilit√© interne, comme le fait la famille des <code>Cell</code>. De la
m√™me mani√®re que nous avons utilis√© <code>RefCell&lt;T&gt;</code> au chapitre 15 pour nous
permettre de changer le contenu dans un <code>Rc&lt;T&gt;</code>, nous utilisons <code>Mutex&lt;T&gt;</code> pour
modifier le contenu d'un <code>Arc&lt;T&gt;</code>.</p>
<!--
Another detail to note is that Rust can‚Äôt protect you from all kinds of logic
errors when you use `Mutex<T>`. Recall in Chapter 15 that using `Rc<T>` came
with the risk of creating reference cycles, where two `Rc<T>` values refer to
each other, causing memory leaks. Similarly, `Mutex<T>` comes with the risk of
creating *deadlocks*. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you‚Äôre interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for `Mutex<T>` and `MutexGuard` offers
useful information.
-->
<p>Un autre d√©tail √† souligner est que Rust ne peut pas vous prot√©ger de tous les
genres d'erreurs de logique lorsque vous utilisez <code>Mutex&lt;T&gt;</code>. Souvenez-vous
que le chapitre 15 utilisait <code>Rc&lt;T&gt;</code> avec le risque de cr√©er des boucles de
r√©f√©rences, dans lesquelles deux valeurs <code>Rc&lt;T&gt;</code> se r√©f√©reraient l'une √†
l'autre, ce qui provoquait des fuites de m√©moire. De la m√™me mani√®re,
l'utilisation de <code>Mutex&lt;T&gt;</code> risque de cr√©er des <em>interblocages</em>. Cela se produit
lorsqu'une op√©ration n√©cessite de verrouiller deux ressources et que deux t√¢ches
ont chacune un des deux verrous, ce qui fait qu'elles s'attendent mutuellement
pour toujours. Si vous √™tes int√©ress√©s par les interblocages, essayez de cr√©er
un programme Rust qui a un interblocage¬†; recherchez ensuite des strat√©gies pour
rem√©dier aux interblocages dans n'importe quel langage et impl√©mentez-les en
Rust. La documentation de l'API de la biblioth√®que standard pour <code>Mutex&lt;T&gt;</code> et
<code>MutexGuard</code> offre des informations pr√©cieuses √† ce sujet.</p>
<!--
We‚Äôll round out this chapter by talking about the `Send` and `Sync` traits and
how we can use them with custom types.
-->
<p>Nous allons terminer ce chapitre en parlant des traits <code>Send</code> et <code>Sync</code> et
voir comment nous pouvons les utiliser sur des types personnalis√©s.</p>
<!--
[atomic]: ../std/sync/atomic/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Extensible Concurrency with the `Sync` and `Send` Traits
-->
<h2 id="etendre-la-concurrence-avec-les-traits-sync-et-send"><a class="header" href="#etendre-la-concurrence-avec-les-traits-sync-et-send">Etendre la concurrence avec les traits <code>Sync</code> et <code>Send</code></a></h2>
<!--
Interestingly, the Rust language has *very* few concurrency features. Almost
every concurrency feature we‚Äôve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.
-->
<p>Curieusement, le langage Rust a <em>tr√®s</em> peu de fonctionnalit√©s de concurrence.
La plupart des fonctionnalit√©s de concurrence que nous avons vues pr√©c√©demment
dans ce chapitre font partie de la biblioth√®que standard, pas du langage. Vos
options pour g√©rer la concurrence ne sont pas limit√©es √† celles du langage ou
de la biblioth√®que standard¬†; vous pouvez aussi √©crire vos propres
fonctionnalit√©s de concurrence ou utiliser celles qui ont √©t√© √©crites par
d'autres.</p>
<!--
However, two concurrency concepts are embedded in the language: the
`std::marker` traits `Sync` and `Send`.
-->
<p>Cependant, deux concepts de concurrence sont int√©gr√©s dans le langage¬†: les
traits <code>Sync</code> et <code>Send</code> de <code>std::marker</code>.</p>
<!--
### Allowing Transference of Ownership Between Threads with `Send`
-->
<h3 id="permettre-le-transfert-de-possession-entre-les-t√¢ches-avec-send"><a class="header" href="#permettre-le-transfert-de-possession-entre-les-t√¢ches-avec-send">Permettre le transfert de possession entre les t√¢ches avec <code>Send</code></a></h3>
<!--
The `Send` marker trait indicates that ownership of values of the type implementing
`Send` can be transferred between threads. Almost every Rust type is `Send`,
but there are some exceptions, including `Rc<T>`: this cannot be `Send` because
if you cloned an `Rc<T>` value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, `Rc<T>` is implemented for use in single-threaded situations
where you don‚Äôt want to pay the thread-safe performance penalty.
-->
<p>Le trait <code>Send</code> indique que la possession des valeurs du type qui impl√©mente
<code>Send</code> peut √™tre transf√©r√© entre plusieurs t√¢ches. Presque tous les types de
Rust impl√©mentent <code>Send</code>, mais il subsiste quelques exceptions, comme <code>Rc&lt;T&gt;</code>¬†:
il ne peut pas impl√©menter <code>Send</code> car si vous clonez une valeur <code>Rc&lt;T&gt;</code> et que
vous essayez de transf√©rer la possession de ce clone √† une autre t√¢che, les
deux t√¢ches peuvent modifier le compteur de r√©f√©rence en m√™me temps. Pour cette
raison, <code>Rc&lt;T&gt;</code> n'est pr√©vu que pour une utilisation dans des situations qui
ne n√©cessitent qu'une seule t√¢che et pour lesquelles vous n'avez pas besoin de payer
le surco√ªt sur la performance induit par la suret√© de fonctionnement multi t√¢ches.</p>
<!--
Therefore, Rust‚Äôs type system and trait bounds ensure that you can never
accidentally send an `Rc<T>` value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error `the trait Send is not implemented for
Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is `Send`, the code
compiled.
-->
<p>Toutefois, le syst√®me de type et de traits li√©s de Rust garantit que vous ne
pourrez jamais envoyer accidentellement en toute ins√©curit√© une valeur <code>Rc&lt;T&gt;</code>
entre des t√¢ches. Lorsque nous avons essay√© de faire cela dans l'encart 16-14,
nous avons obtenu l'erreur
<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Lorsque nous l'avons
chang√© pour un <code>Arc&lt;T&gt;</code>, qui impl√©mente <code>Send</code>, le code s'est compil√©.</p>
<!--
Any type composed entirely of `Send` types is automatically marked as `Send` as
well. Almost all primitive types are `Send`, aside from raw pointers, which
we‚Äôll discuss in Chapter 19.
-->
<p>Tous les types compos√©s enti√®rement d'autres types qui impl√©mentent <code>Send</code> sont
automatiquement marqu√©s comme <code>Send</code> eux-aussi. Presque tous les types
primitifs sont <code>Send</code>, √† part les pointeurs bruts, ce que nous verrons au
chapitre 19.</p>
<!--
### Allowing Access from Multiple Threads with `Sync`
-->
<h3 id="permettre-lacc√®s-√†-plusieurs-t√¢ches-avec-sync"><a class="header" href="#permettre-lacc√®s-√†-plusieurs-t√¢ches-avec-sync">Permettre l'acc√®s √† plusieurs t√¢ches avec <code>Sync</code></a></h3>
<!--
The `Sync` marker trait indicates that it is safe for the type implementing
`Sync` to be referenced from multiple threads. In other words, any type `T` is
`Sync` if `&T` (an immutable reference to `T`) is `Send`, meaning the reference
can be sent safely to another thread. Similar to `Send`, primitive types are
`Sync`, and types composed entirely of types that are `Sync` are also `Sync`.
-->
<p>Le trait <code>Sync</code> indique qu'il est s√ªr d'avoir une r√©f√©rence dans plusieurs
t√¢ches vers le type qui impl√©mente <code>Sync</code>. Autrement dit, n'importe quel type
<code>T</code> impl√©mente <code>Sync</code> si <code>&amp;T</code> (une r√©f√©rence immuable vers <code>T</code>) impl√©mente
<code>Send</code>, ce qui signifie que la r√©f√©rence peut √™tre envoy√©e en toute s√©curit√© √†
une autre t√¢che. De la m√™me mani√®re que <code>Send</code>, les types primitifs
impl√©mentent <code>Sync</code>, et les types compos√©s enti√®rement d'autres types qui
impl√©mentent <code>Sync</code> sont eux-m√™mes <code>Sync</code>.</p>
<!--
The smart pointer `Rc<T>` is also not `Sync` for the same reasons that it‚Äôs not
`Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and the
family of related `Cell<T>` types are not `Sync`. The implementation of borrow
checking that `RefCell<T>` does at runtime is not thread-safe. The smart
pointer `Mutex<T>` is `Sync` and can be used to share access with multiple
threads as you saw in the [‚ÄúSharing a `Mutex<T>` Between Multiple
Threads‚Äù][sharing-a-mutext-between-multiple-threads]<!-- ignore -- > section.
-->
<p>Le pointeur intelligent <code>Rc&lt;T&gt;</code> n'impl√©mente pas non plus <code>Sync</code> pour les m√™mes
raisons qu'il n'impl√©mente pas <code>Send</code>. Le type <code>RefCell&lt;T&gt;</code> (que nous avons vu
au chapitre 15) et la famille li√©e aux types <code>Cell&lt;T&gt;</code> n'impl√©mentent pas <code>Sync</code>.
L'impl√©mentation du v√©rificateur d'emprunt que <code>RefCell&lt;T&gt;</code> met en oeuvre √† l'ex√©cution
n'est pas s√ªre pour le multi t√¢ches. Le pointeur intelligent <code>Mutex&lt;T&gt;</code>
impl√©mente <code>Sync</code> et peut √™tre utilis√© pour partager l'acc√®s entre plusieurs
t√¢ches, comme vous l'avez vu dans la section pr√©c√©dente.</p>
<!--
### Implementing `Send` and `Sync` Manually Is Unsafe
-->
<h3 id="impl√©menter-manuellement-send-et-sync-nest-pas-s√ªr"><a class="header" href="#impl√©menter-manuellement-send-et-sync-nest-pas-s√ªr">Impl√©menter manuellement <code>Send</code> et <code>Sync</code> n'est pas s√ªr</a></h3>
<!--
Because types that are made up of `Send` and `Sync` traits are automatically
also `Send` and `Sync`, we don‚Äôt have to implement those traits manually. As
marker traits, they don‚Äôt even have any methods to implement. They‚Äôre just
useful for enforcing invariants related to concurrency.
-->
<p>Comme les types qui sont constitu√©s de types impl√©mentant les traits <code>Send</code> et
<code>Sync</code> sont automatiquement des <code>Send</code> et <code>Sync</code>, nous n'avons pas √†
impl√©menter manuellement ces traits. Comme ce sont des traits de marquage, ils
n'ont m√™me pas de m√©thodes √† impl√©menter. Ils sont uniquement utiles pour
appliquer les r√®gles de concurrence.</p>
<!--
Manually implementing these traits involves implementing unsafe Rust code.
We‚Äôll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of `Send` and
`Sync` parts requires careful thought to uphold the safety guarantees. [‚ÄúThe
Rustonomicon‚Äù][nomicon] has more information about these guarantees and how to
uphold them.
-->
<p>L'impl√©mentation manuelle de ces traits implique de faire du code Rust non
s√©curis√©. Nous allons voir le code Rust non s√©curis√© dans le chapitre 19¬†; pour
l'instant l'information √† retenir est que construire de nouveaux types
pour la concurrence constitu√©s d'√©l√©ments qui n'impl√©mentent pas <code>Send</code> et
<code>Sync</code> n√©cessite une r√©flexion approfondie pour respecter les garanties de
s√©curit√©. <a href="https://doc.rust-lang.org/nomicon/index.html">‚ÄúThe Rustonomicon‚Äù</a> contient plus d'informations √† propos de
ces garanties et de la fa√ßon de les faire appliquer.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-15"><a class="header" href="#r√©sum√©-15">R√©sum√©</a></h2>
<!--
This isn‚Äôt the last you‚Äôll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.
-->
<p>Ce n'est pas la derni√®re fois que vous allez rencontrer de la concurrence dans
ce livre¬†: le projet du chapitre 20 va utiliser les concepts de ce chapitre dans
une situation plus r√©aliste que les petits exemples que nous avons utilis√©s ici.</p>
<!--
As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.
-->
<p>Nous l'avons dit pr√©c√©demment, comme les outils pour g√©rer la concurrence de
Rust ne sont pas directement int√©gr√©s dans le langage, de nombreuses solutions
pour de la concurrence sont impl√©ment√©es dans des crates. Elles √©voluent plus
rapidement que la biblioth√®que standard, donc assurez-vous de rechercher en
ligne des crates modernes et √† la pointe de la technologie √† utiliser dans des
situations multit√¢ches.</p>
<!--
The Rust standard library provides channels for message passing and smart
pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won‚Äôt end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!
-->
<p>La biblioth√®que standard de Rust fournit les canaux pour l'envoi de messages et
les types de pointeurs intelligents, comme <code>Mutex&lt;T&gt;</code> et <code>Arc&lt;T&gt;</code>, qui sont
s√ªrs √† utiliser en situation de concurrence. Le syst√®me de type et le
v√©rificateur d'emprunt sont l√† pour s'assurer que le code utilis√© dans ces
solutions ne vont pas conduire √† des situations de concurrence ou utiliser des
r√©f√©rences qui ne sont plus en vigueur. Une fois que votre code se compile,
vous pouvez √™tre assur√© qu'il fonctionnera bien sur plusieurs t√¢ches sans avoir
les genres de bogues <em>difficiles √† traquer</em> qui sont monnaie courante dans les
autres langages. Le d√©veloppement en concurrence est un domaine qui ne devrait
plus faire peur¬†: lancez-vous et utilisez la concurrence dans vos programmes
sans crainte¬†!</p>
<!--
Next, we‚Äôll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we‚Äôll discuss how Rust‚Äôs idioms
relate to those you might be familiar with from object-oriented programming.
-->
<p>Au chapitre suivant, nous allons voir des techniques adapt√©es pour mod√©liser des
probl√®mes et structurer votre solution au fur et √† mesure que vos programmes en
Rust grandissent. De plus, nous analyserons les liens qui peuvent exister entre
les id√©es de Rust et celles avec lesquelles vous √™tes peut-√™tre familier en
programmation orient√©e objet.</p>
<!--
[sharing-a-mutext-between-multiple-threads]:
ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads
[nomicon]: ../nomicon/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Object Oriented Programming Features of Rust
-->
<h1 id="les-fonctionnalit√©s-orient√©es-objet-de-rust"><a class="header" href="#les-fonctionnalit√©s-orient√©es-objet-de-rust">Les fonctionnalit√©s orient√©es objet de Rust</a></h1>
<!--
Object-oriented programming (OOP) is a way of modeling programs. Objects came
from Simula in the 1960s. Those objects influenced Alan Kay‚Äôs programming
architecture in which objects pass messages to each other. He coined the term
*object-oriented programming* in 1967 to describe this architecture. Many
competing definitions describe what OOP is; some definitions would classify
Rust as object oriented, but other definitions would not. In this chapter,
we‚Äôll explore certain characteristics that are commonly considered object
oriented and how those characteristics translate to idiomatic Rust. We‚Äôll then
show you how to implement an object-oriented design pattern in Rust and discuss
the trade-offs of doing so versus implementing a solution using some of Rust‚Äôs
strengths instead.
-->
<p>La programmation orient√©e objet (POO) est une fa√ßon de concevoir des programmes.
Les objets sont apparus dans Simula dans les ann√©es 1960. Ces objets ont
influenc√© l'architecture de programmation d'Alan Kay dans laquelle les objets
s'envoient des messages. Il a invent√© le terme <em>programmation orient√©e objet</em> en
1967 pour d√©crire cette architecture. Plusieurs d√©finitions de la POO
s'opposent¬†; Rust est consid√©r√© comme orient√© objet selon certaines d√©finitions
mais pas par d'autres. Dans ce chapitre, nous examinerons certaines
caract√©ristiques g√©n√©ralement consid√©r√©es comme orient√©es objet et nous verrons
comment ces caract√©ristiques se traduisent en code Rust traditionnel. Puis nous
vous montrerons comment impl√©menter un patron de conception orient√© objet en
Rust et nous comparerons les avantages et inconv√©nients de faire cela plut√¥t que
d'impl√©menter une solution qui utilise quelques points forts de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Characteristics of Object-Oriented Languages
-->
<h2 id="les-caract√©ristiques-des-langages-orient√©s-objet"><a class="header" href="#les-caract√©ristiques-des-langages-orient√©s-objet">Les caract√©ristiques des langages orient√©s objet</a></h2>
<!--
There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Let‚Äôs look at what each of those characteristics means and whether
Rust supports it.
-->
<p>Les d√©veloppeurs ne se sont jamais entendus sur les fonctionnalit√©s qu'un
langage doit avoir pour √™tre consid√©r√© orient√© objet. Rust est influenc√© par
de nombreux paradigmes de programmation, y compris la POO¬†; par exemple, nous
avons examin√© les fonctionnalit√©s issues de la programmation fonctionnelle au
chapitre 13. On peut vraisemblablement dire que les langages orient√©s objet ont
plusieurs caract√©ristiques en commun, comme les objets, l'encapsulation et
l'h√©ritage. Examinons chacune de ces caract√©ristiques et regardons si Rust
les supporte.</p>
<!--
### Objects Contain Data and Behavior
-->
<h3 id="les-objets-contiennent-des-donn√©es-et-suivent-un-comportement"><a class="header" href="#les-objets-contiennent-des-donn√©es-et-suivent-un-comportement">Les objets contiennent des donn√©es et suivent un comportement</a></h3>
<!--
The book *Design Patterns: Elements of Reusable Object-Oriented Software* by
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
Professional, 1994), colloquially referred to as *The Gang of Four* book, is a
catalog of object-oriented design patterns. It defines OOP this way:
-->
<p>Le livre <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>
d'Erich Gamma, Richard Helm, Ralph Johnson et John Vlissides (Addison-Wesley
Professional, 1994) que l'on surnomme le livre du <em>Gang of Four</em> est un
catalogue de patrons de conception orient√©s objet. Il d√©finit la POO ainsi¬†:</p>
<!--
> Object-oriented programs are made up of objects. An *object* packages both
> data and the procedures that operate on that data. The procedures are
> typically called *methods* or *operations*.
-->
<blockquote>
<p>Les programmes orient√©s objet sont constitu√©s d'objets. Un <em>objet</em> regroupe
des donn√©es ainsi que les proc√©dures qui op√®rent sur ces donn√©es. Ces
proc√©dures sont typiquement appel√©es <em>m√©thodes</em> ou <em>op√©rations</em>.</p>
</blockquote>
<!--
Using this definition, Rust is object oriented: structs and enums have data,
and `impl` blocks provide methods on structs and enums. Even though structs and
enums with methods aren‚Äôt *called* objects, they provide the same
functionality, according to the Gang of Four‚Äôs definition of objects.
-->
<p>Si l'on s'en tient √† cette d√©finition, Rust est orient√© objet¬†: les structures et
les √©num√©rations ont des donn√©es et les blocs <code>impl</code> leur fournissent des
m√©thodes. Bien que les structures et les √©num√©rations dot√©es de m√©thodes ne
soient pas qualifi√©es d'objets, elles en ont les fonctionnalit√©s selon la
d√©finition des objets faite par le <em>Gang of Four</em>.</p>
<!--
### Encapsulation that Hides Implementation Details
-->
<h3 id="lencapsulation-qui-masque-les-d√©tails-dimpl√©mentation"><a class="header" href="#lencapsulation-qui-masque-les-d√©tails-dimpl√©mentation">L'encapsulation qui masque les d√©tails d'impl√©mentation</a></h3>
<!--
Another aspect commonly associated with OOP is the idea of *encapsulation*,
which means that the implementation details of an object aren‚Äôt accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldn‚Äôt be able to reach into
the object‚Äôs internals and change data or behavior directly. This enables the
programmer to change and refactor an object‚Äôs internals without needing to
change the code that uses the object.
-->
<p>Un autre aspect qu'on associe souvent √† la POO est l'id√©e d'<em>encapsulation</em>, ce
qui signifie que les d√©tails d'impl√©mentation d'un objet ne sont pas accessibles
au code utilisant cet objet. Ainsi, la seule fa√ßon d'interagir avec un objet est
via son API publique¬†; le code qui utilise l'objet ne devrait pas pouvoir
acc√©der aux √©l√©ments internes d'un objet et changer directement ses donn√©es ou
son comportement. Cela permet au d√©veloppeur de changer et remanier les √©l√©ments
internes d'un objet sans avoir √† changer le code qui utilise cet objet.</p>
<!--
We discussed how to control encapsulation in Chapter 7: we can use the `pub`
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct `AveragedCollection` that has a field containing a vector
of `i32` values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesn‚Äôt have to be computed
on demand whenever anyone needs it. In other words, `AveragedCollection` will
cache the calculated average for us. Listing 17-1 has the definition of the
`AveragedCollection` struct:
-->
<p>Nous avons abord√© la fa√ßon de contr√¥ler l'encapsulation au chapitre 7¬†: on peut
utiliser le mot-cl√© <code>pub</code> pour d√©cider quels modules, types, fonctions et
m√©thodes de notre code devraient √™tre publics¬†; par d√©faut, tout le reste est
priv√©. Par exemple, nous pouvons d√©finir une structure <code>CollectionMoyennee</code> qui
a un champ contenant un vecteur de valeurs <code>i32</code>. La structure peut aussi avoir
un champ qui contient la moyenne des valeurs dans le vecteur de sorte qu'il ne
soit pas n√©cessaire de recalculer la moyenne √† chaque fois que quelqu'un en a
besoin. En d'autres termes, <code>CollectionMoyennee</code> va mettre en cache la moyenne
calcul√©e pour nous. L'encart 17-1 contient la d√©finition de la structure
<code>CollectionMoyennee</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```
-->
<pre><code class="language-rust noplayground">pub struct CollectionMoyennee {
    liste: Vec&lt;i32&gt;,
    moyenne: f64,
}
</code></pre>
<!--
<span class="caption">Listing 17-1: An `AveragedCollection` struct that
maintains a list of integers and the average of the items in the
collection</span>
-->
<p><span class="caption">Encart 17-1¬†: Une structure <code>CollectionMoyennee</code> qui
contient une liste d'entiers et la moyenne des √©l√©ments de la collection</span></p>
<!--
The struct is marked `pub` so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing `add`, `remove`, and `average` methods
on the struct, as shown in Listing 17-2:
-->
<p>La structure est marqu√©e <code>pub</code> de fa√ßon √† ce qu'elle puisse √™tre utilis√©e par
du code externe, mais les champs au sein de la structure restent priv√©s. C'est
important dans ce cas puisque nous voulons nous assurer que lorsqu'une valeur
est ajout√©e ou retir√©e dans la liste, la moyenne soit aussi mise √† jour. Nous
le faisons en impl√©mentant les m√©thodes <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sur
la structure, comme le montre l'encart 17-2¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct AveragedCollection {
#     list: Vec<i32>,
#     average: f64,
# }
# 
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct CollectionMoyennee {
</span><span class="boring">    liste: Vec&lt;i32&gt;,
</span><span class="boring">    moyenne: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionMoyennee {
    pub fn ajouter(&amp;mut self, valeur: i32) {
        self.liste.push(valeur);
        self.mettre_a_jour_moyenne();
    }

    pub fn retirer(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let resultat = self.liste.pop();
        match resultat {
            Some(valeur) =&gt; {
                self.mettre_a_jour_moyenne();
                Some(valeur)
            }
            None =&gt; None,
        }
    }

    pub fn moyenne(&amp;self) -&gt; f64 {
        self.moyenne
    }

    fn mettre_a_jour_moyenne(&amp;mut self) {
        let total: i32 = self.liste.iter().sum();
        self.moyenne = total as f64 / self.liste.len() as f64;
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-2: Implementations of the public methods
`add`, `remove`, and `average` on `AveragedCollection`</span>
-->
<p><span class="caption">Encart 17-2¬†: Impl√©mentations des m√©thodes publiques
<code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sur <code>CollectionMoyennee</code></span></p>
<!--
The public methods `add`, `remove`, and `average` are the only ways to access
or modify data in an instance of `AveragedCollection`. When an item is added
to `list` using the `add` method or removed using the `remove` method, the
implementations of each call the private `update_average` method that handles
updating the `average` field as well.
-->
<p>Les m√©thodes publiques <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sont les seules fa√ßons
d'acc√©der ou de modifier les donn√©es d'une instance de <code>CollectionMoyennee</code>.
Lorsqu'un √©l√©ment est ajout√© √† <code>liste</code> en utilisant la m√©thode <code>ajouter</code> ou
retir√© en utilisant la m√©thode <code>retirer</code>, l'impl√©mentation de chacune de ces
m√©thodes appelle la m√©thode priv√©e <code>mettre_a_jour_moyenne</code> qui met √† jour le
champ <code>moyenne</code> √©galement.</p>
<!--
We leave the `list` and `average` fields private so there is no way for
external code to add or remove items to the `list` field directly; otherwise,
the `average` field might become out of sync when the `list` changes. The
`average` method returns the value in the `average` field, allowing external
code to read the `average` but not modify it.
-->
<p>Nous laissons les champs <code>liste</code> et <code>moyenne</code> priv√©s pour qu'il soit impossible
pour du code externe d'ajouter ou de retirer des √©l√©ments dans notre champ
<code>liste</code> directement¬†; sinon, le champ <code>moyenne</code> pourrait ne plus √™tre
synchronis√© lorsque la liste change. La m√©thode <code>moyenne</code> renvoie la valeur du
champ <code>moyenne</code>, ce qui permet au code externe de lire le champ <code>moyenne</code> mais
pas de le modifier.</p>
<!--
Because we‚Äôve encapsulated the implementation details of the struct
`AveragedCollection`, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a `HashSet<i32>` instead of a
`Vec<i32>` for the `list` field. As long as the signatures of the `add`,
`remove`, and `average` public methods stay the same, code using
`AveragedCollection` wouldn‚Äôt need to change. If we made `list` public instead,
this wouldn‚Äôt necessarily be the case: `HashSet<i32>` and `Vec<i32>` have
different methods for adding and removing items, so the external code would
likely have to change if it were modifying `list` directly.
-->
<p>Puisque nous avons encapsul√© les d√©tails d'impl√©mentation de la structure
<code>CollectionMoyennee</code>, nous pourrons ais√©ment en changer plus tard quelques
aspects, tels que la structure de donn√©es. Par exemple, nous pourrions utiliser
un <code>HashSet&lt;i32&gt;</code> plut√¥t qu'un <code>Vec&lt;i32&gt;</code> pour le champ <code>liste</code>. Du moment que
les signatures des m√©thodes publiques <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> restent
les m√™mes, du code qui utilise <code>CollectionMoyennee</code> n'aurait pas besoin de
changer. En revanche, si nous avions fait en sorte que <code>liste</code> soit publique,
cela n'aurait pas √©t√© forc√©ment le cas¬†: <code>HashSet&lt;i32&gt;</code> et <code>Vec&lt;i32&gt;</code> ont des
m√©thodes diff√©rentes pour ajouter et retirer des √©l√©ments, donc il aurait
vraisemblablement fallu changer le code externe s'il modifiait directement
<code>liste</code>.</p>
<!--
If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use `pub` or not for
different parts of code enables encapsulation of implementation details.
-->
<p>Si l'encapsulation est une condition n√©cessaire pour qu'un langage soit
consid√©r√© orient√© objet, alors Rust satisfait cette condition. La possibilit√©
d'utiliser <code>pub</code> ou non pour diff√©rentes parties de notre code permet
d'encapsuler les d√©tails d'impl√©mentation.</p>
<!--
### Inheritance as a Type System and as Code Sharing
-->
<h3 id="lh√©ritage-comme-syst√®me-de-type-et-comme-partage-de-code"><a class="header" href="#lh√©ritage-comme-syst√®me-de-type-et-comme-partage-de-code">L'h√©ritage comme syst√®me de type et comme partage de code</a></h3>
<!--
*Inheritance* is a mechanism whereby an object can inherit from another
object‚Äôs definition, thus gaining the parent object‚Äôs data and behavior without
you having to define them again.
-->
<p>L'<em>h√©ritage</em> est un m√©canisme selon lequel un objet peut h√©riter de la
d√©finition d'un autre objet, acqu√©rant ainsi les donn√©es et le comportement de
l'objet p√®re sans que l'on ait besoin de les red√©finir.</p>
<!--
If a language must have inheritance to be an object-oriented language, then
Rust is not one. There is no way to define a struct that inherits the parent
struct‚Äôs fields and method implementations. However, if you‚Äôre used to having
inheritance in your programming toolbox, you can use other solutions in Rust,
depending on your reason for reaching for inheritance in the first place.
-->
<p>Si un langage doit avoir de l'h√©ritage pour √™tre un langage orient√© objet, alors
Rust n'en est pas un. Il est impossible de d√©finir une structure qui h√©rite des
champs et de l'impl√©mentation des m√©thodes de la structure m√®re. Cependant, si
vous avez l'habitude d'utiliser l'h√©ritage dans vos programmes, vous pouvez
utiliser d'autres solutions en Rust, en fonction de la raison qui vous a conduit
en premier lieu √† vous tourner vers l'h√©ritage.</p>
<!--
You choose inheritance for two main reasons. One is for reuse of code: you can
implement particular behavior for one type, and inheritance enables you to
reuse that implementation for a different type. You can share Rust code using
default trait method implementations instead, which you saw in Listing 10-14
when we added a default implementation of the `summarize` method on the
`Summary` trait. Any type implementing the `Summary` trait would have the
`summarize` method available on it without any further code. This is similar to
a parent class having an implementation of a method and an inheriting child
class also having the implementation of the method. We can also override the
default implementation of the `summarize` method when we implement the
`Summary` trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.
-->
<p>Il y a deux principales raisons de choisir l'h√©ritage. La premi√®re raison est la
r√©utilisation de code¬†: vous pouvez impl√©menter un comportement particulier pour
un type, et l'h√©ritage vous permet de r√©utiliser cette impl√©mentation sur un
autre type. √Ä la place, vous pouvez partager du code Rust en utilisant des
impl√©mentations de m√©thodes de trait par d√©faut, comme nous l'avons vu dans
l'encart 10-14 lorsque nous avons ajout√© une impl√©mentation par d√©faut de la
m√©thode <code>resumer</code> sur le trait <code>Resumable</code>. La m√©thode <code>resumer</code> serait alors
disponible sur tout type impl√©mentant le trait <code>Resumable</code> sans avoir besoin de
rajouter du code. C'est comme si vous aviez une classe m√®re avec
l'impl√©mentation d'une m√©thode et une classe fille avec une autre impl√©mentation
de cette m√©thode. On peut aussi remplacer l'impl√©mentation par d√©faut de la
m√©thode <code>resumer</code> quand on impl√©mente le trait <code>Resumable</code>, un peu comme une
classe fille qui remplace l'impl√©mentation d'une m√©thode h√©rit√©e d'une classe
m√®re.</p>
<!--
The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called *polymorphism*, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.
-->
<p>L'autre raison d'utiliser l'h√©ritage concerne le syst√®me de types¬†: pour
permettre √† un type fils d'√™tre utilis√© √† la place d'un type p√®re. Cela
s'appelle le <em>polymorphisme</em>, ce qui veut dire qu'on peut substituer plusieurs
objets entre eux √† l'ex√©cution s'ils partagent certaines caract√©ristiques.</p>
<!--
> ### Polymorphism
>
> To many people, polymorphism is synonymous with inheritance. But it‚Äôs
> actually a more general concept that refers to code that can work with data
> of multiple types. For inheritance, those types are generally subclasses.
>
> Rust instead uses generics to abstract over different possible types and
> trait bounds to impose constraints on what those types must provide. This is
> sometimes called *bounded parametric polymorphism*.
-->
<blockquote>
<h3 id="polymorphisme"><a class="header" href="#polymorphisme">Polymorphisme</a></h3>
<p>Pour beaucoup de gens, le polymorphisme est synonyme d'h√©ritage. Mais il
s'agit en fait d'un principe plus g√©n√©ral qui se rapporte au code manipulant
des donn√©es de divers types. Pour l'h√©ritage, ces types sont g√©n√©ralement des
classes filles (ou <em>sous-classes</em>).</p>
<p>√Ä la place, Rust utilise la g√©n√©ricit√© pour construire des abstractions des
diff√©rents types et traits li√©s possibles pour imposer des contraintes sur ce
que ces types doivent fournir. Cela est parfois appel√© <em>polymorphisme
param√©trique born√©</em>.</p>
</blockquote>
<!--
Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because it‚Äôs often at risk of sharing more code
than necessary. Subclasses shouldn‚Äôt always share all characteristics of their
parent class but will do so with inheritance. This can make a program‚Äôs design
less flexible. It also introduces the possibility of calling methods on
subclasses that don‚Äôt make sense or that cause errors because the methods don‚Äôt
apply to the subclass. In addition, some languages will only allow a subclass
to inherit from one class, further restricting the flexibility of a program‚Äôs
design.
-->
<p>L'h√©ritage est r√©cemment tomb√© en disgr√¢ce en tant que solution de conception
dans plusieurs langages de programmation parce qu'il conduit souvent √† partager
plus de code que n√©cessaire. Les classes m√®res ne devraient pas toujours
partager toutes leurs caract√©ristiques avec leurs classes filles, mais elles y
sont oblig√©es avec l'h√©ritage. Cela peut rendre la conception d'un programme
moins flexible. De plus, cela introduit la possibilit√© d'appeler des m√©thodes
sur des classes filles qui n'ont aucun sens ou qui entra√Ænent des erreurs parce
que les m√©thodes ne s'appliquent pas √† la classe fille. De plus, certains
langages ne permettront √† une classe fille d'h√©riter que d'une seule classe, ce
qui restreint d'autant plus la flexibilit√© de la conception d'un programme.</p>
<!--
For these reasons, Rust takes a different approach, using trait objects instead
of inheritance. Let‚Äôs look at how trait objects enable polymorphism in Rust.
-->
<p>Voil√† pourquoi Rust suit une autre approche, en utilisant des objets traits
plut√¥t que l'h√©ritage. Jetons un ≈ìil √† la fa√ßon dont les objets traits
permettent le polymorphisme en Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using Trait Objects That Allow for Values of Different Types
-->
<h2 id="utiliser-les-objets-traits-qui-permettent-des-valeurs-de-types-diff√©rents"><a class="header" href="#utiliser-les-objets-traits-qui-permettent-des-valeurs-de-types-diff√©rents">Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></h2>
<!--
In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-10 where
we defined a `SpreadsheetCell` enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.
-->
<p>Au chapitre 8, nous avions mentionn√© qu'une limite des vecteurs est qu'ils ne
peuvent stocker des √©l√©ments que d'un seul type. Nous avions contourn√© le
probl√®me dans l'encart 8-10 en d√©finissant une √©num√©ration <code>Cellule</code> avec des
variantes pouvant contenir des entiers, des flottants et du texte. Ainsi, on
pouvait stocker diff√©rents types de donn√©es dans chaque cellule et quand m√™me
avoir un vecteur qui repr√©sentait une rang√©e de cellules. C'est une tr√®s bonne
solution quand nos √©l√©ments interchangeables ne poss√®dent qu'un ensemble bien
d√©termin√© de types que nous connaissons lors de la compilation de notre code.</p>
<!--
However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we‚Äôll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a `draw` method on each one to draw it to the
screen‚Äîa common technique for GUI tools. We‚Äôll create a library crate called
`gui` that contains the structure of a GUI library. This crate might include
some types for people to use, such as `Button` or `TextField`. In addition,
`gui` users will want to create their own types that can be drawn: for
instance, one programmer might add an `Image` and another might add a
`SelectBox`.
-->
<p>Cependant, nous avons parfois envie que l'utilisateur de notre biblioth√®que
puisse √©tendre l'ensemble des types valides dans une situation donn√©e. Pour
montrer comment nous pourrions y parvenir, cr√©ons un exemple d'outil d'interface
graphique (GUI) qui it√®re sur une liste d'√©l√©ments et appelle une m√©thode
<code>afficher</code> sur chacun d'entre eux pour l'afficher √† l'√©cran ‚Äî une technique
courante pour les outils d'interface graphique. Cr√©ons une <em>crate</em> de
biblioth√®que appel√©e <code>gui</code> qui contient la structure d'une biblioth√®que
d'interface graphique. Cette <em>crate</em> pourrait inclure des types que les usagers
pourront utiliser, tels que <code>Bouton</code> ou <code>ChampDeTexte</code>. De plus, les
utilisateurs de <code>gui</code> voudront cr√©er leurs propres types qui pourront √™tre
affich√©s¬†: par exemple, un d√©veloppeur pourrait ajouter une <code>Image</code> et un autre
pourrait ajouter une <code>ListeDeroulante</code>.</p>
<!--
We won‚Äôt implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we can‚Äôt
know and define all the types other programmers might want to create. But we do
know that `gui` needs to keep track of many values of different types, and it
needs to call a `draw` method on each of these differently typed values. It
doesn‚Äôt need to know exactly what will happen when we call the `draw` method,
just that the value will have that method available for us to call.
-->
<p>Nous n'impl√©menterons pas une v√©ritable biblioth√®que d'interface graphique pour
cet exemple, mais nous verrons comment les morceaux pourraient s'assembler. Au
moment d'√©crire la biblioth√®que, nous ne pouvons pas savoir ni d√©finir tous les
types que les autres d√©veloppeurs auraient envie de cr√©er. Mais nous savons que
<code>gui</code> doit g√©rer plusieurs valeurs de types diff√©rents et qu'elle
doit appeler la m√©thode <code>afficher</code> sur chacune de ces valeurs de types
diff√©rents. Elle n'a pas besoin de savoir exactement ce qui arrivera quand on
appellera la m√©thode <code>afficher</code>, mais seulement de savoir que la valeur
disposera de cette m√©thode que nous pourrons appeler.</p>
<!--
To do this in a language with inheritance, we might define a class named
`Component` that has a method named `draw` on it. The other classes, such as
`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus
inherit the `draw` method. They could each override the `draw` method to define
their custom behavior, but the framework could treat all of the types as if
they were `Component` instances and call `draw` on them. But because Rust
doesn‚Äôt have inheritance, we need another way to structure the `gui` library to
allow users to extend it with new types.
-->
<p>Pour faire ceci dans un langage avec de l'h√©ritage, nous pourrions d√©finir une
classe <code>Composant</code> qui a une m√©thode <code>afficher</code>. Les autres
classes, telles que <code>Bouton</code>, <code>Image</code> et <code>ListeDeroulante</code> h√©riteraient de
<code>Composant</code> et h√©riteraient ainsi de la m√©thode <code>afficher</code>. Elles pourraient
toutes red√©finir la m√©thode <code>afficher</code> avec leur comportement personnalis√©,
mais l'environnement de d√©veloppement pourrait consid√©rer tous les types comme
des instances de <code>Composant</code> et appeler <code>afficher</code> sur chacun d'entre eux. Mais
puisque Rust n'a pas d'h√©ritage, il nous faut un autre moyen de structurer la
biblioth√®que <code>gui</code> pour permettre aux utilisateurs de l'enrichir avec de
nouveaux types.</p>
<!--
### Defining a Trait for Common Behavior
-->
<h3 id="d√©finir-un-trait-pour-du-comportement-commun"><a class="header" href="#d√©finir-un-trait-pour-du-comportement-commun">D√©finir un trait pour du comportement commun</a></h3>
<!--
To implement the behavior we want `gui` to have, we‚Äôll define a trait named
`Draw` that will have one method named `draw`. Then we can define a vector that
takes a *trait object*. A trait object points to both an instance of a type
implementing our specified trait as well as a table used to look up trait
methods on that type at runtime. We create a trait object by specifying some
sort of pointer, such as a `&` reference or a `Box<T>` smart pointer, then the
`dyn` keyword, and then specifying the relevant trait. (We‚Äôll talk about the
reason trait objects must use a pointer in Chapter 19 in the section
[‚ÄúDynamically Sized Types and the `Sized` Trait.‚Äù][dynamically-sized]<!--
ignore -- >) We can use trait objects in place of a generic or concrete type.
Wherever we use a trait object, Rust‚Äôs type system will ensure at compile time
that any value used in that context will implement the trait object‚Äôs trait.
Consequently, we don‚Äôt need to know all the possible types at compile time.
-->
<p>Pour impl√©menter le comportement que nous voulons donner √† <code>gui</code>, nous
d√©finirons un trait nomm√© <code>Affichable</code> qui aura une m√©thode nomm√©e <code>afficher</code>.
Puis nous d√©finirons un vecteur qui prend un <em>objet trait</em>. Un objet trait
pointe √† la fois vers une instance d'un type impl√©mentant le trait indiqu√© ainsi
que vers une table utilis√©e pour chercher les m√©thodes de trait de ce type √†
l'ex√©cution. Nous cr√©ons un objet trait en indiquant une sorte de pointeur, tel
qu'une r√©f√©rence <code>&amp;</code> ou un pointeur intelligent <code>Box&lt;T&gt;</code>, puis le mot-cl√© <code>dyn</code>
et enfin le trait en question. (Nous expliquerons pourquoi les objets traits
doivent utiliser un pointeur dans <a href="ch19-04-advanced-types.html">une section</a><!-- ignore -->
du chapitre 19.) Nous pouvons
utiliser des objets traits √† la place d'un type g√©n√©rique ou concret. Partout o√π
nous utilisons un objet trait, le syst√®me de types de Rust s'assurera √† la
compilation que n'importe quelle valeur utilis√©e dans ce contexte impl√©mentera
le trait de l'objet trait. Ainsi, il n'est pas n√©cessaire de conna√Ætre tous les
types possibles √† la compilation.</p>
<!--
We‚Äôve mentioned that in Rust, we refrain from calling structs and enums
‚Äúobjects‚Äù to distinguish them from other languages‚Äô objects. In a struct or
enum, the data in the struct fields and the behavior in `impl` blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects *are* more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we can‚Äôt add data to
a trait object. Trait objects aren‚Äôt as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.
-->
<p>Nous avons mentionn√© qu'en Rust, nous nous abstenons de qualifier les structures
et √©num√©rations d'<em>objets</em> pour les distinguer des objets des autres langages.
Dans une structure ou une √©num√©ration, les donn√©es dans les champs de la
structure et le comportement dans les blocs <code>impl</code> sont s√©par√©s, alors que dans
d'autres langages, les donn√©es et le comportement se combinent en un concept
souvent qualifi√© d'objet. En revanche, les objets traits ressemblent davantage
aux objets des autres langages dans le sens o√π ils combinent des donn√©es et du
comportement. Mais les objets traits diff√®rent des objets traditionnels dans le
sens o√π on ne peut pas ajouter des donn√©es √† un objet trait. Les objets traits
ne sont g√©n√©ralement pas aussi utiles que les objets des autres langages¬†: leur
but sp√©cifique est de permettre de construire des abstractions de comportements
communs.</p>
<!--
Listing 17-3 shows how to define a trait named `Draw` with one method named
`draw`:
-->
<p>L'encart 17-3 illustre la fa√ßon de d√©finir un trait nomm√© <code>Affichable</code> avec une
m√©thode nomm√©e <code>afficher</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Draw {
    fn draw(&self);
}
```
-->
<pre><code class="language-rust noplayground">pub trait Affichable {
    fn afficher(&amp;self);
}
</code></pre>
<!--
<span class="caption">Listing 17-3: Definition of the `Draw` trait</span>
-->
<p><span class="caption">Encart 17-3¬†: d√©finition du trait <code>Affichable</code></span></p>
<!--
This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
`Screen` that holds a vector named `components`. This vector is of type
`Box<dyn Draw>`, which is a trait object; it‚Äôs a stand-in for any type inside
a `Box` that implements the `Draw` trait.
-->
<p>Cette syntaxe devrait vous rappeler nos discussions sur comment d√©finir des
traits au chapitre 10. Puis vient une nouvelle syntaxe¬†: l'encart 17-4 d√©finit
une structure <code>Ecran</code> qui contient un vecteur <code>composants</code>. Ce
vecteur est du type <code>Box&lt;dyn Affichable&gt;</code>, qui est un objet trait¬†; c'est un
bouche-trou pour n'importe quel type au sein d'un <code>Box</code> qui impl√©mente le trait
<code>Affichable</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Draw {
#     fn draw(&self);
# }
# 
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Ecran {
    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
}
</code></pre>
<!--
<span class="caption">Listing 17-4: Definition of the `Screen` struct with a
`components` field holding a vector of trait objects that implement the `Draw`
trait</span>
-->
<p><span class="caption">Encart 17-4¬†: d√©finition de la structure <code>Ecran</code> avec un
champ <code>composants</code> contenant un vecteur d'objets traits qui impl√©mentent le
trait <code>Affichable</code></span></p>
<!--
On the `Screen` struct, we‚Äôll define a method named `run` that will call the
`draw` method on each of its `components`, as shown in Listing 17-5:
-->
<p>Sur la structure <code>Ecran</code>, nous allons d√©finir une m√©thode nomm√©e <code>executer</code> qui
appellera la m√©thode <code>afficher</code> sur chacun de ses <code>composants</code>, comme l'illustre
l'encart 17-5 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Draw {
#     fn draw(&self);
# }
# 
# pub struct Screen {
#     pub components: Vec<Box<dyn Draw>>,
# }
# 
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Ecran {
</span><span class="boring">    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Ecran {
    pub fn executer(&amp;self) {
        for composant in self.composants.iter() {
            composant.afficher();
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-5: A `run` method on `Screen` that calls the
`draw` method on each component</span>
-->
<p><span class="caption">Encart 17-5¬†: une m√©thode <code>executer</code> sur <code>Ecran</code> qui
appelle la m√©thode <code>afficher</code> sur chaque composant</span></p>
<!--
This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the `Screen` struct using a generic type and a trait bound
as in Listing 17-6:
-->
<p>Cela ne fonctionne pas de la m√™me mani√®re que d'utiliser une structure avec un
param√®tre de type g√©n√©rique avec des traits li√©s. Un param√®tre de type g√©n√©rique
ne peut √™tre remplac√© que par un seul type concret √† la fois, tandis que les
objets traits permettent √† plusieurs types concrets de remplacer l'objet trait √†
l'ex√©cution. Par exemple, nous aurions pu d√©finir la structure <code>Ecran</code> en
utilisant un type g√©n√©rique et un trait li√© comme dans l'encart 17-6¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Draw {
#     fn draw(&self);
# }
# 
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Ecran&lt;T: Affichable&gt; {
    pub composants: Vec&lt;T&gt;,
}

impl&lt;T&gt; Ecran&lt;T&gt;
where
    T: Affichable,
{
    pub fn executer(&amp;self) {
        for composant in self.composants.iter() {
            composant.afficher();
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-6: An alternate implementation of the `Screen`
struct and its `run` method using generics and trait bounds</span>
-->
<p><span class="caption">Encart 17-6¬†: une impl√©mentation diff√©rente de la
structure <code>Ecran</code> et de sa m√©thode <code>executer</code> en utilisant la g√©n√©ricit√© et les
traits li√©s</span></p>
<!--
This restricts us to a `Screen` instance that has a list of components all of
type `Button` or all of type `TextField`. If you‚Äôll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.
-->
<p>Cela nous restreint √† une instance de <code>Ecran</code> qui a une liste de composants qui
sont soit tous de type <code>Bouton</code>, soit tous de type <code>ChampDeTexte</code>. Si vous ne
voulez que des collections homog√®nes, il est pr√©f√©rable d'utiliser la g√©n√©ricit√©
et les traits li√©s parce que les d√©finitions seront monomorphis√©es √† la
compilation pour utiliser les types concrets.</p>
<!--
On the other hand, with the method using trait objects, one `Screen` instance
can hold a `Vec<T>` that contains a `Box<Button>` as well as a
`Box<TextField>`. Let‚Äôs look at how this works, and then we‚Äôll talk about the
runtime performance implications.
-->
<p>D'un autre c√¥t√©, en utilisant des objets traits, une instance de <code>Ecran</code> peut
contenir un <code>Vec&lt;T&gt;</code> qui contient √† la fois un <code>Box&lt;Bouton&gt;</code> et un
<code>Box&lt;ChampDeTexte&gt;</code>. Regardons comment cela fonctionne, puis nous parlerons
ensuite du co√ªt en performances √† l'ex√©cution.</p>
<!--
### Implementing the Trait
-->
<h3 id="impl√©menter-le-trait"><a class="header" href="#impl√©menter-le-trait">Impl√©menter le trait</a></h3>
<!--
Now we‚Äôll add some types that implement the `Draw` trait. We‚Äôll provide the
`Button` type. Again, actually implementing a GUI library is beyond the scope
of this book, so the `draw` method won‚Äôt have any useful implementation in its
body. To imagine what the implementation might look like, a `Button` struct
might have fields for `width`, `height`, and `label`, as shown in Listing 17-7:
-->
<p>Ajoutons maintenant quelques types qui impl√©mentent le trait <code>Affichable</code>. Nous
fournirons le type <code>Bouton</code>. Encore une fois, impl√©menter une vraie biblioth√®que
d'interface graphique d√©passe la port√©e de ce livre, alors la m√©thode <code>afficher</code>
n'aura pas d'impl√©mentation utile dans son corps. Pour imaginer √† quoi pourrait
ressembler l'impl√©mentation, une structure <code>Bouton</code> pourrait avoir des champs
<code>largeur</code>, <code>hauteur</code> et <code>libelle</code>, comme l'illustre l'encart 17-7¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Draw {
#     fn draw(&self);
# }
# 
# pub struct Screen {
#     pub components: Vec<Box<dyn Draw>>,
# }
# 
# impl Screen {
#     pub fn run(&self) {
#         for component in self.components.iter() {
#             component.draw();
#         }
#     }
# }
# 
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a button
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Ecran {
</span><span class="boring">    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Ecran {
</span><span class="boring">    pub fn executer(&amp;self) {
</span><span class="boring">        for composant in self.composants.iter() {
</span><span class="boring">            composant.afficher();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Bouton {
    pub largeur: u32,
    pub hauteur: u32,
    pub libelle: String,
}

impl Affichable for Bouton {
    fn afficher(&amp;self) {
        // code servant √† afficher vraiment un bouton
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-7: A `Button` struct that implements the
`Draw` trait</span>
-->
<p><span class="caption">Encart 17-7¬†: une structure <code>Bouton</code> qui impl√©mente le
trait <code>Affichable</code></span></p>
<!--
The `width`, `height`, and `label` fields on `Button` will differ from the
fields on other components, such as a `TextField` type, that might have those
fields plus a `placeholder` field instead. Each of the types we want to draw on
the screen will implement the `Draw` trait but will use different code in the
`draw` method to define how to draw that particular type, as `Button` has here
(without the actual GUI code, which is beyond the scope of this chapter). The
`Button` type, for instance, might have an additional `impl` block containing
methods related to what happens when a user clicks the button. These kinds of
methods won‚Äôt apply to types like `TextField`.
-->
<p>Les champs <code>largeur</code>, <code>hauteur</code> et <code>libelle</code> de <code>Bouton</code> pourront ne pas √™tre
les m√™mes que ceux d'autres composants, comme un type <code>ChampDeTexte</code>, qui
pourrait avoir ces champs plus un champ <code>texte_de_substitution</code> √† la place.
Chacun des types que nous voudrons afficher √† l'√©cran impl√©mentera le trait
<code>Affichable</code> mais utilisera du code diff√©rent dans la m√©thode <code>afficher</code> pour
d√©finir comment afficher ce type en particulier, comme c'est le cas de <code>Bouton</code>
ici (sans le vrai code d'impl√©mentation, qui d√©passe le cadre de ce chapitre).
Le type <code>Bouton</code>, par exemple, pourrait avoir un bloc <code>impl</code> suppl√©mentaire
contenant des m√©thodes en lien √† ce qui arrive quand un utilisateur clique sur
le bouton. Ce genre de m√©thodes ne s'applique pas √† des types comme
<code>ChampDeTexte</code>.</p>
<!--
If someone using our library decides to implement a `SelectBox` struct that has
`width`, `height`, and `options` fields, they implement the `Draw` trait on the
`SelectBox` type as well, as shown in Listing 17-8:
-->
<p>Si un utilisateur de notre biblioth√®que d√©cide d'impl√©menter une structure
<code>ListeDeroulante</code> avec des champs <code>largeur</code>, <code>hauteur</code> et <code>options</code>, il
impl√©mentera √©galement le trait <code>Affichable</code> sur le type <code>ListeDeroulante</code>,
comme dans l'encart 17-8¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
    }
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore">use gui::Affichable;

struct ListeDeroulante {
    largeur: u32,
    hauteur: u32,
    options: Vec&lt;String&gt;,
}

impl Affichable for ListeDeroulante {
    fn afficher(&amp;self) {
        // code servant √† afficher vraiment une liste d√©roulante
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 17-8: Another crate using `gui` and implementing
the `Draw` trait on a `SelectBox` struct</span>
-->
<p><span class="caption">Encart 17-8¬†: une autre <em>crate</em> utilisant <code>gui</code> et
impl√©mentant le trait <code>Affichable</code> sur une structure <code>ListeDeroulante</code></span></p>
<!--
Our library‚Äôs user can now write their `main` function to create a `Screen`
instance. To the `Screen` instance, they can add a `SelectBox` and a `Button`
by putting each in a `Box<T>` to become a trait object. They can then call the
`run` method on the `Screen` instance, which will call `draw` on each of the
components. Listing 17-9 shows this implementation:
-->
<p>L'utilisateur de notre biblioth√®que peut maintenant √©crire sa fonction <code>main</code>
pour cr√©er une instance de <code>Ecran</code>. Il peut ajouter √† l'instance de <code>Ecran</code> une
<code>ListeDeroulante</code> ou un <code>Bouton</code> en les mettant chacun dans un <code>Box&lt;T&gt;</code> pour en
faire des objets traits. Il peut ensuite appeler la m√©thode <code>executer</code> sur
l'instance de <code>Ecran</code>, qui appellera <code>afficher</code> sur chacun de ses composants.
L'encart 17-9 montre cette impl√©mentation¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use gui::Draw;
# 
# struct SelectBox {
#     width: u32,
#     height: u32,
#     options: Vec<String>,
# }
# 
# impl Draw for SelectBox {
#     fn draw(&self) {
#         // code to actually draw a select box
#     }
# }
# 
use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use gui::Affichable;
</span><span class="boring">
</span><span class="boring">struct ListeDeroulante {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Affichable for ListeDeroulante {
</span><span class="boring">    fn afficher(&amp;self) {
</span><span class="boring">        // code servant vraiment √† afficher une liste d√©roulante
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Bouton, Ecran};

fn main() {
    let ecran = Ecran {
        composants: vec![
            Box::new(ListeDeroulante {
                largeur: 75,
                hauteur: 10,
                options: vec![
                    String::from(&quot;Oui&quot;),
                    String::from(&quot;Peut-√™tre&quot;),
                    String::from(&quot;Non&quot;),
                ],
            }),
            Box::new(Bouton {
                largeur: 50,
                hauteur: 10,
                libelle: String::from(&quot;OK&quot;),
            }),
        ],
    };

    ecran.executer();
}
</code></pre>
<!--
<span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span>
-->
<p><span class="caption">Encart 17-9¬†: utilisation d'objets traits pour stocker des
valeurs de types diff√©rents qui impl√©mentent le m√™me trait</span></p>
<!--
When we wrote the library, we didn‚Äôt know that someone might add the
`SelectBox` type, but our `Screen` implementation was able to operate on the
new type and draw it because `SelectBox` implements the `Draw` trait, which
means it implements the `draw` method.
-->
<p>Quand nous avons √©crit la biblioth√®que, nous ne savions pas que quelqu'un
pourrait y ajouter le type <code>ListeDeroulante</code>, mais notre impl√©mentation de
<code>Ecran</code> a pu op√©rer sur le nouveau type et l'afficher parce que
<code>ListeDeroulante</code> impl√©mente le trait <code>Affichable</code>, ce qui veut dire qu'elle
impl√©mente la m√©thode <code>afficher</code>.</p>
<!--
This concept‚Äîof being concerned only with the messages a value responds to
rather than the value‚Äôs concrete type‚Äîis similar to the concept of *duck
typing* in dynamically typed languages: if it walks like a duck and quacks
like a duck, then it must be a duck! In the implementation of `run` on `Screen`
in Listing 17-5, `run` doesn‚Äôt need to know what the concrete type of each
component is. It doesn‚Äôt check whether a component is an instance of a `Button`
or a `SelectBox`, it just calls the `draw` method on the component. By
specifying `Box<dyn Draw>` as the type of the values in the `components`
vector, we‚Äôve defined `Screen` to need values that we can call the `draw`
method on.
-->
<p>Ce concept ‚Äî se pr√©occuper uniquement des messages auxquels une valeur r√©pond
plut√¥t que du type concret de la valeur ‚Äî est similaire au concept du <em>duck
typing</em> (‚Äútypage canard‚Äù) dans les langages typ√©s dynamiquement¬†: si √ßa marche
comme un canard et que √ßa fait coin-coin comme un canard, alors √ßa doit √™tre un
canard¬†! Dans l'impl√©mentation de <code>executer</code> sur <code>Ecran</code> dans l'encart 17-5,
<code>executer</code> n'a pas besoin de conna√Ætre le type concret de chaque composant. Elle
ne v√©rifie pas si un composant est une instance de <code>Bouton</code> ou de
<code>ListeDeroulante</code>, elle ne fait qu'appeler la m√©thode <code>afficher</code> sur le
composant. En sp√©cifiant <code>Box&lt;dyn Affichable&gt;</code> comme type des valeurs dans le
vecteur <code>composants</code>, nous avons d√©fini que <code>Ecran</code> n'avait besoin que de valeurs
sur lesquelles on peut appeler la m√©thode <code>afficher</code>.</p>
<!--
The advantage of using trait objects and Rust‚Äôs type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn‚Äôt implement a method but we call it anyway. Rust won‚Äôt compile
our code if the values don‚Äôt implement the traits that the trait objects need.
-->
<p>L'avantage d'utiliser les objets traits et le syst√®me de types de Rust pour
√©crire du code semblable √† celui utilisant le <em>duck typing</em> est que nous n'avons
jamais besoin de v√©rifier si une valeur impl√©mente une m√©thode en particulier √†
l'ex√©cution, ni de nous inqui√©ter d'avoir des erreurs si une valeur n'impl√©mente
pas une m√©thode mais qu'on l'appelle quand m√™me. Rust ne compilera pas notre
code si les valeurs n'impl√©mentent pas les traits requis par les objets traits.</p>
<!--
For example, Listing 17-10 shows what happens if we try to create a `Screen`
with a `String` as a component:
-->
<p>Par exemple, l'encart 17-10 montre ce qui arrive si on essaie de cr√©er un
<code>Ecran</code> avec une <code>String</code> comme composant¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use gui::Ecran;

fn main() {
    let ecran = Ecran {
        composants: vec![Box::new(String::from(&quot;Salutations&quot;))],
    };

    ecran.run();
}
</code></pre>
<!--
<span class="caption">Listing 17-10: Attempting to use a type that doesn‚Äôt
implement the trait object‚Äôs trait</span>
-->
<p><span class="caption">Encart 17-10¬†: tentative d'utiliser un type qui
n'impl√©mente pas le trait de l'objet trait</span></p>
<!--
We‚Äôll get this error because `String` doesn‚Äôt implement the `Draw` trait:
-->
<p>Nous aurons cette erreur parce que <code>String</code> n'impl√©mente pas le trait
<code>Affichable</code>¬†:</p>
<!--
```console
$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 -- > src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = note: required for the cast to the object type `dyn Draw`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Affichable` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         composants: vec![Box::new(String::from(&quot;Salutations&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Affichable` is not implemented for `String`
  |
  = note: required for the cast to the object type `dyn Affichable`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
</code></pre>
<!--
This error lets us know that either we‚Äôre passing something to `Screen` we
didn‚Äôt mean to pass and we should pass a different type or we should implement
`Draw` on `String` so that `Screen` is able to call `draw` on it.
-->
<p>L'erreur nous fait savoir que soit nous passons quelque chose √† <code>Ecran</code> que nous
ne voulions pas lui passer et que nous devrions lui passer un type diff√©rent, soit
nous devrions impl√©menter <code>Affichable</code> sur <code>String</code> de sorte que <code>Ecran</code> puisse
appeler <code>afficher</code> dessus.</p>
<!--
### Trait Objects Perform Dynamic Dispatch
-->
<h3 id="les-objets-traits-effectuent-de-la-r√©partition-dynamique"><a class="header" href="#les-objets-traits-effectuent-de-la-r√©partition-dynamique">Les objets traits effectuent de la r√©partition dynamique</a></h3>
<!--
Recall in the [‚ÄúPerformance of Code Using
Generics‚Äù][performance-of-code-using-generics]<!-- ignore -- > section in
Chapter 10 our discussion on the monomorphization process performed by the
compiler when we use trait bounds on generics: the compiler generates
nongeneric implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing *static dispatch*, which is when the compiler knows
what method you‚Äôre calling at compile time. This is opposed to *dynamic
dispatch*, which is when the compiler can‚Äôt tell at compile time which method
you‚Äôre calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call.
-->
<p>Rappelez-vous de notre discussion dans <a href="ch10-01-syntax.html">une
section</a><!-- ignore --> du chapitre 10 √†
propos du processus de monomorphisation effectu√© par le compilateur quand nous
utilisons des traits li√©s sur des g√©n√©riques¬†: le compilateur g√©n√®re des
impl√©mentations non g√©n√©riques de fonctions et de m√©thodes pour chaque type
concret que nous utilisons √† la place d'un param√®tre de type g√©n√©rique. Le code
r√©sultant de la monomorphisation effectue du <em>dispatch statique</em> (<em>r√©partition
statique</em>), qui peut √™tre mis en place quand le compilateur sait, au moment de
la compilation, quelle m√©thode vous appelez. Cela s'oppose au <em>dispatch
dynamique</em> (<em>r√©partition dynamique</em>), qui est mis en place quand le compilateur
ne peut pas d√©terminer √† la compilation quelle m√©thode vous appelez. Dans le
cas de la r√©partition dynamique, le compilateur produit du code qui devra
d√©terminer √† l'ex√©cution quelle m√©thode appeler.</p>
<!--
When we use trait objects, Rust must use dynamic dispatch. The compiler doesn‚Äôt
know all the types that might be used with the code that is using trait
objects, so it doesn‚Äôt know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesn‚Äôt occur with static dispatch. Dynamic dispatch also prevents the compiler
from choosing to inline a method‚Äôs code, which in turn prevents some
optimizations. However, we did get extra flexibility in the code that we wrote
in Listing 17-5 and were able to support in Listing 17-9, so it‚Äôs a trade-off
to consider.
-->
<p>Quand nous utilisons des objets traits, Rust doit utiliser de la r√©partition
dynamique. Le compilateur ne conna√Æt pas tous les types qui pourraient √™tre
utilis√©s avec le code qui utilise des objets traits, donc il ne sait pas quelle
m√©thode impl√©ment√©e sur quel type il doit appeler. √Ä la place, lors de
l'ex√©cution, Rust utilise les pointeurs √† l'int√©rieur de l'objet trait pour
savoir quelle m√©thode appeler. Il y a un co√ªt √† l'ex√©cution lors de la
recherche de cette m√©thode qui n'a pas lieu avec la r√©partition statique. La
r√©partition dynamique emp√™che en outre le compilateur de choisir de remplacer
un appel de m√©thode par le code de cette m√©thode, ce qui emp√™che par ricochet
certaines optimisations. Cependant, cela a permis de rendre plus flexible le
code que nous avons √©crit dans l'encart 17-5 et que nous avons pu g√©rer
dans l'encart 17-9, donc c'est un compromis √† envisager.</p>
<!--
[performance-of-code-using-generics]:
ch10-01-syntax.html#performance-of-code-using-generics
[dynamically-sized]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Implementing an Object-Oriented Design Pattern
-->
<h2 id="impl√©menter-un-patron-de-conception-orient√©-objet"><a class="header" href="#impl√©menter-un-patron-de-conception-orient√©-objet">Impl√©menter un patron de conception orient√©-objet</a></h2>
<!--
The *state pattern* is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of *state objects*, and the value‚Äôs behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.
-->
<p>Le <em>patron √©tat</em> est un patron de conception orient√© objet. Le point essentiel
de ce patron est qu'une valeur poss√®de un √©tat interne qui est repr√©sent√© par
un ensemble <em>d'objets √©tat</em>, et le comportement de la valeur change en fonction
de son √©tat interne. Les objets √©tat partagent des fonctionnalit√©s¬†: en Rust,
bien s√ªr, nous utilisons des structures et des traits plut√¥t que des objets et
de l'h√©ritage. Chaque objet √©tat est responsable de son propre comportement et
d√©cide lorsqu'il doit changer pour un autre √©tat. La valeur contenue dans un
objet √©tat ne sait rien sur les diff√©rents comportements des √©tats et ne sait
pas quand il va changer d'√©tat.</p>
<!--
Using the state pattern means when the business requirements of the program
change, we won‚Äôt need to change the code of the value holding the state or the
code that uses the value. We‚Äôll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Let‚Äôs look
at an example of the state design pattern and how to use it in Rust.
-->
<p>L'utilisation du patron √©tat signifie que lorsque les exigences m√©tier du
programme ont chang√©, nous n'avons pas besoin de changer le code √† l'int√©rieur
de l'objet √©tat ou le code qui utilise l'objet. Nous avons juste besoin de
modifier le code dans un des objets √©tat pour changer son fonctionnement ou pour
ajouter d'autres objets √©tat. Voyons un exemple du patron √©tat et comment
l'utiliser en Rust.</p>
<!--
We‚Äôll implement a blog post workflow in an incremental way. The blog‚Äôs final
functionality will look like this:
-->
<p>Nous allons impl√©menter un processus de publication de billets de blogs de
mani√®re incr√©mentale. Les fonctionnalit√©s finales du blog seront les suivantes¬†:</p>
<!--
1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts can‚Äôt
   accidentally be published.
-->
<ol>
<li>Un billet de blog commence par un brouillon vide.</li>
<li>Lorsque le brouillon est termin√©, une relecture du billet est demand√©e.</li>
<li>Lorsqu'un billet est approuv√©, il est publi√©.</li>
<li>Seuls les billets de blog publi√©s retournent du contenu √† afficher si bien
que les billets non approuv√©s ne peuvent pas √™tre publi√©s accidentellement.</li>
</ol>
<!--
Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we‚Äôve requested a review, the post
should remain an unpublished draft.
-->
<p>Tous les autres changements effectu√©s sur un billet n'auront pas d'effet. Par
exemple, si nous essayons d'approuver un brouillon de billet de blog avant
d'avoir demand√© une relecture, le billet devrait rester √† l'√©tat de brouillon
non publi√©.</p>
<!--
Listing 17-11 shows this workflow in code form: this is an example usage of the
API we‚Äôll implement in a library crate named `blog`. This won‚Äôt compile yet
because we haven‚Äôt implemented the `blog` crate yet.
-->
<p>L'encart 17-11 pr√©sente ce processus de publication sous forme de code¬†: c'est
un exemple d'utilisation de l'API que nous allons impl√©menter dans une crate de
biblioth√®que <code>blog</code>. Elle ne va pas encore se compiler car nous n'avons pas
encore impl√©ment√© la crate <code>blog</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mang√© une salade au d√©jeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.demander_relecture();
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.approuver();
    assert_eq!(&quot;J'ai mang√© une salade au d√©jeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our `blog` crate to have</span>
-->
<p><span class="caption">Encart 17-11¬†: du code qui montre le comportement attendu
de notre crate <code>blog</code></span></p>
<!--
We want to allow the user to create a new draft blog post with `Post::new`. We
want to allow text to be added to the blog post. If we try to get the post‚Äôs
content immediately, before approval, we shouldn't get any text because the
post is still a draft. We‚Äôve added `assert_eq!` in the code for demonstration
purposes. An excellent unit test for this would be to assert that a draft blog
post returns an empty string from the `content` method, but we‚Äôre not going to
write tests for this example.
-->
<p>Nous voulons permettre √† l'utilisateur de cr√©er un nouveau brouillon de billet
de blog avec <code>Billet::new</code>. Nous voulons qu'il puisse ajouter du texte au
billet de blog. Si nous essayons d'obtenir imm√©diatement le contenu du billet,
avant qu'il ne soit relu, nous n'obtiendrons aucun texte car le billet est
toujours un brouillon. Nous avons ajout√© des <code>assert_eq!</code> dans le code pour les
besoins de la d√©monstration. Un excellent test unitaire pour cela serait de
v√©rifier qu'un brouillon de billet de blog retourne bien une cha√Æne de
caract√®res vide √† partir de la m√©thode <code>contenu</code>, mais nous n'allons pas √©crire
de tests pour cet exemple.</p>
<!--
Next, we want to enable a request for a review of the post, and we want
`content` to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when `content` is called.
-->
<p>Ensuite, nous voulons permettre de demander une relecture du billet, et nous
souhaitons que <code>contenu</code> retourne toujours une cha√Æne de caract√®res vide pendant
que nous attendons la relecture. Lorsque la relecture du billet est approuv√©e,
il doit √™tre publi√©, ce qui signifie que le texte du billet doit √™tre retourn√©
lors de l'appel √† <code>contenu</code>.</p>
<!--
Notice that the only type we‚Äôre interacting with from the crate is the `Post`
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in‚Äîdraft, waiting for review, or published. Changing from one state to another
will be managed internally within the `Post` type. The states change in
response to the methods called by our library‚Äôs users on the `Post` instance,
but they don‚Äôt have to manage the state changes directly. Also, users can‚Äôt
make a mistake with the states, like publishing a post before it‚Äôs reviewed.
-->
<p>Remarquez que le seul type avec lequel nous interagissons avec la crate est le
type <code>Billet</code>. Ce type va utiliser le patron √©tat et va h√©berger une valeur qui
sera un des trois objets √©tat repr√©sentant les diff√©rents √©tats par lesquels
passe un billet¬†: brouillon, en attente de relecture ou publi√©. Le changement
d'un √©tat √† un autre sera g√©r√© en interne du type <code>Billet</code>. Les √©tats vont
changer en r√©ponse √† l'appel des m√©thodes de l'instance de <code>Billet</code> par les
utilisateurs de notre biblioth√®que qui n'auront donc pas √† les g√©rer
directement. Ainsi les utilisateurs ne peuvent pas faire d'erreur avec les
√©tats, comme celle de publier un billet avant qu'il ne soit relu par exemple.</p>
<!--
### Defining `Post` and Creating a New Instance in the Draft State
-->
<h3 id="d√©finir-billet-et-cr√©er-une-nouvelle-instance-√†-l√©tat-de-brouillon"><a class="header" href="#d√©finir-billet-et-cr√©er-une-nouvelle-instance-√†-l√©tat-de-brouillon">D√©finir <code>Billet</code> et cr√©er une nouvelle instance √† l'√©tat de brouillon</a></h3>
<!--
Let‚Äôs get started on the implementation of the library! We know we need a
public `Post` struct that holds some content, so we‚Äôll start with the
definition of the struct and an associated public `new` function to create an
instance of `Post`, as shown in Listing 17-12. We‚Äôll also make a private
`State` trait. Then `Post` will hold a trait object of `Box<dyn State>`
inside an `Option<T>` in a private field named `state`. You‚Äôll see why the
`Option<T>` is necessary in a bit.
-->
<p>Commen√ßons l'impl√©mentation de la biblioth√®que¬†! Nous savons que nous aurons
besoin d'une structure publique <code>Billet</code> qui h√©berge du contenu, donc nous
allons commencer par d√©finir cette structure ainsi qu'une fonction publique
<code>new</code> qui lui est associ√©e pour cr√©er une instance de <code>Billet</code>, comme dans
l'encart 17-12. Nous allons aussi cr√©er un trait priv√© <code>Etat</code>. Ensuite <code>Billet</code>
devra avoir un champ priv√© <code>etat</code> pour y loger une <code>Option&lt;T&gt;</code> contenant un
objet trait de <code>Box&lt;dyn Etat&gt;</code>. Nous verrons plus tard l'int√©r√™t du <code>Option&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
```
-->
<pre><code class="language-rust noplayground">pub struct Billet {
    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; Billet {
        Billet {
            etat: Some(Box::new(Brouillon {})),
            contenu: String::new(),
        }
    }
}

trait Etat {}

struct Brouillon {}

impl Etat for Brouillon {}
</code></pre>
<!--
<span class="caption">Listing 17-12: Definition of a `Post` struct and a `new`
function that creates a new `Post` instance, a `State` trait, and a `Draft`
struct</span>
-->
<p><span class="caption">Encart 17-12¬†: d√©finition d'une structure <code>Billet</code> et
d'une fonction <code>new</code> qui cr√©e une nouvelle instance de <code>Billet</code>, un trait
<code>Etat</code> et une structure <code>Brouillon</code></span></p>
<!--
The `State` trait defines the behavior shared by different post states, and the
`Draft`, `PendingReview`, and `Published` states will all implement the `State`
trait. For now, the trait doesn‚Äôt have any methods, and we‚Äôll start by defining
just the `Draft` state because that is the state we want a post to start in.
-->
<p>Le trait <code>Etat</code> d√©finit le comportement partag√© par plusieurs √©tats de billet,
et les √©tats <code>Brouillon</code>, <code>EnRelecture</code> et <code>Publier</code> vont tous impl√©menter ce
trait <code>Etat</code>. Pour l'instant, le trait n'a pas de m√©thode, et nous allons
commencer par d√©finir uniquement l'√©tat <code>Brouillon</code> car c'est l'√©tat dans lequel
nous voulons que soit un nouveau billet lorsqu'il est cr√©√©.</p>
<!--
When we create a new `Post`, we set its `state` field to a `Some` value that
holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This
ensures whenever we create a new instance of `Post`, it will start out as a
draft. Because the `state` field of `Post` is private, there is no way to
create a `Post` in any other state! In the `Post::new` function, we set the
`content` field to a new, empty `String`.
-->
<p>Lorsque nous cr√©ons un nouveau <code>Billet</code>, nous assignons √† son champ <code>etat</code> une
valeur <code>Some</code> qui contient une <code>Box</code>. Cette <code>Box</code> pointe sur une nouvelle
instance de la structure <code>Brouillon</code>. Cela garantira qu'√† chaque fois que nous
cr√©ons une nouvelle instance de <code>Billet</code>, elle commencera √† l'√©tat de brouillon.
Comme le champ <code>etat</code> de <code>Billet</code> est priv√©, il n'y a pas d'autre mani√®re de
cr√©er un <code>Billet</code> dans un autre √©tat¬†! Dans la fonction <code>Billet::new</code>, nous
assignons une nouvelle <code>String</code> vide au champ <code>contenu</code>.</p>
<!--
### Storing the Text of the Post Content
-->
<h3 id="stocker-le-texte-du-contenu-du-billet"><a class="header" href="#stocker-le-texte-du-contenu-du-billet">Stocker le texte du contenu du billet</a></h3>
<!--
Listing 17-11 showed that we want to be able to call a method named
`add_text` and pass it a `&str` that is then added to the text content of the
blog post. We implement this as a method rather than exposing the `content`
field as `pub`. This means we can implement a method later that will control
how the `content` field‚Äôs data is read. The `add_text` method is pretty
straightforward, so let‚Äôs add the implementation in Listing 17-13 to the `impl
Post` block:
-->
<p>L'encart 17-11 a montr√© que nous souhaitons appeler une m√©thode <code>ajouter_texte</code>
et lui passer un <code>&amp;str</code> qui est ensuite ajout√© au contenu textuel du billet de
blog. Nous impl√©mentons ceci avec une m√©thode plut√¥t que d'exposer publiquement
le champ <code>contenu</code> avec <code>pub</code>. Cela signifie que nous pourrons impl√©menter une
m√©thode plus tard qui va contr√¥ler comment le champ <code>contenu</code> sera lu. La
m√©thode <code>ajouter_texte</code> est assez simple, donc ajoutons son impl√©mentation dans
le bloc <code>Billet</code> de l'encart 17-13¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masqu√©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span></code></pre>
<!--
<span class="caption">Listing 17-13: Implementing the `add_text` method to add
text to a post‚Äôs `content`</span>
-->
<p><span class="caption">Encart 17-13¬†: impl√©mentation de la m√©thode
<code>ajouter_texte</code> pour ajouter du texte au <code>contenu</code> d'un billet</span></p>
<!--
The `add_text` method takes a mutable reference to `self`, because we‚Äôre
changing the `Post` instance that we‚Äôre calling `add_text` on. We then call
`push_str` on the `String` in `content` and pass the `text` argument to add to
the saved `content`. This behavior doesn‚Äôt depend on the state the post is in,
so it‚Äôs not part of the state pattern. The `add_text` method doesn‚Äôt interact
with the `state` field at all, but it is part of the behavior we want to
support.
-->
<p>La m√©thode <code>ajouter_texte</code> prend en argument une r√©f√©rence mutable vers <code>self</code>,
car nous changeons l'instance <code>Billet</code> sur laquelle nous appelons
<code>ajouter_texte</code>. Nous faisons ensuite appel √† <code>push_str</code> sur le <code>String</code> dans
<code>contenu</code> et nous y envoyons l'argument <code>texte</code> pour l'ajouter au <code>contenu</code> d√©j√†
stock√©. Ce comportement ne d√©pend pas de l'√©tat dans lequel est le billet, donc
cela ne fait pas partie du patron √©tat. La m√©thode <code>ajouter_texte</code> n'interagit
pas du tout avec le champ <code>etat</code>, mais c'est volontaire.</p>
<!--
### Ensuring the Content of a Draft Post Is Empty
-->
<h3 id="sassurer-que-le-contenu-dun-brouillon-est-vide"><a class="header" href="#sassurer-que-le-contenu-dun-brouillon-est-vide">S'assurer que le contenu d'un brouillon est vide</a></h3>
<!--
Even after we‚Äôve called `add_text` and added some content to our post, we still
want the `content` method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 17-11. For now, let‚Äôs
implement the `content` method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We‚Äôll change this later
once we implement the ability to change a post‚Äôs state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:
-->
<p>M√™me si nous avons appel√© <code>ajouter_texte</code> et ajout√© du contenu dans notre
billet, nous voulons que la m√©thode <code>contenu</code> retourne toujours une slice de
cha√Æne de caract√®res vide car le billet est toujours √† l'√©tat de brouillon,
comme le montre la ligne 7 de l'encart 17-11. Impl√©mentons maintenant la m√©thode
<code>contenu</code> de la mani√®re la plus simple qui r√©ponde √† cette consigne¬†: toujours
retourner un slice de cha√Æne de caract√®res vide. Nous la changerons plus tard
lorsque nous impl√©menterons la capacit√© de changer l'√©tat d'un billet afin qu'il
puisse √™tre publi√©. Pour l'instant, les billets ne peuvent qu'√™tre √† l'√©tat de
brouillon, donc le contenu du billet devrait toujours √™tre vide. L'encart 17-14
montre l'impl√©mentation de ceci¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        ""
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masqu√©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span></code></pre>
<!--
<span class="caption">Listing 17-14: Adding a placeholder implementation for
the `content` method on `Post` that always returns an empty string slice</span>
-->
<p><span class="caption">Encart 17-14¬†: ajout d'une impl√©mentation de la m√©thode
<code>contenu</code> sur <code>Billet</code> qui va toujours retourner une slice de cha√Æne de
caract√®res vide</span></p>
<!--
With this added `content` method, everything in Listing 17-11 up to line 7
works as intended.
-->
<p>Avec cette m√©thode <code>contenu</code> ajout√©e, tout ce qu'il y a dans l'encart 17-11
fonctionne comme pr√©vu jusqu'√† la ligne 7.</p>
<!--
### Requesting a Review of the Post Changes Its State
-->
<h3 id="demander-une-relecture-du-billet-va-changer-son-√©tat"><a class="header" href="#demander-une-relecture-du-billet-va-changer-son-√©tat">Demander une relecture du billet va changer son √©tat</a></h3>
<!--
Next, we need to add functionality to request a review of a post, which should
change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:
-->
<p>Ensuite, nous avons besoin d'ajouter une fonctionnalit√© pour demander la
relecture d'un billet, qui devrait changer son √©tat de <code>Brouillon</code> √†
<code>EnRelecture</code>. L'encart 17-15 montre ce code¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masqu√©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.demander_relecture())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(EnRelecture {})
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-15: Implementing `request_review` methods on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-15¬†: impl√©mentation des m√©thodes
<code>demander_relecture</code> sur <code>Billet</code> et le trait <code>Etat</code></span></p>
<!--
We give `Post` a public method named `request_review` that will take a mutable
reference to `self`. Then we call an internal `request_review` method on the
current state of `Post`, and this second `request_review` method consumes the
current state and returns a new state.
-->
<p>Nous installons la m√©thode publique <code>demander_relecture</code> sur <code>Billet</code> qui va
prendre en argument une r√©f√©rence mutable √† <code>self</code>. Ensuite nous appelons la
m√©thode interne <code>demander_relecture</code> sur l'√©tat interne de <code>Billet</code>, et cette
deuxi√®me m√©thode <code>demander_relecture</code> consomme l'√©tat en cours et applique un
nouvel √©tat.</p>
<!--
We‚Äôve added the `request_review` method to the `State` trait; all types that
implement the trait will now need to implement the `request_review` method.
Note that rather than having `self`, `&self`, or `&mut self` as the first
parameter of the method, we have `self: Box<Self>`. This syntax means the
method is only valid when called on a `Box` holding the type. This syntax takes
ownership of `Box<Self>`, invalidating the old state so the state value of the
`Post` can transform into a new state.
-->
<p>Nous avons ajout√© la m√©thode <code>demander_relecture</code> sur le trait <code>Etat</code>¬†; tous les
types qui impl√©mentent le trait vont maintenant devoir impl√©menter la m√©thode
<code>demander_relecture</code>. Remarquez qu'au lieu d'avoir <code>self</code>, <code>&amp;self</code>, ou
<code>&amp;mut self</code> en premier param√®tre de la m√©thode, nous avons <code>self: Box&lt;Self&gt;</code>.
Cette syntaxe signifie que la m√©thode est valide uniquement lorsqu'on l'appelle
sur une <code>Box</code> qui contient ce type. Cette syntaxe prend possession de
<code>Box&lt;Self&gt;</code>, ce qui annule l'ancien √©tat du <code>Billet</code> qui peut changer pour un
nouvel √©tat.</p>
<!--
To consume the old state, the `request_review` method needs to take ownership
of the state value. This is where the `Option` in the `state` field of `Post`
comes in: we call the `take` method to take the `Some` value out of the `state`
field and leave a `None` in its place, because Rust doesn‚Äôt let us have
unpopulated fields in structs. This lets us move the `state` value out of
`Post` rather than borrowing it. Then we‚Äôll set the post‚Äôs `state` value to the
result of this operation.
-->
<p>Pour consommer l'ancien √©tat, la m√©thode <code>demander_relecture</code> a besoin de
prendre possession de la valeur d'√©tat. C'est ce √† quoi sert le <code>Option</code> dans le
champ <code>etat</code> de <code>Billet</code>¬†: nous faisons appel √† la m√©thode <code>take</code> pour obtenir
la valeur dans le <code>Some</code> du champ <code>etat</code> et le remplacer par <code>None</code>, car Rust ne
nous permet pas d'avoir des champs non renseign√©s dans des structures. Cela nous
permet d'extraire la valeur de <code>etat</code> d'un <code>Billet</code>, plut√¥t que de l'emprunter.
Ensuite, nous allons r√©affecter le r√©sultat de cette op√©ration √† <code>etat</code> du
<code>Billet</code> concern√©.</p>
<!--
We need to set `state` to `None` temporarily rather than setting it directly
with code like `self.state = self.state.request_review();` to get ownership of
the `state` value. This ensures `Post` can‚Äôt use the old `state` value after
we‚Äôve transformed it into a new state.
-->
<p>Nous devons assigner temporairement <code>None</code> √† <code>etat</code> plut√¥t que de lui donner
directement avec du code tel que <code>self.etat = self.etat.demander_relecture();</code> car
nous voulons prendre possession de la valeur <code>etat</code>. Cela garantit que <code>Billet</code>
ne peut pas utiliser l'ancienne valeur de <code>etat</code> apr√®s qu'on ait chang√© cet √©tat.</p>
<!--
The `request_review` method on `Draft` needs to return a new, boxed instance of
a new `PendingReview` struct, which represents the state when a post is waiting
for a review. The `PendingReview` struct also implements the `request_review`
method but doesn‚Äôt do any transformations. Rather, it returns itself, because
when we request a review on a post already in the `PendingReview` state, it
should stay in the `PendingReview` state.
-->
<p>La m√©thode <code>demander_relecture</code> sur <code>Brouillon</code> doit retourner une nouvelle
instance d'une structure <code>EnRelecture</code> dans une <code>Box</code>, qui repr√©sente l'√©tat
lorsqu'un billet est en attente de relecture. La structure <code>EnRelecture</code>
impl√©mente elle aussi la m√©thode <code>demander_relecture</code> mais ne fait aucune
modification. A la place, elle se retourne elle-m√™me, car lorsque nous demandons
une relecture sur un billet d√©j√† √† l'√©tat <code>EnRelecture</code>, il doit rester √† l'√©tat
<code>EnRelecture</code>.</p>
<!--
Now we can start seeing the advantages of the state pattern: the
`request_review` method on `Post` is the same no matter its `state` value. Each
state is responsible for its own rules.
-->
<p>D√©sormais nous commen√ßons √† voir les avantages du patron √©tat¬†: la m√©thode
<code>demander_relecture</code> sur <code>Billet</code> est la m√™me peu importe la valeur de son
<code>etat</code>. Chaque √©tat est ma√Ætre de son fonctionnement.</p>
<!--
We‚Äôll leave the `content` method on `Post` as is, returning an empty string
slice. We can now have a `Post` in the `PendingReview` state as well as in the
`Draft` state, but we want the same behavior in the `PendingReview` state.
Listing 17-11 now works up to line 10!
-->
<p>Nous allons conserver la m√©thode <code>contenu</code> sur <code>Billet</code> comme elle est, elle
va donc continuer √† retourner une slice de cha√Æne de caract√®res vide. Nous pouvons
maintenant avoir un <code>Billet</code> √† l'√©tat <code>Brouillon</code> ou <code>EnRelecture</code>, mais nous
voulons qu'il suive le m√™me comportement lorsqu'il est dans l'√©tat
<code>EnRelecture</code>. L'encart 17-11 fonctionne maintenant jusqu'√† la ligne 10¬†!</p>
<!--
### Adding the `approve` Method that Changes the Behavior of `content`
-->
<h3 id="ajouter-une-m√©thode-approuver-qui-change-le-comportement-de-contenu"><a class="header" href="#ajouter-une-m√©thode-approuver-qui-change-le-comportement-de-contenu">Ajouter une m√©thode <code>approuver</code> qui change le comportement de <code>contenu</code></a></h3>
<!--
The `approve` method will be similar to the `request_review` method: it will
set `state` to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:
-->
<p>La m√©thode <code>approuver</code> ressemble √† la m√©thode <code>demander_relecture</code>¬†: elle va
changer <code>etat</code> pour lui donner la valeur que l'√©tat courant retournera lorsqu'il
sera approuv√©, comme le montre l'encart 17-16¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masqu√©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approuver(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.approuver())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    // -- partie masqu√©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    // -- partie masqu√©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(Publier {})
    }
}

struct Publier {}

impl Etat for Publier {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }

    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-16: Implementing the `approve` method on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-16¬†: impl√©mentation de la m√©thode <code>approuver</code>
sur <code>Billet</code> et sur le trait <code>Etat</code></span></p>
<!--
We add the `approve` method to the `State` trait and add a new struct that
implements `State`, the `Published` state.
-->
<p>Nous avons ajout√© la m√©thode <code>approuver</code> au trait <code>Etat</code> et ajout√© une nouvelle
structure <code>Publier</code>, qui impl√©mente <code>Etat</code>.</p>
<!--
Similar to the way `request_review` on `PendingReview` works, if we call the
`approve` method on a `Draft`, it will have no effect because `approve` will
return `self`. When we call `approve` on `PendingReview`, it returns a new,
boxed instance of the `Published` struct. The `Published` struct implements the
`State` trait, and for both the `request_review` method and the `approve`
method, it returns itself, because the post should stay in the `Published`
state in those cases.
-->
<p>Comme pour la fa√ßon de fonctionner de <code>demander_relecture</code> sur <code>EnRelecture</code>,
si nous faisons appel √† la m√©thode <code>approuver</code> sur un <code>Brouillon</code>, cela n'aura
pas d'effet car <code>approuver</code> va retourner <code>self</code>. Lorsque nous appellerons
<code>approuver</code> sur <code>EnRelecture</code>, elle va retourner une nouvelle instance de la
structure <code>Publier</code> dans une instance de <code>Box</code>. La structure <code>Publier</code>
impl√©mente le trait <code>Etat</code>, et pour chacune des m√©thodes <code>demander_relecture</code>
et <code>approuver</code>, elle va retourner elle-m√™me, car le billet doit rester √† l'√©tat
<code>Publier</code> dans ce cas-l√†.</p>
<!--
Now we need to update the `content` method on `Post`. We want the value
returned from `content` to depend on the current state of the `Post`, so we're
going to have the `Post` delegate to a `content` method defined on its `state`,
as shown in Listing 17-17:
-->
<p>Nous devons maintenant modifier la m√©thode <code>contenu</code> sur <code>Billet</code>. Nous
souhaitons que la valeur retourn√©e par <code>contenu</code> d√©pende de l'√©tat actuel du
<code>Billet</code>, donc nous allons faire en sorte que le <code>Billet</code> d√©l√®gue sa logique √†
une m√©thode <code>contenu</code> d√©fini sur son <code>etat</code>, comme dans l'encart 17-17¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
}
# 
# trait State {
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# }
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
# struct Published {}
# 
# impl State for Published {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masqu√©e ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        self.etat.as_ref().unwrap().contenu(self)
    }
    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait Etat {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Publier {}
</span><span class="boring">
</span><span class="boring">impl Etat for Publier {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 17-17: Updating the `content` method on `Post` to
delegate to a `content` method on `State`</span>
-->
<p><span class="caption">Encart 17-17¬†: correction de la m√©thode <code>contenu</code> de
<code>Billet</code> afin qu'elle d√©l√®gue √† la m√©thode <code>contenu</code> de <code>Etat</code></span></p>
<!--
Because the goal is to keep all these rules inside the structs that implement
`State`, we call a `content` method on the value in `state` and pass the post
instance (that is, `self`) as an argument. Then we return the value that is
returned from using the `content` method on the `state` value.
-->
<p>Comme notre but est de conserver toutes ces r√®gles dans les structures qui
impl√©mentent <code>Etat</code>, nous appelons une m√©thode <code>contenu</code> sur la valeur de
<code>etat</code> et nous lui passons en argument l'instance du billet (avec le <code>self</code>).
Nous retournons ensuite la valeur retourn√©e par la m√©thode <code>contenu</code> sur la
valeur de <code>etat</code>.</p>
<!-- markdownlint-disable -->
<!--
We call the `as_ref` method on the `Option` because we want a reference to the
value inside the `Option` rather than ownership of the value. Because `state`
is an `Option<Box<dyn State>>`, when we call `as_ref`, an `Option<&Box<dyn
State>>` is returned. If we didn‚Äôt call `as_ref`, we would get an error because
we can‚Äôt move `state` out of the borrowed `&self` of the function parameter.
-->
<!-- markdownlint-enable -->
<p>Nous faisons appel √† la m√©thode <code>as_ref</code> sur <code>Option</code> car nous voulons une
r√©f√©rence vers la valeur dans <code>Option</code> plut√¥t que d'en prendre possession. Comme
<code>etat</code> est un <code>Option&lt;Box&lt;dyn Etat&gt;&gt;</code>, lorsque nous faisons appel √† <code>as_ref</code>,
une <code>Option&lt;&amp;Box&lt;dyn Etat&gt;&gt;</code> est retourn√©e. Si nous n'avions pas fait appel √†
<code>as_ref</code>, nous aurions obtenu une erreur car nous ne pouvons pas d√©placer
<code>etat</code> de <code>&amp;self</code>, lui-m√™me est emprunt√© et provenant des param√®tres de la fonction.</p>
<!--
We then call the `unwrap` method, which we know will never panic, because we
know the methods on `Post` ensure that `state` will always contain a `Some`
value when those methods are done. This is one of the cases we talked about in
the [‚ÄúCases In Which You Have More Information Than the
Compiler‚Äù][more-info-than-rustc]<!-- ignore -- > section of Chapter 9 when we
know that a `None` value is never possible, even though the compiler isn‚Äôt able
to understand that.
-->
<p>Nous faisons ensuite appel √† la m√©thode <code>unwrap</code>, mais nous savons qu'elle ne
va jamais paniquer, car nous savons que les m√©thodes sur <code>Billet</code> vont garantir
que <code>etat</code> contiendra toujours une valeur <code>Some</code> lorsqu'elles seront utilis√©es.
C'est un des cas dont nous avons parl√© dans
<a href="ch09-03-to-panic-or-not-to-panic.html">une section</a><!-- ignore --> du chapitre 9 lorsque nous
savions qu'une valeur <code>None</code> ne serait jamais possible, m√™me si le compilateur
n'est pas capable de le comprendre.</p>
<!-- markdownlint-disable -->
<!--
At this point, when we call `content` on the `&Box<dyn State>`, deref coercion will
take effect on the `&` and the `Box` so the `content` method will ultimately be
called on the type that implements the `State` trait. That means we need to add
`content` to the `State` trait definition, and that is where we‚Äôll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:
-->
<!-- markdownlint-enable -->
<p>A partir de l√†, lorsque nous faisons appel √† <code>contenu</code> sur <code>&amp;Box&lt;dyn Etat&gt;</code>,
l'extrapolation de d√©r√©f√©rencement va s'appliquer sur le <code>&amp;</code> et le <code>Box</code> pour
que la m√©thode <code>contenu</code> puisse finalement √™tre appel√©e sur le type qui
impl√©mente le trait <code>Etat</code>. Cela signifie que nous devons ajouter <code>contenu</code> √† la
d√©finition du trait <code>Etat</code>, et que c'est ici que nous allons placer la logique
pour le contenu √† retourner en fonction de l'√©tat nous avons, comme le montre
l'encart 17-18¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         self.state.as_ref().unwrap().content(self)
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
# }
# 
trait State {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

// --snip--
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
struct Published {}

impl State for Published {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.etat.as_ref().unwrap().contenu(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait Etat {
    // -- partie masqu√©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Publier {}

impl Etat for Publier {
    // -- partie masqu√©e ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &amp;billet.contenu
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-18: Adding the `content` method to the `State`
trait</span>
-->
<p><span class="caption">Encart 17-18¬†: ajout de la m√©thode <code>contenu</code> sur le trait
<code>Etat</code></span></p>
<!--
We add a default implementation for the `content` method that returns an empty
string slice. That means we don‚Äôt need to implement `content` on the `Draft`
and `PendingReview` structs. The `Published` struct will override the `content`
method and return the value in `post.content`.
-->
<p>Nous avons ajout√© une impl√©mentation par d√©faut pour la m√©thode <code>contenu</code> qui
retourne une slice de cha√Æne de caract√®res vide. Cela nous permet de ne pas
avoir √† impl√©menter <code>contenu</code> sur les structures <code>Brouillon</code> et <code>EnRelecture</code>.
La structure <code>Publier</code> va remplacer la m√©thode <code>contenu</code> et retourner la valeur
pr√©sente dans <code>billet.contenu</code>.</p>
<!--
Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We‚Äôre taking a reference to a `post` as an argument and returning a
reference to part of that `post`, so the lifetime of the returned reference is
related to the lifetime of the `post` argument.
-->
<p>Remarquez aussi que nous devons annoter des dur√©es de vie sur cette m√©thode,
comme nous l'avons vu au chapitre 10. Nous allons prendre en argument une
r√©f√©rence au <code>billet</code> et retourner une r√©f√©rence √† une partie de ce <code>billet</code>,
donc la dur√©e de vie retourn√©e par la r√©f√©rence est li√©e √† la dur√©e de vie de
l'argument <code>billet</code>.</p>
<!--
And we‚Äôre done‚Äîall of Listing 17-11 now works! We‚Äôve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout `Post`.
-->
<p>Et nous avons maintenant termin√©, tout le code de l'encart 17-11 fonctionne
d√©sormais¬†! Nous avons impl√©ment√© le patron √©tat avec les r√®gles de notre
processus de publication d√©finies pour notre blog. La logique des r√®gles est
int√©gr√©e dans les objets √©tat plut√¥t que d'√™tre dispers√©e un peu partout dans
<code>Billet</code>.</p>
<!--
### Trade-offs of the State Pattern
-->
<h3 id="les-inconv√©nients-du-patron-√©tat"><a class="header" href="#les-inconv√©nients-du-patron-√©tat">Les inconv√©nients du patron √©tat</a></h3>
<!--
We‚Äôve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on `Post` know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the `State`
trait on the `Published` struct.
-->
<p>Nous avons d√©montr√© que Rust est capable d'impl√©menter le patron √©tat qui est
orient√© objet pour regrouper les diff√©rents types de comportement qu'un billet
doit avoir √† chaque √©tat. Les m√©thodes sur <code>Billet</code> ne savent rien des
diff√©rents comportements. De la mani√®re dont nous avons organis√© le code, nous
n'avons qu'√† regarder √† un seul endroit pour conna√Ætre les diff√©rents
comportements qu'un billet publi√© va suivre¬†: l'impl√©mentation du trait <code>Etat</code>
sur la structure <code>Publier</code>.</p>
<!--
If we were to create an alternative implementation that didn‚Äôt use the state
pattern, we might instead use `match` expressions in the methods on `Post` or
even in the `main` code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those `match` expressions
would need another arm.
-->
<p>Si nous avions utilis√© une autre fa√ßon d'impl√©menter ces r√®gles sans utiliser
le patron √©tat, nous aurions d√ª utiliser des expressions <code>match</code> dans les
m√©thodes de <code>Billet</code> ou m√™me dans le code du <code>main</code> qui v√©rifie l'√©tat du
billet et les comportements associ√©s aux changements d'√©tats. Cela aurait eu
pour cons√©quence d'avoir √† regarder √† diff√©rents endroits pour comprendre toutes
les cons√©quences de la publication d'un billet¬†! Et ce code grossirait au fur et
√† mesure que nous ajouterions des √©tats¬†: chaque expression <code>match</code> devrait avoir
des nouvelles branches pour ces nouveaux √©tats.</p>
<!--
With the state pattern, the `Post` methods and the places we use `Post` don‚Äôt
need `match` expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.
-->
<p>Avec le patron √©tat, les m√©thodes de <code>Billet</code> et les endroits o√π nous utilisons
<code>Billet</code> n'ont pas besoin d'expressions <code>match</code>, et pour ajouter un nouvel √©tat,
nous avons seulement besoin d'ajouter une nouvelle structure et d'impl√©menter
les m√©thodes du trait sur cette structure.</p>
<div id="suggestions-implementations">
<!--
The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:
-->
<p>L'impl√©mentation qui utilise le patron √©tat est facile √† am√©liorer pour ajouter
plus de fonctionnalit√©s. Pour d√©couvrir la simplicit√© de maintenance du code qui
utilise le patron √©tat, essayez d'accomplir certaines de ces suggestions¬†:</p>
<!--
* Add a `reject` method that changes the post‚Äôs state from `PendingReview` back
  to `Draft`.
* Require two calls to `approve` before the state can be changed to `Published`.
* Allow users to add text content only when a post is in the `Draft` state.
  Hint: have the state object responsible for what might change about the
  content but not responsible for modifying the `Post`.
-->
<ul>
<li>Ajouter une m√©thode <code>rejeter</code> qui fait retourner l'√©tat d'un billet de
<code>EnRelecture</code> √† <code>Brouillon</code>.</li>
<li>Attendre deux appels √† <code>approuver</code> avant que l'√©tat puisse √™tre chang√© en
<code>Publier</code>.</li>
<li>Permettre aux utilisateurs d'ajouter du contenu textuel uniquement lorsqu'un
billet est √† l'√©tat <code>Brouillon</code>. Indice¬†: rendre l'objet √©tat responsable de
ce qui peut changer dans le contenu mais pas responsable de la modification
de <code>Billet</code>.</li>
</ul>
</div>
<!--
One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between `PendingReview` and `Published`, such as `Scheduled`,
we would have to change the code in `PendingReview` to transition to
`Scheduled` instead. It would be less work if `PendingReview` didn‚Äôt need to
change with the addition of a new state, but that would mean switching to
another design pattern.
-->
<p>Un inconv√©nient du patron √©tat est que comme les √©tats impl√©mentent les
transitions entre les √©tats, certains des √©tats sont coupl√©s entre eux. Si nous
ajoutons un nouvel √©tat entre <code>EnRelecture</code> et <code>Publier</code>, <code>Planifier</code> par exemple,
nous devrons alors changer le code dans <code>EnRelecture</code> pour qu'il passe ensuite
√† l'√©tat <code>Planifier</code> au lieu de <code>Publier</code>. Cela repr√©senterait moins de travail
si <code>EnRelecture</code> n'avait pas besoin de changer lorsqu'on ajoute un nouvel √©tat, mais
cela signifierait alors qu'il faudrait changer de patron.</p>
<!--
Another downside is that we‚Äôve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
`request_review` and `approve` methods on the `State` trait that return `self`;
however, this would violate object safety, because the trait doesn‚Äôt know what
the concrete `self` will be exactly. We want to be able to use `State` as a
trait object, so we need its methods to be object safe.
-->
<p>Un autre inconv√©nient est que nous avons de la logique en double. Pour √©viter ces
doublons, nous devrions essayer de faire en sorte que les m√©thodes
<code>demander_relecture</code> et <code>approuver</code> qui retournent <code>self</code> deviennent les
impl√©mentations par d√©faut sur le trait <code>Etat</code>¬†; cependant, cela violerait la
s√ªret√© des objets, car le trait ne sait pas ce qu'est exactement <code>self</code>. Nous
voulons pouvoir utiliser <code>Etat</code> en tant qu'objet trait, donc nous avons besoin
que ses m√©thodes soient s√ªres pour les objets.</p>
<!--
Other duplication includes the similar implementations of the `request_review`
and `approve` methods on `Post`. Both methods delegate to the implementation of
the same method on the value in the `state` field of `Option` and set the new
value of the `state` field to the result. If we had a lot of methods on `Post`
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the [‚ÄúMacros‚Äù][macros]<!-- ignore -- > section in Chapter 19).
-->
<p>Nous avons aussi des doublons dans le code des m√©thodes <code>demander_relecture</code> et
<code>approuver</code> sur <code>Billet</code>. Ces deux m√©thodes d√©l√®guent leur travail √† la m√™me
m√©thode de la valeur du champ <code>etat</code> de type <code>Option</code> et assignent la nouvelle
valeur du m√™me champ <code>etat</code> √† la fin. Si nous avions beaucoup de m√©thodes sur
<code>Billet</code> qui suivaient cette logique, nous devrions envisager de d√©finir une
macro pour √©viter cette r√©p√©tition (voir la
<a href="ch19-06-macros.html#macros">section d√©di√©e</a><!-- ignore --> dans le chapitre 19).</p>
<!--
By implementing the state pattern exactly as it‚Äôs defined for object-oriented
languages, we‚Äôre not taking as full advantage of Rust‚Äôs strengths as we could.
Let‚Äôs look at some changes we can make to the `blog` crate that can make
invalid states and transitions into compile time errors.
-->
<p>En impl√©mentant le patron √©tat exactement comme il est d√©fini pour les
langages orient√©s-objet, nous ne profitons pas pleinement des avantages de
Rust. Voyons voir si nous pouvons faire quelques changements pour que la crate
<code>blog</code> puisse lever des erreurs d√®s la compilation lorsqu'elle aura d√©tect√© des
√©tats ou des transitions invalides.</p>
<!--
#### Encoding States and Behavior as Types
-->
<h4 id="impl√©menter-les-√©tats-et-les-comportements-avec-des-types"><a class="header" href="#impl√©menter-les-√©tats-et-les-comportements-avec-des-types">Impl√©menter les √©tats et les comportements avec des types</a></h4>
<!--
We‚Äôll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we‚Äôll encode the states into different
types. Consequently, Rust‚Äôs type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.
-->
<p>Nous allons vous montrer comment repenser le patron √©tat pour qu'il offre des
compromis diff√©rents. Plut√¥t que d'encapsuler compl√®tement les √©tats et les
transitions, faisant que le code externe ne puissent pas les conna√Ætre, nous
allons coder ces √©tats sous forme de diff√©rents types. En cons√©quence, le
syst√®me de v√©rification de type de Rust va emp√™cher toute tentative
d'utilisation des brouillons de billets l√† o√π seuls des billets publi√©s sont
autoris√©s, en provoquant une erreur de compilation.</p>
<!--
Let‚Äôs consider the first part of `main` in Listing 17-11:
-->
<p>Consid√©rons la premi√®re partie du <code>main</code> de l'encart 17-11¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
# use blog::Post;
# 
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
# 
#     post.request_review();
#     assert_eq!("", post.content());
# 
#     post.approve();
#     assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use blog::Billet;
</span><span class="boring">
</span>fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mang√© une salade au d√©jeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());
<span class="boring">
</span><span class="boring">    billet.demander_relecture();
</span><span class="boring">    assert_eq!(&quot;&quot;, billet.contenu());
</span><span class="boring">
</span><span class="boring">    billet.approuver();
</span><span class="boring">    assert_eq!(&quot;J'ai mang√© une salade au d√©jeuner aujourd'hui&quot;, billet.contenu());
</span>}
</code></pre>
<!--
We still enable the creation of new posts in the draft state using `Post::new`
and the ability to add text to the post‚Äôs content. But instead of having a
`content` method on a draft post that returns an empty string, we‚Äôll make it so
draft posts don‚Äôt have the `content` method at all. That way, if we try to get
a draft post‚Äôs content, we‚Äôll get a compiler error telling us the method
doesn‚Äôt exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won‚Äôt even compile.
Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,
as well as methods on each:
-->
<p>Nous pouvons toujours cr√©er de nouveaux billets √† l'√©tat de brouillon en
utilisant <code>Billet::new</code> et ajouter du texte au contenu du billet. Mais au lieu
d'avoir une m√©thode <code>contenu</code> sur un brouillon de billet qui retourne une cha√Æne
de caract√®res vide, nous faisons en sorte que les brouillons de billets n'aient
m√™me pas de m√©thode <code>contenu</code>. Ainsi, si nous essayons de r√©cup√©rer le contenu
d'un brouillon de billet, nous obtenons une erreur de compilation qui nous
informera que la m√©thode n'existe pas. Finalement, il nous sera impossible de
publier le contenu d'un brouillon de billet en production, car ce code ne se
compilera m√™me pas. L'encart 17-19 nous propose les d√©finitions d'une structure
<code>Billet</code> et d'une structure <code>BrouillonDeBillet</code> ainsi que leurs m√©thodes¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```
-->
<pre><code class="language-rust noplayground">pub struct Billet {
    contenu: String,
}

pub struct BrouillonDeBillet {
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; BrouillonDeBillet {
        BrouillonDeBillet {
            contenu: String::new(),
        }
    }

    pub fn contenu(&amp;self) -&gt; &amp;str {
        &amp;self.contenu
    }
}

impl BrouillonDeBillet {
    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-19: A `Post` with a `content` method and a
`DraftPost` without a `content` method</span>
-->
<p><span class="caption">Encart 17-19¬†: un <code>Billet</code> avec une m√©thode <code>contenu</code> et
un <code>BrouillonDeBillet</code> sans m√©thode <code>contenu</code></span></p>
<!--
Both the `Post` and `DraftPost` structs have a private `content` field that
stores the blog post text. The structs no longer have the `state` field because
we‚Äôre moving the encoding of the state to the types of the structs. The `Post`
struct will represent a published post, and it has a `content` method that
returns the `content`.
-->
<p>Les deux structures <code>Billet</code> et <code>BrouillonDeBillet</code> ont un champ priv√©
<code>contenu</code> qui stocke le texte du billet de blog. Les structures n'ont plus le
champ <code>etat</code> car nous avons d√©plac√© la signification de l'√©tat directement dans
le nom de ces types de structures. La structure <code>Billet</code> repr√©sente un billet
publi√© et poss√®de une m√©thode <code>contenu</code> qui retourne le <code>contenu</code>.</p>
<!--
We still have a `Post::new` function, but instead of returning an instance of
`Post`, it returns an instance of `DraftPost`. Because `content` is private
and there aren‚Äôt any functions that return `Post`, it‚Äôs not possible to create
an instance of `Post` right now.
-->
<p>Nous avons toujours la fonction <code>Billet::new</code>, mais au lieu de retourner une
instance de <code>Billet</code>, elle va retourner une instance de <code>BrouillonDeBillet</code>.
Comme <code>contenu</code> est priv√© et qu'il n'y a pas de fonction qui retourne <code>Billet</code>,
il ne sera pas possible pour le moment de cr√©er une instance de <code>Billet</code>.</p>
<!--
The `DraftPost` struct has an `add_text` method, so we can add text to
`content` as before, but note that `DraftPost` does not have a `content` method
defined! So now the program ensures all posts start as draft posts, and draft
posts don‚Äôt have their content available for display. Any attempt to get around
these constraints will result in a compiler error.
-->
<p>La structure <code>BrouillonDeBillet</code> a une m√©thode <code>ajouter_texte</code>, donc nous
pouvons ajouter du texte √† <code>contenu</code> comme nous le faisions avant, mais
remarquez toutefois que <code>BrouillonDeBillet</code> n'a pas de m√©thode <code>contenu</code> de
d√©finie¬†! Donc pour l'instant le programme s'assure que tous les billets
d√©marrent √† l'√©tat de brouillon et que les brouillons ne proposent pas de
contenu √† publier. Toute tentative d'outre-passer ces contraintes va
d√©clencher une erreur de compilation.</p>
<!--
#### Implementing Transitions as Transformations into Different Types
-->
<h4 id="impl√©menter-les-changements-d√©tat-en-tant-que-changement-de-type"><a class="header" href="#impl√©menter-les-changements-d√©tat-en-tant-que-changement-de-type">Impl√©menter les changements d'√©tat en tant que changement de type</a></h4>
<!--
So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let‚Äôs implement
these constraints by adding another struct, `PendingReviewPost`, defining the
`request_review` method on `DraftPost` to return a `PendingReviewPost`, and
defining an `approve` method on `PendingReviewPost` to return a `Post`, as
shown in Listing 17-20:
-->
<p>Donc, comment publier un billet¬†? Nous voulons renforcer la r√®gle qui dit qu'un
brouillon de billet doit √™tre relu et approuv√© avant de pouvoir √™tre publi√©. Un
billet √† l'√©tat de relecture doit continuer √† ne pas montrer son contenu.
Impl√©mentons ces contraintes en introduisant une nouvelle structure,
<code>BilletEnRelecture</code>, en d√©finissant la m√©thode <code>demander_relecture</code> sur
<code>BrouillonDeBillet</code> retournant un <code>BilletEnRelecture</code>, et en d√©finissant une
m√©thode <code>approuver</code> sur <code>BilletEnRelecture</code> pour qu'elle retourne un <code>Billet</code>,
comme le propose l'encart 17-20¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Post {
#     content: String,
# }
# 
# pub struct DraftPost {
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> DraftPost {
#         DraftPost {
#             content: String::new(),
#         }
#     }
# 
#     pub fn content(&self) -> &str {
#         &self.content
#     }
# }
# 
impl DraftPost {
    // --snip--
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Billet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct BrouillonDeBillet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; BrouillonDeBillet {
</span><span class="boring">        BrouillonDeBillet {
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.contenu
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl BrouillonDeBillet {
    // -- partie masqu√©e ici --
<span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(self) -&gt; BilletEnRelecture {
        BilletEnRelecture {
            contenu: self.contenu,
        }
    }
}

pub struct BilletEnRelecture {
    contenu: String,
}

impl BilletEnRelecture {
    pub fn approuver(self) -&gt; Billet {
        Billet {
            contenu: self.contenu,
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by
calling `request_review` on `DraftPost` and an `approve` method that turns a
`PendingReviewPost` into a published `Post`</span>
-->
<p><span class="caption">Encart 17-20¬†: ajout d'un <code>BilletEnRelecture</code> qui est cr√©√©
par l'appel √† <code>demander_relecture</code> sur <code>BrouillonDeBillet</code>, ainsi qu'une m√©thode
<code>approuver</code> qui transforme un <code>BilletEnRelecture</code> en <code>Billet</code> publi√©</span></p>
<!--
The `request_review` and `approve` methods take ownership of `self`, thus
consuming the `DraftPost` and `PendingReviewPost` instances and transforming
them into a `PendingReviewPost` and a published `Post`, respectively. This way,
we won‚Äôt have any lingering `DraftPost` instances after we‚Äôve called
`request_review` on them, and so forth. The `PendingReviewPost` struct doesn‚Äôt
have a `content` method defined on it, so attempting to read its content
results in a compiler error, as with `DraftPost`. Because the only way to get a
published `Post` instance that does have a `content` method defined is to call
the `approve` method on a `PendingReviewPost`, and the only way to get a
`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,
we‚Äôve now encoded the blog post workflow into the type system.
-->
<p>Les m√©thodes <code>demander_relecture</code> et <code>approuver</code> prennent possession de <code>self</code>,
ce qui consomme les instances de <code>BrouillonDeBillet</code> et de <code>BilletEnRelecture</code>
pour les transformer respectivement en <code>BilletEnRelecture</code> et en <code>Billet</code>.
Ainsi, il ne restera plus d'instances de <code>BrouillonDeBillet</code> apr√®s avoir appel√©
<code>approuver</code> sur elles, et ainsi de suite. La structure <code>BilletEnRelecture</code> n'a
pas de m√©thode <code>contenu</code> qui lui est d√©finie, donc si on essaye de lire son
contenu, on obtient une erreur de compilation, comme avec <code>BrouillonDeBillet</code>.
Comme la seule mani√®re d'obtenir une instance de <code>Billet</code> qui a une m√©thode
<code>contenu</code> de d√©finie est d'appeler la m√©thode<code>approuver</code> sur un
<code>BilletEnRelecture</code>, et que la seule mani√®re d'obtenir un <code>BilletEnRelecture</code>
est d'appeler la m√©thode <code>demander_relecture</code> sur un <code>BrouillonDeBillet</code>, nous
avons d√©sormais int√©gr√© le processus de publication des billets de blog avec le
syst√®me de type.</p>
<!--
But we also have to make some small changes to `main`. The `request_review` and
`approve` methods return new instances rather than modifying the struct they‚Äôre
called on, so we need to add more `let post =` shadowing assignments to save
the returned instances. We also can‚Äôt have the assertions about the draft and
pending review posts‚Äô contents be empty strings, nor do we need them: we can‚Äôt
compile code that tries to use the content of posts in those states any longer.
The updated code in `main` is shown in Listing 17-21:
-->
<p>Mais nous devons aussi faire quelques petits changements dans le <code>main</code>. Les
m√©thodes <code>demander_relecture</code> et <code>approuver</code> retournent des nouvelles instances
au lieu de modifier la structure sur laquelle elles ont √©t√© appel√©es, donc nous
devons ajouter des assignations de masquage <code>let billet =</code> pour stocker les
nouvelles instances retourn√©es. Nous ne pouvons pas non plus v√©rifier que le
contenu des brouillons de billets et de ceux en cours de relecture sont bien
vides, donc nous n'avons plus besoin des v√©rifications associ√©es¬†: en effet,
nous ne pouvons plus compiler du code qui essaye d'utiliser le contenu d'un
billet dans ces √©tats. Le code du <code>main</code> mis √† jour est pr√©sent√© dans
l'encart 17-21¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mang√© une salade au d√©jeuner aujourd'hui&quot;);

    let billet = billet.demander_relecture();

    let billet = billet.approuver();

    assert_eq!(&quot;J'ai mang√© une salade au d√©jeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-21: Modifications to `main` to use the new
implementation of the blog post workflow</span>
-->
<p><span class="caption">Encart 17-21¬†: modification de <code>main</code> pour utiliser la
nouvelle impl√©mentation du processus de publication de billet de blog</span></p>
<!--
The changes we needed to make to `main` to reassign `post` mean that this
implementation doesn‚Äôt quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the `Post` implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.
-->
<p>Les modifications que nous avons eu besoin de faire √† <code>main</code> pour r√©assigner
<code>billet</code> impliquent que cette impl√©mentation ne suit plus exactement le patron
√©tat orient√©-objet¬†: les changements d'√©tats ne sont plus totalement int√©gr√©s
dans l'impl√©mentation de <code>Billet</code>. Cependant, nous avons obtenu que les
√©tats invalides sont d√©sormais impossibles gr√¢ce au syst√®me de types et √† la
v√©rification de type qui s'effectue √† la compilation¬†! Cela garantit que certains
bogues, comme l'affichage du contenu d'un billet non publi√©, seront d√©tect√©s avant
d'arriver en production.</p>
<!--
Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the `blog` crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.
-->
<p>Essayez d'impl√©menter <a href="ch17-03-oo-design-patterns.html#suggestions-implementations">les exigences fonctionnelles suppl√©mentaires sugg√©r√©es
dans la liste pr√©sente au d√©but de cette section</a>,
sur la crate <code>blog</code> dans l'√©tat o√π elle √©tait apr√®s l'encart 17-20, afin de
vous faire une id√©e sur cette fa√ßon de concevoir le code. Notez aussi que
certaines de ces exigences pourraient d√©j√† √™tre impl√©ment√©es implicitement du
fait de cette conception.</p>
<!--
We‚Äôve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust‚Äôs features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won‚Äôt always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don‚Äôt have.
-->
<p>Nous avons vu que m√™me si Rust est capable d'impl√©menter des patrons de
conception orient√©s-objet, d'autres patrons, tel qu'int√©grer l'√©tat dans le
syst√®me de type, sont √©galement possibles en Rust. Ces patrons pr√©sentent diff√©rents
avantages et inconv√©nients. Bien que vous puissiez √™tre tr√®s familier avec les patrons
orient√©s-objet, vous gagnerez √† repenser les choses pour tirer avantage des
fonctionnalit√©s de Rust, telles que la d√©tection de certains bogues √† la compilation.
Les patrons orient√©s-objet ne sont pas toujours la meilleure solution en Rust √†
cause de certaines de ses fonctionnalit√©s, comme la possession, que les langages
orient√©s-objet n'ont pas.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-16"><a class="header" href="#r√©sum√©-16">R√©sum√©</a></h2>
<!--
No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code‚Äôs
maintainability. Rust also has other features, like ownership, that
object-oriented languages don‚Äôt have. An object-oriented pattern won‚Äôt always
be the best way to take advantage of Rust‚Äôs strengths, but is an available
option.
-->
<p>Que vous pensiez ou non que Rust est un langage orient√©-objet apr√®s avoir lu ce
chapitre, vous savez maintenant que vous pouvez utiliser les objets trait pour
pouvoir obtenir certaines fonctionnalit√©s orient√©-objet en Rust. La r√©partition
dynamique peut offrir de la flexibilit√© √† votre code en √©change d'une perte de
performances √† l'ex√©cution. Vous pouvez utiliser cette flexibilit√© pour
impl√©menter des patrons orient√©s-objet qui facilitent la maintenance de
votre code. Rust offre d'autres fonctionnalit√©s, comme la possession, que les
langages orient√©s-objet n'ont pas. L'utilisation d'un patron orient√©-objet n'est
pas toujours la meilleure mani√®re de tirer parti des avantages de Rust, mais
cela reste une option disponible.</p>
<!--
Next, we‚Äôll look at patterns, which are another of Rust‚Äôs features that enable
lots of flexibility. We‚Äôve looked at them briefly throughout the book but
haven‚Äôt seen their full capability yet. Let‚Äôs go!
-->
<p>Dans le chapitre suivant, nous allons √©tudier les motifs, qui constituent une
autre des fonctionnalit√©s de Rust et apportent beaucoup de flexibilit√©. Nous
les avons abord√©s bri√®vement dans le livre, mais nous n'avons pas encore vu
tout leur potentiel. C'est parti¬†!</p>
<!-- markdownlint-disable -->
<!--
[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->
<div style="break-before: page; page-break-before: always;"></div><!--
# Patterns and Matching
-->
<h1 id="les-motifs-et-le-filtrage-par-motif"><a class="header" href="#les-motifs-et-le-filtrage-par-motif">Les motifs et le filtrage par motif</a></h1>
<!--
Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with `match`
expressions and other constructs gives you more control over a program‚Äôs
control flow. A pattern consists of some combination of the following:
-->
<p>Les motifs sont une syntaxe sp√©ciale de Rust permettant de filtrer selon la
structure des types, qu'elle soit simple ou complexe. L'utilisation de motifs
conjointement avec des expressions <code>match</code> et d'autres constructions vous donne
davantage de ma√Ætrise sur le flux de contr√¥le de votre programme. Un motif est
constitu√© d'une combinaison de :</p>
<!--
* Literals
* Destructured arrays, enums, structs, or tuples
* Variables
* Wildcards
* Placeholders
-->
<ul>
<li>litt√©raux</li>
<li>tableaux de structures, √©num√©rations, structures ou tuples</li>
<li>variables</li>
<li>jokers</li>
<li>espaces r√©serv√©s</li>
</ul>
<!--
These components describe the shape of the data we‚Äôre working with, which we
then match against values to determine whether our program has the correct data
to continue running a particular piece of code.
-->
<p>Ces composants d√©crivent la forme de la donn√©e avec laquelle nous travaillons,
que nous comparons alors √† diff√©rents motifs de valeurs pour d√©terminer si
notre programme dispose de la donn√©e appropri√©e pour ex√©cuter une partie
sp√©cifique de code.</p>
<!--
To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the `match` expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn‚Äôt, the code associated with the pattern won‚Äôt run.
-->
<p>Pour utiliser un motif, nous le comparons √† une certaine valeur. Si le motif
correspond √† la valeur, nous utilisons les √©l√©ments pr√©sents dans la valeur
pour notre code. Rappelez-vous que les expressions <code>match</code> du chapitre 6
utilisaient les motifs, comme pour la machine √† trier la monnaie par exemple.
Si la valeur correspondait √† la forme d'un motif, nous pouvions utiliser le nom de
la pi√®ce. Sinon, le code associ√© au motif n'√©tait pas ex√©cut√©.</p>
<!--
This chapter is a reference on all things related to patterns. We‚Äôll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you‚Äôll know how to use patterns to express many concepts in
a clear way.
-->
<p>Ce chapitre sert de r√©f√©rence pour tout ce qui concerne les motifs. Nous allons voir
les moments appropri√©s pour utiliser les motifs, les diff√©rences entre les
motifs r√©futables et irr√©futables ainsi que les diff√©rentes syntaxes de motifs que
vous pouvez rencontrer. A la fin de ce chapitre, vous saurez comment utiliser
les motifs pour exprimer clairement de nombreux concepts.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## All the Places Patterns Can Be Used
-->
<h2 id="tous-les-endroits-o√π-les-motifs-peuvent-√™tre-utilis√©s"><a class="header" href="#tous-les-endroits-o√π-les-motifs-peuvent-√™tre-utilis√©s">Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></h2>
<!--
Patterns pop up in a number of places in Rust, and you‚Äôve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.
-->
<p>Les motifs apparaissent dans de nombreux endroits en Rust, et vous en avez
utilis√© beaucoup sans vous en rendre compte¬†! Cette section va pr√©senter les
diff√©rentes situations o√π l'utilisation des motifs est appropri√©e.</p>
<!--
### `match` Arms
-->
<h3 id="les-branches-des-match"><a class="header" href="#les-branches-des-match">Les branches des <code>match</code></a></h3>
<!--
As discussed in Chapter 6, we use patterns in the arms of `match` expressions.
Formally, `match` expressions are defined as the keyword `match`, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm‚Äôs pattern, like this:
-->
<p>Comme nous l'avons vu au chapitre 6, nous utilisons les motifs dans les
branches des expressions <code>match</code>. Techniquement, les expressions <code>match</code> sont
d√©finies avec le mot-cl√© <code>match</code>, une valeur sur laquelle proc√©der et une ou
plusieurs branches qui constituent un motif, chacune associ√©e √† une expression
√† ex√©cuter si la valeur correspond au motif de la branche, comme ceci¬†:</p>
<!--
```text
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```
-->
<pre><code class="language-text">match VALEUR {
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
}
</code></pre>
<!--
One requirement for `match` expressions is that they need to be *exhaustive* in
the sense that all possibilities for the value in the `match` expression must
be accounted for. One way to ensure you‚Äôve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.
-->
<p>L'une des conditions √† respecter pour les expressions <code>match</code> est qu'elles
doivent √™tre <em>exhaustives</em> dans le sens o√π toutes les valeurs possibles de la
valeur pr√©sente dans l'expression <code>match</code> doivent √™tre prises en compte. Une
fa√ßon de s'assurer que vous avez couvert toutes les possibilit√©s est d'avoir un
motif passe-partout pour la derni√®re branche¬†: par exemple, une valeur
quelconque ne pourra jamais √©chouer car la derni√®re branche permet de couvrir
tous les autres cas possibles.</p>
<!--
A particular pattern `_` will match anything, but it never binds to a variable,
so it‚Äôs often used in the last match arm. The `_` pattern can be useful when
you want to ignore any value not specified, for example. We‚Äôll cover the `_`
pattern in more detail in the [‚ÄúIgnoring Values in a
Pattern‚Äù][ignoring-values-in-a-pattern]<!-- ignore -- > section later in this
chapter.
-->
<p>Le motif sp√©cifique <code>_</code> va correspondre √† tout, mais il ne fournira jamais de
variable, donc il est souvent utilis√© dans la derni√®re branche. Le motif <code>_</code>
peut par exemple √™tre utile lorsque vous souhaitez ignorer toutes les autres
valeurs qui n'ont pas √©t√© list√©es. Nous allons voir plus en d√©tail le motif <code>_</code>
dans une section
<a href="ch18-03-pattern-syntax.html">plus tard dans ce chapitre</a><!-- ignore -->.</p>
<!--
### Conditional `if let` Expressions
-->
<h3 id="les-expressions-conditionnelles-if-let"><a class="header" href="#les-expressions-conditionnelles-if-let">Les expressions conditionnelles <code>if let</code></a></h3>
<!--
In Chapter 6 we discussed how to use `if let` expressions mainly as a shorter
way to write the equivalent of a `match` that only matches one case.
Optionally, `if let` can have a corresponding `else` containing code to run if
the pattern in the `if let` doesn‚Äôt match.
-->
<p>Au chapitre 6, nous avons vu comment utiliser les expressions <code>if let</code>,
principalement pour pouvoir √©crire l'√©quivalent d'un <code>match</code> qui ne correspond
qu'√† un seul cas.
Accessoirement, <code>if let</code> peut avoir un <code>else</code> correspondant au code √† ex√©cuter
si le motif du <code>if let</code> ne correspond pas au premier crit√®re.</p>
<!--
Listing 18-1 shows that it‚Äôs also possible to mix and match `if let`, `else
if`, and `else if let` expressions. Doing so gives us more flexibility than a
`match` expression in which we can express only one value to compare with the
patterns. Also, the conditions in a series of `if let`, `else if`, `else if
let` arms aren‚Äôt required to relate to each other.
-->
<p>L'encart 18-1 montre qu'il est aussi possible de conjuguer les expressions
<code>if let</code>, <code>else if</code> et <code>else if let</code>. Faire ceci nous donne plus de
flexibilit√© qu'une expression <code>match</code> dans laquelle nous ne pouvons
fournir qu'une seule valeur √† comparer avec les motifs. De plus, dans une s√©rie
de branches <code>if let</code>, <code>else if</code> et <code>else if let</code>, les conditions n'ont pas
besoin d'√™tre en rapport les unes avec les autres.</p>
<!--
The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, we‚Äôve created
variables with hardcoded values that a real program might receive from user
input.
-->
<p>Le code de l'encart 18-1 montre une s√©rie de v√©rifications pour quelques
conditions qui d√©cident quelle devrait √™tre la couleur de fond. Pour cet
exemple, nous avons cr√©√© les variables avec des valeurs cod√©es en dur qu'un
vrai programme devrait recevoir d'une saisie d'un utilisateur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let couleur_favorite: Option&lt;&amp;str&gt; = None;
    let on_est_mardi = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(couleur) = couleur_favorite {
        println!(&quot;Utilisation de votre couleur favorite, {}, comme couleur de fond&quot;, couleur);
    } else if on_est_mardi {
        println!(&quot;Mardi, c'est le jour du vert¬†!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Utilisation du violet comme couleur de fond&quot;);
        } else {
            println!(&quot;Utilisation de l'orange comme couleur de fond&quot;);
        }
    } else {
        println!(&quot;Utilisation du bleu comme couleur de fond&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-1: Mixing `if let`, `else if`, `else if let`,
and `else`</span>
-->
<p><span class="caption">Encart 18-1¬†: m√©lange de <code>if let</code>, <code>else if</code>,
<code>else if let</code>, et <code>else</code></span></p>
<!--
If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue.
-->
<p>Si l'utilisateur renseigne une couleur favorite, c'est cette couleur qui
devient la couleur de fond. Sinon, si nous sommes mardi, la couleur de fond
sera le vert. Sinon, si l'utilisateur a renseign√© son √¢ge dans une cha√Æne de
caract√®res et que nous pouvons l'interpr√©ter comme un nombre avec succ√®s, la
couleur de fond sera soit le violet, soit l'orange en fonction de la valeur de
ce nombre. Enfin, si aucune de ces conditions ne s'applique, la couleur de fond
sera le bleu.</p>
<!--
This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print `Using purple as the
background color`.
-->
<p>Cette structure conditionnelle nous permet de r√©pondre √† des conditions
complexes. Avec les valeurs cod√©es en dur que nous avons ici, cet exemple
devrait afficher <code>Utilisation du violet comme couleur de fond</code>.</p>
<!--
You can see that `if let` can also introduce shadowed variables in the same way
that `match` arms can: the line `if let Ok(age) = age` introduces a new
shadowed `age` variable that contains the value inside the `Ok` variant. This
means we need to place the `if age > 30` condition within that block: we can‚Äôt
combine these two conditions into `if let Ok(age) = age && age > 30`. The
shadowed `age` we want to compare to 30 isn‚Äôt valid until the new scope starts
with the curly bracket.
-->
<p>Vous pouvez constater que le <code>if let</code> nous permet d'utiliser les variables
masqu√©es de la m√™me mani√®re que le font les branches <code>match</code>¬†: la ligne
<code>if let Ok(age) = age</code> cr√©e une nouvelle variable masqu√©e <code>age</code> qui contient la
valeur pr√©sente dans la variante <code>Ok</code>. Cela signifie que nous devons placer la
condition <code>if age &gt; 30</code> √† l'int√©rieur de ce bloc¬†: nous ne pouvons pas combiner
ces deux conditions dans une seule <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. La
variable masqu√©e <code>age</code> que nous souhaitons comparer √† 30 n'est pas encore en
vigueur tant que la nouvelle port√©e entre les accolades n'a pas commenc√©e.</p>
<!--
The downside of using `if let` expressions is that the compiler doesn‚Äôt check
exhaustiveness, whereas with `match` expressions it does. If we omitted the
last `else` block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.
-->
<p>Le d√©savantage de l'utilisation des expressions <code>if let</code> est que le compilateur
ne v√©rifie pas l'exhaustivit√© contrairement √† une expression <code>match</code>. Si nous avions
enlev√© le dernier bloc <code>else</code>, oubliant ainsi de g√©rer certains cas,
le compilateur n'aurait pas pu nous pr√©venir d'un possible bogue de logique.</p>
<!--
### `while let` Conditional Loops
-->
<h3 id="les-boucles-conditionelles-while-let"><a class="header" href="#les-boucles-conditionelles-while-let">les boucles conditionelles <code>while let</code></a></h3>
<!--
Similar in construction to `if let`, the `while let` conditional loop allows a
`while` loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a `while let` loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed.
-->
<p>Comme les constructions <code>if let</code>, les boucles conditionnelles <code>while let</code>
permettent √† une boucle <code>while</code> de s'ex√©cuter aussi longtemps qu'un motif
continue √† correspondre. L'exemple dans l'encart 18-2 montre une boucle
<code>while let</code> qui utilise un vecteur comme une pile et affiche les valeurs du
vecteur dans l'ordre oppos√© √† celui dans lequel elles ont √©t√© ins√©r√©es.</p>
<!--
```rust
# fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut pile = Vec::new();

    pile.push(1);
    pile.push(2);
    pile.push(3);

    while let Some(donnee_du_haut) = pile.pop() {
        println!(&quot;{}&quot;, donnee_du_haut);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-2: Using a `while let` loop to print values
for as long as `stack.pop()` returns `Some`</span>
-->
<p><span class="caption">Encart 18-2¬†: utilisation d'une boucle <code>while let</code> pour
afficher les valeurs aussi longtemps que <code>pile.pop()</code> retourne une <code>Some</code></span></p>
<!--
This example prints 3, 2, and then 1. The `pop` method takes the last element
out of the vector and returns `Some(value)`. If the vector is empty, `pop`
returns `None`. The `while` loop continues running the code in its block as
long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can
use `while let` to pop every element off our stack.
-->
<p>Cet exemple affiche 3, 2 puis ensuite 1. La m√©thode <code>pop</code> sort le dernier
√©l√©ment du vecteur et retourne <code>Some(valeur)</code>. Si le vecteur est vide, <code>pop</code>
retourne alors <code>None</code>. La boucle <code>while</code> continue √† ex√©cuter le code de son bloc
aussi longtemps que <code>pop</code> retourne un <code>Some</code>. Lorsque <code>pop</code> retournera <code>None</code>,
la boucle s'arr√™tera. Nous pouvons utiliser <code>while let</code> pour extraire tous les
√©l√©ments de la pile.</p>
<!--
### `for` Loops
-->
<h3 id="les-boucles-for"><a class="header" href="#les-boucles-for">Les boucles <code>for</code></a></h3>
<!--
In Chapter 3, we mentioned that the `for` loop is the most common loop
construction in Rust code, but we haven‚Äôt yet discussed the pattern that `for`
takes. In a `for` loop, the pattern is the value that directly follows the
keyword `for`, so in `for x in y` the `x` is the pattern.
-->
<p>Au chapitre 3, nous avions mentionn√© que la boucle <code>for</code> √©tait la construction
de boucle la plus utilis√©e dans du code Rust, mais nous n'avons pas encore abord√©
le motif que prend <code>for</code>. Dans une boucle <code>for</code>, le motif est la valeur qui suit
directement le mot-cl√© <code>for</code>, de sorte que <code>x</code> est le motif dans <code>for x in y</code>.</p>
<!--
Listing 18-3 demonstrates how to use a pattern in a `for` loop to destructure,
or break apart, a tuple as part of the `for` loop.
-->
<p>L'encart 18-3 montre comment utiliser un motif dans une boucle <code>for</code> pour
d√©structurer, ou d√©composer, un tuple faisant partie de la boucle <code>for</code>.</p>
<!--
```rust
# fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (indice, valeur) in v.iter().enumerate() {
        println!(&quot;{} est √† l'indice {}&quot;, valeur, indice);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-3: Using a pattern in a `for` loop to
destructure a tuple</span>
-->
<p><span class="caption">Encart 18-3¬†: utilisation d'un motif dans une boucle <code>for</code>
pour d√©structurer un tuple</span></p>
<!--
The code in Listing 18-3 will print the following:
-->
<p>Le code de l'encart 18-3 va afficher ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a est √† l'indice 0
b est √† l'indice 1
c est √† l'indice 2
</code></pre>
<!--
We use the `enumerate` method to adapt an iterator to produce a value and that
value‚Äôs index in the iterator, placed into a tuple. The first value produced is
the tuple `(0, 'a')`. When this value is matched to the pattern `(index,
value)`, `index` will be `0` and `value` will be `'a'`, printing the first line
of the output.
-->
<p>Nous avons utilis√© la m√©thode <code>enumerate</code> pour produire une valeur et son indice
√† partir d'un it√©rateur que nous avons plac√© dans un tuple. La premiere valeur
produite est le tuple <code>(0, 'a')</code>. Comme cette valeur correspond au motif
<code>(indice, valeur)</code>, <code>indice</code> se voit affecter <code>0</code>, <code>valeur</code> se voit affecter <code>'a'</code>,
provoquant l'affichage de la premi√®re ligne sur la sortie.</p>
<!--
### `let` Statements
-->
<h3 id="les-instructions-let"><a class="header" href="#les-instructions-let">Les instructions <code>let</code></a></h3>
<!--
Prior to this chapter, we had only explicitly discussed using patterns with
`match` and `if let`, but in fact, we‚Äôve used patterns in other places as well,
including in `let` statements. For example, consider this straightforward
variable assignment with `let`:
-->
<p>Avant d'arriver √† ce chapitre, nous n'avions abord√© explicitement l'utilisation
des motifs qu'avec <code>match</code> et <code>if let</code>, mais en r√©alit√©, nous avions utilis√©
les motifs dans d'autres endroits, y compris dans les instructions <code>let</code>. Par
exemple, consid√©rons l'assignation de la variable suivante avec <code>let</code>¬†:</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Throughout this book, we‚Äôve used `let` like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a `let` statement looks like this:
-->
<p>Tout au long de ce livre, nous avons utilis√© <code>let</code> de cette mani√®re des
centaines de fois, et malgr√© tout vous ne vous √™tes probablement pas rendu
compte que vous utilisiez les motifs¬†! Plus formellement, une instruction <code>let</code>
ressemble √† ceci¬†:</p>
<!--
```text
let PATTERN = EXPRESSION;
```
-->
<pre><code class="language-text">let MOTIF = EXPRESSION;
</code></pre>
<!--
In statements like `let x = 5;` with a variable name in the `PATTERN` slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
`let x = 5;` example, `x` is a pattern that means ‚Äúbind what matches here to
the variable `x`.‚Äù Because the name `x` is the whole pattern, this pattern
effectively means ‚Äúbind everything to the variable `x`, whatever the value is.‚Äù
-->
<p>Dans des instructions telles que <code>let x = 5;</code> avec un nom de variable dans
l'emplacement <code>MOTIF</code>, le nom de la variable n'est juste qu'une forme
particuli√®rement simple de motif. Rust compare l'expression avec le motif et
assigne tous les noms qu'il trouve. Dans l'exemple <code>let x = 5;</code>, <code>x</code> est un
motif qui signifie ‚Äúrelie ce qui correspond ici √† la variable <code>x</code>‚Äù.  Puisque le
nom <code>x</code> constitue un motif complet, il signifie exactement ‚Äúrelie tout ce qui
suit √† la variable <code>x</code>, quelle qu'en soit la valeur‚Äù.</p>
<!--
To see the pattern matching aspect of `let` more clearly, consider Listing
18-4, which uses a pattern with `let` to destructure a tuple.
-->
<p>Pour comprendre plus clairement l'aspect filtrage par motif de <code>let</code>, examinons
l'encart 18-4, qui utilise un motif <code>let</code> pour destructurer un tuple.</p>
<!--
```rust
# fn main() {
    let (x, y, z) = (1, 2, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span>
-->
<p><span class="caption">Encart 18-4¬†: utilisation d'un motif pour destructurer un
tuple et cr√©er trois variables √† la fois</span></p>
<!--
Here, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)`
to the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust
binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple
pattern as nesting three individual variable patterns inside it.
-->
<p>Ici, nous avons fait correspondre un tuple √† un motif. Rust compare la valeur
<code>(1, 2, 3)</code> avec le motif <code>(x, y, z)</code> et constate que la valeur correspond au motif,
donc Rust relie <code>1</code> √† <code>x</code>, <code>2</code> √† <code>y</code> et <code>3</code> √† <code>z</code>. Vous pouvez ainsi consid√©rer
que ce motif de tuple encapsule trois variables individuelles.</p>
<!--
If the number of elements in the pattern doesn‚Äôt match the number of elements
in the tuple, the overall type won‚Äôt match and we‚Äôll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won‚Äôt work.
-->
<p>Si le nombre d'√©l√©ments dans le motif ne correspond pas au nombre d'√©l√©ments
dans le tuple, le type global ne va pas correspondre et nous allons obtenir
une erreur de compilation. Par exemple, l'encart 18-5 montre une tentative de
d√©structurer un tuple avec trois √©l√©ments dans deux variables, ce qui ne va pas
fonctionner.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let (x, y) = (1, 2, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don‚Äôt match the number of elements in the tuple</span>
-->
<p><span class="caption">Encart 18-5¬†: construction incorrecte d'un motif dont les
variables ne vont pas correspondre au nombre d'√©l√©ments pr√©sents dans le tuple
</span></p>
<!--
Attempting to compile this code results in this type error:
-->
<p>Si vous essayez de compiler ce code, vous obtiendrez cette erreur de type¬†:</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 -- > src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre>
<!--
If we wanted to ignore one or more of the values in the tuple, we could use `_`
or `..`, as you‚Äôll see in the [‚ÄúIgnoring Values in a
Pattern‚Äù][ignoring-values-in-a-pattern]<!-- ignore -- > section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.
-->
<p>Si nous souhaitons ignorer une ou plusieurs valeurs dans un tuple, nous pouvons
utiliser <code>_</code> ou <code>..</code>, comme vous allez le voir √† la derni√®re section de ce
chapitre. Si le probl√®me est que nous avons trop de variables dans le motif, la
solution pour faire correspondre les types consiste √† enlever des variables de
fa√ßon √† ce que le nombre de variables corresponde au nombre d'√©l√©ments pr√©sents
dans le tuple.</p>
<!--
### Function Parameters
-->
<h3 id="les-param√®tres-de-fonctions"><a class="header" href="#les-param√®tres-de-fonctions">Les param√®tres de fonctions</a></h3>
<!--
Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named `foo` that takes one parameter named `x` of type
`i32`, should by now look familiar.
-->
<p>Les param√®tres de fonctions peuvent aussi √™tre des motifs. Le code de l'encart
18-6 d√©clare une fonction <code>foo</code> qui prend un param√®tre <code>x</code> de type <code>i32</code>.</p>
<!--
```rust
fn foo(x: i32) {
    // code goes here
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(x: i32) {
    // le code se place ici
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span>
-->
<p><span class="caption">Encart 18-6¬†: une signature de fonction qui utilise des
motifs dans ses param√®tres</span></p>
<!--
The `x` part is a pattern! As we did with `let`, we could match a tuple in a
function‚Äôs arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.
-->
<p>La partie <code>x</code> est un motif¬†! Comme nous l'avons dit pour <code>let</code>, nous pouvons
faire correspondre le motif avec un tuple dans les arguments de la fonction.
L'encart 18-7 d√©structure les valeurs d'un tuple que nous passons en argument
d'une fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn afficher_coordonnees(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Coordonn√©es actuelles¬†: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    afficher_coordonnees(&amp;point);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span>
-->
<p><span class="caption">Encart 18-7¬†: une fonction avec des param√®tres qui
d√©structurent un tuple</span></p>
<!--
This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the
pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`.
-->
<p>Ce code affiche <code>Coordon√©es actuelles¬†: (3, 5)</code>. Les valeurs <code>&amp;(3, 5)</code>
correspondent au motif <code>&amp;(x, y)</code>, donc <code>x</code> a la valeur <code>3</code> et <code>y</code> a la valeur
<code>5</code>.</p>
<!--
We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.
-->
<p>Nous pouvons aussi utiliser les motifs dans la liste des param√®tres d'une
fermeture de la m√™me mani√®re que dans la liste des param√®tres d'une fonction,
car les fermetures sont similaires aux fonctions, comme nous l'avons dit au
chapitre 13.</p>
<!--
At this point, you‚Äôve seen several ways of using patterns, but patterns don‚Äôt
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We‚Äôll discuss
these two concepts next.
-->
<p>A pr√©sent, vous avez vu plusieurs fa√ßons d'utiliser les motifs, mais les motifs
ne fonctionnent pas de la m√™me mani√®re dans toutes les situations o√π nous les
utilisons. Des fois, le motif sera irr√©futable¬†; d'autres fois, il sera
r√©futable. C'est ce que nous allons voir tout de suite.</p>
<!--
[ignoring-values-in-a-pattern]:
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Refutability: Whether a Pattern Might Fail to Match
-->
<h2 id="la-r√©futabilit√©--lorsquun-motif-peut-√©chouer-√†-correspondre"><a class="header" href="#la-r√©futabilit√©--lorsquun-motif-peut-√©chouer-√†-correspondre">La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></h2>
<!--
Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are *irrefutable*. An example would be `x` in the
statement `let x = 5;` because `x` matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
*refutable*. An example would be `Some(x)` in the expression `if let Some(x) =
a_value` because if the value in the `a_value` variable is `None` rather than
`Some`, the `Some(x)` pattern will not match.
-->
<p>Les motifs se divisent en deux cat√©gories¬†: r√©futables et irr√©futables. Les
motifs qui vont correspondre √† n'importe quelle valeur qu'on lui passe sont
<em>irr√©futables</em>. Un exemple serait le <code>x</code> dans l'instruction <code>let x = 5;</code> car
<code>x</code> correspond √† tout ce qui est possible de sorte que la
correspondance ne puisse pas √©chouer. Les motifs pour lesquels la correspondance
peut √©chouer pour certains valeurs
sont <em>r√©futables</em>. Un exemple serait <code>Some(x)</code> dans l'expression
<code>if let Some(x) = une_valeur</code> car si la valeur dans la variable <code>une_valeur</code> est
<code>None</code> au lieu de <code>Some</code>, le motif <code>Some(x)</code> ne correspondra pas.</p>
<!--
Function parameters, `let` statements, and `for` loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don‚Äôt match. The `if let` and `while let` expressions accept
refutable and irrefutable patterns, but the compiler warns against
irrefutable patterns because by definition they‚Äôre intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.
-->
<p>Les param√®tres de fonctions, les instructions <code>let</code> et les boucles <code>for</code> ne
peuvent accepter que des motifs irr√©futables, car le programme ne peut rien
faire d'autre lorsque les valeurs ne correspondent pas. Les expressions
<code>if let</code> et <code>while let</code> acceptent les motifs r√©futables et irr√©futables, mais
dans le second cas, le compilateur affichera une mise en garde car, par
d√©finition, ces expressions sont destin√©es √† g√©rer un probl√®me √©ventuel¬†: le
but des conditions est de se comporter diff√©remment en fonction de la r√©ussite
ou de l'√©chec.</p>
<!--
In general, you shouldn‚Äôt have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you‚Äôll need to change either the pattern or the construct you‚Äôre
using the pattern with, depending on the intended behavior of the code.
-->
<p>De mani√®re g√©n√©rale, vous ne devriez pas avoir √† vous soucier des diff√©rences
entre les motifs r√©futables et irr√©futables¬†; en revanche, vous devez vous
familiariser avec le concept de r√©futabilit√© afin que vous puissiez comprendre
ce qui se passe lorsque vous le verrez appara√Ætre dans un message d'erreur.
Dans ce cas, vous allez avoir besoin de changer soit le motif, soit la
construction avec laquelle vous l'utilisez, selon le comportement attendu du
code.</p>
<!--
Let‚Äôs look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
`let` statement, but for the pattern we‚Äôve specified `Some(x)`, a refutable
pattern. As you might expect, this code will not compile.
-->
<p>Examinons un exemple de ce qu'il se passe lorsque nous essayons d'utiliser un
motif r√©futable lorsque Rust pr√©voit d'utiliser un motif irr√©futable, et
vice-versa. L'encart 18-8 montre une instruction <code>let</code>, mais comme le motif nous
avons indiqu√© <code>Some(x)</code>, un motif r√©futable. Comme vous pouvez vous en douter,
ce code ne va pas se compiler.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let some_option_value: Option<i32> = None;
    let Some(x) = some_option_value;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let une_option_quelconque: Option&lt;i32&gt; = None;
</span>    let Some(x) = une_option_quelconque;
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-8: Attempting to use a refutable pattern with
`let`</span>
-->
<p><span class="caption">Encart 18-8¬†: tentative d'utilisation d'un motif
r√©futable avec <code>let</code></span></p>
<!--
If `some_option_value` was a `None` value, it would fail to match the pattern
`Some(x)`, meaning the pattern is refutable. However, the `let` statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a `None` value. At compile time, Rust will complain that we‚Äôve tried to
use a refutable pattern where an irrefutable pattern is required:
-->
<p>Si <code>une_option_quelconque</code> √©tait une valeur <code>None</code>, elle ne correspondrait pas
au motif <code>Some(x)</code>, ce qui signifie que le motif est r√©futable. Cependant,
l'instruction <code>let</code> ne peut accepter qu'un motif irr√©futable car il n'existe
pas d'instructions valides √† ex√©cuter avec une valeur <code>None</code>. A la compilation,
Rust s'y opposera en expliquant que nous avons essay√© d'utiliser un motif
r√©futable l√† o√π un motif irr√©futable est n√©cessaire¬†:</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
   -- > src/main.rs:3:9
    |
3   |     let Some(x) = some_option_value;
    |         ^^^^^^^ pattern `None` not covered
    |
    = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
    = note: the matched value is of type `Option<i32>`
help: you might want to use `if let` to ignore the variant that isn't matched
    |
3   |     if let Some(x) = some_option_value { /* */ }
    |

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
   --&gt; src/main.rs:3:9
    |
3   |     let Some(x) = une_option_quelconque;
    |         ^^^^^^^ pattern `None` not covered
    |
    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
    = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `if let` to ignore the variant that isn't matched
    |
3   |     if let Some(x) = une_option_quelconque { /* */ }
    |

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
</code></pre>
<!--
Because we didn‚Äôt cover (and couldn‚Äôt cover!) every valid value with the
pattern `Some(x)`, Rust rightfully produces a compiler error.
-->
<p>Comme nous n'avons pas couvert (et nous ne pouvons pas le faire¬†!) chaque
valeur possible avec le motif <code>Some(x)</code>, Rust g√©n√®re une erreur de compilation,
√† juste titre.</p>
<!--
To fix the problem where we have a refutable pattern where an irrefutable
pattern is needed, we can change the code that uses the pattern: instead of
using `let`, we can use `if let`. Then if the pattern doesn‚Äôt match, the code
will just skip the code in the curly brackets, giving it a way to continue
validly. Listing 18-9 shows how to fix the code in Listing 18-8.
-->
<p>Pour corriger le probl√®me lorsque nous avons un motif r√©futable l√† o√π un motif
irr√©futable est n√©cessaire, nous pouvons modifier le code qui utilise ce motif¬†:
au lieu d'utiliser <code>let</code>, nous pouvons utiliser <code>if let</code>. Dans ce cas, si le
motif ne correspond pas, le programme va simplement sauter le code entre les
accolades, ce qui lui permet de poursuivre son ex√©cution sans rencontrer
d'erreur. L'encart 18-9 montre comment corriger le code de l'encart 18-8.</p>
<!--
```rust
# fn main() {
#     let some_option_value: Option<i32> = None;
    if let Some(x) = some_option_value {
        println!("{}", x);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let une_option_quelconque: Option&lt;i32&gt; = None;
</span>    if let Some(x) = une_option_quelconque {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-9: Using `if let` and a block with refutable
patterns instead of `let`</span>
-->
<p><span class="caption">Encart 18-9¬†: utilisation de <code>if let</code> et d'un bloc avec
un motif r√©futable plut√¥t qu'un <code>let</code></span></p>
<!--
We‚Äôve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give `if
let` a pattern that will always match, such as `x`, as shown in Listing 18-10,
the compiler will give a warning.
-->
<p>Nous avons donn√© au code une porte de sortie. Ce code est parfaitement valide,
cependant il implique que nous ne pouvons pas utiliser un motif irr√©futable
sans provoquer une erreur. Si nous donnons au <code>if let</code> un motif qui correspond
toujours, tel que <code>x</code>, comme montr√© dans l'encart 18-10, le compilateur va
lever un avertissement.</p>
<!--
```rust
# fn main() {
    if let x = 5 {
        println!("{}", x);
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with `if let`</span>
-->
<p><span class="caption">Encart 18-10¬†: tentative d'utiliser un motif irr√©futable
avec <code>if let</code></span></p>
<!--
Rust complains that it doesn‚Äôt make sense to use `if let` with an irrefutable
pattern:
-->
<p>Rust explique que cela ne fait aucun sens d'utiliser <code>if let</code> avec un motif
irr√©futable¬†:</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 -- > src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

warning: `patterns` (bin "patterns") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<!--
For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a `match` with only one arm, but
this syntax isn‚Äôt particularly useful and could be replaced with a simpler
`let` statement.
-->
<p>C'est pourquoi les branches de <code>match</code> doivent utiliser des motifs r√©futables,
sauf pour la derni√®re branche, qui devrait correspondre √† n'importe quelle
valeur gr√¢ce √† un motif irr√©futable. Rust nous permet d'utiliser un motif
irr√©futable dans un <code>match</code> ne poss√©dant qu'une seule branche, mais cette
syntaxe n'est pas particuli√®rement utile et devrait √™tre remplac√©e par une
instruction <code>let</code> plus simple.</p>
<!--
Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let‚Äôs cover all the syntax we can use to create
patterns.
-->
<p>Maintenant que vous savez o√π utiliser les motifs et que vous connaissez la
diff√©rence entre les motifs r√©futables et irr√©futables, voyons toutes les
syntaxes que nous pouvons utiliser pour cr√©er des motifs.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Pattern Syntax
-->
<h2 id="la-syntaxe-des-motifs"><a class="header" href="#la-syntaxe-des-motifs">La syntaxe des motifs</a></h2>
<!--
Throughout the book, you‚Äôve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each one.
-->
<p>Tout au long de ce livre, vous avez rencontr√© de nombreux types de motifs. Dans cette
section, nous allons rassembler toutes les syntaxes valides des motifs et
examiner les raisons pour lesquelles vous devriez utiliser chacune d'entre
elles.</p>
<!--
### Matching Literals
-->
<h3 id="correspondre-aux-litt√©raux"><a class="header" href="#correspondre-aux-litt√©raux">Correspondre aux litt√©raux</a></h3>
<!--
As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:
-->
<p>Comme vous l'avez vu chapitre 6, vous pouvez faire directement correspondre des
motifs avec des litt√©raux. Le code suivant vous donne quelques exemples¬†:</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;un&quot;),
        2 =&gt; println!(&quot;deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;n'importe quoi&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one` because the value in `x` is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.
-->
<p>Ce code affiche <code>un</code> car la valeur dans <code>x</code> est <code>1</code>. Cette syntaxe est tr√®s
utile lorsque vous souhaitez que votre code fasse quelque chose s'il obtient une
valeur pr√©cise.</p>
<!--
### Matching Named Variables
-->
<h3 id="correspondre-√†-des-variables-nomm√©es"><a class="header" href="#correspondre-√†-des-variables-nomm√©es">Correspondre √† des variables nomm√©es</a></h3>
<!--
Named variables are irrefutable patterns that match any value, and we‚Äôve used
them many times in the book. However, there is a complication when you use
named variables in `match` expressions. Because `match` starts a new scope,
variables declared as part of a pattern inside the `match` expression will
shadow those with the same name outside the `match` construct, as is the case
with all variables. In Listing 18-11, we declare a variable named `x` with the
value `Some(5)` and a variable `y` with the value `10`. We then create a
`match` expression on the value `x`. Look at the patterns in the match arms and
`println!` at the end, and try to figure out what the code will print before
running this code or reading further.
-->
<p>Les variables nomm√©es sont des motifs irr√©futables qui correspondent √†
n'importe quelle valeur, et nous les avons utilis√©es de nombreuses fois dans le
livre. Cependant, il subsiste un probl√®me lorsque vous utilisez les variables
nomm√©es dans les expressions <code>match</code>. Comme <code>match</code> d√©bute une nouvelle port√©e,
les variables utilis√©es comme faisant partie du motif de la construction
<code>match</code> vont masquer celles ayant le m√™me nom et provenant de l'ext√©rieur de la
construction <code>match</code>, comme c'est le cas avec toutes les variables. Dans
l'encart 18-11, nous d√©clarons une variable <code>x</code> avec la valeur <code>Some(5)</code> et une
variable <code>y</code> avec la valeur <code>10</code>. Nous cr√©ons alors une expression <code>match</code> sur
la valeur <code>x</code>. Observez les motifs sur les branches du <code>match</code> et du <code>println!</code>
√† la fin, et essayez de deviner ce qui sera √©crit avant d'ex√©cuter ce code ou
de lire la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;On a 50&quot;),
        Some(y) =&gt; println!(&quot;Correspondance, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Cas par d√©faut, x = {:?}&quot;, x),
    }

    println!(&quot;A la fin¬†: x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-11: A `match` expression with an arm that
introduces a shadowed variable `y`</span>
-->
<p><span class="caption">Encart 18-11¬†: une expression <code>match</code> avec une branche
qui cr√©e une variable masqu√©e <code>y</code></span></p>
<!--
Let‚Äôs walk through what happens when the `match` expression runs. The pattern
in the first match arm doesn‚Äôt match the defined value of `x`, so the code
continues.
-->
<p>Voyons ce qui se passe lorsque l'expression <code>match</code> est utilis√©e. Le motif
pr√©sent dans la premi√®re branche du <code>match</code> ne correspond pas √† la valeur
actuelle de <code>x</code>, donc le code passe √† la branche suivante.</p>
<!--
The pattern in the second match arm introduces a new variable named `y` that
will match any value inside a `Some` value. Because we‚Äôre in a new scope inside
the `match` expression, this is a new `y` variable, not the `y` we declared at
the beginning with the value 10. This new `y` binding will match any value
inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to
the inner value of the `Some` in `x`. That value is `5`, so the expression for
that arm executes and prints `Matched, y = 5`.
-->
<p>Le motif dans la deuxi√®me branche du <code>match</code> ajoute une nouvelle variable <code>y</code>
qui va correspondre √† n'importe quelle valeur log√©e dans une valeur <code>Some</code>.
Comme nous sommes dans une nouvelle port√©e √† l'int√©rieur de l'expression
<code>match</code>, c'est une nouvelle variable <code>y</code>, et pas le <code>y</code> que nous avons
d√©clar√© au d√©but avec la valeur 10. Cette nouvelle correspondance <code>y</code> va
correspondre √† n'importe quelle valeur √† l'int√©rieur d'un <code>Some</code>, ce qui est
la situation pr√©sente actuellement dans <code>x</code>. Ainsi, ce nouveau <code>y</code> correspondra
√† la valeur interne du <code>Some</code> pr√©sent dans <code>x</code>. Cette valeur est <code>5</code>, donc
l'expression de cette branche s'ex√©cute et affiche <code>Correspondance, y = 5</code>.</p>
<!--
If `x` had been a `None` value instead of `Some(5)`, the patterns in the first
two arms wouldn‚Äôt have matched, so the value would have matched to the
underscore. We didn‚Äôt introduce the `x` variable in the pattern of the
underscore arm, so the `x` in the expression is still the outer `x` that hasn‚Äôt
been shadowed. In this hypothetical case, the `match` would print `Default
case, x = None`.
-->
<p>En supposant maintenant que <code>x</code> ait la valeur <code>None</code> plut√¥t que <code>Some(5)</code>, les
motifs pr√©sents dans les deux premi√®res branches ne correspondront pas, donc la
valeur qui correspondra sera celle avec le tiret du bas. Comme nous n'avons pas
introduit de nouvelle variable <code>x</code> dans la branche du motif, le <code>x</code> de
l'expression associ√©e d√©signe toujours la variable <code>x</code> en dehors et qui n'a pas
√©t√© masqu√©e. Le <code>match</code> va donc afficher <code>Cas par d√©faut, x = None</code>.</p>
<!--
When the `match` expression is done, its scope ends, and so does the scope of
the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.
-->
<p>Lorsque l'expression <code>match</code> est termin√©e, sa port√©e se termine √©galement, et
avec elle la port√©e de la variable interne <code>y</code>. Le dernier <code>println!</code> affiche
donc <code>A la fin¬†: x = Some(5), y = 10</code>.</p>
<!--
To create a `match` expression that compares the values of the outer `x` and
`y`, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We‚Äôll talk about match guards later in the [‚ÄúExtra
Conditionals with Match Guards‚Äù](#extra-conditionals-with-match-guards)<!--
ignore -- > section.
-->
<p>Pour cr√©er une expression <code>match</code> qui compare les valeurs de la variable
externe <code>x</code> avec <code>y</code>, plut√¥t que d'utiliser une variable masqu√©e, nous aurions
besoin d'utiliser √† la place un contr√¥le de correspondance. Nous verrons les
contr√¥les de correspondance dans une des sections suivantes.</p>
<!--
### Multiple Patterns
-->
<h3 id="plusieurs-motifs"><a class="header" href="#plusieurs-motifs">Plusieurs motifs</a></h3>
<!--
In `match` expressions, you can match multiple patterns using the `|` syntax,
which means *or*. For example, the following code matches the value of `x`
against the match arms, the first of which has an *or* option, meaning if the
value of `x` matches either of the values in that arm, that arm‚Äôs code will
run:
-->
<p>Dans les expressions <code>match</code>, vous pouvez faire correspondre une m√™me branche √†
plusieurs motifs en utilisant la syntaxe <code>|</code>, qui signifie <em>ou</em>. Par exemple,
dans le code suivant appliquant un <code>match</code> sur la valeur de <code>x</code>, la premi√®re
des branches poss√®de une option <em>ou</em>, ce qui signifie que si la valeur de <code>x</code>
correspond √† l'un ou l'autre des motifs de cette branche, le code associ√© sera
ex√©cut√©¬†:</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;un ou deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one or two`.
-->
<p>Ce code va afficher <code>un ou deux</code>.</p>
<!--
### Matching Ranges of Values with `..=`
-->
<h3 id="faire-correspondre-un-intervalle-de-valeurs-avec-"><a class="header" href="#faire-correspondre-un-intervalle-de-valeurs-avec-">Faire correspondre un intervalle de valeurs avec <code>..=</code></a></h3>
<!--
The `..=` syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:
-->
<p>La syntaxe <code>..=</code> nous permet de faire correspondre un intervalle inclusif de
valeurs. Dans le code suivant, lorsqu'un motif correspond √† une des valeurs
pr√©sentes dans l'intervalle, cette branche va s'ex√©cuter¬†:</p>
<!--
```rust
# fn main() {
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;de un √† cinq&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the `|` operator to express the same idea; instead of
`1..=5`, we would have to specify `1 | 2 | 3 | 4 | 5` if we used `|`.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!
-->
<p>Si <code>x</code> vaut 1, 2, 3, 4 ou 5, la premi√®re branche va correspondre. Cette syntaxe
est plus pratique √† utiliser que d'avoir √† utiliser l'op√©rateur <code>|</code> pour
exprimer la m√™me id√©e¬†; √† la place de <code>1..=5</code> nous aurions d√ª √©crire
<code>1 | 2 | 3 | 4 | 5</code> si nous avions utilis√© <code>|</code>. Renseigner un intervalle est
bien plus court, en particulier si nous souhaitons avoir une correspondance
avec les valeurs comprises entre 1 et 1000 par exemple¬†!</p>
<!--
Ranges are only allowed with numeric values or `char` values, because the
compiler checks that the range isn‚Äôt empty at compile time. The only types for
which Rust can tell if a range is empty or not are `char` and numeric values.
-->
<p>Les intervalles peuvent √™tre des nombres ou des <code>char</code> (caract√®res), car le
compilateur v√©rifie que l'intervalle n'est pas vide au moment de la
compilation et les seuls types pour lesquels Rust peut dire si un intervalle est
vide ou non sont ceux constitu√©s de nombres ou de <code>char</code>.</p>
<!--
Here is an example using ranges of `char` values:
-->
<p>Voici un exemple d'utilisation d'intervalles de <code>char</code>¬†:</p>
<!--
```rust
# fn main() {
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;lettre ASCII du d√©but&quot;),
        'k'..='z' =&gt; println!(&quot;lettre ASCII de la fin&quot;),
        _ =&gt; println!(&quot;autre chose&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Rust can tell that `c` is within the first pattern‚Äôs range and prints `early
ASCII letter`.
-->
<p>Rust peut nous dire que <code>c</code> est dans le premier intervalle du premier motif et
afficher <code>lettre ASCII du d√©but</code>.</p>
<!--
### Destructuring to Break Apart Values
-->
<h3 id="destructurer-pour-s√©parer-les-valeurs"><a class="header" href="#destructurer-pour-s√©parer-les-valeurs">Destructurer pour s√©parer les valeurs</a></h3>
<!--
We can also use patterns to destructure structs, enums, and tuples to use
different parts of these values. Let‚Äôs walk through each value.
-->
<p>Nous pouvons aussi utiliser les motifs pour destructurer les structures, les
√©num√©rations, et les tuples pour utiliser diff√©rentes parties de ces valeurs.
Passons en revue chacun des cas.</p>
<!--
#### Destructuring Structs
-->
<h4 id="destructurer-les-structures"><a class="header" href="#destructurer-les-structures">Destructurer les structures</a></h4>
<!--
Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can
break apart using a pattern with a `let` statement.
-->
<p>L'encart 18-12 montre une structure <code>Point</code> avec deux champs, <code>x</code> et <code>y</code>, que
nous pouvons s√©parer en utilisant un motif avec une instruction <code>let</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-12: Destructuring a struct‚Äôs fields into
separate variables</span>
-->
<p><span class="caption">Encart 18-12¬†: d√©structuration des champs d'une structure
dans des variables s√©par√©es</span></p>
<!--
This code creates the variables `a` and `b` that match the values of the `x`
and `y` fields of the `p` struct. This example shows that the names of the
variables in the pattern don‚Äôt have to match the field names of the struct. But
it‚Äôs common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.
-->
<p>Ce code cr√©e les variables <code>a</code> et <code>b</code> qui correspondent aux valeurs des champs
<code>x</code> et <code>y</code> de la structure <code>p</code>. Cet exemple montre que les noms des variables
du motif n'ont pas √† correspondre aux noms des champs de la structure. Mais il
est courant de vouloir faire correspondre le nom des variables avec le nom des
champs pour se rappeler plus facilement quelle variable provient de quel champ.</p>
<!--
Because having variable names match the fields is common and because writing
`let Point { x: x, y: y } = p;` contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the `let` pattern are `x` and
`y` instead of `a` and `b`.
-->
<p>Comme faire correspondre les noms des variables avec ceux des champs est une
pratique courante et qu'√©crire <code>let Point { x: x, y: y } = p;</code> est inutilement
redondant, il existe un raccourci pour les motifs qui correspondent aux champs
des structures¬†: il vous suffit de lister simplement le nom des champs de la
structure pour que les variables cr√©√©es √† partir du motif aient les m√™mes noms.
L'encart 18-12 montre du code qui se comporte de la m√™me mani√®re que le code de
l'encart 18-12, mais dans lequel les variables cr√©√©es dans le motif du <code>let</code>
sont <code>x</code> et <code>y</code> au lieu de <code>a</code> et <code>b</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span>
-->
<p><span class="caption">Encart 18-13¬†: d√©structuration des champs d'une structure
en utilisant le raccourci pour les champs des structures</span></p>
<!--
This code creates the variables `x` and `y` that match the `x` and `y` fields
of the `p` variable. The outcome is that the variables `x` and `y` contain the
values from the `p` struct.
-->
<p>Ce code cr√©e les variables <code>x</code> et <code>y</code> qui correspondent aux champs <code>x</code> et <code>y</code>
de la variable <code>p</code>. Il en r√©sulte que les variables <code>x</code> et <code>y</code> contiennent les
valeurs correspondantes de la structure <code>p</code>.</p>
<!--
We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.
-->
<p>Nous pouvons aussi destructurer en utilisant des valeurs litt√©rales faisant partie
du motif de la structure plut√¥t que d'avoir √† cr√©er les variables pour tous les
champs. Ceci nous permet de tester que certains champs poss√®dent des valeurs
particuli√®res tout en cr√©ant des variables pour destructurer les autres champs.</p>
<!--
Listing 18-14 shows a `match` expression that separates `Point` values into
three cases: points that lie directly on the `x` axis (which is true when `y =
0`), on the `y` axis (`x = 0`), or neither.
-->
<p>L'encart 18-14 montre une expression <code>match</code> qui s√©pare les valeurs <code>Point</code>
en trois cat√©gories¬†: les points qui sont sur l'axe <code>x</code> (ce qui est
vrai lorsque <code>y = 0</code>), ceux sur l'axe <code>y</code> (<code>x = 0</code>) et ceux qui ne sont sur aucun
de ces deux axes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;Sur l'axe x √† la position {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;Sur l'axe y √† la position {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Sur aucun des axes¬†: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span>
-->
<p><span class="caption">Encart 18-14¬†: d√©structurer et faire correspondre des
valeurs litt√©rales gr√¢ce √† un seul motif</span></p>
<!--
The first arm will match any point that lies on the `x` axis by specifying that
the `y` field matches if its value matches the literal `0`. The pattern still
creates an `x` variable that we can use in the code for this arm.
-->
<p>La premi√®re branche va correspondre avec tous les points qui se trouvent sur
l'axe <code>x</code> en pr√©cisant que le champ <code>y</code> correspond au litt√©ral <code>0</code>. Le motif va
syst√©matiquement cr√©er une variable <code>x</code> que nous pourrons utiliser dans le code
de cette branche.</p>
<!--
Similarly, the second arm matches any point on the `y` axis by specifying that
the `x` field matches if its value is `0` and creates a variable `y` for the
value of the `y` field. The third arm doesn‚Äôt specify any literals, so it
matches any other `Point` and creates variables for both the `x` and `y` fields.
-->
<p>De la m√™me mani√®re, la deuxi√®me branche correspondra avec tous les points sur
l'axe <code>y</code> en pr√©cisant que le champ <code>x</code> correspondra uniquement si sa valeur
est <code>0</code> et cr√©era une variable <code>y</code> pour la valeur du champ <code>y</code>. La troisi√®me
branche n'a pas besoin d'un litt√©ral en particulier, donc elle correspondra √†
n'importe quel autre <code>Point</code> et cr√©era les variables pour les champs <code>x</code> et
<code>y</code>.</p>
<!--
In this example, the value `p` matches the second arm by virtue of `x`
containing a 0, so this code will print `On the y axis at 7`.
-->
<p>Dans cet exemple, la valeur <code>p</code> correspond avec la deuxi√®me branche car son <code>x</code>
vaut <code>0</code>, donc ce code va afficher <code>Sur l'axe y √† la position 7</code>.</p>
<!--
#### Destructuring Enums
-->
<h4 id="destructurer-une-√©num√©ration"><a class="header" href="#destructurer-une-√©num√©ration">Destructurer une √©num√©ration</a></h4>
<!--
We‚Äôve destructured enums earlier in this book, for example, when we
destructured `Option<i32>` in Listing 6-5 in Chapter 6. One detail we haven‚Äôt
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write
a `match` with patterns that will destructure each inner value.
-->
<p>Nous avons d√©j√† destructur√© des √©num√©rations pr√©c√©demment dans ce livre, par exemple
lorsque nous avions destructur√© <code>Option&lt;i32&gt;</code> dans l'encart 6-5 du chapitre 6.
Un d√©tail que nous n'avions pas pr√©cis√© explicitement √©tait que le motif pour
destructurer une √©num√©ration doit correspondre √† la fa√ßon dont sont d√©finies les
donn√©es dans l'√©num√©ration. Par exemple, dans l'encart 18-15 nous utilisons
l'√©num√©ration <code>Message</code> de l'encart 6-2 et nous ajoutons un <code>match</code> avec des
motifs qui devraient destructurer chaque valeur interne.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x, y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangerCouleur(0, 160, 255);

    match msg {
        Message::Quitter =&gt; {
            println!(&quot;La variante Quitter n'a pas de donn√©es √† d√©structurer.&quot;)
        }
        Message::Deplacer { x, y } =&gt; {
            println!(
                &quot;D√©placement de {} sur l'axe x et de {} sur l'axe y&quot;,
                x, y
            );
        }
        Message::Ecrire(text) =&gt; println!(&quot;Message textuel¬†: {}&quot;, text),
        Message::ChangerCouleur(r, g, b) =&gt; println!(
            &quot;Changement des taux de rouge √† {}, de vert √† {} et de bleu √† {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span>
-->
<p><span class="caption">Encart 18-15¬†: d√©structuration des variantes d'une
√©num√©ration qui stocke diff√©rents types de valeurs</span></p>
<!--
This code will print `Change the color to red 0, green 160, and blue 255`. Try
changing the value of `msg` to see the code from the other arms run.
-->
<p>Ce code va afficher
<code>Changement des taux de rouge √† 0, de vert √† 160 et de bleu √† 255</code>. Essayez de
changer la valeur de <code>message</code> pour voir le code qu'ex√©cute les autres
branches.</p>
<!--
For enum variants without any data, like `Message::Quit`, we can‚Äôt destructure
the value any further. We can only match on the literal `Message::Quit` value,
and no variables are in that pattern.
-->
<p>Pour les variantes d'√©num√©ration sans aucune donn√©e, telle que <code>Message::Quitter</code>,
nous ne pouvons pas destructurer de valeurs. Nous pouvons uniquement
correspondre √† la valeur litt√©rale <code>Message::Quitter</code> et il n'y a pas de
variable dans ce motif.</p>
<!--
For struct-like enum variants, such as `Message::Move`, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.
-->
<p>Pour les variantes d'√©num√©ration qui ressemblent aux structures, comme
<code>Message::Deplacer</code>, nous pouvons utiliser un motif similaire aux motifs que
nous utilisons pour correspondre aux structures. Apr√®s le nom de la variante,
nous utilisons des accolades puis nous listons les champs avec des
variables afin de diviser les √©l√©ments √† utiliser dans le code de cette
branche. Ici nous utilisons la forme raccourcie comme nous l'avons fait √†
l'encart 18-13.</p>
<!--
For tuple-like enum variants, like `Message::Write` that holds a tuple with one
element and `Message::ChangeColor` that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we‚Äôre
matching.
-->
<p>Pour les variantes d'√©num√©rations qui ressemblent √† des tuples, telles que
<code>Message::Ecrire</code> qui stocke un tuple avec un seul √©l√©ment, ou
<code>Message::ChangerCouleur</code> qui stocke un tuple avec trois √©l√©ments, le motif
est semblable √† celui que nous renseignons pour correspondre aux tuples. Le nombre
de variables dans le motif doit correspondre au nombre d'√©l√©ments dans la
variante qui correspond.</p>
<!--
#### Destructuring Nested Structs and Enums
-->
<h4 id="destructurer-des-structures-et-des-√©num√©rations-imbriqu√©es"><a class="header" href="#destructurer-des-structures-et-des-√©num√©rations-imbriqu√©es">Destructurer des structures et des √©num√©rations imbriqu√©es</a></h4>
<!--
Until now, all our examples have been matching structs or enums that were one
level deep. Matching can work on nested items too!
-->
<p>Jusqu'√† pr√©sent, tous nos exemples avaient des correspondances avec des structures
ou des √©num√©rations qui n'avaient qu'un seul niveau de profondeur. Les
correspondances fonctionnent aussi sur les √©l√©ments imbriqu√©s¬†!</p>
<!--
For example, we can refactor the code in Listing 18-15 to support RGB and HSV
colors in the `ChangeColor` message, as shown in Listing 18-16.
-->
<p>Par exemple, nous pouvons remanier le code de l'encart 18-15 pour pouvoir
utiliser des couleurs RVB et TSV dans le message <code>ChangerCouleur</code>, comme dans
l'encart 18-16.</p>
<!--
```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) => println!(
            "Change the color to hue {}, saturation {}, and value {}",
            h, s, v
        ),
        _ => (),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Couleur {
    Rvb(i32, i32, i32),
    Tsv(i32, i32, i32),
}

enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(Couleur),
}

fn main() {
    let msg = Message::ChangerCouleur(Couleur::Tsv(0, 160, 255));

    match msg {
        Message::ChangerCouleur(Couleur::Rvb(r, v, b)) =&gt; println!(
            &quot;Changement des taux de rouge √† {}, de vert √† {} et de bleu √† {}&quot;,
            r, v, b
        ),
        Message::ChangerCouleur(Couleur::Tsv(t, s, v)) =&gt; println!(
            &quot;Changement des taux de teinte √† {}, de saturation √† {} et de valeur √† {}&quot;,
            t, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-16: Matching on nested enums</span>
-->
<p><span class="caption">Encart 18-16¬†: correspondance avec des √©num√©rations
imbriqu√©es</span></p>
<!--
The pattern of the first arm in the `match` expression matches a
`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; then
the pattern binds to the three inner `i32` values. The pattern of the second
arm also matches a `Message::ChangeColor` enum variant, but the inner enum
matches the `Color::Hsv` variant instead. We can specify these complex
conditions in one `match` expression, even though two enums are involved.
-->
<p>Le motif de la premi√®re branche dans l'expression <code>match</code> correspond √† la
variante d'√©num√©ration <code>Message::ChangerCouleur</code> qui contient une variante
<code>Couleur::Rvb</code>¬†; ensuite le motif fait correspondre des variables aux trois
valeurs <code>i32</code> que cette derni√®re contient. Le motif de la seconde branche
correspond aussi √† une variante de l'√©num√©ration de <code>Message::ChangerCouleur</code>,
mais la valeur interne correspond plut√¥t √† la variante <code>Couleur::Tsv</code>. Nous
pouvons renseigner ces conditions complexes dans une seule expression <code>match</code>,
bien que deux √©num√©rations diff√©rentes soient impliqu√©es.</p>
<!--
#### Destructuring Structs and Tuples
-->
<h4 id="destructurer-des-structures-et-des-tuples"><a class="header" href="#destructurer-des-structures-et-des-tuples">Destructurer des structures et des tuples</a></h4>
<!--
We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:
-->
<p>Nous pouvons m√©langer les correspondances et les motifs pour d√©structurer des
√©l√©ments imbriqu√©s de mani√®re bien plus complexe. L'exemple suivant montre une
d√©structuration complexe dans laquelle nous imbriquons des structures et des
tuples √† l'int√©rieur d'un tuple et nous y destructurons toutes les valeurs
primitives¬†:</p>
<!--
```rust
# fn main() {
#     struct Point {
#         x: i32,
#         y: i32,
#     }
# 
    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((pieds, pouces), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<!--
This code lets us break complex types into their component parts so we can use
the values we‚Äôre interested in separately.
-->
<p>Ce code nous permet de d√©composer les parties qui composent des types complexes
pour pouvoir utiliser s√©par√©ment les valeurs qui nous int√©ressent.</p>
<!--
Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.
-->
<p>La d√©structuration avec les motifs est un moyen efficace d'utiliser des parties
de valeurs, comme par exemple la valeur de chaque champ d'une structure,
ind√©pendamment les unes des autres.</p>
<!--
### Ignoring Values in a Pattern
-->
<h3 id="ignorer-des-valeurs-dans-un-motif"><a class="header" href="#ignorer-des-valeurs-dans-un-motif">Ignorer des valeurs dans un motif</a></h3>
<!--
You‚Äôve seen that it‚Äôs sometimes useful to ignore values in a pattern, such as
in the last arm of a `match`, to get a catchall that doesn‚Äôt actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the `_`
pattern (which you‚Äôve seen), using the `_` pattern within another pattern,
using a name that starts with an underscore, or using `..` to ignore remaining
parts of a value. Let‚Äôs explore how and why to use each of these patterns.
-->
<p>Vous avez pu constater qu'il est parfois utile d'ignorer des valeurs dans un
motif, comme celle dans la derni√®re branche d'un <code>match</code>, pour obtenir un joker
qui ne fait rien mis √† part qu'il repr√©sente toutes les autres valeurs
possibles. Il existe plusieurs fa√ßons d'ignorer totalement ou en partie des
valeurs dans un motif¬†: en utilisant le motif <code>_</code> (que vous avez d√©j√† vu), le
motif <code>_</code> √† l'int√©rieur d'un autre motif, un nom qui commence avec un tiret
bas, ou enfin <code>..</code> pour ignorer les parties restantes d'une valeur. Voyons
comment et pourquoi utiliser ces diff√©rents motifs.</p>
<!--
#### Ignoring an Entire Value with `_`
-->
<h4 id="ignorer-compl√®tement-une-valeur-avec-_"><a class="header" href="#ignorer-compl√®tement-une-valeur-avec-_">Ignorer compl√®tement une valeur avec <code>_</code></a></h4>
<!--
We‚Äôve used the underscore (`_`) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore `_` pattern is especially
useful as the last arm in a `match` expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.
-->
<p>Nous avons utilis√© le tiret bas (<code>_</code>) comme un motif joker qui correspondra
avec n'importe quelle valeur mais ne l'assignera pas. Bien que le motif du
tiret bas <code>_</code> soit particuli√®rement utile dans la derni√®re branche d'une
expression <code>match</code>, nous pouvons aussi l'utiliser dans n'importe quel motif, y
compris dans les param√®tres de fonctions, comme montr√© dans l'encart 18-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(_: i32, y: i32) {
    println!(&quot;Ce code utilise uniquement le param√®tre y¬†: {}&quot;, y);
}

fn main() {
    fonction(3, 4);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-17: Using `_` in a function signature</span>
-->
<p><span class="caption">Encart 18-17¬†: utilisation d'un <code>_</code> dans la signature
d'une fonction</span></p>
<!--
This code will completely ignore the value passed as the first argument, `3`,
and will print `This code only uses the y parameter: 4`.
-->
<p>Ce code va compl√®tement ignorer la valeur envoy√©e en premier argument, <code>3</code>, et
va afficher <code>Ce code utilise uniquement le param√®tre y¬†: 4</code>.</p>
<!--
In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn‚Äôt include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesn‚Äôt need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.
-->
<p>Dans la plupart des cas lorsque vous n'avez pas besoin d'un param√®tre d'une
fonction, vous pouvez changer la signature pour qu'elle n'inclut pas le
param√®tre non utilis√©. Ignorer un param√®tre de fonction peut √™tre
particuli√®rement utile dans certains cas, comme par exemple, lors de
l'impl√©mentation d'un trait lorsque vous avez besoin d'un certain type de
signature mais que le corps de la fonction dans votre impl√©mentation n'a pas
besoin d'un des param√®tres. Le compilateur ne vous avertira plus que ces
param√®tres de fonction ne sont pas utilis√©s, ce qui serait le cas si vous
utilisiez un nom √† la place.</p>
<!--
#### Ignoring Parts of a Value with a Nested `_`
-->
<h4 id="ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriqu√©"><a class="header" href="#ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriqu√©">Ignorer des parties d'une valeur en utilisant un <code>_</code> imbriqu√©</a></h4>
<!--
We can also use `_` inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting‚Äôs value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.
-->
<p>Nous pouvons aussi utiliser <code>_</code> au sein d'un autre motif pour ignorer
uniquement une partie d'une valeur, par exemple, si nous ne souhaitons tester
qu'une seule partie d'une valeur mais que nous n'utilisons pas les autres
parties dans le code que nous souhaitons ex√©cuter. L'encart 18-18 montre du
code qui s'occupe de g√©rer la valeur d'un r√©glage. Les r√®gles m√©tier sont que
l'utilisateur ne doit pas pouvoir modifier un r√©glage existant mais peut
annuler le r√©glage ou lui donner une valeur s'il n'en a pas encore.</p>
<!--
```rust
# fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut valeur_du_reglage = Some(5);
    let nouvelle_valeur_du_reglage = Some(10);

    match (valeur_du_reglage, nouvelle_valeur_du_reglage) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Vous ne pouvez pas √©craser une valeur d√©j√† existante&quot;);
        }
        _ =&gt; {
            valeur_du_reglage = nouvelle_valeur_du_reglage;
        }
    }

    println!(&quot;Le r√©glage vaut {:?}&quot;, valeur_du_reglage);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-18: Using an underscore within patterns that
match `Some` variants when we don‚Äôt need to use the value inside the
`Some`</span>
-->
<p><span class="caption">Encart 18-18¬†: utilisation d'un tiret bas dans des motifs
qui correspondent avec des variantes <code>Some</code> lorsque nous n'avons pas besoin
d'utiliser la valeur √† l'int√©rieur du <code>Some</code></span></p>
<!--
This code will print `Can't overwrite an existing customized value` and then
`setting is Some(5)`. In the first match arm, we don‚Äôt need to match on or use
the values inside either `Some` variant, but we do need to test for the case
when `setting_value` and `new_setting_value` are the `Some` variant. In that
case, we print why we‚Äôre not changing `setting_value`, and it doesn‚Äôt get
changed.
-->
<p>Ce code va afficher <code>Vous ne pouvez pas √©craser une valeur d√©j√† existante</code> et
ensuite <code>Le r√©glage vaut Some(5)</code>. Dans la premi√®re branche, nous n'avons pas
besoin de r√©cup√©rer ou d'utiliser les valeurs √† l'int√©rieur de chacune des
variantes <code>Some</code>, mais nous avons besoin de tester les situations
o√π <code>valeur_du_reglage</code> et <code>nouvelle_valeur_du_reglage</code> sont toutes deux des variantes
<code>Some</code>. Dans ce cas, nous √©crivons que nous n'allons pas changer
<code>valeur_du_reglage</code> et elle ne changera pas.</p>
<!--
In all other cases (if either `setting_value` or `new_setting_value` are
`None`) expressed by the `_` pattern in the second arm, we want to allow
`new_setting_value` to become `setting_value`.
-->
<p>Dans tous les autres cas (lorsque soit <code>valeur_du_reglage</code>, soit
<code>nouvelle_valeur_du_reglage</code> vaut <code>None</code>) qui correspondront avec le motif
<code>_</code> de la seconde branche, nous voulons permettre √† la valeur de
<code>nouvelle_valeur_du_reglage</code> de remplacer celle de <code>valeur_du_reglage</code>.</p>
<!--
We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.
-->
<p>Nous pouvons aussi utiliser les tirets bas √† plusieurs endroits dans un m√™me
motif pour ignorer des valeurs pr√©cises. L'encart 18-19 montre un exemple qui
ignore la deuxi√®me et la quatri√®me valeur dans un tuple de cinq √©l√©ments.</p>
<!--
```rust
# fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        }
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, _, troisieme, _, cinquieme) =&gt; {
            println!(&quot;Voici quelques nombres¬†: {}, {}, {}&quot;, premier, troisieme, cinquieme)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span>
-->
<p><span class="caption">Encart 18-19¬†: on ignore plusieurs √©l√©ments d'un tuple
</span></p>
<!--
This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be
ignored.
-->
<p>Ce code va afficher <code>Voici quelques nombres¬†: 2, 8, 32</code> tandis que les valeurs
4 et 16 sont ignor√©es.</p>
<!--
#### Ignoring an Unused Variable by Starting Its Name with `_`
-->
<h4 id="ignorer-une-variable-non-utilis√©e-en-pr√©fixant-son-nom-avec-un-_"><a class="header" href="#ignorer-une-variable-non-utilis√©e-en-pr√©fixant-son-nom-avec-un-_">Ignorer une variable non utilis√©e en pr√©fixant son nom avec un <code>_</code></a></h4>
<!--
If you create a variable but don‚Äôt use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes it‚Äôs useful to create a
variable you won‚Äôt use yet, such as when you‚Äôre prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we compile this code, we should
only get a warning about one of them.
-->
<p>Si vous cr√©ez une variable mais que vous ne l'utilisez nulle part, Rust va
lancer un avertissement car cela pourrait √™tre un bogue. Mais parfois il est
utile de cr√©er une variable que vous n'utilisez pas encore, ce qui peut arriver
lorsque vous cr√©ez un prototype ou un projet. Dans ce genre de situation,
vous pouvez demander √† Rust de ne pas vous avertir que la variable n'est pas utilis√©e
en pr√©fixant son nom avec un tiret bas. Dans l'encart 18-20, nous
cr√©ons deux variables non utilis√©es, mais lorsque nous compilerons ce code,
nous n'aurons d'avertissement que pour une seule d'entre elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span>
-->
<p><span class="caption">Encart 18-20¬†: pr√©fixer le nom d'une variable avec un
tiret bas pour √©viter d'avoir des avertissements signalant une variable non
utilis√©e</span></p>
<!--
Here we get a warning about not using the variable `y`, but we don‚Äôt get a
warning about not using the variable preceded by the underscore.
-->
<p>Ici nous avons un avertissement qui nous pr√©vient que nous n'utilisons pas la
variable <code>y</code>, mais nous n'avons pas d'avertissement concernant la variable dont
le nom est pr√©fix√© par un tiret bas.</p>
<!--
Note that there is a subtle difference between using only `_` and using a name
that starts with an underscore. The syntax `_x` still binds the value to the
variable, whereas `_` doesn‚Äôt bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.
-->
<p>Notez qu'il existe une diff√©rence subtile entre utiliser uniquement <code>_</code>
et pr√©fixer un nom avec un tiret bas. La syntaxe <code>_x</code> continue √† associer la
valeur √† une variable, alors que <code>_</code> ne le fait pas du tout. Pour montrer un
cas o√π cette diff√©rence est importante, l'encart 18-21 va nous donner une
erreur.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Salutations¬†!&quot;));

    if let Some(_s) = s {
        println!(&quot;j'ai trouv√© une chaine de caract√®res&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span>
-->
<p><span class="caption">Encart 18-21¬†: une variable non utilis√©e pr√©fix√©e par un
tiret bas continue √† assigner la valeur, ce qui pourrait entra√Æner une prise de
possession de la valeur</span></p>
<!--
We‚Äôll receive an error because the `s` value will still be moved into `_s`,
which prevents us from using `s` again. However, using the underscore by itself
doesn‚Äôt ever bind to the value. Listing 18-22 will compile without any errors
because `s` doesn‚Äôt get moved into `_`.
-->
<p>Nous allons obtenir une erreur car la valeur <code>s</code> est toujours d√©plac√©e dans
<code>_s</code>, ce qui nous emp√™che d'utiliser <code>s</code> ensuite. A l'inverse, l'utilisation du
tiret bas tout seul n'assigne jamais la valeur √† quelque chose. Par cons√©quent,
l'encart 18-22 va se compiler sans aucune erreur car <code>s</code> n'est pas d√©plac√© dans
<code>_</code>.</p>
<!--
```rust
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Salutations¬†!&quot;));

    if let Some(_) = s {
        println!(&quot;j'ai trouv√© une chaine de caract√®res&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-22: Using an underscore does not bind the
value</span>
-->
<p><span class="caption">Encart 18-22¬†: l'utilisation d'un tiret bas n'assigne pas
la valeur</span></p>
<!--
This code works just fine because we never bind `s` to anything; it isn‚Äôt moved.
-->
<p>Ce code fonctionne correctement car nous n'assignons jamais <code>s</code> √† quelque
chose¬†; elle n'est jamais d√©plac√©e.</p>
<!--
#### Ignoring Remaining Parts of a Value with `..`
-->
<h4 id="ignorer-les-√©l√©ments-restants-dune-valeur-avec-"><a class="header" href="#ignorer-les-√©l√©ments-restants-dune-valeur-avec-">Ignorer les √©l√©ments restants d'une valeur avec <code>..</code></a></h4>
<!--
With values that have many parts, we can use the `..` syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The `..` pattern ignores any parts of a value that we haven‚Äôt
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
`Point` struct that holds a coordinate in three-dimensional space. In the
`match` expression, we want to operate only on the `x` coordinate and ignore
the values in the `y` and `z` fields.
-->
<p>Avec les valeurs qui ont de nombreux √©l√©ments, nous pouvons utiliser la syntaxe
<code>..</code> pour n'utiliser que quelques √©l√©ments et ignorer les autres, ce qui
√©vite d'avoir √† faire une liste de tirets bas pour chacune des valeurs
ignor√©es. Le motif <code>..</code> ignore tous les √©l√©ments d'une valeur qui ne
correspondent pas explicitement au reste du motif. Dans l'encart 18-23, nous
avons une structure <code>Point</code> qui stocke des coordonn√©es dans un espace
tridimensionnel. Dans l'expression <code>match</code>, nous souhaitons utiliser uniquement
la coordonn√©e <code>x</code> et ignorer les valeurs des champs <code>y</code> et <code>z</code>.</p>
<!--
```rust
# fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origine = Point { x: 0, y: 0, z: 0 };

    match origine {
        Point { x, .. } =&gt; println!(&quot;x vaut {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-23: Ignoring all fields of a `Point` except
for `x` by using `..`</span>
-->
<p><span class="caption">Encart 18-23¬†: on ignore tous les champs d'un <code>Point</code> √†
l'exception de <code>x</code> en utilisant <code>..</code></span></p>
<!--
We list the `x` value and then just include the `..` pattern. This is quicker
than having to list `y: _` and `z: _`, particularly when we‚Äôre working with
structs that have lots of fields in situations where only one or two fields are
relevant.
-->
<p>Nous ajoutons la valeur <code>x</code> puis nous ins√©rons simplement le motif <code>..</code>. C'est
plus rapide que d'avoir √† ajouter <code>y: _</code> et <code>z: _</code>, en particulier lorsque
nous travaillons avec des structures qui ont beaucoup de champs alors qu'un
seul champ ou deux nous int√©ressent.</p>
<!--
The syntax `..` will expand to as many values as it needs to be. Listing 18-24
shows how to use `..` with a tuple.
-->
<p>La syntaxe <code>..</code> va s'√©tendre √† toutes les valeurs qu'elle devra couvrir.
L'encart 18-24 montre comment utiliser <code>..</code> avec un tuple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, .., dernier) =&gt; {
            println!(&quot;Voici quelques nombres¬†: {}, {}&quot;, premier, dernier);
        }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span>
-->
<p><span class="caption">Encart 18-24¬†: on correspond uniquement avec la premi√®re
et la derni√®re valeur d'un tuple en ignorant toutes les autres valeurs
</span></p>
<!--
In this code, the first and last value are matched with `first` and `last`. The
`..` will match and ignore everything in the middle.
-->
<p>Dans ce code, la premi√®re et la derni√®re valeur correspondent √† <code>premier</code> et
<code>dernier</code>. Le <code>..</code> va correspondre et ignorer tout ce qui se trouve entre les
deux.</p>
<!--
However, using `..` must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using `..` ambiguously, so it will not
compile.
-->
<p>Cependant, l'utilisation de <code>..</code> peut √™tre ambigu. S'il n'est pas possible de
d√©terminer clairement quelles valeurs doivent correspondre et quelles valeurs
doivent √™tre ignor√©es, Rust va nous retourner une erreur. L'encart 18-25 nous
montre un exemple d'utilisation ambigu de <code>..</code> qui, par cons√©quent, ne se
compilera pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (.., second, ..) =&gt; {
            println!(&quot;Voici quelques nombres¬†: {}&quot;, second)
        },
    }
}
</code></pre>
<!--
<span class="caption">Listing 18-25: An attempt to use `..` in an ambiguous
way</span>
-->
<p><span class="caption">Encart 18-25¬†: une tentative d'utilisation de <code>..</code> de
mani√®re ambig√ºe</span></p>
<!--
When we compile this example, we get this error:
-->
<p>Lorsque nous compilons cet exemple, nous obtenons l'erreur suivante¬†:</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 -- > src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<!--
It‚Äôs impossible for Rust to determine how many values in the tuple to ignore
before matching a value with `second` and then how many further values to
ignore thereafter. This code could mean that we want to ignore `2`, bind
`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore
`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth.
The variable name `second` doesn‚Äôt mean anything special to Rust, so we get a
compiler error because using `..` in two places like this is ambiguous.
-->
<p>Il est impossible pour Rust de d√©terminer combien de valeurs doivent √™tre ignor√©es
dans le tuple avant de faire correspondre une valeur avec <code>second</code> et ensuite
combien d'autres doivent √™tre ignor√©es apr√®s. Ce code pourrait signifier que nous
voulons ignorer <code>2</code>, faire correspondre <code>second</code> avec <code>4</code>, puis ignorer ensuite
<code>8</code>, <code>16</code> et <code>32</code>¬†; ou que nous souhaitons ignorer <code>2</code> et <code>4</code>, faire
correspondre <code>second</code> √† <code>8</code>, puis ignorer ensuite <code>16</code> et <code>32</code>¬†; et ainsi de
suite. Le nom de la variable <code>second</code> ne signifie pas grand-chose pour Rust,
donc nous obtenons une erreur de compilation √† cause de l'utilisation de <code>..</code>
√† deux endroits qui rendent la situation ambig√ºe.</p>
<!--
### Extra Conditionals with Match Guards
-->
<h3 id="plus-de-conditions-avec-les-contr√¥les-de-correspondance"><a class="header" href="#plus-de-conditions-avec-les-contr√¥les-de-correspondance">Plus de conditions avec les contr√¥les de correspondance</a></h3>
<!--
A *match guard* is an additional `if` condition specified after the pattern in
a `match` arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.
-->
<p>Un <em>contr√¥le de correspondance</em> est une condition <code>if</code> suppl√©mentaire
renseign√©e apr√®s le motif d'une branche d'un <code>match</code> qui doit elle aussi
correspondre en m√™me temps que le filtrage par motif, pour que cette branche
soit choisie. Les contr√¥les de correspondance sont utiles pour exprimer des
id√©es plus complexes que celles permises uniquement par les motifs.</p>
<!--
The condition can use variables created in the pattern. Listing 18-26 shows a
`match` where the first arm has the pattern `Some(x)` and also has a match
guard of `if x % 2 == 0` (which will be true if the number is even).
-->
<p>La condition peut utiliser des variables cr√©√©es dans le motif. L'encart 18-26
montre un <code>match</code> dans lequel la premi√®re branche a le motif <code>Some(x)</code> et
proc√®de aussi au contr√¥le de correspondance <code>if x &lt; % 2 == 0</code> (qui sera vrai si
le nombre est pair).</p>
<!--
```rust
# fn main() {
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 => println!("The number {} is even", x),
        Some(x) => println!("The number {} is odd", x),
        None => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombre = Some(4);

    match nombre {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;Le nombre {} est pair&quot;, x),
        Some(x) =&gt; println!(&quot;Le nombre {} est impair&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-26: Adding a match guard to a pattern</span>
-->
<p><span class="caption">Encart 18-26¬†: ajout d'un contr√¥le de correspondance √† un
motif</span></p>
<!--
This example will print `The number 4 is even`. When `num` is compared to the
pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then
the match guard checks whether the remainder of dividing `x` by 2 is equal to
0, and because it is, the first arm is selected.
-->
<p>Cet exemple va afficher <code>Le nombre 4 est pair</code>. Lorsque <code>nombre</code> est compar√© au
motif de la premi√®re branche, il va correspondre, car <code>Some(4)</code> correspond √†
<code>Some(x)</code>. Ensuite, le contr√¥le de correspondance v√©rifie si le reste de la
division de <code>x</code> par 2 vaut 0, et comme c'est le cas, la premi√®re branche est
choisie.</p>
<!--
If `num` had been `Some(5)` instead, the match guard in the first arm would
have been false because the remainder of 5 divided by 2 is 1, which is not
equal to 0. Rust would then go to the second arm, which would match because the
second arm doesn‚Äôt have a match guard and therefore matches any `Some` variant.
-->
<p>Si <code>nombre</code> avait √©t√© plut√¥t <code>Some(5)</code>, le contr√¥le de correspondance de la
premi√®re branche aurait √©t√© faux car le reste de la division de 5 par 2 est 1,
ce qui n'est pas √©gal √† 0. Rust serait donc all√© √† la deuxi√®me branche, qui
devrait √™tre choisie car cette deuxi√®me branche correspond √† n'importe quelle
variante <code>Some</code> et n'a pas de contr√¥le de correspondance.</p>
<!--
There is no way to express the `if x % 2 == 0` condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of
this additional expressiveness is that the compiler doesn't try to check for
exhaustiveness when match guard expressions are involved.
-->
<p>Comme il n'existe pas d'autre moyen d'exprimer la condition <code>if x % 2 == 0</code>
dans un motif, le contr√¥le de correspondance nous donne la possibilit√©
d'exprimer une telle logique. L'inconv√©nient de cette expressivit√© renforc√©e
est que le compilateur n'essaie pas de v√©rifier l'exhaustivit√© lorsqu'on
utilise les contr√¥les de correspondance.</p>
<!--
In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the `match` expression instead of using the variable outside the
`match`. That new variable meant we couldn‚Äôt test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.
-->
<p>Dans l'encart 18-11, nous avions mentionn√© le fait que nous pouvions utiliser
des contr√¥les de correspondance pour r√©soudre notre probl√®me de masquage dans
le motif. Souvenez-vous qu'une nouvelle variable avait √©t√© cr√©√©e √† l'int√©rieur
du motif dans l'expression <code>match</code> au lieu d'utiliser la variable situ√©e √†
l'ext√©rieur du <code>match</code>. Cette nouvelle variable implique que nous ne pouvons
pas comparer avec la variable qui se situe √† l'ext√©rieur. L'encart 18-27 nous
montre comment nous pouvons utiliser un contr√¥le de correspondance pour
r√©pondre √† ce besoin.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Nous obtenons 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Nous avons une correspondance, n = {}&quot;, n),
        _ =&gt; println!(&quot;Cas par d√©faut, x = {:?}&quot;, x),
    }

    println!(&quot;Au final¬†: x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span>
-->
<p><span class="caption">Encart 18-27¬†: utilisation d'un contr√¥le de
correspondance pour v√©rifier l'√©galit√© avec une variable externe au bloc</span></p>
<!--
This code will now print `Default case, x = Some(5)`. The pattern in the second
match arm doesn‚Äôt introduce a new variable `y` that would shadow the outer `y`,
meaning we can use the outer `y` in the match guard. Instead of specifying the
pattern as `Some(y)`, which would have shadowed the outer `y`, we specify
`Some(n)`. This creates a new variable `n` that doesn‚Äôt shadow anything because
there is no `n` variable outside the `match`.
-->
<p>Ce code va maintenant afficher <code>Cas par d√©faut, x = Some(5)</code>. Le motif de la
deuxi√®me branche du <code>match</code> ne cr√©e pas de nouvelle variable <code>y</code> qui masquerait
le <code>y</code> externe, ce qui signifie que nous pouvons utiliser le <code>y</code> externe dans
le contr√¥le de correspondance. Au lieu de renseigner le motif comme √©tant
<code>Some(y)</code>, ce qui aurait masqu√© le <code>y</code> externe, nous renseignons <code>Some(n)</code>.
Cela va cr√©er une nouvelle variable <code>n</code> qui ne masque rien car il n'y a pas de
variable <code>n</code> √† l'ext√©rieur du <code>match</code>.</p>
<!--
The match guard `if n == y` is not a pattern and therefore doesn‚Äôt introduce
new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and
we can look for a value that has the same value as the outer `y` by comparing
`n` to `y`.
-->
<p>Le contr√¥le de correspondance <code>if n == y</code> n'est pas un motif et donc il
n'introduit pas de nouvelle variable. Ce <code>y</code> <em>est</em> la variable externe <code>y</code> au
lieu d'√™tre une nouvelle variable masqu√©e <code>y</code>, et nous pouvons comparer une
valeur qui a la m√™me valeur que le <code>y</code> externe en comparant <code>n</code> √† <code>y</code>.</p>
<!--
You can also use the *or* operator `|` in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence of combining a match guard with a pattern that uses
`|`. The important part of this example is that the `if y` match guard applies
to `4`, `5`, *and* `6`, even though it might look like `if y` only applies to
`6`.
-->
<p>Vous pouvez aussi utiliser l'op√©rateur <em>ou</em> <code>|</code> dans un contr√¥le de
correspondance pour y renseigner plusieurs motifs¬†; la condition du contr√¥le de
correspondance s'effectuera alors sur tous les motifs. L'encart 18-28 montre la
priorit√© de combinaison d'un contr√¥le de correspondance sur un motif qui
utilise <code>|</code>. La partie importante de cet exemple est que le contr√¥le de
correspondance <code>if y</code> s'applique sur <code>4</code>, <code>5</code> <em>et</em> <code>6</code>, m√™me si <code>if y</code> semble
s'appliquer uniquement √† <code>6</code>.</p>
<!--
```rust
# fn main() {
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span>
-->
<p><span class="caption">Encart 18-28¬†: combinaison de plusieurs motifs avec un
contr√¥le de correspondance</span></p>
<!--
The match condition states that the arm only matches if the value of `x` is
equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the
pattern of the first arm matches because `x` is `4`, but the match guard `if y`
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints `no`. The reason is that the `if`
condition applies to the whole pattern `4 | 5 | 6`, not only to the last value
`6`. In other words, the precedence of a match guard in relation to a pattern
behaves like this:
-->
<p>La condition de correspondance signifie que la branche correspond uniquement si
la valeur de <code>x</code> vaut <code>4</code>, <code>5</code> ou <code>6</code> <em>et</em> que <code>y</code> vaut <code>true</code>. Lorsque ce
code s'ex√©cute, le motif de la premi√®re branche correspond car <code>x</code> vaut 4, mais
le contr√¥le de correspondance <code>if y</code> est faux, donc ce programme affiche <code>no</code>.
La raison est que la condition <code>if</code> s'applique √† tout le motif <code>4 | 5 | 6</code> et
pas seulement √† la derni√®re valeur <code>6</code>. Autrement dit, la priorit√© d'un
contr√¥le de correspondance avec un motif se comporte comme ceci¬†:</p>
<!--
```text
(4 | 5 | 6) if y => ...
```
-->
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<!--
rather than this:
-->
<p>et pas comme ceci¬†:</p>
<!--
```text
4 | 5 | (6 if y) => ...
```
-->
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<!--
After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
`|` operator, the arm would have matched and the program would have printed
`yes`.
-->
<p>Apr√®s avoir ex√©cut√© le code, le fonctionnement des priorit√©s devient √©vident¬†:
si le contr√¥le de correspondance √©tait seulement appliqu√© √† la derni√®re valeur
renseign√©e avec l'op√©rateur <code>|</code>, la branche correspondrait et le programme
aurait affich√© <code>yes</code>.</p>
<!--
### `@` Bindings
-->
<h3 id="capturer-des-valeurs-avec-"><a class="header" href="#capturer-des-valeurs-avec-">Capturer des valeurs avec <code>@</code></a></h3>
<!--
The *at* operator (`@`) lets us create a variable that holds a value at the
same time we‚Äôre testing that value to see whether it matches a pattern. Listing
18-29 shows an example where we want to test that a `Message::Hello` `id` field
is within the range `3..=7`. But we also want to bind the value to the variable
`id_variable` so we can use it in the code associated with the arm. We could
name this variable `id`, the same as the field, but for this example we‚Äôll use
a different name.
-->
<p>L'op√©rateur <code>@</code> nous permet de cr√©er une variable qui stocke une valeur en m√™me
temps que nous testons cette valeur pour v√©rifier si elle correspond √† un
motif. L'encart 18-29 montre un exemple dans lequel nous souhaitons tester
qu'un champ <code>id</code> d'un <code>Message::Hello</code> est dans un intervalle <code>3..=7</code>. Mais
nous voulons aussi associer la valeur √† la variable <code>id_variable</code> pour que nous
puissions l'utiliser dans le code associ√© √† la branche. Nous aurions pu nommer
cette variable avec le m√™me nom que le champ <code>id</code>, mais pour cet exemple nous
allons utiliser un nom diff√©rent.</p>
<!--
```rust
# fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Nous avons trouv√© un id dans l'intervalle¬†: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Nous avons trouv√© un id dans un autre intervalle&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Nous avons trouv√© un autre id¬†: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-29: Using `@` to bind to a value in a pattern
while also testing it</span>
-->
<p><span class="caption">Encart 18-29¬†: utilisation de <code>@</code> pour lier une valeur
d'un motif √† une variable pendant qu'on la teste</span></p>
<!--
This example will print `Found an id in range: 5`. By specifying `id_variable
@` before the range `3..=7`, we‚Äôre capturing whatever value matched the range
while also testing that the value matched the range pattern.
-->
<p>Cet exemple va afficher <code>Nous avons trouv√© un id dans l'intervalle¬†: 5</code>. En
renseignant <code>id_variable @</code> avant l'intervalle <code>3..=7</code>, nous capturons la
valeur qui correspond √† l'intervalle pendant que nous v√©rifions que la valeur
correspond au motif de l'intervalle.</p>
<!--
In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn‚Äôt have a variable that contains the actual value
of the `id` field. The `id` field‚Äôs value could have been 10, 11, or 12, but
the code that goes with that pattern doesn‚Äôt know which it is. The pattern code
isn‚Äôt able to use the value from the `id` field, because we haven‚Äôt saved the
`id` value in a variable.
-->
<p>Dans la deuxi√®me branche, o√π nous avons uniquement un intervalle renseign√© dans
le motif, le code associ√© √† la branche n'a pas besoin d'une variable qui
contienne la valeur actuelle du champ <code>id</code>. La valeur du champ <code>id</code> aurait pu
√™tre 10, 11 ou 12, mais le code associ√© √† ce motif ne la conna√Ætra pas. Le code
du motif n'est pas capable d'utiliser la valeur du champ <code>id</code>, car nous n'avons
pas enregistr√© <code>id</code> dans une variable.</p>
<!--
In the last arm, where we‚Äôve specified a variable without a range, we do have
the value available to use in the arm‚Äôs code in a variable named `id`. The
reason is that we‚Äôve used the struct field shorthand syntax. But we haven‚Äôt
applied any test to the value in the `id` field in this arm, as we did with the
first two arms: any value would match this pattern.
-->
<p>Dans la derni√®re branche, nous avons renseign√© une variable sans intervalle,
nous avons donc dans la variable <code>id</code> la valeur qui peut √™tre utilis√©e dans le
code de la branche. La raison √† cela est que nous avons utilis√© la syntaxe
raccourcie pour les champs des structures. Mais, dans cette branche, nous
n'avons pas appliqu√© de tests √† la valeur sur le champ <code>id</code>, comme nous
l'avions fait avec les deux premi√®res branches¬†: n'importe quelle valeur
correspondra √† ce motif.</p>
<!--
Using `@` lets us test a value and save it in a variable within one pattern.
-->
<p>L'utilisation de <code>@</code> nous permet de tester une valeur et de l'enregistrer dans
une variable au sein d'un seul et m√™me motif.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-17"><a class="header" href="#r√©sum√©-17">R√©sum√©</a></h2>
<!--
Rust‚Äôs patterns are very useful in that they help distinguish between different
kinds of data. When used in `match` expressions, Rust ensures your patterns
cover every possible value, or your program won‚Äôt compile. Patterns in `let`
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.
-->
<p>Les motifs de Rust sont tr√®s utiles lorsque nous devons distinguer diff√©rents
types de donn√©es. Lorsque nous les avions utilis√©s dans les expressions
<code>match</code>, Rust s'est assur√© que vos motifs couvraient l'int√©gralit√© de toutes
valeurs possibles, et, dans le cas contraire, votre programme ne se compilait
pas. Les motifs dans les instructions <code>let</code> et les param√®tres de fonction
rendent ces constructions encore plus utiles, permettant de d√©structurer les
valeurs en parties plus petites tout en les assignant √† des variables. Nous
pouvons cr√©er des motifs tr√®s simples ou alors plus complexes pour r√©pondre √†
nos besoins.</p>
<!--
Next, for the penultimate chapter of the book, we‚Äôll look at some advanced
aspects of a variety of Rust‚Äôs features.
-->
<p>Dans le chapitre suivant, qui sera l'avant-dernier du livre, nous allons
d√©couvrir quelques aspects avanc√©s de l'√©ventail de fonctionnalit√©s de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Advanced Features
-->
<h1 id="les-fonctionnalit√©s-avanc√©es"><a class="header" href="#les-fonctionnalit√©s-avanc√©es">Les fonctionnalit√©s avanc√©es</a></h1>
<!--
By now, you‚Äôve learned the most commonly used parts of the Rust programming
language. Before we do one more project in Chapter 20, we‚Äôll look at a few
aspects of the language you might run into every once in a while. You can use
this chapter as a reference for when you encounter any unknowns when using
Rust. The features you‚Äôll learn to use in this chapter are useful in very
specific situations. Although you might not reach for them often, we want to
make sure you have a grasp of all the features Rust has to offer.
-->
<p>Jusqu'ici, vous avez appris les fonctionnalit√©s les plus utilis√©es du langage
de programmation Rust. Avant de commencer le nouveau projet du chapitre 20, nous
allons regarder quelques aspects du langage que vous pourriez rencontrer de
temps √† autre. Vous pouvez utiliser ce chapitre comme r√©f√©rence √† consulter
lorsque vous rencontrerez des √©l√©ments de Rust qui vous sont inconnus.
Les fonctionnalit√©s que vous allez d√©couvrir dans ce chapitre sont utiles dans
des situations tr√®s sp√©cifiques. M√™me si vous n'allez pas les rencontrer
tr√®s souvent, nous voulons nous assurer que vous comprenez bien toutes les
fonctionnalit√©s que Rust peut offrir.</p>
<!--
In this chapter, we‚Äôll cover:
-->
<p>Dans ce chapitre, nous allons voir¬†:</p>
<!--
* Unsafe Rust: how to opt out of some of Rust‚Äôs guarantees and take
  responsibility for manually upholding those guarantees
* Advanced traits: associated types, default type parameters, fully qualified
  syntax, supertraits, and the newtype pattern in relation to traits
* Advanced types: more about the newtype pattern, type aliases, the never type,
  and dynamically sized types
* Advanced functions and closures: function pointers and returning closures
* Macros: ways to define code that defines more code at compile time
-->
<ul>
<li>Le <em>unsafe</em> de Rust¬†: comment d√©sactiver certaines garanties de Rust et
prendre la responsabilit√© de veiller vous-m√™me manuellement √† les assurer</li>
<li>Les traits avanc√©s¬†: les types associ√©s, les types de param√®tres par d√©faut,
la syntaxe enti√®rement d√©taill√©e, les supertraits et le motif newtype en lien
avec les traits</li>
<li>Les types avanc√©s¬†: en savoir plus sur le motif newtype, les alias de type,
le type never et les types √† taille dynamique</li>
<li>Les fonctions et fermetures avanc√©es¬†: les pointeurs de fonctions et la fa√ßon
de retourner des fermetures</li>
<li>Les macros¬†: une mani√®re de d√©finir du code qui produit encore plus de code au
moment de la compilation</li>
</ul>
<!--
It‚Äôs a panoply of Rust features with something for everyone! Let‚Äôs dive in!
-->
<p>Voil√† pl√©thore de fonctionnalit√©s de Rust dans lesquelles chacun y trouvera
son compte¬†! Commen√ßons tout de suite¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Unsafe Rust
-->
<h2 id="le-rust-non-s√©curis√©-unsafe"><a class="header" href="#le-rust-non-s√©curis√©-unsafe">Le Rust non s√©curis√© (<code>unsafe</code>)</a></h2>
<!--
All the code we‚Äôve discussed so far has had Rust‚Äôs memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn‚Äôt enforce these memory safety guarantees: it‚Äôs called *unsafe Rust*
and works just like regular Rust, but gives us extra superpowers.
-->
<p>Tout le code Rust que nous avons abord√© jusqu'√† pr√©sent a b√©n√©fici√© des
garanties de s√©curit√© de la m√©moire, v√©rifi√©es √† la compilation. Cependant Rust
poss√®de un second langage cach√© en son sein qui n'applique pas ces v√©rifications
de s√©curit√© de la m√©moire¬†: il s'appelle le <em>Rust non s√©curis√©</em> et
fonctionne comme le Rust habituel, mais fournit quelques super-pouvoirs
suppl√©mentaires.</p>
<!--
Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it‚Äôs better for it to reject some valid programs rather than accept some
invalid programs. Although the code *might* be okay, if the Rust compiler
doesn‚Äôt have enough information to be confident, it will reject the code. In
these cases, you can use unsafe code to tell the compiler, ‚ÄúTrust me, I know
what I‚Äôm doing.‚Äù The downside is that you use it at your own risk: if you use
unsafe code incorrectly, problems due to memory unsafety, such as null pointer
dereferencing, can occur.
-->
<p>Le Rust non s√©curis√© existe car, par nature, l'analyse statique est conservative.
Lorsque le compilateur essaye de d√©terminer si le code respecte ou non les
garanties, il vaut mieux rejeter quelques programmes valides plut√¥t que
d'accepter quelques programmes invalides. Bien que le code <em>puisse</em> √™tre
correct, si le compilateur Rust n'a pas assez d'information pour √™tre s√ªr, il
va refuser ce code. Dans ce cas, vous pouvez utiliser du code non s√©curis√© pour
dire au compilateur ‚Äúfais-moi confiance, je sais ce que je fait‚Äù. Le prix √†
payer pour cela est que vous l'utilisez √† vos risques et p√©rils¬†: si
vous √©crivez du code non s√©curis√© de mani√®re incorrecte, des probl√®mes li√©s √†
la s√©curit√© de la m√©moire peuvent se produire, tel qu'un d√©r√©f√©rencement d'un
pointeur vide.</p>
<!--
Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn‚Äôt let you do unsafe operations, you
couldn‚Äôt do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let‚Äôs explore what we can do with unsafe
Rust and how to do it.
-->
<p>Une autre raison pour laquelle Rust embarque son alter-ego non s√©curis√© est que
le mat√©riel des ordinateurs sur lequel il repose n'est pas s√©curis√© par essence.
Si Rust ne vous laissait pas proc√©der √† des op√©rations non s√©curis√©es, vous ne
pourriez pas faire certaines choses. Rust doit pouvoir vous permettre de
d√©velopper du code bas-niveau, comme pouvoir interagir directement avec le
syst√®me d'exploitation ou m√™me √©crire votre propre syst√®me d'exploitation.
Pouvoir travailler avec des syst√®mes bas-niveau est un des objectifs du langage.
Voyons ce que nous pouvons faire avec le Rust non s√©curis√© et comment le faire.</p>
<!--
### Unsafe Superpowers
-->
<h3 id="les-super-pouvoirs-du-code-non-s√©curis√©"><a class="header" href="#les-super-pouvoirs-du-code-non-s√©curis√©">Les super-pouvoirs du code non s√©curis√©</a></h3>
<!--
To switch to unsafe Rust, use the `unsafe` keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust, called
*unsafe superpowers*, that you can‚Äôt in safe Rust. Those superpowers include
the ability to:
-->
<p>Pour pouvoir utiliser le Rust non s√©curis√©, il faut utiliser le mot-cl√© <code>unsafe</code>
et ensuite cr√©er un nouveau bloc qui contient le code non s√©curis√©. Vous pouvez
faire cinq actions en Rust non s√©curis√©, qui s'appellent <em>les super-pouvoirs du
non s√©curis√©</em>, actions que vous ne pourriez pas faire en Rust s√©curis√©. Ces super-pouvoirs
permettent de¬†:</p>
<!--
* Dereference a raw pointer
* Call an unsafe function or method
* Access or modify a mutable static variable
* Implement an unsafe trait
* Access fields of `union`s
-->
<ul>
<li>D√©r√©f√©rencer un pointeur brut</li>
<li>Faire appel √† une fonction ou une m√©thode non s√©curis√©e</li>
<li>Lire ou modifier une variable statique mutable</li>
<li>Impl√©menter un trait non s√©curis√©</li>
<li>Acc√©der aux champs des <code>union</code></li>
</ul>
<!--
It‚Äôs important to understand that `unsafe` doesn‚Äôt turn off the borrow checker
or disable any other of Rust‚Äôs safety checks: if you use a reference in unsafe
code, it will still be checked. The `unsafe` keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You‚Äôll still get some degree of safety inside of an unsafe block.
-->
<p>Il est important de comprendre que <code>unsafe</code> ne d√©sactive pas le v√©rificateur
d'emprunt et ne d√©sactive pas les autres v√©rifications de s√©curit√© de Rust¬†: si
vous utilisez une r√©f√©rence dans du code non s√©curis√©, elle sera toujours
v√©rifi√©e. Le mot-cl√© <code>unsafe</code> vous donne seulement acc√®s √† ces cinq
fonctionnalit√©s qui ne sont alors pas v√©rifi√©es par le compilateur en vue de veiller
√† la s√©curit√© de la m√©moire. Vous conservez donc un certain niveau de s√©curit√© √†
l'int√©rieur d'un bloc <code>unsafe</code>.</p>
<!--
In addition, `unsafe` does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you‚Äôll ensure the code inside an `unsafe` block will
access memory in a valid way.
-->
<p>De plus, <code>unsafe</code> ne signifie pas que le code √† l'int√©rieur du bloc est
obligatoirement dangereux ou qu'il va forc√©ment pr√©senter des probl√®mes de s√©curit√©
m√©moire¬†: l'id√©e √©tant qu'en tant que d√©veloppeur, vous vous assuriez que le code
√† l'int√©rieur d'un bloc <code>unsafe</code> va acc√©der correctement √† la m√©moire.</p>
<!--
People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with `unsafe` you‚Äôll know that
any errors related to memory safety must be within an `unsafe` block. Keep
`unsafe` blocks small; you‚Äôll be thankful later when you investigate memory
bugs.
-->
<p>Personne n'est parfait, les erreurs arrivent, et en imposant que ces cinq
op√©rations non s√©curis√©s se trouvent dans des blocs marqu√©s d'un <code>unsafe</code>, Rust
vous permet de savoir que ces √©ventuelles erreurs li√©es √† la s√©curit√© de la
m√©moire se trouveront dans un bloc <code>unsafe</code>. Vous devez donc essayer de
minimiser la taille des blocs <code>unsafe</code>¬†; vous ne le regretterez pas lorsque
vous rechercherez des bogues de m√©moire.</p>
<!--
To isolate unsafe code as much as possible, it‚Äôs best to enclose unsafe code
within a safe abstraction and provide a safe API, which we‚Äôll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`
from leaking out into all the places that you or your users might want to use
the functionality implemented with `unsafe` code, because using a safe
abstraction is safe.
-->
<p>Pour isoler autant que possible le code non s√©curis√©, il vaut mieux int√©grer du
code non s√©curis√© dans une abstraction et fournir ainsi une API s√©curis√©e,
comme nous le verrons plus tard dans ce chapitre lorsque nous examinerons les
fonctions et m√©thodes non s√©curis√©es. Certaines parties de la biblioth√®que
standard sont impl√©ment√©es comme √©tant des abstractions s√©curis√©es et bas√©es
sur du code non s√©curis√© qui a √©t√© audit√©. Encapsuler du code non s√©curis√© dans
une abstraction s√©curis√©e √©vite que l'utilisation de <code>unsafe</code> ne se propage
dans des endroits o√π vous ou vos utilisateurs souhaiteraient √©viter d'utiliser
les fonctionnalit√©s du code <code>unsafe</code>, car au final utiliser une abstraction
s√©curis√©e doit rester s√ªr.</p>
<!--
Let‚Äôs look at each of the five unsafe superpowers in turn. We‚Äôll also look at
some abstractions that provide a safe interface to unsafe code.
-->
<p>Analysons ces cinq super-pouvoirs √† tour de r√¥le. Nous allons aussi
d√©couvrir quelques abstractions qui fournissent une interface s√©curis√©e pour
faire fonctionner du code non s√©curis√©.</p>
<!--
### Dereferencing a Raw Pointer
-->
<h3 id="d√©r√©f√©rencer-un-pointeur-brut"><a class="header" href="#d√©r√©f√©rencer-un-pointeur-brut">D√©r√©f√©rencer un pointeur brut</a></h3>
<!--
In Chapter 4, in the [‚ÄúDangling References‚Äù][dangling-references]<!-- ignore
-- > section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called *raw pointers* that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as `*const T` and `*mut T`, respectively. The asterisk isn‚Äôt the
dereference operator; it‚Äôs part of the type name. In the context of raw
pointers, *immutable* means that the pointer can‚Äôt be directly assigned to
after being dereferenced.
-->
<p>Au chapitre 4, dans la section
<a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-pendouillantes">‚ÄúLes r√©f√©rences pendouillantes‚Äù</a><!-- ignore -->, nous
avions mentionn√© que le compilateur s'assure que les r√©f√©rences sont toujours
valides. Le Rust non s√©curis√© offre deux nouveaux types qui s'appellent les
<em>pointeurs brut</em> et qui ressemblent aux r√©f√©rences. Comme les r√©f√©rences, les
pointeurs bruts peuvent √™tre immuables ou mutables et s'√©crivent respectivement
<code>*const T</code> et <code>*mut T</code>. L'ast√©risque n'est pas l'op√©rateur de d√©r√©f√©rencement¬†;
il fait partie du nom du type. Dans un contexte de pointeur brut, <em>immuable</em>
signifie que le pointeur ne peut pas √™tre affect√© directement apr√®s avoir √©t√©
d√©r√©f√©renc√©.</p>
<!--
Different from references and smart pointers, raw pointers:
-->
<p>Par rapport aux r√©f√©rences et aux pointeurs intelligents, les pointeurs
bruts peuvent¬†:</p>
<!--
* Are allowed to ignore the borrowing rules by having both immutable and
  mutable pointers or multiple mutable pointers to the same location
* Aren‚Äôt guaranteed to point to valid memory
* Are allowed to be null
* Don‚Äôt implement any automatic cleanup
-->
<ul>
<li>ignorer les r√®gles d'emprunt en ayant plusieurs pointeurs tant immuables que
mutables ou en ayant plusieurs pointeurs mutables qui pointent vers le m√™me
endroit.</li>
<li>ne pas √™tre oblig√©s de pointer sur un emplacement m√©moire valide</li>
<li>√™tre autoris√©s √† avoir la valeur nulle</li>
<li>ne pas impl√©menter de fonctionnalit√© de nettoyage automatique</li>
</ul>
<!--
By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust‚Äôs guarantees don‚Äôt apply.
-->
<p>En renon√ßant √† ce que Rust fasse respecter ces garanties, vous pouvez sacrifier
la s√©curit√© garantie pour obtenir de meilleures performances ou avoir la
possibilit√© de vous interfacer avec un autre langage ou mat√©riel pour lesquels
les garanties de Rust ne s'appliquent pas.</p>
<!--
Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.
-->
<p>L'encart 19-1 montre comment cr√©er un pointeur brut immuable et mutable √† partir
de r√©f√©rences.</p>
<!--
```rust
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-1: Creating raw pointers from references</span>
-->
<p><span class="caption">Encart 19-1¬†: cr√©ation de pointeurs bruts √† partir de
r√©f√©rences</span></p>
<!--
Notice that we don‚Äôt include the `unsafe` keyword in this code. We can create
raw pointers in safe code; we just can‚Äôt dereference raw pointers outside an
unsafe block, as you‚Äôll see in a bit.
-->
<p>Remarquez que nous n'incorporons pas le mot-cl√© <code>unsafe</code> dans ce code. Nous
pouvons cr√©er des pointeurs bruts dans du code s√©curis√©¬†; nous ne pouvons
simplement pas d√©r√©f√©rencer les pointeurs bruts √† l'ext√©rieur d'un bloc non
s√©curis√©, comme vous allez le constater d'ici peu.</p>
<!--
We‚Äôve created raw pointers by using `as` to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can‚Äôt make that assumption about just any raw
pointer.
-->
<p>Nous avons cr√©√© des pointeurs bruts en utilisant <code>as</code> pour transformer les
r√©f√©rences immuables et mutables en leur type de pointeur brut correspondant.
Comme nous les avons cr√©√©s directement √† partir de r√©f√©rences qui sont garanties
d'√™tre valides, nous savons que ces pointeurs bruts seront valides, mais nous ne
pouvons pas faire cette supposition sur tous les pointeurs bruts.</p>
<!--
Next, we‚Äôll create a raw pointer whose validity we can‚Äôt be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.
-->
<p>Ensuite, nous allons cr√©er un pointeur brut dont la validit√© n'est pas
certaine. L'encart 19-2 montre comment cr√©er un pointeur brut vers un
emplacement arbitraire de la m√©moire. Essayer d'utiliser de la m√©moire
arbitraire va engendrer un comportement incertain¬†: il peut y avoir des donn√©es
√† cette adresse comme il peut ne pas y en avoir, le compilateur pourrait
optimiser le code de tel sorte qu'aucun acc√®s m√©moire n'aura lieu ou bien le
programme pourrait d√©clencher une erreur de segmentation. Habituellement, il
n'y a pas de bonne raison d'√©crire du code comme celui-ci, mais c'est possible.</p>
<!--
```rust
# fn main() {
    let address = 0x012345usize;
    let r = address as *const i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let addresse = 0x012345usize;
    let r = addresse as *const i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span>
-->
<p><span class="caption">Encart 19-2¬†: cr√©ation d'un pointeur brut vers une
adresse m√©moire arbitraire</span></p>
<!--
Recall that we can create raw pointers in safe code, but we can‚Äôt *dereference*
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator `*` on a raw pointer that requires an `unsafe` block.
-->
<p>Souvenez-vous que nous pouvons cr√©er des pointeurs bruts dans du code s√©curis√©,
mais que nous ne pouvons pas y <em>d√©r√©f√©rencer</em> les pointeurs bruts et lire les
donn√©es sur lesquelles ils pointent. Dans l'encart 19-3, nous utilisons
l'op√©rateur de d√©r√©f√©rencement <code>*</code> sur un pointeur brut qui n√©cessite un bloc
<code>unsafe</code>.</p>
<!--
```rust
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;

    unsafe {
        println!(&quot;r1 vaut¬†: {}&quot;, *r1);
        println!(&quot;r2 vaut¬†: {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-3: Dereferencing raw pointers within an
`unsafe` block</span>
-->
<p><span class="caption">Encart 19-3¬†: d√©r√©f√©rencement d'un pointeur brut √†
l'int√©rieur d'un bloc <code>unsafe</code></span></p>
<!--
Creating a pointer does no harm; it‚Äôs only when we try to access the value that
it points at that we might end up dealing with an invalid value.
-->
<p>La cr√©ation de pointeur ne pose pas de probl√®mes¬†; c'est seulement lorsque nous
essayons d'acc√©der aux valeurs sur lesquelles ils pointent qu'on risque
d'obtenir une valeur invalide.</p>
<!--
Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`
raw pointers that both pointed to the same memory location, where `num` is
stored. If we instead tried to create an immutable and a mutable reference to
`num`, the code would not have compiled because Rust‚Äôs ownership rules don‚Äôt
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!
-->
<p>Remarquez aussi que dans les encarts 19-1 et 19-3, nous avons cr√©√© les
pointeurs bruts <code>*const i32</code> et <code>*mut i32</code> qui pointent tous les deux au m√™me
endroit de la m√©moire, o√π <code>nombre</code> est stock√©. Si nous avions plut√¥t tent√© de
cr√©er une r√©f√©rence immuable et une mutable vers <code>nombre</code>, le code n'aurait pas
compil√© √† cause des r√®gles de possession de Rust qui ne permettent pas d'avoir
une r√©f√©rence mutable en m√™me temps qu'une ou plusieurs r√©f√©rences immuables.
Avec les pointeurs bruts, nous pouvons cr√©er un pointeur mutable et un pointeur
immuable vers le m√™me endroit et changer la donn√©e via le pointeur mutable, en
risquant un acc√®s concurrent. Soyez vigilant¬†!</p>
<!--
With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you‚Äôll see in the next section,
[‚ÄúCalling an Unsafe Function or
Method.‚Äù](#calling-an-unsafe-function-or-method)<!-- ignore -- > Another case is
when building up safe abstractions that the borrow checker doesn‚Äôt understand.
We‚Äôll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.
-->
<p>Avec tous ces dangers, pourquoi vous risquer √† utiliser les pointeurs bruts¬†?
Une des utilisations principale consiste √† s'interfacer avec du code
C, comme vous allez le d√©couvrir dans la section suivante. Une autre
utilisation est de nous permettre de cr√©er une abstraction s√©curis√©e que le
v√©rificateur d'emprunt ne comprend pas. Nous allons d√©couvrir les fonctions
non s√©curis√©es puis voir un exemple d'une abstraction s√©curis√©e qui
utilise du code non s√©curis√©.</p>
<!--
### Calling an Unsafe Function or Method
-->
<h3 id="faire-appel-√†-une-fonction-ou-une-m√©thode-non-s√©curis√©e"><a class="header" href="#faire-appel-√†-une-fonction-ou-une-m√©thode-non-s√©curis√©e">Faire appel √† une fonction ou une m√©thode non s√©curis√©e</a></h3>
<!--
The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra `unsafe` before the rest of the definition. The
`unsafe` keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can‚Äôt guarantee we‚Äôve
met these requirements. By calling an unsafe function within an `unsafe` block,
we‚Äôre saying that we‚Äôve read this function‚Äôs documentation and take
responsibility for upholding the function‚Äôs contracts.
-->
<p>Le deuxi√®me type d'op√©ration qui n√©cessite un bloc <code>unsafe</code> est l'appel √† des
fonctions non s√©curis√©es. Les fonctions et m√©thodes non s√©curis√©es ressemblent
exactement aux m√©thodes et fonctions habituelles, mais ont un <code>unsafe</code> en plus
devant le reste de leur d√©finition. Le mot-cl√© <code>unsafe</code> dans ce cas signifie
que la fonction a des exigences que nous devons respecter pour pouvoir y faire
appel, car Rust ne pourra pas garantir de son c√¥t√© que nous les ayons remplies.
En faisant appel √† une fonction non s√©curis√©e dans un bloc <code>unsafe</code>, nous
reconnaissons que nous avons lu la documentation de cette fonction et pris la
responsabilit√© de respecter les conditions d'utilisation de la fonction.</p>
<!--
Here is an unsafe function named `dangerous` that doesn‚Äôt do anything in its
body:
-->
<p>Voici une fonction non s√©curis√©e <code>dangereux</code>, qui ne fait rien dans son corps¬†:</p>
<!--
```rust
# fn main() {
    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangereux() {}

    unsafe {
        dangereux();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
We must call the `dangerous` function within a separate `unsafe` block. If we
try to call `dangerous` without the `unsafe` block, we‚Äôll get an error:
-->
<p>Nous devons faire appel √† la fonction <code>dangereux</code> dans un bloc <code>unsafe</code> s√©par√©.
Si nous essayons d'appeler <code>dangereux</code> sans le bloc <code>unsafe</code>, nous obtenons une
erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 -- > src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangereux();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<!--
By inserting the `unsafe` block around our call to `dangerous`, we‚Äôre asserting
to Rust that we‚Äôve read the function‚Äôs documentation, we understand how to use
it properly, and we‚Äôve verified that we‚Äôre fulfilling the contract of the
function.
-->
<p>En ajoutant le bloc <code>unsafe</code> autour de notre appel √† <code>dangereux</code>, nous
d√©clarons √† Rust que nous avons lu la documentation de la fonction, que nous
comprenons comment l'utiliser correctement et que nous avons v√©rifi√© que nous
r√©pondons bien aux exigences de la fonction.</p>
<!--
Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other
unsafe operations within an unsafe function, we don‚Äôt need to add another
`unsafe` block.
-->
<p>Les corps des fonctions non s√©curis√©es sont bel et bien des blocs <code>unsafe</code>,
donc pour pouvoir proc√©der √† d'autres op√©rations non s√©curis√©es dans une
fonction non s√©curis√©e, nous n'avons pas besoin d'ajouter un autre bloc
<code>unsafe</code>.</p>
<!--
#### Creating a Safe Abstraction over Unsafe Code
-->
<h4 id="cr√©er-une-abstraction-s√©curis√©e-sur-du-code-non-s√©curis√©"><a class="header" href="#cr√©er-une-abstraction-s√©curis√©e-sur-du-code-non-s√©curis√©">Cr√©er une abstraction s√©curis√©e sur du code non s√©curis√©</a></h4>
<!--
Just because a function contains unsafe code doesn‚Äôt mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let‚Äôs study a function from the standard
library, `split_at_mut`, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use `split_at_mut`.
-->
<p>Ce n'est pas parce qu'une fonction contient du code non s√©curis√© que nous devons
forc√©ment marquer l'int√©gralit√© de cette fonction comme non s√©curis√©e. En fait,
envelopper du code non s√©curis√© dans une fonction s√©curis√©e est une abstraction
courante. Par exemple, √©tudions une fonction de la biblioth√®que standard,
<code>split_at_mut</code>, qui n√©cessite du code non s√©curis√©, et √©tudions comment nous
devrions l'impl√©menter. Cette m√©thode s√©curis√©e est d√©finie sur des slices
mutables¬†: elle prend une slice en param√®tre et en cr√©√©e deux autres en divisant
la slice √† l'indice donn√© en argument. L'encart 19-4 montre comment utiliser
<code>split_at_mut</code>.</p>
<!--
```rust
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-4: Using the safe `split_at_mut`
function</span>
-->
<p><span class="caption">Encart 19-4¬†: utilisation de la fonction s√©curis√©e
<code>split_at_mut</code></span></p>
<!--
We can‚Äôt implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won‚Äôt compile. For simplicity, we‚Äôll
implement `split_at_mut` as a function rather than a method and only for slices
of `i32` values rather than for a generic type `T`.
-->
<p>Nous ne pouvons pas impl√©menter cette fonction en utilisant uniquement du Rust
s√©curis√©. Une tentative en ce sens ressemblerait √† l'encart 19-5, qui ne se
compilera pas. Par simplicit√©, nous allons impl√©menter <code>split_at_mut</code> comme une
fonction plut√¥t qu'une m√©thode et seulement pour des slices de valeurs <code>i32</code> au
lieu d'un type g√©n√©rique <code>T</code>.</p>
<!--
```rust,ignore,does_not_compile
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-5: An attempted implementation of
`split_at_mut` using only safe Rust</span>
-->
<p><span class="caption">Encart 19-5¬†: une tentative d'impl√©mentation de
<code>split_at_mut</code> en utilisant uniquement du Rust s√©curis√©</span></p>
<!--
This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it‚Äôs
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.
-->
<p>Cette fonction commence par obtenir la longueur totale de la slice. Elle
v√©rifie ensuite que l'indice donn√© en param√®tre est bien √† l'int√©rieur de la
slice en v√©rifiant s'il est inf√©rieur ou √©gal √† la longueur. La v√©rification
implique que si nous envoyons un indice qui est plus grand que la longueur de
la slice √† d√©couper, la fonction va paniquer avant d'essayer d'utiliser cet
indice.</p>
<!--
Then we return two mutable slices in a tuple: one from the start of the
original slice to the `mid` index and another from `mid` to the end of the
slice.
-->
<p>Ensuite, nous retournons deux slices mutables dans un tuple¬†: une √† partir du
d√©but de la slice initiale jusqu'√† l'indice <code>mod</code> et une autre √† partir de
l'indice jusqu'√† la fin de la slice.</p>
<!--
When we try to compile the code in Listing 19-5, we‚Äôll get an error.
-->
<p>Lorsque nous essayons de compiler le code de l'encart 19-5, nous allons obtenir
une erreur.</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 -- > src/main.rs:6:31
  |
1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&mut values[..mid], &mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<!--
Rust‚Äôs borrow checker can‚Äôt understand that we‚Äôre borrowing different parts of
the slice; it only knows that we‚Äôre borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren‚Äôt overlapping, but Rust isn‚Äôt smart enough to know this. When we
know code is okay, but Rust doesn‚Äôt, it‚Äôs time to reach for unsafe code.
-->
<p>Le v√©rificateur d'emprunt de Rust ne comprend pas que nous empruntons
diff√©rentes parties de la slice¬†; il comprend seulement que nous empruntons la
m√™me slice √† deux reprises. L'emprunt de diff√©rentes parties d'une slice ne
pose fondamentalement pas de probl√®mes car les deux slices ne se chevauchent
pas, mais Rust n'est pas suffisamment intelligent pour comprendre ceci. Lorsque
nous savons que ce code est correct, mais que Rust ne le sait pas, il est
appropri√© d'utiliser du code non s√©curis√©.</p>
<!--
Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls
to unsafe functions to make the implementation of `split_at_mut` work.
-->
<p>L'encart 19-6 montre comment utiliser un bloc <code>unsafe</code>, un pointeur brut, et
quelques appels √† des fonctions non s√©curis√©es pour construire une
impl√©mentation de <code>split_at_mut</code> qui fonctionne.</p>
<!--
```rust
use std::slice;

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-6: Using unsafe code in the implementation of
the `split_at_mut` function</span>
-->
<p><span class="caption">Encart 19-6¬†: utilisation de code non s√©curis√© dans
l'impl√©mentation de la fonction <code>split_at_mut</code></span></p>
<!--
Recall from [‚ÄúThe Slice Type‚Äù][the-slice-type]<!-- ignore -- > section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the `len` method to get the length of a slice and the `as_mut_ptr`
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the type
`*mut i32`, which we‚Äôve stored in the variable `ptr`.
-->
<p>Souvenez-vous de la section <a href="ch04-03-slices.html#le-type-slice">‚ÄúLe type slice‚Äù</a><!-- ignore --> du
chapitre 4 dans laquelle nous avions dit qu'une slice est d√©finie par un pointeur
vers une donn√©e ainsi qu'une longueur de la slice. Nous avons utilis√© la m√©thode
<code>len</code> pour obtenir la longueur d'une slice ainsi que la m√©thode <code>as_mut_ptr</code>
pour acc√©der au pointeur brut d'une slice. Dans ce cas, comme nous avons une
slice mutable de valeurs <code>i32</code>, <code>as_mut_ptr</code> retourne un pointeur brut avec le
type <code>*mut i32</code> que nous stockons dans la variable <code>ptr</code>.</p>
<!--
We keep the assertion that the `mid` index is within the slice. Then we get to
the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from `ptr` and is `mid` items long. Then we call the `add`
method on `ptr` with `mid` as an argument to get a raw pointer that starts at
`mid`, and we create a slice using that pointer and the remaining number of
items after `mid` as the length.
-->
<p>Nous avons conserv√© la v√©rification que l'indice <code>mid</code> soit dans la slice.
Ensuite, nous utilisons le code non s√©curis√©¬†: la fonction
<code>slice::from_raw_parts_mut</code> prend en param√®tre un pointeur brut et une longueur,
et elle cr√©√©e une slice. Nous utilisons cette fonction pour cr√©er une slice qui
d√©bute √† <code>ptr</code> et qui est longue de <code>mid</code> √©l√©ments. Ensuite nous faisons appel √†
la m√©thode <code>add</code> sur <code>ptr</code> avec <code>mid</code> en argument pour obtenir un pointeur
brut qui d√©marre √† <code>mid</code>, et nous cr√©ons une slice qui utilise ce pointeur et
le nombre restant d'√©l√©ments apr√®s <code>mid</code> comme longueur.</p>
<!--
The function `slice::from_raw_parts_mut` is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The `add` method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an `unsafe` block around our calls to
`slice::from_raw_parts_mut` and `add` so we could call them. By looking at
the code and by adding the assertion that `mid` must be less than or equal to
`len`, we can tell that all the raw pointers used within the `unsafe` block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of `unsafe`.
-->
<p>La fonction <code>slice::from_raw_parts_mut</code> est non s√©curis√©e car elle prend en
argument un pointeur brut et doit avoir confiance en la validit√© de ce pointeur.
La m√©thode <code>add</code> sur les pointeurs bruts est aussi non s√©curis√©e, car elle
doit croire que l'emplacement d√©cal√© est aussi un pointeur valide. Voil√†
pourquoi nous avons plac√© un bloc <code>unsafe</code> autour de nos appels √†
<code>slice::from_raw_parts_mut</code> et <code>add</code> afin que nous puissions les effectuer. En
analysant le code et en ayant ajout√© la v√©rification que <code>mid</code> doit √™tre
inf√©rieur ou √©gal √† <code>len</code>, nous pouvons affirmer que tous les pointeurs bruts
utilis√©s dans le bloc <code>unsafe</code> sont des pointeurs valides vers les donn√©es de la
slice. C'est une utilisation acceptable et appropri√©e de <code>unsafe</code>.</p>
<!--
Note that we don‚Äôt need to mark the resulting `split_at_mut` function as
`unsafe`, and we can call this function from safe Rust. We‚Äôve created a safe
abstraction to the unsafe code with an implementation of the function that uses
`unsafe` code in a safe way, because it creates only valid pointers from the
data this function has access to.
-->
<p>Remarquez que nous n'avons pas eu besoin de marquer la fonction r√©sultante
<code>split_at_mut</code> comme √©tant <code>unsafe</code>, et que nous pouvons faire appel √† cette
fonction dans du code Rust s√©curis√©. Nous avons cr√©√© une abstraction s√©curis√©e
du code non s√©curis√© avec une impl√©mentation de la fonction qui utilise de
mani√®re s√©curis√©e du code non s√©curis√©, car elle cr√©√©e uniquement des pointeurs
valides √† partir des donn√©es auxquelles cette fonction a acc√®s.</p>
<!--
In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.
-->
<p>En contre-partie, l'utilisation de <code>slice::from_raw_parts_mut</code> dans l'encart
19-7 peut planter lorsque la slice sera utilis√©e. Ce code prend un emplacement
arbitraire dans la m√©moire et cr√©e un slice de 10 000 √©l√©ments.</p>
<!--
```rust
# fn main() {
    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let addresse = 0x01234usize;
    let r = addresse as *mut i32;

    let valeurs: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span>
-->
<p><span class="caption">Encart 19-7¬†: cr√©ation d'une slice √† partir d'un
emplacement m√©moire arbitraire</span></p>
<!--
We don‚Äôt own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid `i32` values. Attempting to use
`values` as though it‚Äôs a valid slice results in undefined behavior.
-->
<p>Nous ne poss√©dons pas la m√©moire √† cet emplacement arbitraire, et il n'y a
aucune garantie que la slice cr√©√©e par ce code contiennent des valeurs <code>i32</code>
valides. Toute tentative d'utilisation de <code>valeurs</code> aura un comportement
impr√©visible bien qu'il s'agisse d'une slice valide.</p>
<!--
#### Using `extern` Functions to Call External Code
-->
<h4 id="utiliser-des-fonctions-extern-pour-faire-appel-√†-du-code-externe"><a class="header" href="#utiliser-des-fonctions-extern-pour-faire-appel-√†-du-code-externe">Utiliser des fonctions <code>extern</code> pour faire appel √† du code externe</a></h4>
<!--
Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, `extern`, that facilitates the creation
and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.
-->
<p>Parfois, votre code Rust peut avoir besoin d'interagir avec du code √©crit dans
d'autres langages. Dans ce cas, Rust propose un mot-cl√©, <code>extern</code>, qui facilite
la cr√©ation et l'utilisation du <em>Foreign Function Interface (FFI)</em>. Le FFI est
un outil permettant √† un langage de programmation de d√©finir des fonctions auxquelles
d'autres langages de programmation pourront faire appel.</p>
<!--
Listing 19-8 demonstrates how to set up an integration with the `abs` function
from the C standard library. Functions declared within `extern` blocks are
always unsafe to call from Rust code. The reason is that other languages don‚Äôt
enforce Rust‚Äôs rules and guarantees, and Rust can‚Äôt check them, so
responsibility falls on the programmer to ensure safety.
-->
<p>L'encart 19-8 montre comment configurer l'int√©gration de la fonction <code>abs</code> de la
biblioth√®que standard du C. Les fonctions d√©clar√©es dans des blocs <code>extern</code>
sont toujours non s√©curis√©es lorsqu'on les utilise dans du code Rust. La raison
√† cela est que les autres langages n'appliquent pas les r√®gles et garanties de
Rust, Rust ne peut donc pas les v√©rifier, si bien que la responsabilit√© de s'assurer
de la s√©curit√© revient au d√©veloppeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage C¬†: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-8: Declaring and calling an `extern` function
defined in another language</span>
-->
<p><span class="caption">Encart 19-8¬†: d√©claration et appel √† une fonction externe
qui est d√©finie dans un autre langage</span></p>
<!--
Within the `extern "C"` block, we list the names and signatures of external
functions from another language we want to call. The `"C"` part defines which
*application binary interface (ABI)* the external function uses: the ABI
defines how to call the function at the assembly level. The `"C"` ABI is the
most common and follows the C programming language‚Äôs ABI.
-->
<p>Au sein du bloc <code>extern &quot;C&quot;</code>, nous listons les noms et les signatures des
fonctions externes de l'autre langage que nous souhaitons solliciter. La partie
&quot;C&quot; d√©finit quelle est l'<em>application binary interface (ABI)</em> que la fonction
doit utiliser¬†: l'ABI d√©finit comment faire appel √† la fonction au niveau
assembleur. L'ABI <code>&quot;C&quot;</code> est la plus courante et respecte l'ABI du langage de
programmation C.</p>
<!--
> #### Calling Rust Functions from Other Languages
>
> We can also use `extern` to create an interface that allows other languages
> to call Rust functions. Instead of an `extern` block, we add the `extern`
> keyword and specify the ABI to use just before the `fn` keyword. We also need
> to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle
> the name of this function. *Mangling* is when a compiler changes the name
> we‚Äôve given a function to a different name that contains more information for
> other parts of the compilation process to consume but is less human readable.
> Every programming language compiler mangles names slightly differently, so
> for a Rust function to be nameable by other languages, we must disable the
> Rust compiler‚Äôs name mangling.
>
> In the following example, we make the `call_from_c` function accessible from
> C code, after it‚Äôs compiled to a shared library and linked from C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> This usage of `extern` does not require `unsafe`.
-->
<blockquote>
<h4 id="faire-appel-√†-des-fonctions-rust-dans-dautres-langages"><a class="header" href="#faire-appel-√†-des-fonctions-rust-dans-dautres-langages">Faire appel √† des fonctions Rust dans d'autres langages</a></h4>
<p>Nous pouvons aussi utiliser <code>extern</code> pour cr√©er une interface qui permet √†
d'autres langages de faire appel √† des fonctions Rust. Au lieu d'avoir un
bloc <code>extern</code>, nous ajoutons le mot-cl√© <code>extern</code> et nous renseignons l'ABI
√† utiliser juste avant le mot-cl√© <code>fn</code>. Nous avons aussi besoin d'ajouter
l'annotation <code>#[no_mangle]</code> pour dire au compilateur Rust de ne pas d√©former
le nom de cette fonction. La <em>d√©formation</em> s'effectue lorsqu'un compilateur
change le nom que nous avons donn√© √† une fonction pour un nom qui contient
plus d'informations pour d'autres √©tapes du processus de compilation, mais
qui est moins lisible par l'humain. Tous les compilateurs de langages de
programmation d√©forment les noms de fa√ßon l√©g√®rement diff√©rente, donc pour
que le nom d'une fonction Rust soit utilisable par d'autres langages, nous
devons d√©sactiver la d√©formation du nom par le compilateur de Rust.</p>
</blockquote>
<!--
### Accessing or Modifying a Mutable Static Variable
-->
<h3 id="lire-ou-modifier-une-variable-statique-mutable"><a class="header" href="#lire-ou-modifier-une-variable-statique-mutable">Lire ou modifier une variable statique mutable</a></h3>
<!--
Until now, we‚Äôve not talked about *global variables*, which Rust does support
but can be problematic with Rust‚Äôs ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.
-->
<p>Jusqu'√† pr√©sent, nous n'avons pas parl√© des <em>variables globales</em>, que Rust
accepte mais qui peuvent poser des probl√®mes avec les r√®gles de possession de
Rust. Si deux t√¢ches acc√®dent en m√™me temps √† la m√™me variable globale, cela
peut causer un acc√®s concurrent.</p>
<!--
In Rust, global variables are called *static* variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.
-->
<p>En Rust, les variables globales s'appellent des variables <em>statiques</em>. L'encart
19-9 montre un exemple de d√©claration et d'utilisation d'une variable statique
avec une slice de cha√Æne de caract√®res comme valeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```
-->
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;Cela vaut¬†: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-9: Defining and using an immutable static
variable</span>
-->
<p><span class="caption">Encart 19-9¬†: d√©finition et utilisation d'une variable
statique immuable</span></p>
<!--
Static variables are similar to constants, which we discussed in the
[‚ÄúDifferences Between Variables and
Constants‚Äù][differences-between-variables-and-constants]<!-- ignore -- >
section in Chapter 3. The names of static variables are in
`SCREAMING_SNAKE_CASE` by convention. Static variables can only store
references with the `'static` lifetime, which means the Rust compiler can
figure out the lifetime and we aren‚Äôt required to annotate it explicitly.
Accessing an immutable static variable is safe.
-->
<p>Les variables statiques ressemblent aux constantes, que nous avons vues dans la
section
<a href="ch03-01-variables-and-mutability.html#les-constantes">‚ÄúDiff√©rences entre les variables et les constantes‚Äù</a><!-- ignore -->
du chapitre 3. Les noms des variables statiques sont par convention en
<code>SCREAMING_SNAKE_CASE</code>. Les variables statiques
peuvent uniquement stocker des r√©f√©rences ayant la dur√©e de vie <code>'static</code>, de fa√ßon
√† ce que le compilateur Rust puisse la d√©terminer tout seul¬†et que nous
n'ayons pas besoin de la renseigner explicitement. L'acc√®s √† une variable
statique immuable est s√©curis√©.</p>
<!--
Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they‚Äôre used.
-->
<p>Les constantes et les variables statiques immuables se ressemblent, mais leur
diff√©rence subtile est que les valeurs dans les variables statiques ont une
adresse fixe en m√©moire. L'utilisation de sa valeur va toujours acc√©der √† la
m√™me donn√©e. Les constantes en revanche, peuvent reproduire leurs donn√©es √†
chaque fois qu'elles sont utilis√©es.</p>
<!--
Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named `COUNTER`.
-->
<p>Une autre diff√©rence entre les constantes et les variables statiques est que
les variables statiques peuvent √™tre mutables. Lire et modifier des variables
statiques mutables est <em>non s√©curis√©</em>. L'encart 19-10 montre comment d√©clarer,
lire et modifier la variable statique mutable <code>COMPTEUR</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">static mut COMPTEUR: u32 = 0;

fn ajouter_au_compteur(valeur: u32) {
    unsafe {
        COMPTEUR += valeur;
    }
}

fn main() {
    ajouter_au_compteur(3);

    unsafe {
        println!(&quot;COMPTEUR¬†: {}&quot;, COMPTEUR);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span>
-->
<p><span class="caption">Encart 19-10¬†: la lecture et l'√©criture d'une variable
statique mutable est non s√©curis√©</span></p>
<!--
As with regular variables, we specify mutability using the `mut` keyword. Any
code that reads or writes from `COUNTER` must be within an `unsafe` block. This
code compiles and prints `COUNTER: 3` as we would expect because it‚Äôs single
threaded. Having multiple threads access `COUNTER` would likely result in data
races.
-->
<p>Comme avec les variables classiques, nous renseignons la mutabilit√© en
utilisant le mot-cl√© <code>mut</code>. Tout code qui lit ou modifie <code>COMPTEUR</code> doit se
trouver dans un bloc <code>unsafe</code>. Ce code se compile et affiche <code>COMPTEUR¬†: 3</code>
comme nous l'esp√©rions car nous n'avons qu'une seule t√¢che. Si nous avions
plusieurs t√¢ches qui acc√®dent √† <code>COMPTEUR</code>, nous pourrions avoir un acc√®s
concurrent.</p>
<!--
With mutable data that is globally accessible, it‚Äôs difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it‚Äôs preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.
-->
<p>Avec les donn√©es mutables qui sont accessibles globalement, il devient
difficile de s'assurer qu'il n'y a pas d'acc√®s concurrent, c'est pourquoi Rust
consid√®re les variables statiques mutables comme √©tant non s√©curis√©es. Lorsque
c'est possible, il vaut mieux utiliser les techniques de concurrence et les
pointeurs intelligents adapt√©s au multit√¢che que nous avons vus au chapitre 16,
afin que le compilateur puisse v√©rifier que les donn√©es qu'utilisent les
diff√©rentes t√¢ches sont s√©curis√©es.</p>
<!--
### Implementing an Unsafe Trait
-->
<h3 id="impl√©menter-un-trait-non-s√©curis√©"><a class="header" href="#impl√©menter-un-trait-non-s√©curis√©">Impl√©menter un trait non s√©curis√©</a></h3>
<!--
Another use case for `unsafe` is implementing an unsafe trait. A trait is
unsafe when at least one of its methods has some invariant that the compiler
can‚Äôt verify. We can declare that a trait is `unsafe` by adding the `unsafe`
keyword before `trait` and marking the implementation of the trait as `unsafe`
too, as shown in Listing 19-11.
-->
<p>Un autre cas d'usage de <code>unsafe</code> est l'impl√©mentation d'un trait non s√©curis√©.
Un trait n'est pas s√©curis√© lorsque au moins une de ses m√©thodes contient une
invariante que le compilateur ne peut pas v√©rifier. Nous pouvons d√©clarer un
trait qui n'est pas s√©curis√© en ajoutant le mot-cl√© <code>unsafe</code> devant <code>trait</code> et
en marquant aussi l'impl√©mentation du trait comme <code>unsafe</code>, comme dans
l'encart 19-11.</p>
<!--
```rust
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // les m√©thodes vont ici
}

unsafe impl Foo for i32 {
    // les impl√©mentations des m√©thodes vont ici
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span>
-->
<p><span class="caption">Encart 19-11¬†: d√©finition et impl√©mentation d'un trait non
s√©curis√©</span></p>
<!--
By using `unsafe impl`, we‚Äôre promising that we‚Äôll uphold the invariants that
the compiler can‚Äôt verify.
-->
<p>En utilisant <code>unsafe impl</code>, nous promettons que nous veillons aux invariantes
que le compilateur ne peut pas v√©rifier.</p>
<!--
As an example, recall the `Sync` and `Send` marker traits we discussed in the
[‚ÄúExtensible Concurrency with the `Sync` and `Send`
Traits‚Äù][extensible-concurrency-with-the-sync-and-send-traits]<!-- ignore -- >
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of `Send` and `Sync` types. If we implement a
type that contains a type that is not `Send` or `Sync`, such as raw pointers,
and we want to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust
can‚Äôt verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with `unsafe`.
-->
<p>Par exemple, souvenez-vous des traits <code>Sync</code> et <code>Send</code> que nous avions d√©couverts
dans une section du
<a href="ch16-04-extensible-concurrency-sync-and-send.html">chapitre 16</a><!--
ignore -->¬†: le compilateur impl√©mente automatiquement ces traits si nos types
sont enti√®rement compos√©s des types <code>Send</code> et <code>Sync</code>. Si nous impl√©mentions un
type qui contenait un type qui n'√©tait pas <code>Send</code> ou <code>Sync</code>, tel que les
pointeurs bruts, et nous souhaitions marquer ce type comme √©tant <code>Send</code> ou
<code>Sync</code>, nous aurions d√ª utiliser <code>unsafe</code>. Rust ne peut pas v√©rifier que notre
type respecte les garanties pour que ce type puisse √™tre envoy√© en toute
s√©curit√© entre des t√¢ches ou qu'il puisse √™tre utilis√© par plusieurs t√¢ches¬†;
en cons√©quence, nous avons besoin de faire ces v√©rifications manuellement et le
signaler avec <code>unsafe</code>.</p>
<!--
### Accessing Fields of a Union
-->
<h3 id="utiliser-des-champs-dun-union"><a class="header" href="#utiliser-des-champs-dun-union">Utiliser des champs d'un Union</a></h3>
<!--
The final action that works only with `unsafe` is accessing fields of a
*union*. A `union` is similar to a `struct`, but only one declared field is
used in a particular instance at one time. Unions are primarily used to
interface with unions in C code. Accessing union fields is unsafe because Rust
can‚Äôt guarantee the type of the data currently being stored in the union
instance. You can learn more about unions in [the Rust Reference][reference].
-->
<p>La derni√®re action qui fonctionne uniquement avec <code>unsafe</code> est d'acc√©der aux
champs d'un <em>union</em>. Un <code>union</code> ressemble √† une <code>struct</code>, mais un seul champ de
ceux d√©clar√©s est utilis√© dans une instance pr√©cise au m√™me moment. Les unions
sont principalement utilis√©s pour s'interfacer avec les unions du code C.
L'acc√®s aux champs des unions n'est pas s√©curis√© car Rust ne peut pas garantir
le type de la donn√©e qui est actuellement stock√©e dans l'instance de l'union.
Vous pouvez en apprendre plus sur les unions dans
<a href="https://doc.rust-lang.org/reference/items/unions.html">the Rust Reference</a>.</p>
<!--
### When to Use Unsafe Code
-->
<h3 id="quand-utiliser-du-code-non-s√©curis√©"><a class="header" href="#quand-utiliser-du-code-non-s√©curis√©">Quand utiliser du code non s√©curis√©</a></h3>
<!--
Using `unsafe` to take one of the five actions (superpowers) just discussed
isn‚Äôt wrong or even frowned upon. But it is trickier to get `unsafe` code
correct because the compiler can‚Äôt help uphold memory safety. When you have a
reason to use `unsafe` code, you can do so, and having the explicit `unsafe`
annotation makes it easier to track down the source of problems when they occur.
-->
<p>L'utilisation de <code>unsafe</code> pour mettre en oeuvre une des cinq actions (ou
super-pouvoirs) que nous venons d'aborder n'est pas une mauvaise chose et ne doit
pas √™tre mal vu. Mais il est plus difficile de s√©curiser du code <code>unsafe</code> car le
compilateur ne peut pas aider √† garantir la s√©curit√© de la m√©moire. Lorsque vous
avez une bonne raison d'utiliser du code non s√©curis√©, vous pouvez le faire, et
vous aurez l'annotation explicite <code>unsafe</code> pour faciliter la recherche de la
source des probl√®mes lorsqu'ils surviennent.</p>
<!--
[dangling-references]:
ch04-02-references-and-borrowing.html#dangling-references
[differences-between-variables-and-constants]:
ch03-01-variables-and-mutability.html#constants
[extensible-concurrency-with-the-sync-and-send-traits]:
ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits
[the-slice-type]: ch04-03-slices.html#the-slice-type
[reference]: ../reference/items/unions.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Advanced Traits
-->
<h2 id="les-traits-avanc√©s"><a class="header" href="#les-traits-avanc√©s">Les traits avanc√©s</a></h2>
<!--
We first covered traits in the [‚ÄúTraits: Defining Shared
Behavior‚Äù][traits-defining-shared-behavior]<!-- ignore -- > section of Chapter
10, but we didn‚Äôt discuss the more advanced details. Now that you know more
about Rust, we can get into the nitty-gritty.
-->
<p>Nous avons vu les traits dans une section du chapitre 10, mais nous n'avons pas
abord√© certains d√©tails plus avanc√©s. Maintenant que vous en savez plus sur
Rust, nous pouvons attaquer les choses s√©rieuses.</p>
<!--
### Specifying Placeholder Types in Trait Definitions with Associated Types
-->
<h3 id="placer-des-types-√†-remplacer-dans-les-d√©finitions-des-traits-gr√¢ce-aux-types-associ√©s"><a class="header" href="#placer-des-types-√†-remplacer-dans-les-d√©finitions-des-traits-gr√¢ce-aux-types-associ√©s">Placer des types √† remplacer dans les d√©finitions des traits gr√¢ce aux types associ√©s</a></h3>
<!--
*Associated types* connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used in this type‚Äôs
place for the particular implementation. That way, we can define a trait that
uses some types without needing to know exactly what those types are until the
trait is implemented.
-->
<p>Les <em>types associ√©s</em> connectent un type √† remplacer avec un trait afin que la
d√©finition des m√©thodes puisse utiliser ces types √† remplacer dans leur
signature. Celui qui impl√©mente un trait doit renseigner un type concret pour
√™tre utilis√© √† la place du type √† remplacer pour cette impl√©mentation pr√©cise.
Ainsi, nous pouvons d√©finir un trait qui utilise certains types sans avoir
besoin de savoir exactement quels sont ces types jusqu'√† ce que ce trait soit
impl√©ment√©.</p>
<!--
We‚Äôve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they‚Äôre used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.
-->
<p>Nous avions dit que vous auriez rarement besoin de la plupart des
fonctionnalit√©s avanc√©es de ce chapitre. Les types associ√©s sont un entre-deux¬†:
ils sont utilis√©s plus rarement que les fonctionnalit√©s expliqu√©es dans le reste
de ce livre, mais on les rencontre plus fr√©quemment que la plupart des autres
fonctionnalit√©s pr√©sent√©es dans ce chapitre.</p>
<!--
One example of a trait with an associated type is the `Iterator` trait that the
standard library provides. The associated type is named `Item` and stands in
for the type of the values the type implementing the `Iterator` trait is
iterating over. In [‚ÄúThe `Iterator` Trait and the `next`
Method‚Äù][the-iterator-trait-and-the-next-method]<!-- ignore -- > section of
Chapter 13, we mentioned that the definition of the `Iterator` trait is as
shown in Listing 19-12.
-->
<p>Un exemple de trait avec un type associ√© est le trait <code>Iterator</code> que fournit la
biblioth√®que standard. Le type associ√© <code>Item</code> permet de renseigner le type des
valeurs que le type qui impl√©mente le trait <code>Iterator</code> parcourt. Dans une
section du chapitre 13, nous avions mentionn√© que la d√©finition du trait
<code>Iterator</code> ressemblait √† cet encart 19-12.</p>
<!--
```rust,noplayground
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```
-->
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<!--
<span class="caption">Listing 19-12: The definition of the `Iterator` trait
that has an associated type `Item`</span>
-->
<p><span class="caption">Encart 19-12¬†: la d√©finition du trait <code>Iterator</code> qui a un
type <code>Item</code> associ√©</span></p>
<!--
The type `Item` is a placeholder type, and the `next` method‚Äôs definition shows
that it will return values of type `Option<Self::Item>`. Implementors of the
`Iterator` trait will specify the concrete type for `Item`, and the `next`
method will return an `Option` containing a value of that concrete type.
-->
<p>Le type <code>Item</code> est un type √† remplacer, et la d√©finition de la m√©thode <code>next</code>
informe qu'elle va retourner des valeurs du type <code>Option&lt;Self::Item&gt;</code>. Ceux qui
impl√©menterons le trait <code>Iterator</code> devront renseigner un type concret pour
<code>Item</code>, et la m√©thode <code>next</code> va retourner une <code>Option</code> qui contiendra une
valeur de ce type concret.</p>
<!--
Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. So why use associated types?
-->
<p>Les types associ√©s ressemblent au m√™me concept que les g√©n√©riques, car ces
derniers nous permettent de d√©finir une fonction sans avoir √† renseigner les
types avec lesquels elle travaille. Donc pourquoi utiliser les types associ√©s¬†?</p>
<!--
Let‚Äôs examine the difference between the two concepts with an example from
Chapter 13 that implements the `Iterator` trait on the `Counter` struct. In
Listing 13-21, we specified that the `Item` type was `u32`:
-->
<p>Examinons les diff√©rences entre les deux concepts gr√¢ce √† un exemple du
chapitre 13 qui impl√©mente le trait <code>Iterator</code> sur la structure <code>Compteur</code>.
Dans l'encart 13-21, nous avions renseign√© que le type <code>Item</code> √©tait <code>u32</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // -- partie masqu√©e ici --
<span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This syntax seems comparable to that of generics. So why not just define the
`Iterator` trait with generics, as shown in Listing 19-13?
-->
<p>Cette syntaxe ressemble aux g√©n√©riques. Donc pourquoi ne pas simplement d√©finir le
trait <code>Iterator</code> avec les g√©n√©riques, comme dans l'encart 19-13¬†?</p>
<!--
```rust,noplayground
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```
-->
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
</code></pre>
<!--
<span class="caption">Listing 19-13: A hypothetical definition of the
`Iterator` trait using generics</span>
-->
<p><span class="caption">Encart 19-13¬†: une d√©finition hypoth√©tique du trait
<code>Iterator</code> en utilisant des g√©n√©riques</span></p>
<!--
The difference is that when using generics, as in Listing 19-13, we must
annotate the types in each implementation; because we can also implement
`Iterator<String> for Counter` or any other type, we could have multiple
implementations of `Iterator` for `Counter`. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
`next` method on `Counter`, we would have to provide type annotations to
indicate which implementation of `Iterator` we want to use.
-->
<p>La diff√©rence est que lorsque on utilise les g√©n√©riques, comme dans l'encart
19-13, on doit annoter les types dans chaque impl√©mentation¬†; et comme nous
pouvons aussi impl√©menter <code>Iterator&lt;String&gt; for Compteur</code> ou tout autre type,
nous pourrions alors avoir plusieurs impl√©mentations de <code>Iterator</code> pour
<code>Compteur</code>. Autrement dit, lorsqu'un trait a un param√®tre g√©n√©rique, il peut
√™tre impl√©ment√© sur un type plusieurs fois, en changeant √† chaque fois le type
concret du param√®tre de type g√©n√©rique. Lorsque nous utilisons la m√©thode <code>next</code>
sur <code>Compteur</code>, nous devons appliquer une annotation de type pour indiquer
quelle impl√©mentation de <code>Iterator</code> nous souhaitons utiliser.</p>
<!--
With associated types, we don‚Äôt need to annotate types because we can‚Äôt
implement a trait on a type multiple times. In Listing 19-12 with the
definition that uses associated types, we can only choose what the type of
`Item` will be once, because there can only be one `impl Iterator for Counter`.
We don‚Äôt have to specify that we want an iterator of `u32` values everywhere
that we call `next` on `Counter`.
-->
<p>Avec les types associ√©s, nous n'avons pas besoin d'annoter les types car nous
ne pouvons pas impl√©menter un trait plusieurs fois sur un m√™me type. Dans l'encart
19-12 qui contient la d√©finition qui utilise les types associ√©s, nous ne pouvons
choisir quel sera le type de <code>Item</code> qu'une seule fois, car il ne peut
y avoir qu'un seul <code>impl Iterator for Compteur</code>. Nous n'avons pas √† pr√©ciser
que nous souhaitons avoir un it√©rateur de valeurs <code>u32</code> √† chaque fois que nous
faisons appel √† <code>next</code> sur <code>Compteur</code>.</p>
<!--
### Default Generic Type Parameters and Operator Overloading
-->
<h3 id="les-param√®tres-de-types-g√©n√©riques-par-d√©faut-et-la-surcharge-dop√©rateur"><a class="header" href="#les-param√®tres-de-types-g√©n√©riques-par-d√©faut-et-la-surcharge-dop√©rateur">Les param√®tres de types g√©n√©riques par d√©faut et la surcharge d'op√©rateur</a></h3>
<!--
When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is `<PlaceholderType=ConcreteType>` when
declaring the generic type.
-->
<p>Lorsque nous utilisons les param√®tres de types g√©n√©riques, nous pouvons
renseigner un type concret par d√©faut pour le type g√©n√©rique. Cela √©vite de
contraindre ceux qui impl√©mentent ce trait d'avoir √† renseigner un type concret
si celui par d√©faut fonctionne bien. La syntaxe pour renseigner un type par
d√©faut pour un type g√©n√©rique est <code>&lt;TypeARemplacer=TypeConcret&gt;</code> lorsque nous
d√©clarons le type g√©n√©rique.</p>
<!--
A great example of a situation where this technique is useful is with operator
overloading. *Operator overloading* is customizing the behavior of an operator
(such as `+`) in particular situations.
-->
<p>Un bon exemple d'une situation pour laquelle cette technique est utile est avec
la surcharge d'op√©rateurs. <em>La surcharge d'op√©rateur</em> permet de personnaliser
le comportement d'un op√©rateur (comme <code>+</code>) dans des cas particuliers.</p>
<!--
Rust doesn‚Äôt allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in `std::ops` by implementing the traits associated with the operator. For
example, in Listing 19-14 we overload the `+` operator to add two `Point`
instances together. We do this by implementing the `Add` trait on a `Point`
struct:
-->
<p>Rust ne vous permet pas de cr√©er vos propres op√©rateurs ou de surcharger des
op√©rateurs. Mais vous pouvez surcharger les op√©rations et les traits list√©s
dans <code>std::ops</code> en impl√©mentant les traits associ√©s √† l'op√©rateur. Par exemple,
dans l'encart 19-14 nous surchargeons l'op√©rateur <code>+</code> pour additionner ensemble
deux instances de <code>Point</code>. Nous pouvons faire cela en impl√©mentant le trait
<code>Add</code> sur une structure <code>Point</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-14: Implementing the `Add` trait to overload
the `+` operator for `Point` instances</span>
-->
<p><span class="caption">Encart 19-14¬†: impl√©mentation du trait <code>Add</code> pour
surcharger l'op√©rateur <code>+</code> pour les instances de <code>Point</code></span></p>
<!--
The `add` method adds the `x` values of two `Point` instances and the `y`
values of two `Point` instances to create a new `Point`. The `Add` trait has an
associated type named `Output` that determines the type returned from the `add`
method.
-->
<p>La m√©thode <code>add</code> ajoute les valeurs <code>x</code> de deux instances de <code>Point</code> ainsi que
les valeurs <code>y</code> de deux instances de <code>Point</code> pour cr√©er un nouveau <code>Point</code>. Le
trait <code>Add</code> a un type associ√© <code>Output</code> qui d√©termine le type retourn√© pour la
m√©thode <code>add</code>.</p>
<!--
The default generic type in this code is within the `Add` trait. Here is its
definition:
-->
<p>Le type g√©n√©rique par d√©faut dans ce code est dans le trait <code>Add</code>. Voici sa
d√©finition¬†:</p>
<!--
```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code should look generally familiar: a trait with one method and an
associated type. The new part is `Rhs=Self`: this syntax is called *default
type parameters*. The `Rhs` generic type parameter (short for ‚Äúright hand
side‚Äù) defines the type of the `rhs` parameter in the `add` method. If we don‚Äôt
specify a concrete type for `Rhs` when we implement the `Add` trait, the type
of `Rhs` will default to `Self`, which will be the type we‚Äôre implementing
`Add` on.
-->
<p>Ce code devrait vous √™tre familier¬†: un trait avec une m√©thode et un type
associ√©. La nouvelle partie concerne <code>Rhs=Self</code>¬†: cette syntaxe s'appelle les
<em>param√®tres de types par d√©faut</em>. Le param√®tre de type g√©n√©rique <code>Rhs</code>
(c'est le raccourci de ‚ÄúRight Hand Side‚Äù) qui d√©finit le type du param√®tre
<code>rhs</code> dans la m√©thode <code>add</code>. Si nous ne renseignons pas de type concret pour
<code>Rhs</code> lorsque nous impl√©mentons le trait <code>Add</code>, le type de <code>Rhs</code> sera par
d√©faut <code>Self</code>, qui sera le type sur lequel nous impl√©mentons <code>Add</code>.</p>
<!--
When we implemented `Add` for `Point`, we used the default for `Rhs` because we
wanted to add two `Point` instances. Let‚Äôs look at an example of implementing
the `Add` trait where we want to customize the `Rhs` type rather than using the
default.
-->
<p>Lorsque nous avons impl√©ment√© <code>Add</code> sur <code>Point</code>, nous avons utilis√© la valeur
par d√©faut de <code>Rhs</code> car nous voulions additionner deux instances de <code>Point</code>.
Voyons un exemple d'impl√©mentation du trait <code>Add</code> dans lequel nous souhaitons
personnaliser le type <code>Rhs</code> plut√¥t que d'utiliser celui par d√©faut.</p>
<!--
We have two structs, `Millimeters` and `Meters`, holding values in different
units. This thin wrapping of an existing type in another struct is known as the
*newtype pattern*, which we describe in more detail in the [‚ÄúUsing the Newtype
Pattern to Implement External Traits on External Types‚Äù][newtype]<!-- ignore
-- > section. We want to add values in millimeters to values in meters and have
the implementation of `Add` do the conversion correctly. We can implement `Add`
for `Millimeters` with `Meters` as the `Rhs`, as shown in Listing 19-15.
-->
<p>Nous avons deux structures, <code>Millimetres</code> et <code>Metres</code>, qui stockent des valeurs
dans diff√©rentes unit√©s. Ce l√©ger enrobage d'un type existant dans une autre
structure s'appelle le <em>motif newtype</em>, que nous d√©crivons plus en d√©tail dans
la section <a href="ch19-03-advanced-traits.html#utiliser-le-motif-newtype-pour-impl%C3%A9menter-des-traits-externes-sur-des-types-externes">Utiliser le motif newtype pour la s√©curit√© et l'abstraction des
types</a><!-- ignore -->. Nous voulons pouvoir additionner les valeurs en
millim√®tres avec les valeurs en m√®tres et appliquer l'impl√©mentation de <code>Add</code>
pour pouvoir faire la conversion correctement. Nous pouvons impl√©menter <code>Add</code>
sur <code>Millimetres</code> avec <code>Metres</code> comme √©tant le <code>Rhs</code>, comme dans l'encart
19-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimetres(u32);
struct Metres(u32);

impl Add&lt;Metres&gt; for Millimetres {
    type Output = Millimetres;

    fn add(self, other: Metres) -&gt; Millimetres {
        Millimetres(self.0 + (other.0 * 1000))
    }
}
</code></pre>
<!--
<span class="caption">Listing 19-15: Implementing the `Add` trait on
`Millimeters` to add `Millimeters` to `Meters`</span>
-->
<p><span class="caption">Encart 19-15¬†: impl√©mentation du trait <code>Add</code> sur
<code>Millimetres</code> pour pouvoir additionner <code>Millimetres</code> √† <code>Metres</code></span></p>
<!--
To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the
value of the `Rhs` type parameter instead of using the default of `Self`.
-->
<p>Pour additionner <code>Millimetres</code> et <code>Metres</code>, nous renseignons
<code>impl Add&lt;Metres&gt;</code> pour r√©gler la valeur du param√®tre de type <code>Rhs</code> au lieu
d'utiliser la valeur par d√©faut <code>Self</code>.</p>
<!--
You‚Äôll use default type parameters in two main ways:
-->
<p>Vous utiliserez les param√®tres de types par d√©faut dans deux principaux cas¬†:</p>
<!--
* To extend a type without breaking existing code
* To allow customization in specific cases most users won‚Äôt need
-->
<ul>
<li>Pour √©tendre un type sans casser le code existant</li>
<li>Pour permettre la personnalisation dans des cas sp√©cifiques que la plupart
des utilisateurs n'auront pas</li>
</ul>
<!--
The standard library‚Äôs `Add` trait is an example of the second purpose:
usually, you‚Äôll add two like types, but the `Add` trait provides the ability to
customize beyond that. Using a default type parameter in the `Add` trait
definition means you don‚Äôt have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn‚Äôt needed, making
it easier to use the trait.
-->
<p>Le trait <code>Add</code> de la biblioth√®que standard est un exemple du second cas¬†:
g√©n√©ralement, vous additionnez deux types similaires, mais le trait <code>Add</code> offre
la possibilit√© de personnaliser cela. L'utilisation d'un param√®tre de type par
d√©faut dans la d√©finition du trait <code>Add</code> signifie que vous n'aurez pas √†
renseigner de param√®tre en plus la plupart du temps. Autrement dit, il n'est
pas n√©cessaire d'avoir recours √† des assemblages de code, ce qui facilite
l'utilisation du trait.</p>
<!--
The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.
-->
<p>Le premier cas est similaire au second mais dans le cas inverse¬†: si vous
souhaitez ajouter un param√®tre de type √† un trait existant, vous pouvez lui en
donner un par d√©faut pour permettre l'ajout des fonctionnalit√©s du trait sans
casser l'impl√©mentation actuelle du code.</p>
<!--
### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name
-->
<h3 id="la-syntaxe-totalement-d√©finie-pour-clarifier-les-appels-√†-des-m√©thodes-qui-ont-le-m√™me-nom"><a class="header" href="#la-syntaxe-totalement-d√©finie-pour-clarifier-les-appels-√†-des-m√©thodes-qui-ont-le-m√™me-nom">La syntaxe totalement d√©finie pour clarifier les appels √† des m√©thodes qui ont le m√™me nom</a></h3>
<!--
Nothing in Rust prevents a trait from having a method with the same name as
another trait‚Äôs method, nor does Rust prevent you from implementing both traits
on one type. It‚Äôs also possible to implement a method directly on the type with
the same name as methods from traits.
-->
<p>Il n'y a rien en Rust qui emp√™che un trait d'avoir une m√©thode portant le m√™me
nom qu'une autre m√©thode d'un autre trait, ni ne vous emp√™che d'impl√©menter
ces deux traits sur un m√™me type. Il est aussi possible
d'impl√©menter directement une m√©thode avec le m√™me nom que celle pr√©sente dans
les traits sur ce type.</p>
<!--
When calling methods with the same name, you‚Äôll need to tell Rust which one you
want to use. Consider the code in Listing 19-16 where we‚Äôve defined two traits,
`Pilot` and `Wizard`, that both have a method called `fly`. We then implement
both traits on a type `Human` that already has a method named `fly` implemented
on it. Each `fly` method does something different.
-->
<p>Lorsque nous faisons appel √† des m√©thodes qui ont un conflit de nom, vous devez
pr√©ciser √† Rust pr√©cis√©ment celle que vous souhaitez utiliser. Imaginons le
code dans l'encart 19-16 dans lequel nous avons d√©fini deux traits, <code>Pilote</code> et
<code>Magicien</code>, qui ont tous les deux une m√©thode <code>voler</code>. Nous
impl√©mentons ensuite ces deux traits sur un type <code>Humain</code> qui a d√©j√† lui-aussi
une m√©thode <code>voler</code> qui lui a √©t√© impl√©ment√©e. Chaque m√©thode <code>voler</code> fait
quelque chose de diff√©rent.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">trait Pilote {
    fn voler(&amp;self);
}

trait Magicien {
    fn voler(&amp;self);
}

struct Humain;

impl Pilote for Humain {
    fn voler(&amp;self) {
        println!(&quot;Ici le capitaine qui vous parle.&quot;);
    }
}

impl Magicien for Humain {
    fn voler(&amp;self) {
        println!(&quot;D√©collage !&quot;);
    }
}

impl Humain {
    fn voler(&amp;self) {
        println!(&quot;*agite fr√©n√©tiquement ses bras*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-16: Two traits are defined to have a `fly`
method and are implemented on the `Human` type, and a `fly` method is
implemented on `Human` directly</span>
-->
<p><span class="caption">Encart 19-16¬†: deux traits qui ont une m√©thode <code>voler</code>
et qui sont impl√©ment√©s sur le type <code>Humain</code>, et une m√©thode <code>voler</code> est aussi
impl√©ment√©e directement sur <code>Humain</code></span></p>
<!--
When we call `fly` on an instance of `Human`, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-17.
-->
<p>Lorsque nous utilisons <code>voler</code> sur une instance de <code>Humain</code>, le compilateur
fait appel par d√©faut √† la m√©thode qui est directement impl√©ment√©e sur le type,
comme le montre l'encart 19-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# trait Pilot {
#     fn fly(&self);
# }
# 
# trait Wizard {
#     fn fly(&self);
# }
# 
# struct Human;
# 
# impl Pilot for Human {
#     fn fly(&self) {
#         println!("This is your captain speaking.");
#     }
# }
# 
# impl Wizard for Human {
#     fn fly(&self) {
#         println!("Up!");
#     }
# }
# 
# impl Human {
#     fn fly(&self) {
#         println!("*waving arms furiously*");
#     }
# }
# 
fn main() {
    let person = Human;
    person.fly();
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilote {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Magicien {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Humain;
</span><span class="boring">
</span><span class="boring">impl Pilote for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Ici le capitaine qui vous parle.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Magicien for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;D√©collage !&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;*agite fr√©n√©tiquement ses bras*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let une_personne = Humain;
    une_personne.voler();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-17: Calling `fly` on an instance of
`Human`</span>
-->
<p><span class="caption">Encart 19-17¬†: utilisation de <code>voler</code> sur une instance de
<code>Humain</code></span></p>
<!--
Running this code will print `*waving arms furiously*`, showing that Rust
called the `fly` method implemented on `Human` directly.
-->
<p>L'ex√©cution de ce code va afficher <code>*agite fr√©n√©tiquement ses bras*</code>, ce qui
d√©montre que Rust a appel√© la m√©thode <code>voler</code> impl√©ment√©e directement sur
<code>Humain</code>.</p>
<!--
To call the `fly` methods from either the `Pilot` trait or the `Wizard` trait,
we need to use more explicit syntax to specify which `fly` method we mean.
Listing 19-18 demonstrates this syntax.
-->
<p>Pour faire appel aux m√©thodes <code>voler</code> des traits <code>Pilote</code> ou <code>Magicien</code>, nous
devons utiliser une syntaxe plus explicite pour pr√©ciser quelle m√©thode <code>voler</code>
nous souhaitons utiliser. L'encart 19-18 montre cette syntaxe.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# trait Pilot {
#     fn fly(&self);
# }
# 
# trait Wizard {
#     fn fly(&self);
# }
# 
# struct Human;
# 
# impl Pilot for Human {
#     fn fly(&self) {
#         println!("This is your captain speaking.");
#     }
# }
# 
# impl Wizard for Human {
#     fn fly(&self) {
#         println!("Up!");
#     }
# }
# 
# impl Human {
#     fn fly(&self) {
#         println!("*waving arms furiously*");
#     }
# }
# 
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilote {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Magicien {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Humain;
</span><span class="boring">
</span><span class="boring">impl Pilote for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Ici le capitaine qui vous parle.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Magicien for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;D√©collage !&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;*agite fr√©n√©tiquement ses bras*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let une_personne = Humain;
    Pilote::voler(&amp;une_personne);
    Magicien::voler(&amp;une_personne);
    une_personne.voler();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-18: Specifying which trait‚Äôs `fly` method we
want to call</span>
-->
<p><span class="caption">Encart 19-18¬†: pr√©ciser de quel trait nous souhaitons
utiliser la m√©thode <code>voler</code></span></p>
<!--
Specifying the trait name before the method name clarifies to Rust which
implementation of `fly` we want to call. We could also write
`Human::fly(&person)`, which is equivalent to the `person.fly()` that we used
in Listing 19-18, but this is a bit longer to write if we don‚Äôt need to
disambiguate.
-->
<p>Si on renseigne le nom du trait avant le nom de la m√©thode, cela indique √† Rust
quelle impl√©mentation de <code>voler</code> nous souhaitons utiliser. Nous pouvons aussi
√©crire <code>Humain::voler(&amp;une_personne)</code>, qui est √©quivalent √†
<code>une_personne.voler()</code> que nous avons utilis√© dans l'encart 19-18, mais c'est
un peu plus long √† √©crire si nous n'avons pas besoin de pr√©ciser les choses.</p>
<!--
Running this code prints the following:
-->
<p>L'ex√©cution de ce code affiche ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Ici le capitaine qui vous parle.
D√©collage !
*agite fr√©n√©tiquement ses bras*
</code></pre>
<!--
Because the `fly` method takes a `self` parameter, if we had two *types* that
both implement one *trait*, Rust could figure out which implementation of a
trait to use based on the type of `self`.
-->
<p>Comme la m√©thode <code>voler</code> prend un param√®tre <code>self</code>, si nous avions deux
<em>types</em> qui impl√©mentaient chacun un des deux <em>traits</em>, Rust pourrait en
d√©duire quelle impl√©mentation de quel trait utiliser en fonction du type
de <code>self</code>.</p>
<!--
However, associated functions that are not methods don‚Äôt have a `self`
parameter. When there are multiple types or traits that define non-method
functions with the same function name, Rust doesn't always know which type you
mean unless you use *fully qualified syntax*. For example, the `Animal` trait
in Listing 19-19 has the associated non-method function `baby_name`, and the
`Animal` trait is implemented for the struct `Dog`. There‚Äôs also an associated
non-method function `baby_name` defined on `Dog` directly.
-->
<p>Cependant, les fonctions associ√©es qui ne sont pas des m√©thodes n'ont pas de
param√®tre <code>self</code>. Lorsqu'il y a plusieurs types ou traits qui d√©finissent des
fonctions qui ne sont pas des m√©thodes et qui ont le m√™me nom de fonction, Rust
ne peut pas toujours savoir quel type vous sous-entendez jusqu'√† ce que vous
utilisiez la <em>syntaxe totalement d√©finie</em>. Par exemple, le trait <code>Animal</code> de
l'encart 19-19 a une fonction associ√©e <code>nom_bebe</code> qui n'est pas une m√©thode, et
le trait <code>Animal</code> est impl√©ment√© pour la structure <code>Dog</code>.Il y a aussi une
fonction associ√©e <code>nom_bebe</code> qui n'est pas une m√©thode et qui est d√©finie
directement sur <code>Chien</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```
-->
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn nom_bebe() -&gt; String;
}

struct Chien;

impl Chien {
    fn nom_bebe() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Chien {
    fn nom_bebe() -&gt; String {
        String::from(&quot;chiot&quot;)
    }
}

fn main() {
    println!(&quot;Un b√©b√© chien s'appelle un {}&quot;, Chien::nom_bebe());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-19: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span>
-->
<p><span class="caption">Encart 19-19¬†: un trait avec une fonction associ√©e et un
type avec une autre fonction associ√©e qui porte le m√™me nom et qui impl√©mente
aussi ce trait</span></p>
<!--
This code is for an animal shelter that wants to name all puppies Spot, which
is implemented in the `baby_name` associated function that is defined on `Dog`.
The `Dog` type also implements the trait `Animal`, which describes
characteristics that all animals have. Baby dogs are called puppies, and that
is expressed in the implementation of the `Animal` trait on `Dog` in the
`baby_name` function associated with the `Animal` trait.
-->
<p>Ce code a √©t√© con√ßu pour un refuge pour animaux qui souhaite que tous leurs chiots
soient nomm√©s Spot, ce qui est impl√©ment√© dans la fonction associ√©e <code>nom_bebe</code>
de <code>Chien</code>. Le type <code>Chien</code> impl√©mente lui aussi le trait <code>Animal</code>, qui d√©crit
les caract√©ristiques que tous les animaux doivent avoir. Les b√©b√©s chiens
doivent s'appeler des chiots, et ceci est exprim√© dans l'impl√©mentation du
trait <code>Animal</code> sur <code>Chien</code> dans la fonction <code>nom_bebe</code> associ√©e au trait
<code>Animal</code>.</p>
<!--
In `main`, we call the `Dog::baby_name` function, which calls the associated
function defined on `Dog` directly. This code prints the following:
-->
<p>Dans le <code>main</code>, nous faisons appel √† la fonction <code>Chien::nom_bebe</code>, qui fait
appel √† la fonction associ√©e directement d√©finie sur <code>Chien</code>. Ce code affiche
ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
Un b√©b√© chien s'appelle un Spot
</code></pre>
<!--
This output isn‚Äôt what we wanted. We want to call the `baby_name` function that
is part of the `Animal` trait that we implemented on `Dog` so the code prints
`A baby dog is called a puppy`. The technique of specifying the trait name that
we used in Listing 19-18 doesn‚Äôt help here; if we change `main` to the code in
Listing 19-20, we‚Äôll get a compilation error.
-->
<p>Ce r√©sultat n'est pas celui que nous souhaitons. Nous voulons appeler la
fonction <code>nom_bebe</code> qui fait partie du trait <code>Animal</code> que nous avons impl√©ment√©
sur <code>Chien</code> afin que le code affiche <code>Un b√©b√© chien s'appelle un chiot</code>. La
technique pour pr√©ciser le nom du trait que nous avons utilis√©e pr√©c√©demment ne
va pas nous aider ici¬†; si nous changeons le <code>main</code> par le code de l'encart
19-20, nous allons avoir une erreur de compilation.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# trait Animal {
#     fn baby_name() -> String;
# }
# 
# struct Dog;
# 
# impl Dog {
#     fn baby_name() -> String {
#         String::from("Spot")
#     }
# }
# 
# impl Animal for Dog {
#     fn baby_name() -> String {
#         String::from("puppy")
#     }
# }
# 
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn nom_bebe() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Chien;
</span><span class="boring">
</span><span class="boring">impl Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;chiot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Un b√©b√© chien s'appelle un {}&quot;, Animal::nom_bebe());
}
</code></pre>
<!--
<span class="caption">Listing 19-20: Attempting to call the `baby_name`
function from the `Animal` trait, but Rust doesn‚Äôt know which implementation to
use</span>
-->
<p><span class="caption">Encart 19-20¬†: tentative d'appel √† la fonction <code>nom_bebe</code>
du trait <code>Animal</code>, mais Rust ne sait pas quelle impl√©mentation utiliser</span></p>
<!--
Because `Animal::baby_name` doesn‚Äôt have a `self` parameter, and there could be
other types that implement the `Animal` trait, Rust can‚Äôt figure out which
implementation of `Animal::baby_name` we want. We‚Äôll get this compiler error:
-->
<p>Comme <code>Animal::nom_bebe</code> n'a pas de param√®tre <code>self</code>, et qu'il peut y avoir
d'autres types qui impl√©mentent le trait <code>Animal</code>, Rust ne peut pas savoir
quelle impl√©mentation de <code>Animal::nom_bebe</code> nous souhaitons utiliser. Nous
obtenons alors cette erreur de compilation¬†:</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  -- > src/main.rs:20:43
   |
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot satisfy `_: Animal`

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;Un b√©b√© chien s'appelle un {}&quot;, Animal::nom_bebe());
   |                                               ^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot satisfy `_: Animal`

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example` due to previous error
</code></pre>
<!--
To disambiguate and tell Rust that we want to use the implementation of
`Animal` for `Dog` as opposed to the implementation of `Animal` for some other
type, we need to use fully qualified syntax. Listing 19-21 demonstrates how to
use fully qualified syntax.
-->
<p>Pour expliquer √† Rust que nous souhaitons utiliser l'impl√©mentation de <code>Animal</code>
pour <code>Chien</code> et non pas l'impl√©mentation de <code>Animal</code> pour d'autres types, nous
devons utiliser la syntaxe totalement d√©finie. L'encart 19-21 montre comment
utiliser la syntaxe totalement d√©finie.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# trait Animal {
#     fn baby_name() -> String;
# }
# 
# struct Dog;
# 
# impl Dog {
#     fn baby_name() -> String {
#         String::from("Spot")
#     }
# }
# 
# impl Animal for Dog {
#     fn baby_name() -> String {
#         String::from("puppy")
#     }
# }
# 
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn nom_bebe() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Chien;
</span><span class="boring">
</span><span class="boring">impl Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;chiot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Un b√©b√© chien s'appelle un {}&quot;, &lt;Chien as Animal&gt;::nom_bebe());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-21: Using fully qualified syntax to specify
that we want to call the `baby_name` function from the `Animal` trait as
implemented on `Dog`</span>
-->
<p><span class="caption">Encart 19-21¬†: utilisation de la syntaxe totalement
d√©finie pour pr√©ciser que nous souhaitons appeler la fonction <code>nom_bebe</code> du
trait <code>Animal</code> tel qu'il est impl√©ment√© sur <code>Chien</code></span></p>
<!--
We‚Äôre providing Rust with a type annotation within the angle brackets, which
indicates we want to call the `baby_name` method from the `Animal` trait as
implemented on `Dog` by saying that we want to treat the `Dog` type as an
`Animal` for this function call. This code will now print what we want:
-->
<p>Nous avons donn√© √† Rust une annotation de type entre des chevrons, ce qui
indique que nous souhaitons appeler la m√©thode <code>nom_bebe</code> du trait <code>Animal</code>
telle qu'elle est impl√©ment√©e sur <code>Chien</code> en indiquant que nous souhaitons traiter
le type <code>Chien</code> comme √©tant un <code>Animal</code> pour cet appel de fonction. Ce code va
d√©sormais afficher ce que nous souhaitons¬†:</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Un b√©b√© chien s'appelle un chiot
</code></pre>
<!--
In general, fully qualified syntax is defined as follows:
-->
<p>De mani√®re g√©n√©rale, une syntaxe totalement d√©finie est d√©finie comme ceci¬†:</p>
<!--
```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```
-->
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(destinataire_si_methode, argument_suivant, ...);
</code></pre>
<!--
For associated functions that aren‚Äôt methods, there would not be a `receiver`:
there would only be the list of other arguments. You could use fully qualified
syntax everywhere that you call functions or methods. However, you‚Äôre allowed
to omit any part of this syntax that Rust can figure out from other information
in the program. You only need to use this more verbose syntax in cases where
there are multiple implementations that use the same name and Rust needs help
to identify which implementation you want to call.
-->
<p>Pour les fonctions associ√©es qui ne sont pas des m√©thodes, il n'y a pas de
<code>destinataire</code>¬†: il n'y a qu'une liste d'arguments. Vous pouvez utiliser la
syntaxe totalement d√©finie √† n'importe quel endroit o√π vous faites appel √† des
fonctions ou des m√©thodes. Cependant, vous avez la possibilit√© de ne pas
renseigner toute partie de cette syntaxe que Rust peut d√©duire √† partir
d'autres informations pr√©sentes dans le code. Vous avez seulement besoin
d'utiliser cette syntaxe plus verbeuse dans les cas o√π il y a plusieurs
impl√©mentations qui utilisent le m√™me nom et que Rust doit √™tre aid√© pour
identifier quelle impl√©mentation vous souhaitez appeler.</p>
<!--
### Using Supertraits to Require One Trait‚Äôs Functionality Within Another Trait
-->
<h3 id="utiliser-les-supertraits-pour-utiliser-la-fonctionnalit√©-dun-trait-dans-un-autre-trait"><a class="header" href="#utiliser-les-supertraits-pour-utiliser-la-fonctionnalit√©-dun-trait-dans-un-autre-trait">Utiliser les supertraits pour utiliser la fonctionnalit√© d'un trait dans un autre trait</a></h3>
<!--
Sometimes, you might need one trait to use another trait‚Äôs functionality. In
this case, you need to rely on the dependent trait also being implemented.
The trait you rely on is a *supertrait* of the trait you‚Äôre implementing.
-->
<p>Des fois, vous pourriez avoir besoin d'un trait pour utiliser la fonctionnalit√©
d'un autre trait. Dans ce cas, vous devez pouvoir compter sur le fait que le
trait d√©pendant soit bien impl√©ment√©. Le trait sur lequel vous comptez est
alors un <em>supertrait</em> du trait que vous impl√©mentez.</p>
<!--
For example, let‚Äôs say we want to make an `OutlinePrint` trait with an
`outline_print` method that will print a value framed in asterisks. That is,
given a `Point` struct that implements `Display` to result in `(x, y)`, when we
call `outline_print` on a `Point` instance that has `1` for `x` and `3` for
`y`, it should print the following:
-->
<p>Par exemple, imaginons que nous souhaitons cr√©er un trait <code>OutlinePrint</code> qui
offre une m√©thode <code>outline_print</code> affichant une valeur entour√©e d'ast√©risques.
Ainsi, pour une structure <code>Point</code> qui impl√©mente <code>Display</code> pour afficher <code>(x, y)</code>,
lorsque nous faisons appel √† <code>outline_print</code> sur une instance de <code>Point</code> qui a
<code>1</code> pour valeur de <code>x</code> et <code>3</code> pour <code>y</code>, cela devrait afficher ceci¬†:</p>
<!--
```text
**********
*        *
* (1, 3) *
*        *
**********
```
-->
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<!--
In the implementation of `outline_print`, we want to use the `Display` trait‚Äôs
functionality. Therefore, we need to specify that the `OutlinePrint` trait will
work only for types that also implement `Display` and provide the functionality
that `OutlinePrint` needs. We can do that in the trait definition by specifying
`OutlinePrint: Display`. This technique is similar to adding a trait bound to
the trait. Listing 19-22 shows an implementation of the `OutlinePrint` trait.
-->
<p>Dans l'impl√©mentation de <code>outline_print</code>, nous souhaitons utiliser la
fonctionnalit√© du trait <code>Display</code>. De ce fait, nous devons indiquer que le
trait <code>OutlinePrint</code> fonctionnera uniquement pour les types qui auront √©galement
impl√©ment√© <code>Display</code> et qui fourniront la fonctionnalit√© dont a besoin
<code>OutlinePrint</code>. Nous pouvons faire ceci dans la d√©finition du trait en
renseignant <code>OutlinePrint: Display</code>. Cette technique ressemble √† l'ajout d'un
trait li√© au trait. L'encart 19-22 montre une impl√©mentation du trait
<code>OutlinePrint</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let valeur = self.to_string();
        let largeur = valeur.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
        println!(&quot;* {} *&quot;, valeur);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-22: Implementing the `OutlinePrint` trait that
requires the functionality from `Display`</span>
-->
<p><span class="caption">Encart 19-22¬†: impl√©mentation du trait <code>OutlinePrint</code> qui
n√©cessite la fonctionnalit√© offerte par <code>Display</code></span></p>
<!--
Because we‚Äôve specified that `OutlinePrint` requires the `Display` trait, we
can use the `to_string` function that is automatically implemented for any type
that implements `Display`. If we tried to use `to_string` without adding a
colon and specifying the `Display` trait after the trait name, we‚Äôd get an
error saying that no method named `to_string` was found for the type `&Self` in
the current scope.
-->
<p>Comme nous avons pr√©cis√© que <code>OutlinePrint</code> n√©cessite le trait <code>Display</code>, nous
pouvons utiliser la fonction <code>to_string</code> qui est automatiquement impl√©ment√©e
pour n'importe quel type qui impl√©mente <code>Display</code>. Si nous avions essay√©
d'utiliser <code>to_string</code> sans ajouter un double-point et en renseignant le trait
<code>Display</code> apr√®s le nom du trait, nous aurions alors obtenu une erreur qui nous
informerait qu'il n'y a pas de m√©thode <code>to_string</code> pour le type <code>&amp;Self</code> dans la
port√©e courante.</p>
<!--
Let‚Äôs see what happens when we try to implement `OutlinePrint` on a type that
doesn‚Äôt implement `Display`, such as the `Point` struct:
-->
<p>Voyons ce qui ce passe lorsque nous essayons d'impl√©menter <code>OutlinePrint</code> sur
un type qui n'impl√©mente pas <code>Display</code>, comme c'est le cas de la structure
<code>Point</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::fmt;
# 
# trait OutlinePrint: fmt::Display {
#     fn outline_print(&self) {
#         let output = self.to_string();
#         let len = output.len();
#         println!("{}", "*".repeat(len + 4));
#         println!("*{}*", " ".repeat(len + 2));
#         println!("* {} *", output);
#         println!("*{}*", " ".repeat(len + 2));
#         println!("{}", "*".repeat(len + 4));
#     }
# }
# 
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
# 
# fn main() {
#     let p = Point { x: 1, y: 3 };
#     p.outline_print();
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let valeur = self.to_string();
</span><span class="boring">        let largeur = valeur.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, valeur);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<!--
We get an error saying that `Display` is required but not implemented:
-->
<p>Nous obtenons une erreur qui dit que <code>Display</code> est n√©cessaire mais n'est pas
impl√©ment√©¬†:</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  -- > src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  -- > src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
</code></pre>
<!--
To fix this, we implement `Display` on `Point` and satisfy the constraint that
`OutlinePrint` requires, like so:
-->
<p>Pour r√©gler cela, nous impl√©mentons <code>Display</code> sur <code>Point</code> afin de r√©pondre aux
besoins de <code>OutlinePrint</code>, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
# trait OutlinePrint: fmt::Display {
#     fn outline_print(&self) {
#         let output = self.to_string();
#         let len = output.len();
#         println!("{}", "*".repeat(len + 4));
#         println!("*{}*", " ".repeat(len + 2));
#         println!("* {} *", output);
#         println!("*{}*", " ".repeat(len + 2));
#         println!("{}", "*".repeat(len + 4));
#     }
# }
# 
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
# impl OutlinePrint for Point {}
# 
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
# 
# fn main() {
#     let p = Point { x: 1, y: 3 };
#     p.outline_print();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let valeur = self.to_string();
</span><span class="boring">        let largeur = valeur.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, valeur);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<!--
Then implementing the `OutlinePrint` trait on `Point` will compile
successfully, and we can call `outline_print` on a `Point` instance to display
it within an outline of asterisks.
-->
<p>Ceci fait, l'impl√©mentation du trait <code>OutlinePrint</code> sur <code>Point</code> va se
compiler avec succ√®s, et nous pourrons appeler <code>outline_print</code> sur une instance
de <code>Point</code> pour l'afficher dans le cadre constitu√© d'ast√©risques.</p>
<!--
### Using the Newtype Pattern to Implement External Traits on External Types
-->
<h3 id="utiliser-le-motif-newtype-pour-impl√©menter-des-traits-externes-sur-des-types-externes"><a class="header" href="#utiliser-le-motif-newtype-pour-impl√©menter-des-traits-externes-sur-des-types-externes">Utiliser le motif newtype pour impl√©menter des traits externes sur des types externes</a></h3>
<!--
In Chapter 10 in the [‚ÄúImplementing a Trait on a
Type‚Äù][implementing-a-trait-on-a-type]<!-- ignore -- > section, we mentioned
the orphan rule that states we‚Äôre allowed to implement a trait on a type as
long as either the trait or the type are local to our crate. It‚Äôs possible to
get around this restriction using the *newtype pattern*, which involves
creating a new type in a tuple struct. (We covered tuple structs in the
[‚ÄúUsing Tuple Structs without Named Fields to Create Different
Types‚Äù][tuple-structs]<!-- ignore -- > section of Chapter 5.) The tuple struct
will have one field and be a thin wrapper around the type we want to implement
a trait for. Then the wrapper type is local to our crate, and we can implement
the trait on the wrapper. *Newtype* is a term that originates from the Haskell
programming language. There is no runtime performance penalty for using this
pattern, and the wrapper type is elided at compile time.
-->
<p>Dans <a href="ch10-02-traits.html">une section</a><!-- ignore --> du chapitre
10, nous avions mentionn√© la r√®gle de l'orphelin qui √©non√ßait que nous pouvions
impl√©menter un trait sur un type √† condition que le trait ou le type soit
local √† notre crate. Il est possible de contourner cette restriction en
utilisant le <em>motif newtype</em>, ce qui implique de cr√©er un nouveau type dans une
structure tuple (nous avons vu les structures tuple dans la section
<a href="ch05-01-defining-structs.html#utilisation-de-structures-tuples-sans-champ-nomm%C3%A9-pour-cr%C3%A9er-des-types-diff%C3%A9rents">‚ÄúUtilisation de structures tuples sans champ nomm√© pour cr√©er des types diff√©rents‚Äù</a><!-- ignore -->
du chapitre 5). La structure tuple aura un champ et sera une petite enveloppe
pour le type sur lequel nous souhaitons impl√©menter le trait. Ensuite, le type
enveloppant est local √† notre crate, et nous pouvons lui impl√©menter un trait.
<em>Newtype</em> est un terme qui provient du langage de programmation Haskell. Il n'y
a pas de cons√©quence sur les performance √† l'ex√©cution pour l'utilisation de ce
motif, ce qui signifie que le type enveloppant est r√©solu √† la compilation.</p>
<!--
As an example, let‚Äôs say we want to implement `Display` on `Vec<T>`, which the
orphan rule prevents us from doing directly because the `Display` trait and the
`Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct
that holds an instance of `Vec<T>`; then we can implement `Display` on
`Wrapper` and use the `Vec<T>` value, as shown in Listing 19-23.
-->
<p>Comme exemple, disons que nous souhaitons impl√©menter <code>Display</code> sur <code>Vec&lt;T&gt;</code>, ce
que la r√®gle de l'orphelin nous emp√™che de faire directement car le trait
<code>Display</code> et le type <code>Vec&lt;T&gt;</code> sont d√©finis en dehors de notre crate. Nous
pouvons construire une structure <code>Enveloppe</code> qui poss√®de une instance de
<code>Vec&lt;T&gt;</code>¬†; et ensuite nous pouvons impl√©menter <code>Display</code> sur <code>Enveloppe</code> et
utiliser la valeur <code>Vec&lt;T&gt;</code>, comme dans l'encart 19-23.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Enveloppe(Vec&lt;String&gt;);

impl fmt::Display for Enveloppe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Enveloppe(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-23: Creating a `Wrapper` type around
`Vec<String>` to implement `Display`</span>
-->
<p><span class="caption">Encart 19-23¬†: cr√©ation d'un type <code>Enveloppe</code> autour de
<code>Vec&lt;String&gt;</code> pour impl√©menter <code>Display</code></span></p>
<!--
The implementation of `Display` uses `self.0` to access the inner `Vec<T>`,
because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the
tuple. Then we can use the functionality of the `Display` type on `Wrapper`.
-->
<p>L'impl√©mentation de <code>Display</code> utilise <code>self.0</code> pour acc√©der √† la valeur de
<code>Vec&lt;T&gt;</code>, car <code>Enveloppe</code> est une structure tuple et <code>Vec&lt;T&gt;</code> est l'√©l√©ment √†
l'indice 0 du tuple. Ensuite, nous pouvons utiliser la fonctionnalit√© du type
<code>Display</code> sur <code>Enveloppe</code>.</p>
<!--
The downside of using this technique is that `Wrapper` is a new type, so it
doesn‚Äôt have the methods of the value it‚Äôs holding. We would have to implement
all the methods of `Vec<T>` directly on `Wrapper` such that the methods
delegate to `self.0`, which would allow us to treat `Wrapper` exactly like a
`Vec<T>`. If we wanted the new type to have every method the inner type has,
implementing the `Deref` trait (discussed in Chapter 15 in the [‚ÄúTreating Smart
Pointers Like Regular References with the `Deref`
Trait‚Äù][smart-pointer-deref]<!-- ignore -- > section) on the `Wrapper` to return
the inner type would be a solution. If we don‚Äôt want the `Wrapper` type to have
all the methods of the inner type‚Äîfor example, to restrict the `Wrapper` type‚Äôs
behavior‚Äîwe would have to implement just the methods we do want manually.
-->
<p>Le d√©savantage d'utiliser cette technique est que <code>Enveloppe</code> est un nouveau
type, donc il n'impl√©mente pas toutes les m√©thodes de la valeur qu'il poss√®de.
Il faudrait impl√©menter toutes les m√©thodes de <code>Vec&lt;T&gt;</code> directement sur
<code>Enveloppe</code> de fa√ßon √† ce qu'elles d√©l√®guent aux m√©thodes correspondantes de
<code>self.0</code>, ce qui nous permettrait d'utiliser <code>Enveloppe</code> exactement comme un
<code>Vec&lt;T&gt;</code>. Si nous voulions que le nouveau type ait toutes les m√©thodes du type
qu'il poss√®de, l'impl√©mentation du trait <code>Deref</code> (que nous avons vu dans
<a href="ch15-02-deref.html">une section du chapitre 15</a><!-- ignore -->) sur
<code>Enveloppe</code> pour retourner le type interne pourrait √™tre une solution. Si nous
ne souhaitons pas que le type <code>Enveloppe</code> ait toutes les m√©thodes du type qu'il
poss√®de (par exemple, pour limiter les fonctionnalit√©s du type <code>Enveloppe</code>),
nous n'avons qu'√† impl√©menter manuellement que les m√©thodes que nous souhaitons.</p>
<!--
Now you know how the newtype pattern is used in relation to traits; it‚Äôs also a
useful pattern even when traits are not involved. Let‚Äôs switch focus and look
at some advanced ways to interact with Rust‚Äôs type system.
-->
<p>Maintenant vous savez comment le motif newtype est utilis√© en lien avec les
traits¬†; c'est aussi un motif tr√®s utile m√™me lorsque les traits ne sont pas
concern√©s. Changeons de sujet et d√©couvrons d'autres techniques avanc√©es pour
interagir avec le syst√®me de type de Rust.</p>
<!-- markdownlint-disable -->
<!--
[newtype]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
[implementing-a-trait-on-a-type]:
ch10-02-traits.html#implementing-a-trait-on-a-type
[the-iterator-trait-and-the-next-method]:
ch13-02-iterators.html#the-iterator-trait-and-the-next-method
[traits-defining-shared-behavior]:
ch10-02-traits.html#traits-defining-shared-behavior
[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## Advanced Types
-->
<h2 id="les-types-avanc√©s"><a class="header" href="#les-types-avanc√©s">Les types avanc√©s</a></h2>
<!--
The Rust type system has some features that we‚Äôve mentioned in this book but
haven‚Äôt yet discussed. We‚Äôll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then we‚Äôll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. We‚Äôll also
discuss the `!` type and dynamically sized types.
-->
<p>Le syst√®me de type de Rust offre quelques fonctionnalit√©s que nous avons
mentionn√©es dans ce livre mais que nous n'avons pas encore √©tudi√©es. Nous allons
commencer par voir les newtypes en g√©n√©ral lorsque nous examinerons pourquoi
les newtypes sont des types utiles. Ensuite nous nous pencherons sur les alias
de type, une fonctionnalit√© qui ressemble aux newtypes mais avec quelques
diff√©rences s√©mantiques. Nous allons aussi voir le type <code>!</code> et les types √†
taille dynamique.</p>
<!--
### Using the Newtype Pattern for Type Safety and Abstraction
-->
<h3 id="utiliser-le-motif-newtype-pour-la-s√©curit√©-et-labstraction-des-types"><a class="header" href="#utiliser-le-motif-newtype-pour-la-s√©curit√©-et-labstraction-des-types">Utiliser le motif newtype pour la s√©curit√© et l'abstraction des types</a></h3>
<!--
> Note: This section assumes you‚Äôve read the earlier section [‚ÄúUsing the
> Newtype Pattern to Implement External Traits on External
> Types.‚Äù][using-the-newtype-pattern]<!-- ignore -- >
-->
<blockquote>
<p>Remarque¬†: cette section suppose que vous avez lu la
<a href="ch19-03-advanced-traits.html">section pr√©c√©dente</a><!-- ignore --></p>
</blockquote>
<!--
The newtype pattern is useful for tasks beyond those we‚Äôve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-15: recall that the `Millimeters` and `Meters` structs wrapped `u32`
values in a newtype. If we wrote a function with a parameter of type
`Millimeters`, we couldn‚Äôt compile a program that accidentally tried to call
that function with a value of type `Meters` or a plain `u32`.
-->
<p>Le motif newtype est utile pour faire des choses qui vont au-del√† de ce que
nous avons vu jusqu'√† pr√©sent, notamment pour s'assurer statiquement que des
valeurs ne soient jamais confondues ou pour sp√©cifier les unit√©s d'une valeur.
Vous avez vu un exemple d'utilisation des newtypes pour indiquer des unit√©s
dans l'encart 19-15¬†: souvenez-vous des structures <code>Millimetres</code> et <code>Metres</code>
qui englobaient des valeurs <code>u32</code> dans ces newtypes. Si nous avions √©crit une
fonction avec un param√®tre de type <code>Millimetres</code>, nous ne n'aurions pas pu
compiler un programme qui aurait accidentellement fait appel √† cette fonction
avec une valeur du type <code>Metres</code> ou <code>u32</code> pur.</p>
<!--
Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type.
-->
<p>Une autre utilisation du motif newtype est de permettre d'abstraire certains d√©tails
d'impl√©mentation d'un type¬†: le newtype peut exposer une API publique qui est
diff√©rente de l'API du type interne priv√©.</p>
<!--
Newtypes can also hide internal implementation. For example, we could provide a
`People` type to wrap a `HashMap<i32, String>` that stores a person‚Äôs ID
associated with their name. Code using `People` would only interact with the
public API we provide, such as a method to add a name string to the `People`
collection; that code wouldn‚Äôt need to know that we assign an `i32` ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the [‚ÄúEncapsulation that
Hides Implementation
Details‚Äù][encapsulation-that-hides-implementation-details]<!-- ignore -- >
section of Chapter 17.
-->
<p>Les newtypes peuvent aussi masquer des impl√©mentations internes. Par exemple,
nous pouvons fournir un type <code>Personnes</code> pour embarquer un
<code>HashMap&lt;i32, String&gt;</code> qui stocke l'identifiant de personnes associ√©s √† leur
nom. Le code qui utilisera <code>Personnes</code> ne pourra utiliser que l'API publique
que nous fournissons, telle qu'une m√©thode pour ajouter une cha√Æne de caract√®res
en tant que nom √† la collection <code>Personnes</code>¬†; ce code n'aura pas
besoin de savoir que nous assignons en interne un identifiant <code>i32</code> aux noms.
Le motif newtype est une fa√ßon all√©g√©e de proc√©der √† de l'encapsulation pour
masquer des d√©tails d'impl√©mentation, comme nous l'avons vu dans <a href="ch17-01-what-is-oo.html">une partie du
chapitre 17</a><!-- ignore -->.</p>
<!--
### Creating Type Synonyms with Type Aliases
-->
<h3 id="cr√©er-des-synonymes-de-types-avec-les-alias-de-type"><a class="header" href="#cr√©er-des-synonymes-de-types-avec-les-alias-de-type">Cr√©er des synonymes de types avec les alias de type</a></h3>
<!--
Along with the newtype pattern, Rust provides the ability to declare a *type
alias* to give an existing type another name. For this we use the `type`
keyword. For example, we can create the alias `Kilometers` to `i32` like so:
-->
<p>En plus du motif newtype, Rust fournit la possibilit√© de d√©clarer un <em>alias de
type</em> pour donner un autre nom √† un type d√©j√† existant. Pour faire cela, nous
utilisons le mot-cl√© <code>type</code>. Par exemple, nous pouvons cr√©er l'alias
<code>Kilometres</code> pour un <code>i32</code>, comme ceci¬†:</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;
# 
#     let x: i32 = 5;
#     let y: Kilometers = 5;
# 
#     println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometres = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters`
and `Meters` types we created in Listing 19-15, `Kilometers` is not a separate,
new type. Values that have the type `Kilometers` will be treated the same as
values of type `i32`:
-->
<p>D√©sormais, l'alias <code>Kilometres</code> est un <em>synonyme</em> de <code>i32</code>¬†; contrairement aux
types <code>Millimetres</code> et <code>Metres</code> que nous avons cr√©√©s dans l'encart 19-15,
<code>Kilometres</code> n'est pas un newtype s√©par√©. Les valeurs qui ont le type
<code>Kilometre</code> seront trait√©es comme si elles √©taient du type <code>i32</code>¬†:</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;

    let x: i32 = 5;
    let y: Kilometres = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<!--
Because `Kilometers` and `i32` are the same type, we can add values of both
types and we can pass `Kilometers` values to functions that take `i32`
parameters. However, using this method, we don‚Äôt get the type checking benefits
that we get from the newtype pattern discussed earlier.
-->
<p>Comme <code>Kilometres</code> et <code>i32</code> sont du m√™me type, nous pouvons additionner les
valeurs des deux types et nous pouvons envoyer des valeurs <code>Kilometres</code> aux
fonctions qui prennent des param√®tres <code>i32</code>. Cependant, en utilisant cette
m√©thode, nous ne b√©n√©ficions pas des bienfaits de la v√©rification du type que
nous avions avec le motif newtype que nous avons vu pr√©c√©demment.</p>
<!--
The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:
-->
<p>L'utilisation principale pour les synonymes de types est de r√©duire la
r√©p√©tition. Par exemple, nous pourrions avoir un type un peu long tel que
celui-ci¬†:</p>
<!--
```rust,ignore
Box<dyn Fn() + Send + 'static>
```
-->
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<!--
Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.
-->
<p>Ecrire ce type un peu long dans des signatures de fonctions et comme
annotations de types tout au long du code peut s'av√©rer p√©nible et faciliter
les erreurs. Imaginez que vous ayez un projet avec plein de code ressemblant √†
celui de l'encart 19-24.</p>
<!--
```rust
# fn main() {
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
        // --snip--
    }

    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // -- partie masqu√©e ici --
    }

    fn retourne_un_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // -- partie masqu√©e ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-24: Using a long type in many places</span>
-->
<p><span class="caption">Encart 19-24¬†: utilisation d'un type long √† √©crire dans
de nombreux endroits</span></p>
<!--
A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, we‚Äôve introduced an alias named `Thunk` for the verbose type and
can replace all uses of the type with the shorter alias `Thunk`.
-->
<p>Un alias de type simplifie ce code en r√©duisant la r√©p√©tition. Dans l'encart
19-25, nous avons ajout√© un alias <code>Thunk</code> pour ce type verbeux, alias plus
court qui peut le remplacer partout o√π il est utilis√©.</p>
<!--
```rust
# fn main() {
    type Thunk = Box<dyn Fn() + Send + 'static>;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -> Thunk {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Thunk) {
        // -- partie masqu√©e ici --
    }

    fn retourne_un_long_type() -&gt; Thunk {
        // -- partie masqu√©e ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-25: Introducing a type alias `Thunk` to reduce
repetition</span>
-->
<p><span class="caption">Encart 19-25¬†: ajout et utilisation d'un alias <code>Thunk</code>
pour r√©duire les r√©p√©titions</span></p>
<!--
This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (*thunk* is a word for code
to be evaluated at a later time, so it‚Äôs an appropriate name for a closure that
gets stored).
-->
<p>Ce code est plus facile √† lire et √©crire¬†! Choisir un nom plus explicite pour
un alias peut aussi vous aider √† communiquer ce que vous voulez faire (<em>thunk</em>
est un terme d√©signant du code qui doit √™tre √©valu√© plus tard, donc c'est un nom
appropri√© pour une fermeture qui est stock√©e).</p>
<!--
Type aliases are also commonly used with the `Result<T, E>` type for reducing
repetition. Consider the `std::io` module in the standard library. I/O
operations often return a `Result<T, E>` to handle situations when operations
fail to work. This library has a `std::io::Error` struct that represents all
possible I/O errors. Many of the functions in `std::io` will be returning
`Result<T, E>` where the `E` is `std::io::Error`, such as these functions in
the `Write` trait:
-->
<p>Les alias de type sont couramment utilis√©s avec le type <code>Result&lt;T, E&gt;</code> pour
r√©duire la r√©p√©tition. Regardez le module <code>std::io</code> de la biblioth√®que standard.
Les op√©rations d'entr√©e/sortie retournent souvent un <code>Result&lt;T, E&gt;</code> pour g√©rer
les situations o√π les op√©rations √©chouent. Cette biblioth√®que a une structure
<code>std::io::Error</code> qui repr√©sente toutes les erreurs possibles d'entr√©e/sortie.
De nombreuses fonctions dans <code>std::io</code> vont retourner un <code>Result&lt;T, E&gt;</code> avec
<code>E</code> qui est un alias pour <code>std::io::Error</code>, comme par exemple ces fonctions
sont dans le trait <code>Write</code>¬†:</p>
<!--
```rust,noplayground
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<!--
The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type
alias declaration:
-->
<p>Le <code>Result&lt;..., Error&gt;</code> est r√©p√©t√© plein de fois. C'est pourquoi <code>std::io</code>
poss√®de cette d√©claration d'alias de type¬†:</p>
<!--
```rust,noplayground
# use std::fmt;
# 
type Result<T> = std::result::Result<T, std::io::Error>;
# 
# pub trait Write {
#     fn write(&mut self, buf: &[u8]) -> Result<usize>;
#     fn flush(&mut self) -> Result<()>;
# 
#     fn write_all(&mut self, buf: &[u8]) -> Result<()>;
#     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span></code></pre>
<!--
Because this declaration is in the `std::io` module, we can use the fully
qualified alias `std::io::Result<T>`‚Äîthat is, a `Result<T, E>` with the `E`
filled in as `std::io::Error`. The `Write` trait function signatures end up
looking like this:
-->
<p>Comme cette d√©claration est dans le module <code>std::io</code>, nous pouvons utiliser
l'alias <code>std::io::Result&lt;T&gt;</code> ‚Äî qui est un <code>Result&lt;T, E&gt;</code> avec le <code>E</code> qui est
d√©j√† renseign√© comme √©tant un <code>std::io::Error</code>. Les fonctions du trait <code>Write</code>
ressemblent finalement √† ceci¬†:</p>
<!--
```rust,noplayground
# use std::fmt;
# 
# type Result<T> = std::result::Result<T, std::io::Error>;
# 
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<!--
The type alias helps in two ways: it makes code easier to write *and* it gives
us a consistent interface across all of `std::io`. Because it‚Äôs an alias, it‚Äôs
just another `Result<T, E>`, which means we can use any methods that work on
`Result<T, E>` with it, as well as special syntax like the `?` operator.
-->
<p>L'alias de type nous aide sur deux domaines¬†: il permet de faciliter l'√©criture
du code <em>et</em> il nous donne une interface coh√©rente pour tout <code>std::io</code>. Comme
c'est un alias, c'est simplement un autre <code>Result&lt;T, E&gt;</code>, ce qui signifie que
nous pouvons utiliser n'importe quelle m√©thode qui fonctionne avec
<code>Result&lt;T, E&gt;</code>, ainsi que les syntaxes sp√©ciales telle que l'op√©rateur <code>?</code>.</p>
<!--
### The Never Type that Never Returns
-->
<h3 id="le-type-jamais-qui-ne-retourne-jamais-de-valeur"><a class="header" href="#le-type-jamais-qui-ne-retourne-jamais-de-valeur">Le type &quot;jamais&quot;, qui ne retourne jamais de valeur</a></h3>
<!--
Rust has a special type named `!` that‚Äôs known in type theory lingo as the
*empty type* because it has no values. We prefer to call it the *never type*
because it stands in the place of the return type when a function will never
return. Here is an example:
-->
<p>Rust a un type sp√©cial qui s'appelle <code>!</code> qui est connu dans le vocabulaire de
la th√©orie des types comme √©tant le <em>type vide</em> car il n'a pas de valeur. Nous
pr√©f√©rons appeler cela le <em>type jamais</em> car il remplace le type de retour
lorsqu'une fonction ne va jamais retourner quelque chose. Voici un exemple¬†:</p>
<!--
```rust,noplayground
fn bar() -> ! {
    // --snip--
#     panic!();
}
```
-->
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // -- partie masqu√©e ici --
<span class="boring">    panic!();
</span>}
</code></pre>
<!--
This code is read as ‚Äúthe function `bar` returns never.‚Äù Functions that return
never are called *diverging functions*. We can‚Äôt create values of the type `!`
so `bar` can never possibly return.
-->
<p>Ce code peut √™tre interpr√©t√© comme ‚Äúla fonction <code>bar</code> qui ne retourne pas de
valeur‚Äù. Les fonctions qui ne retournent pas de valeur s'appellent des
<em>fonctions divergentes</em>. Nous ne pouvons pas cr√©er de valeurs de type <code>!</code> donc
<code>bar</code> ne pourra jamais retourner de valeur.</p>
<!--
But what use is a type you can never create values for? Recall the code from
Listing 2-5; we‚Äôve reproduced part of it here in Listing 19-26.
-->
<p>Mais √† quoi sert un type dont on ne peut jamais cr√©er de valeurs ?
Souvenez-vous du code de l'encart 2-5¬†; nous avons reproduit une partie de
celui-ci dans l'encart 19-26.</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         // --snip--
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
# 
#         println!("You guessed: {}", guess);
# 
#         // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre¬†!&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est¬†: {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        // -- partie masqu√©e ici --
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;√âchec de la lecture de l'entr√©e utilisateur&quot;);
</span><span class="boring">
</span>        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre¬†: {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">        // -- partie masqu√©e ici --
</span><span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus¬†!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins¬†!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagn√©¬†!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-26: A `match` with an arm that ends in
`continue`</span>
-->
<p><span class="caption">Encart 19-26¬†: un <code>match</code> avec une branche qui finit par
un <code>continue</code></span></p>
<!--
At the time, we skipped over some details in this code. In Chapter 6 in [‚ÄúThe
`match` Control Flow Operator‚Äù][the-match-control-flow-operator]<!-- ignore
-- > section, we discussed that `match` arms must all return the same type. So,
for example, the following code doesn‚Äôt work:
-->
<p>A l'√©poque, nous avions saut√© quelques d√©tails dans ce code. Dans la section
<a href="ch06-02-match.html#la-structure-de-contr%C3%B4le-match">‚ÄúLa structure de contr√¥le
<code>match</code>‚Äù</a><!-- ignore --> du chapitre 6, nous
avons vu que les branches d'un <code>match</code> doivent toutes retourner le m√™me type.
Donc, par exemple, le code suivant ne fonctionne pas¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let guess = "3";
    let guess = match guess.trim().parse() {
        Ok(_) => 5,
        Err(_) => "hello",
    };
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let supposition = &quot;3&quot;;
</span>    let supposition = match supposition.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;salut&quot;,
    };
<span class="boring">}
</span></code></pre>
<!--
The type of `guess` in this code would have to be an integer *and* a string,
and Rust requires that `guess` have only one type. So what does `continue`
return? How were we allowed to return a `u32` from one arm and have another arm
that ends with `continue` in Listing 19-26?
-->
<p>Le type de <code>supposition</code> dans ce code devrait √™tre un entier <em>et</em> une cha√Æne de
caract√®res, et Rust n√©cessite que <code>supposition</code> n'ait qu'un seul type possible.
Donc que retourne <code>continue</code>¬†? Pourquoi pouvons-nous retourner un <code>u32</code> dans
une branche et avoir une autre branche qui finit avec un <code>continue</code> dans
l'encart 19-26¬†?</p>
<!--
As you might have guessed, `continue` has a `!` value. That is, when Rust
computes the type of `guess`, it looks at both match arms, the former with a
value of `u32` and the latter with a `!` value. Because `!` can never have a
value, Rust decides that the type of `guess` is `u32`.
-->
<p>Comme vous l'avez devin√©, <code>continue</code> a une valeur <code>!</code>. Ainsi, lorsque Rust
calcule le type de <code>supposition</code>, il regarde les deux branches, la premi√®re
avec une valeur <code>u32</code> et la seconde avec une valeur <code>!</code>. Comme <code>!</code> ne peut
jamais retourner de valeur, Rust d√©cide alors que le type de <code>supposition</code> est
<code>u32</code>.</p>
<!--
The formal way of describing this behavior is that expressions of type `!` can
be coerced into any other type. We‚Äôre allowed to end this `match` arm with
`continue` because `continue` doesn‚Äôt return a value; instead, it moves control
back to the top of the loop, so in the `Err` case, we never assign a value to
`guess`.
-->
<p>Une fa√ßon classique de d√©crire ce comportement est de dire que les expressions
du type <code>!</code> peuvent √™tre transform√©es dans n'importe quel type. Nous pouvons
finir cette branche de <code>match</code> avec <code>continue</code> car <code>continue</code> ne retourne pas
de valeur¬†; √† la place, il retourne le contr√¥le en haut de la boucle, donc dans
le cas d'un <code>Err</code>, nous n'assignons jamais de valeur √† <code>supposition</code>.</p>
<!--
The never type is useful with the `panic!` macro as well. Remember the `unwrap`
function that we call on `Option<T>` values to produce a value or panic? Here
is its definition:
-->
<p>Ce type &quot;jamais&quot; est tout aussi utile avec la macro <code>panic!</code>. Vous
souvenez-vous que la fonction <code>unwrap</code> que nous appelons sur les valeurs
<code>Option&lt;T&gt;</code> fournit une valeur ou panique¬†? Voici sa d√©finition¬†:</p>
<!--
```rust,ignore
# enum Option<T> {
#     Some(T),
#     None,
# }
# 
# use crate::Option::*;
# 
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<!--
In this code, the same thing happens as in the `match` in Listing 19-26: Rust
sees that `val` has the type `T` and `panic!` has the type `!`, so the result
of the overall `match` expression is `T`. This code works because `panic!`
doesn‚Äôt produce a value; it ends the program. In the `None` case, we won‚Äôt be
returning a value from `unwrap`, so this code is valid.
-->
<p>Dans ce code, il se passe la m√™me chose que l'encart 19-26¬†: Rust constate que
<code>val</code> est du type <code>T</code> et que <code>panic!</code> est du type <code>!</code>, donc le r√©sultat de
l'ensemble de l'expression <code>match</code> est <code>T</code>. Ce code fonctionne car <code>panic!</code> ne
produit pas de valeur¬†; il termine le programme. Dans le cas d'un <code>None</code>, nous
ne retournons pas une valeur de <code>unwrap</code>, donc ce code est valide.</p>
<!--
One final expression that has the type `!` is a `loop`:
-->
<p>Une des expressions qui sont du type <code>!</code> est le <code>loop</code>¬†:</p>
<!--
```rust,ignore
# fn main() {
    print!("forever ");

    loop {
        print!("and ever ");
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;pour toujours &quot;);

    loop {
        print!(&quot;et toujours &quot;);
    }
<span class="boring">}
</span></code></pre>
<!--
Here, the loop never ends, so `!` is the value of the expression. However, this
wouldn‚Äôt be true if we included a `break`, because the loop would terminate
when it got to the `break`.
-->
<p>Ici, la boucle ne se termine jamais, donc <code>!</code> est la valeur de cette
expression. En revanche, cela ne sera pas vrai si nous utilisons un <code>break</code>,
car la boucle va s'arr√™ter lorsqu'elle rencontrera le <code>break</code>.</p>
<!--
### Dynamically Sized Types and the `Sized` Trait
-->
<h3 id="les-types-√†-taille-dynamique-et-le-trait-sized"><a class="header" href="#les-types-√†-taille-dynamique-et-le-trait-sized">Les types √† taille dynamique et le trait <code>Sized</code></a></h3>
<!--
Due to Rust‚Äôs need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of *dynamically sized types*. Sometimes referred to
as *DSTs* or *unsized types*, these types let us write code using values whose
size we can know only at runtime.
-->
<p>Vu qu'il est n√©cessaire pour Rust de conna√Ætre certains d√©tails, comme la
quantit√© d'espace √† allouer √† une valeur d'un type donn√©, il y a un aspect de
ce syst√®me de type qui peut √™tre d√©routant¬†: le concept des <em>types √† taille
dynamique</em>. Parfois appel√©s <em>DST</em> (Dynamically Sized Types) ou <em>types sans
taille</em>, ces types nous permettent d'√©crire du code qui utilise des valeurs
dont la taille ne peut √™tre connue qu'√† l'ex√©cution.</p>
<!--
Let‚Äôs dig into the details of a dynamically sized type called `str`, which
we‚Äôve been using throughout the book. That‚Äôs right, not `&str`, but `str` on
its own, is a DST. We can‚Äôt know how long the string is until runtime, meaning
we can‚Äôt create a variable of type `str`, nor can we take an argument of type
`str`. Consider the following code, which does not work:
-->
<p>Voyons les d√©tails d'un type √† taille dynamique qui s'appelle <code>str</code>, que nous
avons utilis√© dans ce livre. Notez bien que ce n'est pas <code>&amp;str</code>, mais bien
<code>str</code> qui est un DST. Nous ne pouvons conna√Ætre la longueur de la cha√Æne de
caract√®re qu'√† l'ex√©cution, ce qui signifie que nous ne pouvons ni cr√©er une
variable de type <code>str</code>, ni prendre en argument un type <code>str</code>. Imaginons le code
suivant, qui ne fonctionnera pas¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Salut tout le monde¬†!&quot;;
    let s2: str = &quot;Comment √ßa va¬†?&quot;;
<span class="boring">}
</span></code></pre>
<!--
Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two `str` values would need to take up the
same amount of space. But they have different lengths: `s1` needs 12 bytes of
storage and `s2` needs 15. This is why it‚Äôs not possible to create a variable
holding a dynamically sized type.
-->
<p>Rust a besoin de savoir combien de m√©moire allouer pour chaque valeur d'un type
donn√©, et toutes les valeurs de ce type doivent utiliser la m√™me quantit√© de
m√©moire. Si Rust nous avait autoris√© √† √©crire ce code, ces deux valeurs <code>str</code>
devraient occuper la m√™me quantit√© de m√©moire. Mais elles ont deux longueurs
diff√©rentes¬†: <code>s1</code> prend 21 octets en m√©moire alors que <code>s2</code> en a besoin de 15.
C'est pourquoi il est impossible de cr√©er une variable qui stocke un type √†
taille dynamique.</p>
<!--
So what do we do? In this case, you already know the answer: we make the types
of `s1` and `s2` a `&str` rather than a `str`. Recall that in the [‚ÄúString
Slices‚Äù][string-slices]<!-- ignore -- > section of Chapter 4, we said the slice
data structure stores the starting position and the length of the slice.
-->
<p>Donc qu'est-ce qu'on peut faire¬†? Dans ce cas, vous connaissez d√©j√† la r√©ponse¬†:
nous faisons en sorte que le type de <code>s1</code> et <code>s2</code> soit <code>&amp;str</code> plut√¥t que <code>str</code>.
Souvenez-vous que dans la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res">‚ÄúLes slices de cha√Ænes de caract√®res‚Äù</a><!-- ignore -->
du chapitre 4, nous avions dit que la structure de donn√©es slice stockait
l'emplacement de d√©part et la longueur de la slice.</p>
<!--
So although a `&T` is a single value that stores the memory address of where
the `T` is located, a `&str` is *two* values: the address of the `str` and its
length. As such, we can know the size of a `&str` value at compile time: it‚Äôs
twice the length of a `usize`. That is, we always know the size of a `&str`, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.
-->
<p>Aussi, bien qu'un <code>&amp;T</code> soit une valeur unique qui stocke l'adresse m√©moire √†
laquelle se trouve le <code>T</code>, un <code>&amp;str</code> est constitu√© de <em>deux</em> valeurs¬†:
l'adresse du <code>str</code> et sa longueur. Ainsi, nous pouvons conna√Ætre la taille
d'une valeur <code>&amp;str</code> √† la compilation¬†: elle vaut deux fois la taille d'un
<code>usize</code>. Ce faisant, nous connaissons toujours la taille d'un <code>&amp;str</code>, peu
importe la longueur de la cha√Æne de caract√®res sur laquelle il pointe.
G√©n√©ralement, c'est comme cela que les types √† taille dynamique sont utilis√©s
en Rust¬†: ils ont des m√©tadonn√©es suppl√©mentaires qui stockent la taille des
informations dynamiques. La r√®gle d'or des types √† taille dynamique est que
nous devons toujours placer les valeurs √† types √† taille dynamique derri√®re un
pointeur d'une certaine sorte.</p>
<!--
We can combine `str` with all kinds of pointers: for example, `Box<str>` or
`Rc<str>`. In fact, you‚Äôve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the [‚ÄúUsing Trait Objects That
Allow for Values of Different
Types‚Äù][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` (`Rc<dyn
Trait>` would work too).
-->
<p>Nous pouvons combiner <code>str</code> avec n'importe quel type de pointeur¬†: par exemple,
<code>Box&lt;str&gt;</code> ou <code>Rc&lt;str&gt;</code>. En fait, vous avez vu cela d√©j√† auparavant mais avec un
autre type √† taille dynamique¬†: les traits. Chaque trait est un type √† taille
dynamique auquel nous pouvons nous r√©f√©rer en utilisant le nom du trait. Dans
<a href="ch17-02-trait-objects.html">une section</a><!--
ignore --> du chapitre 17, nous avions mentionn√© que pour utiliser les traits
comme des objets traits, nous devions les utiliser via un pointeur, tel que
<code>&amp;dyn Trait</code> ou <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> fonctionnera √©galement).</p>
<!--
To work with DSTs, Rust has a particular trait called the `Sized` trait to
determine whether or not a type‚Äôs size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on `Sized` to every generic function.
That is, a generic function definition like this:
-->
<p>Pour pouvoir travailler avec les DST, Rust dispose d'un trait particulier
<code>Sized</code> pour d√©terminer si oui ou non la taille d'un type est connue √† la
compilation. Ce trait est automatiquement impl√©ment√© sur tout ce qui a une
taille connue √† la compilation. De plus, Rust ajoute implicitement le trait
li√© <code>Sized</code> sur chaque fonction g√©n√©rique. Ainsi, la d√©finition d'une fonction
g√©n√©rique telle que celle-ci¬†:</p>
<!--
```rust,ignore
fn generic<T>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T&gt;(t: T) {
    // -- partie masqu√©e ici --
}
</code></pre>
<!--
is actually treated as though we had written this:
-->
<p>... est en r√©alit√© trait√©e comme si nous avions √©crit ceci¬†:</p>
<!--
```rust,ignore
fn generic<T: Sized>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: Sized&gt;(t: T) {
    // -- partie masqu√©e ici --
}
</code></pre>
<!--
By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:
-->
<p>Par d√©faut, les fonctions g√©n√©riques vont fonctionner uniquement sur des types
qui ont une taille connue √† la compilation. Cependant, vous pouvez utiliser la
syntaxe sp√©ciale suivante pour √©viter cette restriction¬†:</p>
<!--
```rust,ignore
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: ?Sized&gt;(t: &amp;T) {
    // -- partie masqu√©e ici --
}
</code></pre>
<!--
A trait bound on `?Sized` means ‚Äú`T` may or may not be `Sized`‚Äù and this
notation overrides the default that generic types must have a known size at
compile time. The `?Trait` syntax with this meaning is only available for
`Sized`, not any other traits.
-->
<p>Le trait li√© <code>?Sized</code> signifie que ‚Äú<code>T</code> peut √™tre ou ne pas √™tre <code>Sized</code>‚Äù et
cette notation pr√©vaut sur le comportement par d√©faut qui dit que les types
g√©n√©riques doivent avoir une taille connue au moment de la compilation. La
syntaxe <code>?Trait</code> avec ce comportement n'est disponible que pour <code>Sized</code>,
et pour aucun autre trait.</p>
<!--
Also note that we switched the type of the `t` parameter from `T` to `&T`.
Because the type might not be `Sized`, we need to use it behind some kind of
pointer. In this case, we‚Äôve chosen a reference.
-->
<p>Remarquez aussi que nous avons chang√© le type du param√®tre <code>t</code> de <code>T</code> en <code>&amp;T</code>.
Comme ce type pourrait ne pas √™tre un <code>Sized</code>, nous devons l'utiliser via
un pointeur d'une sorte ou d'une autre. Dans ce cas, nous avons choisi une
r√©f√©rence.</p>
<!--
Next, we‚Äôll talk about functions and closures!
-->
<p>Dans la partie suivante, nous allons parler des fonctions et des fermetures¬†!</p>
<!--
[encapsulation-that-hides-implementation-details]:
ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details
[string-slices]: ch04-03-slices.html#string-slices
[the-match-control-flow-operator]:
ch06-02-match.html#the-match-control-flow-operator
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[using-the-newtype-pattern]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Advanced Functions and Closures
-->
<h2 id="les-fonctions-et-fermetures-avanc√©es"><a class="header" href="#les-fonctions-et-fermetures-avanc√©es">Les fonctions et fermetures avanc√©es</a></h2>
<!--
This section explores some advanced features related to functions and closures,
including function pointers and returning closures.
-->
<p>Dans cette section, nous allons explorer quelques fonctionnalit√©s avanc√©es
li√©es aux fonctions et aux fermetures, y compris les pointeurs de fonctions et
la capacit√© de retourner des fermetures.</p>
<!--
### Function Pointers
-->
<h3 id="pointeurs-de-fonctions"><a class="header" href="#pointeurs-de-fonctions">Pointeurs de fonctions</a></h3>
<!--
We‚Äôve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you‚Äôve already defined rather than defining a new closure. Doing this
with function pointers will allow you to use functions as arguments to other
functions. Functions coerce to the type `fn` (with a lowercase f), not to be
confused with the `Fn` closure trait. The `fn` type is called a *function
pointer*. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-27.
-->
<p>Nous avons d√©j√† vu comment envoyer des fermetures dans des fonctions¬†; mais vous
pouvez aussi envoyer des fonctions classiques dans d'autres fonctions¬†! Cette
technique est utile lorsque vous souhaitez envoyer une fonction que vous avez
d√©j√† d√©finie plut√¥t que de d√©finir une nouvelle fermeture. Vous pouvez faire
ceci avec des pointeurs de fonctions, qui vous permettent d'utiliser des
fonctions en argument d'autres fonctions. Les fonctions n√©cessitent le type <code>fn</code>
(avec un f minuscule), √† ne pas confondre avec le trait de fermeture <code>Fn</code>. Le
type <code>fn</code> s'appelle un <em>pointeur de fonction</em>. La syntaxe pour indiquer qu'un
param√®tre est un pointeur de fonction ressemble √† celle des fermetures, comme
vous pouvez le voir dans l'encart 19-27.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}

fn le_faire_deux_fois(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let reponse = le_faire_deux_fois(ajouter_un, 5);

    println!(&quot;La r√©ponse est¬†: {}&quot;, reponse);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-27: Using the `fn` type to accept a function
pointer as an argument</span>
-->
<p><span class="caption">Encart 19-27¬†: utiliser le type <code>fn</code> pour accepter un
pointeur de fonction en argument</span></p>
<!--
This code prints `The answer is: 12`. We specify that the parameter `f` in
`do_twice` is an `fn` that takes one parameter of type `i32` and returns an
`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can pass
the function name `add_one` as the first argument to `do_twice`.
-->
<p>Ce code affiche <code>La r√©ponse est¬†: 12</code>. Nous avons pr√©cis√© que le param√®tre <code>f</code>
dans <code>le_faire_deux_fois</code> est une <code>fn</code> qui prend en argument un param√®tre du
type <code>i32</code> et retourne un <code>i32</code>. Nous pouvons ensuite appeler <code>f</code> dans le corps
de <code>le_faire_deux_fois</code>. Dans <code>main</code>, nous pouvons envoyer le nom de la fonction
<code>ajouter_un</code> dans le premier argument de <code>le_faire_deux_fois</code>.</p>
<!--
Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as the
parameter type directly rather than declaring a generic type parameter with one
of the `Fn` traits as a trait bound.
-->
<p>Contrairement aux fermetures, <code>fn</code> est un type plut√¥t qu'un trait, donc nous
indiquons <code>fn</code> directement comme type de param√®tre plut√¥t que de d√©clarer un
param√®tre de type g√©n√©rique avec un des traits <code>Fn</code> comme trait li√©.</p>
<!--
Function pointers implement all three of the closure traits (`Fn`, `FnMut`, and
`FnOnce`), so you can always pass a function pointer as an argument for a
function that expects a closure. It‚Äôs best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.
-->
<p>Les pointeurs de fonctions impl√©mentent simultan√©ment les trois traits de fermeture
(<code>Fn</code>, <code>FnMut</code> et <code>FnOnce</code>) afin que vous puissiez toujours envoyer un
pointeur de fonction en argument d'une fonction qui attendait une fermeture. Il
vaut mieux √©crire des fonctions qui utilisent un type g√©n√©rique et un des traits
de fermeture afin que vos fonctions puissent accepter soit des fonctions, soit
des fermetures.</p>
<!--
An example of where you would want to only accept `fn` and not closures is when
interfacing with external code that doesn‚Äôt have closures: C functions can
accept functions as arguments, but C doesn‚Äôt have closures.
-->
<p>Une situation dans laquelle vous ne voudrez accepter que des <code>fn</code> et pas
des fermetures, est lorsque vous vous interfacez avec du code externe qui n'a
pas de fermetures¬†: les fonctions C peuvent accepter des fonctions en argument,
mais le C n'a pas fermetures.</p>
<!--
As an example of where you could use either a closure defined inline or a named
function, let‚Äôs look at a use of `map`. To use the `map` function to turn a
vector of numbers into a vector of strings, we could use a closure, like this:
-->
<p>Comme exemple d'une situation dans laquelle vous pouvez utiliser soit une
fermeture d√©finie directement ou le nom d'une fonction, prenons l'utilisation
de <code>map</code>. Pour utiliser la fonction <code>map</code> pour transformer un vecteur de
nombres en vecteur de cha√Ænes de caract√®res, nous pouvons utiliser une
fermeture, comme ceci¬†:</p>
<!--
```rust
# fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let liste_de_nombres = vec![1, 2, 3];
    let liste_de_chaines: Vec&lt;String&gt; =
        liste_de_nombres.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could name a function as the argument to `map` instead of the closure,
like this:
-->
<p>Ou alors nous pouvons utiliser le nom d'une fonction en argument de <code>map</code> plut√¥t
qu'une fermeture, comme ceci¬†:</p>
<!--
```rust
# fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(ToString::to_string).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let liste_de_nombres = vec![1, 2, 3];
    let liste_de_chaines: Vec&lt;String&gt; =
        liste_de_nombres.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Note that we must use the fully qualified syntax that we talked about earlier
in the [‚ÄúAdvanced Traits‚Äù][advanced-traits]<!-- ignore -- > section because
there are multiple functions available named `to_string`. Here, we‚Äôre using the
`to_string` function defined in the `ToString` trait, which the standard
library has implemented for any type that implements `Display`.
-->
<p>Notez que nous devons utiliser la syntaxe compl√®te que nous avons vue
pr√©c√©demment dans <a href="ch19-03-advanced-traits.html">la section pr√©c√©dente</a><!-- ignore --> car il
existe plusieurs fonctions disponibles qui s'appellent <code>to_string</code>. Ici, nous
utilisons la fonction <code>to_string</code> d√©finie dans le trait <code>ToString</code> que la
biblioth√®que standard a impl√©ment√© sur chaque type qui impl√©mente <code>Display</code>.</p>
<!--
Recall from the [‚ÄúEnum values‚Äù][enum-values]<!-- ignore -- > section of Chapter
6 that the name of each enum variant that we define also becomes an initializer
function. We can use these initializer functions as function pointers that
implement the closure traits, which means we can specify the initializer
functions as arguments for methods that take closures, like so:
-->
<p>Rappelez-vous qu'√† la section
<a href="ch06-01-defining-an-enum.html#enum-values">‚ÄúLes valeurs d'√©num√©rations‚Äù</a><!-- ignore --> du chapitre 6, nous
apprenions que le nom de chaque variante d'√©num√©ration que nous d√©clarons
devient aussi une fonction d'initialisation. Nous pouvons utiliser ces
fonctions d'initialisation en tant que pointeurs de fonctions qui impl√©mentent
les traits de fermetures, ce qui signifie que nous pouvons utiliser les
fonctions d'initialisation comme param√®tre des m√©thodes qui acceptent des
fermetures, comme ceci¬†:</p>
<!--
```rust
# fn main() {
    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Statut {
        Valeur(u32),
        Stop,
    }

    let liste_de_statuts: Vec&lt;Statut&gt; = (0u32..20).map(Statut::Valeur).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Here we create `Status::Value` instances using each `u32` value in the range
that `map` is called on by using the initializer function of `Status::Value`.
Some people prefer this style, and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.
-->
<p>Nous avons ici cr√©√© des instances de <code>Statut::Valeur</code> en utilisant chacune des
valeurs <code>u32</code> pr√©sentes dans l'intervalle sur laquelle nous appelons <code>map</code> en
utilisant la fonction d'initialisation de <code>Statut::Valeur</code>. Certaines personnes
pr√©f√®rent ce style, et d'autres pr√©f√®rent utiliser des fermetures. Ces deux approches
se compilent et produisent le m√™me code, vous pouvez donc utiliser le style qui
est le plus clair pour vous.</p>
<!--
### Returning Closures
-->
<h3 id="retourner-des-fermetures"><a class="header" href="#retourner-des-fermetures">Retourner des fermetures</a></h3>
<!--
Closures are represented by traits, which means you can‚Äôt return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. But you can‚Äôt do that with closures because they don‚Äôt have a
concrete type that is returnable; you‚Äôre not allowed to use the function
pointer `fn` as a return type, for example.
-->
<p>Les fermetures sont repr√©sent√©es par des traits, ce qui signifie que vous ne
pouvez pas retourner directement des fermetures. Dans la plupart des situations
o√π vous auriez voulu retourner un trait, vous pouvez utiliser √† la place le
type concret qui impl√©mente le trait comme valeur de retour de la fonction.
Mais vous ne pouvez pas faire ceci avec les fermetures car elles n'ont pas de
type concret qu'elles peuvent retourner¬†; vous n'√™tes pas autoris√© √† utiliser
le pointeur de fonction <code>fn</code> comme type de retour, par exemple.</p>
<!--
The following code tries to return a closure directly, but it won‚Äôt compile:
-->
<p>Le code suivant essaye de retourner directement une fermeture, mais ne peut pas
se compiler¬†:</p>
<!--
```rust,ignore,does_not_compile
fn returns_closure() -> dyn Fn(i32) -> i32 {
    |x| x + 1
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<!--
The compiler error is as follows:
-->
<p>Voici l'erreur de compilation¬†:</p>
<!--
```console
$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 -- > src/lib.rs:1:25
  |
1 | fn returns_closure() -> dyn Fn(i32) -> i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>
help: use `impl Fn(i32) -> i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:14]`, which implements `Fn(i32) -> i32`
  |
1 | fn returns_closure() -> impl Fn(i32) -> i32 {
  |                         ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
  |                                ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:14]`, which implements `Fn(i32) -&gt; i32`
  |
1 | fn retourne_une_fermeture() -&gt; impl Fn(i32) -&gt; i32 {
  |                                ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
</code></pre>
<!--
The error references the `Sized` trait again! Rust doesn‚Äôt know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:
-->
<p>Une nouvelle fois l'erreur du trait <code>Sized</code>¬†! Rust ne sait pas combien de
m√©moire sera n√©cessaire pour stocker la fermeture. Nous avons vu une solution √†
ce probl√®me pr√©c√©demment. Nous pouvons utiliser un objet trait¬†:</p>
<!--
```rust,noplayground
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```
-->
<pre><code class="language-rust noplayground">fn retourne_une_fermeture() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre>
<!--
This code will compile just fine. For more about trait objects, refer to the
section [‚ÄúUsing Trait Objects That Allow for Values of Different
Types‚Äù][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > in Chapter 17.
-->
<p>Ce code va se compiler √† merveille. Pour en savoir plus sur les objets trait,
rendez-vous
<a href="ch17-02-trait-objects.html">√† la section</a><!--
ignore --> du chapitre 17.</p>
<!--
Next, let‚Äôs look at macros!
-->
<p>Maintenant, penchons-nous sur les macros¬†!</p>
<!--
[advanced-traits]:
ch19-03-advanced-traits.html#advanced-traits
[enum-values]: ch06-01-defining-an-enum.html#enum-values
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Macros
-->
<h2 id="les-macros"><a class="header" href="#les-macros">Les macros</a></h2>
<!--
We‚Äôve used macros like `println!` throughout this book, but we haven‚Äôt fully
explored what a macro is and how it works. The term *macro* refers to a family
of features in Rust: *declarative* macros with `macro_rules!` and three kinds
of *procedural* macros:
-->
<p>Nous avons d√©j√† utilis√© des macros tout au long de ce livre, comme <code>println!</code>,
mais nous n'avons pas examin√© en profondeur ce qu'est une macro et comment
elles fonctionnent. Le terme <em>macro</em> renvoie √† une famille de fonctionnalit√©s de
Rust¬†: les macros <em>d√©claratives</em> avec <code>macro_rules!</code> et trois types de macros
<em>proc√©durales</em>¬†:</p>
<!--
* Custom `#[derive]` macros that specify code added with the `derive` attribute
  used on structs and enums
* Attribute-like macros that define custom attributes usable on any item
* Function-like macros that look like function calls but operate on the tokens
  specified as their argument
-->
<ul>
<li>Des macros <code>#[derive]</code> personnalis√©es qui renseigne du code ajout√© gr√¢ce √†
l'attribut <code>derive</code> utilis√© sur les structures et les √©num√©rations</li>
<li>Les macros qui ressemblent √† des attributs qui d√©finissent des attributs
personnalis√©s qui sont utilisables sur n'importe quel √©l√©ment</li>
<li>Les macros qui ressemblent √† des fonctions mais qui op√®rent sur les √©l√©ments
renseign√©s en argument</li>
</ul>
<!--
We‚Äôll talk about each of these in turn, but first, let‚Äôs look at why we even
need macros when we already have functions.
-->
<p>Nous allons voir chacune d'entre elles √† leur tour, mais avant, posons-nous la
question de pourquoi nous avons besoin de macros alors que nous avons d√©j√† les
fonctions.</p>
<!--
### The Difference Between Macros and Functions
-->
<h3 id="la-diff√©rence-entre-les-macros-et-les-fonctions"><a class="header" href="#la-diff√©rence-entre-les-macros-et-les-fonctions">La diff√©rence entre les macros et les fonctions</a></h3>
<!--
Fundamentally, macros are a way of writing code that writes other code, which
is known as *metaprogramming*. In Appendix C, we discuss the `derive`
attribute, which generates an implementation of various traits for you. We‚Äôve
also used the `println!` and `vec!` macros throughout the book. All of these
macros *expand* to produce more code than the code you‚Äôve written manually.
-->
<p>Essentiellement, les macros sont une fa√ßon d'√©crire du code qui √©crit un autre
code, ce qui s'appelle la <em>m√©taprogrammation</em>. Dans l'annexe C, nous verrons
l'attribut <code>derive</code>, qui g√©n√®re une impl√©mentation de diff√©rents traits pour
vous. Nous avons aussi utilis√© les macros <code>println!</code> et <code>vec!</code> dans ce livre.
Toutes ces macros <em>se d√©ploient</em> pour produire plus de code que celui que vous
avez √©crit manuellement.</p>
<!--
Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don‚Äôt.
-->
<p>La m√©taprogrammation est utile pour r√©duire la quantit√© de code que vous avez √†
√©crire et √† maintenir, ce qui est aussi un des r√¥les des fonctions. Cependant,
les macros ont quelques pouvoirs en plus que les fonctions n'ont pas.</p>
<!--
A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call `println!("hello")` with one argument or
`println!("hello {}", name)` with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can‚Äôt, because it gets
called at runtime and a trait needs to be implemented at compile time.
-->
<p>La signature d'une fonction doit d√©clarer le nombre et le type de param√®tres
qu'a cette fonction. Les macros, √† l'inverse, peuvent prendre un nombre
variable de param√®tres¬†: nous pouvons appeler <code>println!(&quot;salut&quot;)</code> avec un
seul param√®tre, ou <code>println!(&quot;salut {}&quot;, nom)</code> avec deux param√®tres. De plus, les
macros sont d√©ploy√©es avant que le compilateur n'interpr√®te la signification du
code, donc une macro peut, par exemple, impl√©menter un trait sur un type donn√©.
Une fonction ne peut pas le faire, car elle est ex√©cut√©e √† l'ex√©cution et un
trait doit √™tre impl√©ment√© √† la compilation.</p>
<!--
The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you‚Äôre writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.
-->
<p>Le d√©savantage d'impl√©menter une macro par rapport √† une fonction est que les
d√©finitions de macros sont plus complexes que les d√©finitions de fonction car
vous √©crivez du code Rust qui √©crit lui-m√™me du code Rust. A cause de cette
approche, les d√©finitions de macro sont g√©n√©ralement plus difficiles √† lire,
√† comprendre et √† maintenir que les d√©finitions de fonctions.</p>
<!--
Another important difference between macros and functions is that you must
define macros or bring them into scope *before* you call them in a file, as
opposed to functions you can define anywhere and call anywhere.
-->
<p>Une autre diff√©rence importante entre les macros et les fonctions est que vous
devez d√©finir les macros ou les importer dans la port√©e <em>avant</em> de les utiliser
dans le fichier, contrairement aux fonctions que vous pouvez d√©finir n'importe
o√π et y faire appel n'importe o√π.</p>
<!--
### Declarative Macros with `macro_rules!` for General Metaprogramming
-->
<h3 id="les-macros-d√©claratives-avec-macro_rules-pour-la-m√©taprogrammation-g√©n√©rale"><a class="header" href="#les-macros-d√©claratives-avec-macro_rules-pour-la-m√©taprogrammation-g√©n√©rale">Les macros d√©claratives avec <code>macro_rules!</code> pour la m√©taprogrammation g√©n√©rale</a></h3>
<!--
The most widely used form of macros in Rust is *declarative macros*. These are
also sometimes referred to as ‚Äúmacros by example,‚Äù ‚Äú`macro_rules!` macros,‚Äù or
just plain ‚Äúmacros.‚Äù At their core, declarative macros allow you to write
something similar to a Rust `match` expression. As discussed in Chapter 6,
`match` expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.
-->
<p>La forme la plus utilis√©e de macro en Rust est la <em>macro d√©clarative</em>. Elles
sont parfois appel√©es ‚Äúmacros d√©finies par un exemple‚Äù,
‚Äúmacros <code>macro_rules!</code>‚Äù ou simplement ‚Äúmacros‚Äù. Fondamentalement, les macros
d√©claratives vous permettent d'√©crire quelque chose de similaire √† une
expression <code>match</code> de Rust. Comme nous l'avons vu au chapitre 6, les
expressions <code>match</code> sont des structures de contr√¥le qui prennent en argument
une expression, comparent la valeur qui en r√©sulte avec les motifs et ensuite
ex√©cutent le code associ√© au motif qui correspond. Les macros comparent elles
aussi une valeur avec des motifs qui sont associ√©s √† code particulier¬†: dans
cette situation, la valeur est litt√©ralement le code source Rust envoy√© √† la
macro¬†; les motifs sont compar√©s avec la structure de ce code source¬†; et le
code associ√© √† chaque motif vient remplacer le code pass√© √† la macro, lorsqu'il
correspond. Tout ceci se passe lors de la compilation.</p>
<!--
To define a macro, you use the `macro_rules!` construct. Let‚Äôs explore how to
use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8
covered how we can use the `vec!` macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:
-->
<p>Pour d√©finir une macro, il faut utiliser la construction <code>macro_rules!</code>.
Explorons l'utilisation de <code>macro_rules!</code> en observant comment la macro <code>vec!</code>
est d√©finie. Le chapitre 8 nous a permis de comprendre comment utiliser la
macro <code>vec!</code> pour cr√©er un nouveau vecteur avec des valeurs pr√©cises. Par
exemple, la macro suivante cr√©e un nouveau vecteur qui contient trois entiers¬†:</p>
<!--
```rust
let v: Vec<u32> = vec![1, 2, 3];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
We could also use the `vec!` macro to make a vector of two integers or a vector
of five string slices. We wouldn‚Äôt be able to use a function to do the same
because we wouldn‚Äôt know the number or type of values up front.
-->
<p>Nous aurions pu aussi utiliser la macro <code>vec!</code> pour cr√©er un vecteur de deux
entiers ou un vecteur de cinq slices de cha√Ænes de caract√®res. Nous n'aurions
pas pu utiliser une fonction pour faire la m√™me chose car nous n'aurions pas pu
conna√Ætre le nombre ou le type des valeurs au d√©part.</p>
<!--
Listing 19-28 shows a slightly simplified definition of the `vec!` macro.
-->
<p>L'encart 19-28 montre une d√©finition l√©g√®rement simplifi√©e de la macro <code>vec!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```
-->
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>
<!--
<span class="caption">Listing 19-28: A simplified version of the `vec!` macro
definition</span>
-->
<p><span class="caption">Encart 19-28¬†: une version simplifi√©e de la d√©finition de
la macro <code>vec!</code></span></p>
<!--
> Note: The actual definition of the `vec!` macro in the standard library
> includes code to preallocate the correct amount of memory up front. That code
> is an optimization that we don‚Äôt include here to make the example simpler.
-->
<blockquote>
<p>Remarque¬†: la d√©finition actuelle de la macro <code>vec!</code> de la biblioth√®que
standard embarque du code pour pr√©-allouer la bonne quantit√© de m√©moire en
amont. Ce code est une optimisation que nous n'allons pas int√©grer ici pour
simplifier l'exemple.</p>
</blockquote>
<!--
The `#[macro_export]` annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can‚Äôt be brought into scope.
-->
<p>L'annotation <code>#[macro_export]</code> indique que cette macro doit √™tre disponible √†
chaque fois que la crate dans laquelle la macro est d√©finie est import√©e dans
la port√©e. Sans cette annotation, la macro ne pourrait pas √™tre import√©e dans
la port√©e.</p>
<!--
We then start the macro definition with `macro_rules!` and the name of the
macro we‚Äôre defining *without* the exclamation mark. The name, in this case
`vec`, is followed by curly brackets denoting the body of the macro definition.
-->
<p>Ensuite, nous commen√ßons la d√©finition de la macro avec <code>macro_rules!</code> suivi du
nom de la macro que nous d√©finissons <em>sans</em> le point d'exclamation. Le nom, qui
dans ce cas est <code>vec</code>, est suivi par des accolades indiquant le corps de la
d√©finition de la macro.</p>
<!--
The structure in the `vec!` body is similar to the structure of a `match`
expression. Here we have one arm with the pattern `( $( $x:expr ),* )`,
followed by `=>` and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.
-->
<p>La structure dans le corps de <code>vec!</code> ressemble √† la structure d'une expression
<code>match</code>. Ici nous avons une branche avec le motif <code>( $( $x:expr ), * )</code>, suivie
par <code>=&gt;</code> et le code du bloc associ√© √† ce motif. Si le motif correspond, le bloc
de code associ√© sera d√©ploy√©. Etant donn√© que c'est le seul motif dans cette
macro, il n'y a qu'une seule bonne fa√ßon d'y correspondre¬†; tout autre motif va
d√©boucher sur une erreur. Des macros plus complexes auront plus qu'une seule
branche.</p>
<!--
Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let‚Äôs walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see [the reference].
-->
<p>La syntaxe correcte pour un motif dans les d√©finitions de macros est diff√©rente
de la syntaxe de motif que nous avons vue au chapitre 18 car les motifs de
macros sont compar√©s √† des structures de code Rust plut√¥t qu'√† des valeurs.
Examinons la signification des √©l√©ments du motif de l'encart 19-28¬†; pour voir
l'int√©gralit√© de la syntaxe du motif de la macro, r√©f√©rez-vous
<a href="https://doc.rust-lang.org/reference/macros-by-example.html">√† la documentation</a>.</p>
<!--
[the reference]: ../reference/macros-by-example.html
-->
<!--
First, a set of parentheses encompasses the whole pattern. A dollar sign (`$`)
is next, followed by a set of parentheses that captures values that match the
pattern within the parentheses for use in the replacement code. Within `$()` is
`$x:expr`, which matches any Rust expression and gives the expression the name
`$x`.
-->
<p>Premi√®rement, un jeu de parenth√®ses englobent l'int√©gralit√© du motif. Ensuite
vient le symbole dollar (<code>$</code>), suivi par un jeu de parenth√®ses qui capturent les
valeurs qui correspondent au motif entre les parenth√®ses pour les utiliser dans
le code de remplacement. A l'int√©rieur du <code>$()</code> nous avons <code>$x:expr</code>, qui
correspond √† n'importe quelle expression Rust et donne le nom <code>$x</code> √†
l'expression.</p>
<!--
The comma following `$()` indicates that a literal comma separator character
could optionally appear after the code that matches the code in `$()`. The `*`
specifies that the pattern matches zero or more of whatever precedes the `*`.
-->
<p>La virgule qui suit le <code>$()</code> signifie que cette virgule litt√©rale comme
caract√®re litt√©ral de s√©paration peut optionnellement appara√Ætre apr√®s le code
qui correspond au code du <code>$()</code>. Le <code>*</code> informe que ce motif correspond √† z√©ro
ou plus √©l√©ments r√©p√©t√©s correspondant √† ce qui pr√©c√®de ce <code>*</code>.</p>
<!--
When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three
times with the three expressions `1`, `2`, and `3`.
-->
<p>Lorsque nous faisons appel √† cette macro avec <code>vec![1, 2, 3];</code>, le motif <code>$x</code>
correspond √† trois reprises avec les trois expressions <code>1</code>, <code>2</code>, et <code>3</code>.</p>
<!--
Now let‚Äôs look at the pattern in the body of the code associated with this arm:
`temp_vec.push()` within `$()*` is generated for each part that matches `$()`
in the pattern zero or more times depending on how many times the pattern
matches. The `$x` is replaced with each expression matched. When we call this
macro with `vec![1, 2, 3];`, the code generated that replaces this macro call
will be the following:
-->
<p>Maintenant, penchons-nous sur le motif dans le corps du code associ√© √† cette
branche¬†: <code>temp_vec.push()</code> dans le <code>$()*</code> est g√©n√©r√© pour chacune des parties
qui correspondent au <code>$()</code> dans le motif pour z√©ro ou plus de fois, en fonction
de combien de fois le motif correspond. Le <code>$x</code> est remplac√© par chaque
expression qui correspond. Lorsque nous faisons appel √† cette macro avec
<code>vec![1, 2, 3];</code>, le code g√©n√©r√© qui remplace cet appel de macro ressemblera √†
ceci¬†:</p>
<!--
```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```
-->
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<!--
We‚Äôve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.
-->
<p>Nous avons d√©fini une macro qui peut prendre n'importe quel nombre d'arguments
de n'importe quel type et qui peut g√©n√©rer du code pour cr√©er un vecteur qui
contient les √©l√©ments renseign√©s.</p>
<!--
There are some strange edge cases with `macro_rules!`. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, `macro_rules!` will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will *use* macros more than *write* macros, we won‚Äôt discuss
`macro_rules!` any further. To learn more about how to write macros, consult
the online documentation or other resources, such as [‚ÄúThe Little Book of Rust
Macros‚Äù][tlborm] started by Daniel Keep and continued by Lukas Wirth.
-->
<p>Il subsiste quelques cas limites √©tranges avec <code>macro_rules!</code>. Bient√¥t, Rust
rajoutera un second type de macro d√©clarative qui fonctionnera de la m√™me
mani√®re mais qui corrigera ces cas limites. Apr√®s cette mise √† jour,
<code>macro_rules!</code> sera d√©pr√©ci√©e. En sachant cela, ainsi que le fait que la
plupart des d√©veloppeurs Rust vont davantage <em>utiliser</em> les macros qu'en
<em>√©crire</em>, nous arr√™tons l√† la discussion sur <code>macro_rules!</code>. Pour en apprendre
plus sur l'√©criture des macros, consultez la documentation en ligne ou d'autres
ressources comme <a href="https://veykril.github.io/tlborm/">‚ÄúThe Little Book of Rust Macros‚Äù</a>, d√©but√© par Daniel
Keep et continu√© par Lukas Wirth.</p>
<!--
[tlborm]: https://veykril.github.io/tlborm/
-->
<!--
### Procedural Macros for Generating Code from Attributes
-->
<h3 id="les-macros-proc√©durales-pour-g√©n√©rer-du-code-√†-partir-des-attributs"><a class="header" href="#les-macros-proc√©durales-pour-g√©n√©rer-du-code-√†-partir-des-attributs">Les macros proc√©durales pour g√©n√©rer du code √† partir des attributs</a></h3>
<!--
The second form of macros is *procedural macros*, which act more like functions
(and are a type of procedure). Procedural macros accept some code as an input,
operate on that code, and produce some code as an output rather than matching
against patterns and replacing the code with other code as declarative macros
do.
-->
<p>La seconde forme de macro est la <em>macro proc√©durale</em>, qui se comporte davantage
comme une fonction (et est un type de proc√©dure). Les macros proc√©durales
prennent du code en entr√©e, travaillent sur ce code et produisent du code en sortie
plut√¥t que de faire des correspondances sur des motifs et remplacer du code
avec un autre code, comme le font les macros d√©claratives.</p>
<!--
The three kinds of procedural macros (custom derive, attribute-like, and
function-like) all work in a similar fashion.
-->
<p>Les trois types de macros proc√©durales (les d√©riv√©es personnalis√©es, celles qui
ressemblent aux attributs, et celles qui ressemblent √† des fonctions)
fonctionnent toutes de la m√™me mani√®re.</p>
<!--
When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. Defining procedural macros looks like the code in
Listing 19-29, where `some_attribute` is a placeholder for using a specific
macro variety.
-->
<p>Lorsque vous cr√©ez une macro proc√©durale, les d√©finitions doivent √™tre rang√©es
dans leur propre crate avec un type sp√©cial de crate. Ceci pour des raisons
techniques complexes que nous esp√©rons supprimer dans l'avenir. La d√©claration
des macros proc√©durales ressemble au code de l'encart 19-29, dans lequel
<code>un_attribut_quelconque</code> est un emplacement pour l'utilisation d'une macro
sp√©cifique.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```
-->
<pre><code class="language-rust ignore">use proc_macro;

#[un_attribut_quelconque]
pub fn un_nom_quelconque(entree: TokenStream) -&gt; TokenStream {
}
</code></pre>
<!--
<span class="caption">Listing 19-29: An example of defining a procedural
macro</span>
-->
<p><span class="caption">Encart 19-29¬†: un exemple de d√©claration d'une macro
proc√©durale</span></p>
<!--
The function that defines a procedural macro takes a `TokenStream` as an input
and produces a `TokenStream` as an output. The `TokenStream` type is defined by
the `proc_macro` crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input `TokenStream`, and the code the macro produces
is the output `TokenStream`. The function also has an attribute attached to it
that specifies which kind of procedural macro we‚Äôre creating. We can have
multiple kinds of procedural macros in the same crate.
-->
<p>La fonction qui d√©finit une macro proc√©durale prend un <code>TokenStream</code> en entr√©e
et produit un <code>TokenStream</code> en sortie. Le type <code>TokenStream</code> est d√©fini par la
crate <code>proc_macro</code> qui est fournie par Rust et repr√©sente une s√©quence de
jetons. C'est le c≈ìur de la macro¬†: le code source sur lequel la macro op√®re
compose l'entr√©e <code>TokenStream</code>, et le code que la macro produit est la sortie
<code>TokenStream</code>. La fonction a aussi un attribut qui lui est rattach√© et qui
indique quel genre de macro proc√©durale nous cr√©ons. Nous pouvons avoir
diff√©rents types de macros proc√©durales dans la m√™me crate.</p>
<!--
Let‚Äôs look at the different kinds of procedural macros. We‚Äôll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.
-->
<p>Voyons maintenant les diff√©rents types de macros proc√©durales. Nous allons
commencer par une macro d√©riv√©e personnalis√©e et nous expliquerons ensuite les
petites diff√©rences avec les autres types.</p>
<!--
### How to Write a Custom `derive` Macro
-->
<h3 id="comment-√©crire-une-macro-d√©riv√©e-personnalis√©e"><a class="header" href="#comment-√©crire-une-macro-d√©riv√©e-personnalis√©e">Comment √©crire une macro d√©riv√©e personnalis√©e</a></h3>
<!--
Let‚Äôs create a crate named `hello_macro` that defines a trait named
`HelloMacro` with one associated function named `hello_macro`. Rather than
making our crate users implement the `HelloMacro` trait for each of their
types, we‚Äôll provide a procedural macro so users can annotate their type with
`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro`
function. The default implementation will print `Hello, Macro! My name is
TypeName!` where `TypeName` is the name of the type on which this trait has
been defined. In other words, we‚Äôll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.
-->
<p>Cr√©ons une crate <code>hello_macro</code> qui d√©finit un trait qui s'appelle <code>HelloMacro</code>
avec une fonction associ√©e <code>hello_macro</code>. Plut√¥t que de contraindre les
utilisateurs de notre crate √† impl√©menter le trait <code>HelloMacro</code> sur chacun de
leurs types, nous allons fournir une macro proc√©durale qui permettra aux
utilisateurs de pouvoir annoter leur type avec <code>#[derive(HelloMacro)]</code> afin
d'obtenir une impl√©mentation par d√©faut de la fonction <code>hello_macro</code>.
L'impl√©mentation par d√©faut affichera <code>Hello, Macro¬†! Mon nom est TypeName¬†!</code>,
dans lequel <code>TypeName</code> est le nom du type sur lequel ce trait a √©t√© d√©fini.
Autrement dit, nous allons √©crire une crate qui permet √† un autre d√©veloppeur
d'√©crire du code comme l'encart 19-30 en utilisant notre crate.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
<span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span>
-->
<p><span class="caption">Encart 19-30¬†: le code qu'un utilisateur de notre crate
pourra √©crire lorsqu'il utilisera notre macro proc√©durale</span></p>
<!--
This code will print `Hello, Macro! My name is Pancakes!` when we‚Äôre done. The
first step is to make a new library crate, like this:
-->
<p>Ce code va afficher <code>Hello, Macro¬†! Mon nom est Pancakes¬†!</code> lorsque vous en
aurez fini. La premi√®re √©tape consiste √† cr√©er une nouvelle crate de biblioth√®que,
comme ceci¬†:</p>
<!--
```console
$ cargo new hello_macro --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<!--
Next, we‚Äôll define the `HelloMacro` trait and its associated function:
-->
<p>Ensuite, nous allons d√©finir le trait <code>HelloMacro</code> et sa fonction associ√©e¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait HelloMacro {
    fn hello_macro();
}
```
-->
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}
</code></pre>
<!--
We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:
-->
<p>Nous avons maintenant un trait et sa fonction. A partir de l√†, notre
utilisateur de la crate peut impl√©menter le trait pour accomplir la
fonctionnalit√© souhait√©e, comme ceci¬†:</p>
<!--
```rust,ignore
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro¬†! Mon nom est Pancakes¬†!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
However, they would need to write the implementation block for each type they
wanted to use with `hello_macro`; we want to spare them from having to do this
work.
-->
<p>Cependant, l'utilisateur doit √©crire le bloc d'impl√©mentation pour chacun des
types qu'il souhaite utiliser avec <code>hello_macro</code>¬†; nous souhaitons lui
√©pargner ce travail.</p>
<!--
Additionally, we can‚Äôt yet provide the `hello_macro` function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn‚Äôt have reflection capabilities, so it can‚Äôt look up the type‚Äôs
name at runtime. We need a macro to generate code at compile time.
-->
<p>De plus, nous ne pouvons pas encore fournir la fonction <code>hello_macro</code> avec
l'impl√©mentation par d√©faut qui va afficher le nom du type du trait sur lequel
nous l'impl√©mentons¬†: Rust n'est pas r√©flexif, donc il ne peut pas conna√Ætre le
nom du type √† l'ex√©cution. Nous avons besoin d'une macro pour g√©n√©rer le code √†
la compilation.</p>
<!--
The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named `foo`, a custom derive procedural macro crate is
called `foo_derive`. Let‚Äôs start a new crate called `hello_macro_derive` inside
our `hello_macro` project:
-->
<p>La prochaine √©tape consiste √† d√©finir la macro proc√©durale. Au moment de l'√©criture
de ces lignes, les macros proc√©durales ont besoin d'√™tre plac√©es dans leur
propre crate. Cette restriction sera lev√©e plus tard. La convention
pour structurer les crates et les crates de macros est la suivante¬†: pour
une crate <code>foo</code>, une crate de macro proc√©durale personnalis√©e de d√©riv√©e doit
s'appeler <code>foo_derive</code>. Cr√©ons une nouvelle crate <code>hello_macro_derive</code> au sein
de notre projet <code>hello_macro</code>¬†:</p>
<!--
```console
$ cargo new hello_macro_derive --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<!--
Our two crates are tightly related, so we create the procedural macro crate
within the directory of our `hello_macro` crate. If we change the trait
definition in `hello_macro`, we‚Äôll have to change the implementation of the
procedural macro in `hello_macro_derive` as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
`hello_macro` crate use `hello_macro_derive` as a dependency and re-export the
procedural macro code. However, the way we‚Äôve structured the project makes it
possible for programmers to use `hello_macro` even if they don‚Äôt want the
`derive` functionality.
-->
<p>Nos deux crates sont √©troitement li√©es, donc nous cr√©ons la crate de macro
proc√©durale √† l'int√©rieur du dossier de notre crate <code>hello_macro</code>. Si nous
changeons la d√©finition du trait dans <code>hello_macro</code>, nous aurons aussi √†
changer l'impl√©mentation de la macro proc√©durale dans <code>hello_macro_derive</code>. Les
deux crates vont devoir √™tre publi√©es s√©par√©ment, et les d√©veloppeurs qui vont
utiliser ces crates vont avoir besoin d'ajouter les deux d√©pendances et les
importer dans la port√©e. Nous pourrions plut√¥t faire en sorte que la crate
<code>hello_macro</code> utilise <code>hello_macro_derive</code> comme d√©pendance et r√©-exporter le
code de la macro proc√©durale. Cependant, la fa√ßon dont nous avons structur√© le
projet donne la possibilit√© aux d√©veloppeurs d'utiliser <code>hello_macro</code> m√™me s'ils
ne veulent pas la fonctionnalit√© <code>derive</code>.</p>
<!--
We need to declare the `hello_macro_derive` crate as a procedural macro crate.
We‚Äôll also need functionality from the `syn` and `quote` crates, as you‚Äôll see
in a moment, so we need to add them as dependencies. Add the following to the
*Cargo.toml* file for `hello_macro_derive`:
-->
<p>Nous devons d√©clarer la crate <code>hello_macro_derive</code> comme √©tant une crate de
macro proc√©durale. Nous allons aussi avoir besoin des fonctionnalit√©s des
crates <code>syn</code> et <code>quote</code>, comme vous allez le constater bient√¥t, donc nous
allons les ajouter comme d√©pendances. Ajoutez ceci dans le fichier <em>Cargo.toml</em>
de <code>hello_macro_derive</code>¬†:</p>
<!--
<span class="filename">Filename: hello_macro_derive/Cargo.toml</span>
-->
<p><span class="filename">Fichier¬†: hello_macro_derive/Cargo.toml</span></p>
<!--
```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```
-->
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<!--
To start defining the procedural macro, place the code in Listing 19-31 into
your *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code
won‚Äôt compile until we add a definition for the `impl_hello_macro` function.
-->
<p>Pour commencer √† d√©finir la macro proc√©durale, placez le code de l'encart 19-31
dans votre fichier <em>src/lib.rs</em> de la crate <code>hello_macro_derive</code>. Notez que ce
code ne se compilera pas tant que nous n'ajouterons pas une d√©finition pour la
fonction <code>impl_hello_macro</code>.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construit une repr√©sentation du code Rust en arborescence
    // syntaxique que nous pouvons manipuler
    let ast = syn::parse(input).unwrap();

    // Construit l'impl√©mentation du trait
    impl_hello_macro(&amp;ast)
}
</code></pre>
<!--
<span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span>
-->
<p><span class="caption">Encart 19-31¬†: du code dont la plupart des macros
proc√©durales auront besoin pour travailler avec du code Rust</span></p>
<!--
Notice that we‚Äôve split the code into the `hello_macro_derive` function, which
is responsible for parsing the `TokenStream`, and the `impl_hello_macro`
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(`hello_macro_derive` in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (`impl_hello_macro` in this case) will be different
depending on your procedural macro‚Äôs purpose.
-->
<p>Remarquez que nous avons s√©par√© le code de la fonction <code>hello_macro_derive</code>,
qui est responsable de parcourir le <code>TokenStream</code>, de celui de la fonction
<code>impl_hello_macro</code>, qui est responsable de transformer l'arborescence
syntaxique¬†: cela facilite l'√©criture de la macro proc√©durale. Le code dans la
fonction englobante (qui est <code>hello_macro_derive</code> dans notre cas) sera le m√™me
pour presque toutes les crates de macro proc√©durales que vous allez voir ou
cr√©er. Le code que vous renseignez dans le corps de la fonction (qui est
<code>impl_hello_macro</code> dans notre cas) diff√®rera en fonction de ce que fait votre
macro proc√©durale.</p>
<!--
We‚Äôve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The
`proc_macro` crate comes with Rust, so we didn‚Äôt need to add that to the
dependencies in *Cargo.toml*. The `proc_macro` crate is the compiler‚Äôs API that
allows us to read and manipulate Rust code from our code.
-->
<p>Nous avons ajout√© trois nouvelles crates¬†: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a> et <a href="https://crates.io/crates/quote"><code>quote</code></a>.
La crate <code>proc_macro</code> est fournie par Rust, donc nous n'avons pas besoin de
l'ajouter aux d√©pendances dans <em>Cargo.toml</em>. La crate <code>proc_macro</code> fournit une
API du compilateur qui nous permet de lire et manipuler le code Rust √† partir de
notre code.</p>
<!--
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
-->
<!--
The `syn` crate parses Rust code from a string into a data structure that we
can perform operations on. The `quote` crate turns `syn` data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.
-->
<p>La crate <code>syn</code> transforme le code Rust d'une cha√Æne de caract√®res en une
structure de donn√©es sur laquelle nous pouvons proc√©der √† des op√©rations. La
crate <code>quote</code> re-transforme les structures de donn√©es de <code>syn</code> en code Rust.
Ces crates facilite le parcours de toute sorte de code Rust que nous aurions
besoin de g√©rer¬†: l'√©criture d'un interpr√©teur complet de code Rust n'a jamais
√©t√© aussi facile.</p>
<!--
The `hello_macro_derive` function will be called when a user of our library
specifies `#[derive(HelloMacro)]` on a type. This is possible because we‚Äôve
annotated the `hello_macro_derive` function here with `proc_macro_derive` and
specified the name, `HelloMacro`, which matches our trait name; this is the
convention most procedural macros follow.
-->
<p>La fonction <code>hello_macro_derive</code> va √™tre appel√©e lorsqu'un utilisateur de notre
biblioth√®que utilisera <code>#[derive(HelloMacro)]</code> sur un type. Cela sera possible
car nous avons annot√© notre fonction <code>hello_macro_derive</code> avec
<code>proc_macro_derive</code> et nous avons indiqu√© le nom, <code>HelloMacro</code>, qui
correspond au nom de notre trait¬†; c'est la convention que la plupart des
macros proc√©durales suivent.</p>
<!--
The `hello_macro_derive` function first converts the `input` from a
`TokenStream` to a data structure that we can then interpret and perform
operations on. This is where `syn` comes into play. The `parse` function in
`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput`
struct we get from parsing the `struct Pancakes;` string:
-->
<p>La fonction <code>hello_macro_derive</code> commence par convertir le <code>input</code> qui est un
<code>TokenStream</code> en une structure de donn√©es que nous pouvons ensuite interpr√©ter
et sur laquelle faire des op√©rations. C'est l√† que <code>syn</code> entre en jeu. La fonction
<code>parse</code> de <code>syn</code> prend un <code>TokenStream</code> et retourne une structure <code>DeriveInput</code>
qui repr√©sente le code Rust. L'encart 19-32 montre les parties int√©ressantes de
la structure <code>DeriveInput</code> que nous obtenons en convertissant la cha√Æne de
caract√®res <code>struct Pancakes;</code>¬†:</p>
<!--
```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```
-->
<pre><code class="language-rust ignore">DeriveInput {
    // -- partie masqu√©e ici --

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<!--
<span class="caption">Listing 19-32: The `DeriveInput` instance we get when
parsing the code that has the macro‚Äôs attribute in Listing 19-30</span>
-->
<p><span class="caption">Encart 19-32¬†: l'instance de <code>DeriveInput</code> que nous
obtenons lorsque nous analysons le code qui est d√©cor√© par l'attribut de la
macro dans l'encart 19-30</span></p>
<!--
The fields of this struct show that the Rust code we‚Äôve parsed is a unit struct
with the `ident` (identifier, meaning the name) of `Pancakes`. There are more
fields on this struct for describing all sorts of Rust code; check the [`syn`
documentation for `DeriveInput`][syn-docs] for more information.
-->
<p>Les champs de cette structure montrent que ce code Rust que nous avons converti
est une structure unitaire avec l'<code>ident</code> (raccourci de <code>identifier</code>, qui
d√©signe le nom) <code>Pancakes</code>. Il y a d'autres champs sur cette structure
d√©crivant toutes sortes de codes Rust¬†; regardez la
<a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">documentation de <code>syn</code> pour <code>DeriveInput</code></a> pour en savoir plus.</p>
<!--
[syn-docs]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
-->
<!--
Soon we‚Äôll define the `impl_hello_macro` function, which is where we‚Äôll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a `TokenStream`. The returned `TokenStream` is
added to the code that our crate users write, so when they compile their crate,
they‚Äôll get the extra functionality that we provide in the modified
`TokenStream`.
-->
<p>Bient√¥t, nous d√©finirons la fonction <code>impl_hello_macro</code>, qui nous permettra de
construire le nouveau code Rust que nous souhaitons injecter. Mais avant de faire
cela, remarquez que la sortie de notre macro <code>derive</code> est aussi un <code>TokenStream</code>.
Le <code>TokenStream</code> retourn√© est ajout√© au code que les utilisateurs de notre
crate ont √©crit, donc lorsqu'ils compilent leur crate, ils r√©cup√©reront la
fonctionnalit√© additionnelle que nous injectons dans le <code>TokenStream</code> modifi√©.</p>
<!--
You might have noticed that we‚Äôre calling `unwrap` to cause the
`hello_macro_derive` function to panic if the call to the `syn::parse` function
fails here. It‚Äôs necessary for our procedural macro to panic on errors because
`proc_macro_derive` functions must return `TokenStream` rather than `Result` to
conform to the procedural macro API. We‚Äôve simplified this example by using
`unwrap`; in production code, you should provide more specific error messages
about what went wrong by using `panic!` or `expect`.
-->
<p>Vous avez peut-√™tre remarqu√© que nous faisons appel √† <code>unwrap</code> pour faire
paniquer la fonction <code>hello_macro_derive</code> si l'appel √† la fonction <code>syn::parse</code>
que nous faisons √©choue. Il est n√©cessaire de faire paniquer notre macro
proc√©durale si elle rencontre des erreurs car les fonctions <code>proc_macro_derive</code>
doivent retourner un <code>TokenStream</code> plut√¥t qu'un <code>Result</code> pour se conformer √†
l'API de la macro proc√©durale. Nous avons simplifi√© cet exemple en utilisant
<code>unwrap</code>¬†; dans du code en production, vous devriez renseigner des messages
d'erreur plus pr√©cis sur ce qui s'est mal pass√© en utilisant <code>panic!</code> ou
<code>expect</code>.</p>
<!--
Now that we have the code to turn the annotated Rust code from a `TokenStream`
into a `DeriveInput` instance, let‚Äôs generate the code that implements the
`HelloMacro` trait on the annotated type, as shown in Listing 19-33.
-->
<p>Maintenant que nous avons le code pour transformer le code Rust annot√© d'un
<code>TokenStream</code> en une instance de <code>DeriveInput</code>, cr√©ons le code qui impl√©mente le
trait <code>HelloMacro</code> sur le type annot√©, comme montr√© dans l'encart 19-33.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore
# use proc_macro::TokenStream;
# use quote::quote;
# use syn;
# 
# #[proc_macro_derive(HelloMacro)]
# pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
#     // Construct a representation of Rust code as a syntax tree
#     // that we can manipulate
#     let ast = syn::parse(input).unwrap();
# 
#     // Build the trait implementation
#     impl_hello_macro(&ast)
# }
# 
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construit une repr√©sentation du code Rust en arborescence
</span><span class="boring">    // syntaxique que nous pouvons manipuler
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Construit l'impl√©mentation du trait
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let nom = &amp;ast.ident;
    let generation = quote! {
        impl HelloMacro for #nom {
            fn hello_macro() {
                println!(&quot;Hello, Macro¬†! Mon nom est¬†{}&quot;, stringify!(#nom));
            }
        }
    };
    generation.into()
}
</code></pre>
<!--
<span class="caption">Listing 19-33: Implementing the `HelloMacro` trait using
the parsed Rust code</span>
-->
<p><span class="caption">Encart 19-33¬†: impl√©mentation du trait <code>HelloMacro</code> en
utilisant le code Rust interpr√©t√©</span></p>
<!--
We get an `Ident` struct instance containing the name (identifier) of the
annotated type using `ast.ident`. The struct in Listing 19-32 shows that when
we run the `impl_hello_macro` function on the code in Listing 19-30, the
`ident` we get will have the `ident` field with a value of `"Pancakes"`. Thus,
the `name` variable in Listing 19-33 will contain an `Ident` struct instance
that, when printed, will be the string `"Pancakes"`, the name of the struct in
Listing 19-30.
-->
<p>Nous obtenons une instance de structure <code>Ident</code> qui contient le nom
(<code>identifier</code>) du type annot√© en utilisant <code>ast.ident</code>. La structure de l'encart
19-32 montre que lorsque nous ex√©cutons la fonction <code>impl_hello_macro</code> sur le
code de l'encart 19-30, le <code>ident</code> que nous obtenons aura le champ <code>ident</code> avec
la valeur <code>&quot;Pancakes&quot;</code>. Ainsi, la variable <code>nom</code> de l'encart 19-33 contiendra
une instance de la structure <code>Ident</code> qui, une fois affich√©e, sera la cha√Æne de
caract√®res <code>&quot;Pancakes&quot;</code>, le nom de la structure de l'encart 19-30.</p>
<!--
The `quote!` macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the `quote!`
macro‚Äôs execution, so we need to convert it to a `TokenStream`. We do this by
calling the `into` method, which consumes this intermediate representation and
returns a value of the required `TokenStream` type.
-->
<p>La macro <code>quote!</code> nous permet de d√©finir le code Rust que nous souhaitons
retourner. Le compilateur attend quelque chose de diff√©rent que le r√©sultat
direct produit par l'ex√©cution de <code>quote!</code>, donc nous devons convertir ce
dernier en <code>TokenStream</code>. Nous faisons ceci en faisant appel √† la m√©thode
<code>into</code>, qui utilise cette repr√©sentation interm√©diaire et retourne une valeur
du type attendu, le type <code>TokenStream</code> ici.</p>
<!--
The `quote!` macro also provides some very cool templating mechanics: we can
enter `#name`, and `quote!` will replace it with the value in the variable
`name`. You can even do some repetition similar to the way regular macros work.
Check out [the `quote` crate‚Äôs docs][quote-docs] for a thorough introduction.
-->
<p>La macro <code>quote!</code> fournit aussi quelques m√©caniques de gabarit int√©ressantes¬†:
nous pouvons entrer <code>#nom</code>, et <code>quote!</code> va le remplacer avec la valeur pr√©sente
dans la variable <code>nom</code>. Vous pouvez m√™me ex√©cuter des r√©p√©titions d'une fa√ßon
similaire √† celle des macros classiques. Regardez dans
<a href="https://docs.rs/quote">la documentation de <code>quote</code></a> pour une pr√©sentation plus d√©taill√©e.</p>
<!--
[quote-docs]: https://docs.rs/quote
-->
<!--
We want our procedural macro to generate an implementation of our `HelloMacro`
trait for the type the user annotated, which we can get by using `#name`. The
trait implementation has one function, `hello_macro`, whose body contains the
functionality we want to provide: printing `Hello, Macro! My name is` and then
the name of the annotated type.
-->
<p>Nous souhaitons que notre macro proc√©durale g√©n√®re une impl√©mentation de notre
trait <code>HelloMacro</code> pour le type que l'utilisateur a annot√©, que nous pouvons
obtenir en utilisant <code>#nom</code>. L'impl√©mentation du trait utilise une fonction,
<code>hello_macro</code>, dont le corps contient la fonctionnalit√© que nous souhaitons
fournir¬†: l'affichage de <code>Hello, Macro¬†! Mon nom est</code> suivi par le nom du type
annot√©.</p>
<!--
The `stringify!` macro used here is built into Rust. It takes a Rust
expression, such as `1 + 2`, and at compile time turns the expression into a
string literal, such as `"1 + 2"`. This is different than `format!` or
`println!`, macros which evaluate the expression and then turn the result into
a `String`. There is a possibility that the `#name` input might be an
expression to print literally, so we use `stringify!`. Using `stringify!` also
saves an allocation by converting `#name` to a string literal at compile time.
-->
<p>La macro <code>stringify!</code> utilis√©e ici est √©crite en Rust. Elle prend en argument
une expression Rust, comme <code>1 + 2</code>, et √† la compilation transforme l'expression
en une cha√Æne de caract√®res litt√©rale, comme <code>&quot;1 + 2&quot;</code>. Cela est diff√©rent de
<code>format!</code> ou de <code>println!</code>, des macros qui √©valuent l'expression et retourne
ensuite le r√©sultat dans une <code>String</code>. Il est possible que l'entr√©e <code>#nom</code> soit
une expression √† √©crire litt√©ralement, donc nous utilisons <code>stringify!</code>.
L'utilisation de <code>stringify!</code> √©vite aussi une allocation en convertissant <code>#nom</code>
en une chaine de caract√®res litt√©rale √† la compilation.</p>
<!--
At this point, `cargo build` should complete successfully in both `hello_macro`
and `hello_macro_derive`. Let‚Äôs hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your *projects* directory using `cargo new pancakes`. We need to add
`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`
crate‚Äôs *Cargo.toml*. If you‚Äôre publishing your versions of `hello_macro` and
`hello_macro_derive` to [crates.io](https://crates.io/), they would be regular
dependencies; if not, you can specify them as `path` dependencies as follows:
-->
<p>Maintenant, <code>cargo build</code> devrait fonctionner correctement pour <code>hello_macro</code> et
<code>hello_macro_derive</code>. Relions maintenant ces crates au code de l'encart 19-30
pour voir les macros proc√©durales √† l'oeuvre¬†! Cr√©ez un nouveau projet binaire
dans votre dossier <em>projects</em> en utilisant <code>cargo new pancakes</code>. Nous avons
besoin d'ajouter <code>hello_macro</code> et <code>hello_macro_derive</code> comme d√©pendances dans le
<em>Cargo.toml</em> de la crate <code>pancakes</code>. Si vous publiez vos versions de
<code>hello_macro</code> et de <code>hello_macro_derive</code> sur <a href="https://crates.io">crates.io</a>,
ce seront des d√©pendances classiques¬†; sinon, vous pouvez les indiquer en tant que
d√©pendances locales avec <code>path</code> comme ci-apr√®s¬†:</p>
<!--
```toml
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```
-->
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!--
Put the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it
should print `Hello, Macro! My name is Pancakes!` The implementation of the
`HelloMacro` trait from the procedural macro was included without the
`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the
trait implementation.
-->
<p>Renseignez le code l'encart 19-30 dans <em>src/main.rs</em>, puis lancez <code>cargo run</code>¬†:
cela devrait afficher <code>Hello, Macro¬†! Mon nom est Pancakes¬†!</code>. L'impl√©mentation
du trait <code>HelloMacro</code> √† l'aide de la macro proc√©durale a √©t√© incluse sans que la
crate <code>pancakes</code> n'ait eu besoin de l'impl√©menter¬†; le
<code>#[derive(HelloMacro)]</code> a ajout√© automatiquement l'impl√©mentation du trait.</p>
<!--
Next, let‚Äôs explore how the other kinds of procedural macros differ from custom
derive macros.
-->
<p>Maintenant, d√©couvrons comment les autres types de macros proc√©durales se
distinguent des macros <code>derive</code> personnalis√©es.</p>
<!--
### Attribute-like macros
-->
<h3 id="les-macros-qui-ressemblent-√†-des-attributs"><a class="header" href="#les-macros-qui-ressemblent-√†-des-attributs">Les macros qui ressemblent √† des attributs</a></h3>
<!--
Attribute-like macros are similar to custom derive macros, but instead of
generating code for the `derive` attribute, they allow you to create new
attributes. They‚Äôre also more flexible: `derive` only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here‚Äôs an example of using an attribute-like macro: say you have an attribute
named `route` that annotates functions when using a web application framework:
-->
<p>Les macros qui ressemblent √† des attributs ressemblent aux macros <code>derive</code>
personnalis√©es, mais au lieu de g√©n√©rer du code pour l'attribut <code>derive</code>, elles
vous permettent de cr√©er des nouveaux attributs. Elles sont aussi plus
flexibles¬†: <code>derive</code> fonctionne uniquement pour les structures et les
√©num√©rations¬†; les attributs peuvent √™tre aussi appliqu√©s aux autres √©l√©ments,
comme les fonctions. Voici un exemple d'utilisation d'une macro qui ressemble √†
un attribut¬†: imaginons que vous avez un attribut <code>chemin</code> qui est une
annotation pour des fonctions lorsque vous utilisez un environnement de
d√©veloppement d'application web¬†:</p>
<!--
```rust,ignore
#[route(GET, "/")]
fn index() {
```
-->
<pre><code class="language-rust ignore">#[chemin(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<!--
This `#[route]` attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:
-->
<p>Cet attribut <code>#[chemin]</code> sera d√©fini par l'environnement de d√©veloppement comme
√©tant une macro proc√©durale. La signature de la fonction de d√©finition de la
macro ressemblera √† ceci¬†:</p>
<!--
```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn chemin(attribut: TokenStream, element: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
Here, we have two parameters of type `TokenStream`. The first is for the
contents of the attribute: the `GET, "/"` part. The second is the body of the
item the attribute is attached to: in this case, `fn index() {}` and the rest
of the function‚Äôs body.
-->
<p>Maintenant, nous avons deux param√®tres de type <code>TokenStream</code>. Le premier
correspond au contenu de l'attribut¬†: la partie <code>GET, &quot;/&quot;</code>. Le second est le
corps de l'√©l√©ment sur lequel cet attribut sera appliqu√©¬†: dans notre cas,
<code>fn index() {}</code> et le reste du corps de la fonction.</p>
<!--
Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the `proc-macro` crate type and implement a
function that generates the code you want!
-->
<p>Mis √† part cela, les macros qui ressemblent √† des attributs fonctionnent de la
m√™me mani√®re que les macros <code>derive</code> personnalis√©es¬†: vous g√©n√©rez une crate avec
le type de la crate <code>proc-macro</code> et vous impl√©mentez une fonction qui g√©n√®rera le
code que vous souhaitez¬†!</p>
<!--
### Function-like macros
-->
<h3 id="les-macros-qui-ressemblent-√†-des-fonctions"><a class="header" href="#les-macros-qui-ressemblent-√†-des-fonctions">Les macros qui ressemblent √† des fonctions</a></h3>
<!--
Function-like macros define macros that look like function calls. Similarly to
`macro_rules!` macros, they‚Äôre more flexible than functions; for example, they
can take an unknown number of arguments. However, `macro_rules!` macros can be
defined only using the match-like syntax we discussed in the section
[‚ÄúDeclarative Macros with `macro_rules!` for General
Metaprogramming‚Äù][decl]<!-- ignore -- > earlier. Function-like macros take a
`TokenStream` parameter and their definition manipulates that `TokenStream`
using Rust code as the other two types of procedural macros do. An example of a
function-like macro is an `sql!` macro that might be called like so:
-->
<p>Les macros qui ressemblent √† des fonctions d√©finissent des macros qui
ressemblent √† des appels de fonction. De la m√™me mani√®re que les macros
<code>macro_rules!</code>, elles sont plus flexibles que les fonctions¬†; par exemple, elles
peuvent prendre une quantit√© non finie d'arguments. Cependant, les macros
<code>macro_rules!</code> peuvent √™tre d√©finies uniquement en utilisant la syntaxe qui
ressemble √† <code>match</code> et que nous avons vue dans <a href="ch19-06-macros.html#les-macros-d%C3%A9claratives-avec-macro_rules-pour-la-m%C3%A9taprogrammation-g%C3%A9n%C3%A9rale">une section
pr√©c√©dente</a><!-- ignore -->. Les macros qui ressemblent √† des fonctions
prennent en param√®tre un <code>TokenStream</code> et leurs d√©finitions manipulent ce
<code>TokenStream</code> en utilisant du code Rust comme le font les deux autres types de
macros proc√©durales. Voici un exemple d'une macro qui ressemble √† une fonction
qui est une macro <code>sql!</code> qui devrait √™tre utilis√©e comme ceci¬†:</p>
<!--
[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming
-->
<!--
```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```
-->
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM publications WHERE id=1);
</code></pre>
<!--
This macro would parse the SQL statement inside it and check that it‚Äôs
syntactically correct, which is much more complex processing than a
`macro_rules!` macro can do. The `sql!` macro would be defined like this:
-->
<p>Cette macro devrait interpr√©ter l'instruction SQL qu'on lui envoie et v√©rifier
si elle est syntaxiquement correcte, ce qui est un proc√©d√© bien plus complexe
que ce qu'une macro <code>macro_rules!</code> peut faire. La macro <code>sql!</code> sera d√©finie
comme ceci¬†:</p>
<!--
```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
This definition is similar to the custom derive macro‚Äôs signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.
-->
<p>Cette d√©finition ressemble √† la signature de la macro <code>derive</code> personnalis√©e¬†:
nous r√©cup√©rons les √©l√©ments entre parenth√®ses et retournons le code que nous
souhaitons g√©n√©rer.</p>
<!--
## Summary
-->
<h2 id="r√©sum√©-18"><a class="header" href="#r√©sum√©-18">R√©sum√©</a></h2>
<!--
Whew! Now you have some Rust features in your toolbox that you won‚Äôt use often,
but you‚Äôll know they‚Äôre available in very particular circumstances. We‚Äôve
introduced several complex topics so that when you encounter them in error
message suggestions or in other peoples‚Äô code, you‚Äôll be able to recognize
these concepts and syntax. Use this chapter as a reference to guide you to
solutions.
-->
<p>Ouah¬†! Maintenant vous avez quelques fonctionnalit√©s de Rust suppl√©mentaires
dans votre boite √† outils que vous n'utiliserez probablement que rarement, mais vous
savez maintenant qu'elles pourront vous aider dans certaines situations tr√®s particuli√®res.
Nous avons introduits plusieurs sujets complexes afin que vous puissiez les
reconna√Ætre, ainsi que la syntaxe associ√©e, lorsque vous les rencontrerez dans des
messages de suggestions dans des erreurs ou dans le code de quelqu'un d'autre.
Utilisez ce chapitre comme r√©f√©rence pour vous guider vers ces solutions.</p>
<!--
Next, we‚Äôll put everything we‚Äôve discussed throughout the book into practice
and do one more project!
-->
<p>Au chapitre suivant, nous allons mettre en pratique tout ce que nous avons
appris dans ce livre en l'appliquant √† un nouveau projet¬†!</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Final Project: Building a Multithreaded Web Server
-->
<h1 id="projet-final--construire-un-serveur-web-multit√¢ches"><a class="header" href="#projet-final--construire-un-serveur-web-multit√¢ches">Projet final : construire un serveur web multit√¢ches</a></h1>
<!--
It‚Äôs been a long journey, but we‚Äôve reached the end of the book. In this
chapter, we‚Äôll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.
-->
<p>Ce fut un long voyage, mais nous avons atteint la fin de ce livre. Dans ce
chapitre, nous allons construire un nouveau projet ensemble pour mettre en
application certains concepts que nous avons vus dans les derniers chapitres, et
aussi pour r√©capituler quelques le√ßons pr√©c√©dentes.</p>
<!--
For our final project, we‚Äôll make a web server that says ‚Äúhello‚Äù and looks like
Figure 20-1 in a web browser.
-->
<p>Pour notre projet final, nous allons construire un serveur web qui dit
‚Äúsalutations‚Äù et qui ressemble dans un navigateur web √† l'illustration 20-1.</p>
<!--
![hello from rust](img/trpl20-01.png)
-->
<p><img src="img/trpl20-01.png" alt="bonjour de la part de Rust" /></p>
<!--
<span class="caption">Figure 20-1: Our final shared project</span>
-->
<p><span class="caption">Illustration 20-1¬†: notre dernier projet en commun</span></p>
<!--
Here is the plan to build the web server:
-->
<p>Voici le plan de construction du serveur web¬†:</p>
<!--
1. Learn a bit about TCP and HTTP.
2. Listen for TCP connections on a socket.
3. Parse a small number of HTTP requests.
4. Create a proper HTTP response.
5. Improve the throughput of our server with a thread pool.
-->
<ol>
<li>En savoir plus sur TCP et HTTP.</li>
<li>Ecouter les connections TCP sur un port.</li>
<li>Interpr√©ter une petite quantit√© de requ√™tes HTTP.</li>
<li>Cr√©er une r√©ponse HTTP ad√©quate.</li>
<li>Augmenter le d√©bit de notre serveur avec un groupe de t√¢ches.</li>
</ol>
<!--
But before we get started, we should mention one detail: the method we‚Äôll use
won‚Äôt be the best way to build a web server with Rust. A number of
production-ready crates are available on [crates.io](https://crates.io/) that
provide more complete web server and thread pool implementations than we‚Äôll
build.
-->
<p>Mais avant de commencer, nous devons signaler une chose¬†: les m√©thodes que nous
allons utiliser ne sont pas les meilleures pour construire un serveur web avec
Rust. Un certain nombre de crates √©prouv√©es en production et disponibles sur
<a href="https://crates.io/">crates.io</a> fourniront des serveurs web et des
impl√©mentations de groupe de t√¢ches plus complets que ce que nous allons
construire.</p>
<!--
However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We‚Äôll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.
-->
<p>Toutefois, notre intention dans ce chapitre est de vous aider √† apprendre, et
ne pas de se laisser aller √† la facilit√©. Comme Rust est un langage de
programmation syst√®me, nous pouvons choisir le niveau d'abstraction avec lequel
nous souhaitons travailler et nous pouvons descendre √† un niveau plus bas que
ce qui est possible ou pratique dans d'autres langages. Nous allons √©crire
manuellement le serveur HTTP basique et le groupe de t√¢ches afin que vous
puissiez apprendre les id√©es et techniques g√©n√©rales qui se cachent derri√®re
les crates que vous serez peut-√™tre amen√©s √† utiliser √† l'avenir.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Building a Single-Threaded Web Server
-->
<h2 id="d√©velopper-un-serveur-web-monot√¢che"><a class="header" href="#d√©velopper-un-serveur-web-monot√¢che">D√©velopper un serveur web monot√¢che</a></h2>
<!--
We‚Äôll start by getting a single-threaded web server working. Before we begin,
let‚Äôs look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.
-->
<p>Nous allons commencer par faire fonctionner un serveur web monot√¢che.
Avant de commencer, faisons un survol rapide des protocoles utilis√©s dans les
serveurs web. Les d√©tails de ces protocoles ne sont pas le sujet de ce livre,
mais un rapide aper√ßu vous donnera les informations dont vous avez besoin.</p>
<!--
The two main protocols involved in web servers are the *Hypertext Transfer
Protocol* *(HTTP)* and the *Transmission Control Protocol* *(TCP)*. Both
protocols are *request-response* protocols, meaning a *client* initiates
requests and a *server* listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.
-->
<p>Les deux principaux protocoles utilis√©s dans les serveurs web sont le
<em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> et le <em>Transmission Control Protocol</em>
<em>(TCP)</em>. Ces deux protocoles sont des protocoles de type <em>requ√™te-r√©ponse</em>, ce
qui signifie qu'un <em>client</em> initie des requ√™tes tandis que le <em>serveur</em> √©coute les
requ√™tes et fournit une r√©ponse au client. Le contenu de ces requ√™tes et de ces
r√©ponses est d√©fini par les protocoles.</p>
<!--
TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn‚Äôt specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It‚Äôs technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We‚Äôll work with the
raw bytes of TCP and HTTP requests and responses.
-->
<p>TCP est le protocole le plus bas-niveau qui d√©crit les d√©tails de comment une
information passe d'un serveur √† un autre mais ne pr√©cise pas ce qu'est cette
information. HTTP est construit sur TCP en d√©finissant le contenu des requ√™tes et
des r√©ponses. Il est techniquement possible d'utiliser HTTP avec d'autres
protocoles, mais dans la grande majorit√© des cas, HTTP envoie ses donn√©es via
TCP. Nous allons travailler avec les octets bruts des requ√™tes et des r√©ponses
de TCP et HTTP.</p>
<!--
### Listening to the TCP Connection
-->
<h3 id="ecouter-les-connexions-tcp"><a class="header" href="#ecouter-les-connexions-tcp">Ecouter les connexions TCP</a></h3>
<!--
Our web server needs to listen to a TCP connection, so that‚Äôs the first part
we‚Äôll work on. The standard library offers a `std::net` module that lets us do
this. Let‚Äôs make a new project in the usual fashion:
-->
<p>Notre serveur web a besoin d'√©couter les connexions TCP, donc cela sera la
premi√®re partie sur laquelle nous travaillerons. La biblioth√®que standard offre
un module <code>std::net</code> qui nous permet de faire ceci. Cr√©ons un nouveau projet de
mani√®re habituelle¬†:</p>
<!--
```console
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```
-->
<pre><code class="language-console">$ cargo new salutations
     Created binary (application) `salutations` project
$ cd salutations
</code></pre>
<!--
Now enter the code in Listing 20-1 in *src/main.rs* to start. This code will
listen at the address `127.0.0.1:7878` for incoming TCP streams. When it gets
an incoming stream, it will print `Connection established!`.
-->
<p>Maintenant, saisissez le code de l'encart 20-1 dans <em>src/main.rs</em> pour
commencer. Ce code va √©couter les flux TCP entrants √† l'adresse
<code>127.0.0.1:7878</code>. Lorsqu'il obtiendra un flux entrant, il va afficher
<code>Connexion √©tablie¬†!</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        println!(&quot;Connexion √©tablie¬†!&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span>
-->
<p><span class="caption">Encart 20-1¬†: √©coute des flux entrants et affichage d'un
message lorsque nous recevons un flux</span></p>
<!--
Using `TcpListener`, we can listen for TCP connections at the address
`127.0.0.1:7878`. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn‚Äôt
represent the authors‚Äô computer specifically), and `7878` is the port. We‚Äôve
chosen this port for two reasons: HTTP isn‚Äôt normally accepted on this port, and
7878 is *rust* typed on a telephone.
-->
<p>En utilisant <code>TcpListener</code>, nous pouvons √©couter les connexions TCP √† l'adresse
<code>127.0.0.1:7878</code>. Dans cette adresse, la partie avant les double-points est une
adresse IP qui repr√©sente votre ordinateur (c'est la m√™me sur chaque ordinateur
et ne repr√©sente pas sp√©cifiquement l'ordinateur de l'auteur), et <code>7878</code> est le
port. Nous avons choisi ce port pour deux raisons¬†: HTTP n'est pas
habituellement accept√© sur ce port et 7878 correspond aux touches utilis√©es
sur un clavier de t√©l√©phone pour √©crire <em>Rust</em>.</p>
<!--
The `bind` function in this scenario works like the `new` function in that it
will return a new `TcpListener` instance. The reason the function is called
`bind` is that in networking, connecting to a port to listen to is known as
‚Äúbinding to a port.‚Äù
-->
<p>La fonction <code>bind</code> dans ce sc√©nario fonctionne comme la fonction <code>new</code> dans le
sens o√π elle retourne une nouvelle instance de <code>TcpListener</code>. La raison pour
laquelle cette fonction s'appelle <code>bind</code> <em>(NdT : signifie &quot;lier&quot;)</em> est que dans
le domaine des r√©seaux, se connecter √† un port se dit se ‚Äúlier √† un port‚Äù.</p>
<!--
The `bind` function returns a `Result<T, E>`, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1023), so if
we tried to connect to port 80 without being an administrator, binding wouldn‚Äôt
work. As another example, binding wouldn‚Äôt work if we ran two instances of our
program and so had two programs listening to the same port. Because we‚Äôre
writing a basic server just for learning purposes, we won‚Äôt worry about
handling these kinds of errors; instead, we use `unwrap` to stop the program if
errors happen.
-->
<p>La fonction <code>bind</code> retourne un <code>Result&lt;T, E&gt;</code>, ce qui signifie que la cr√©ation
de lien peut √©chouer. Par exemple, la connexion au port 80 n√©cessite d'√™tre
administrateur (les utilisateurs non-administrateur ne peuvent √©couter que sur
les ports sup√©rieurs √† 1023), donc si nous essayons de connecter un port 80
sans √™tre administrateur, le lien ne va pas fonctionner. Pour donner un autre
exemple, le lien ne va pas fonctionner si nous ex√©cutons deux instances de
notre programme et que nous avons deux programmes qui √©coutent sur le m√™me
port. Comme nous √©crivons un serveur basique uniquement √† but p√©dagogique, nous
n'avons pas √† nous soucier de la gestion de ce genre d'erreur¬†; c'est pourquoi
nous utilisons <code>unwrap</code> pour arr√™ter l'ex√©cution du programme si des erreurs
surviennent.</p>
<!--
The `incoming` method on `TcpListener` returns an iterator that gives us a
sequence of streams (more specifically, streams of type `TcpStream`). A single
*stream* represents an open connection between the client and the server. A
*connection* is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, `TcpStream` will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this `for` loop will process each connection in turn and produce a series of
streams for us to handle.
-->
<p>La m√©thode <code>incoming</code> d'un <code>TcpListener</code> retourne l'it√©rateur qui nous donne une
s√©quence de flux (plus pr√©cis√©ment, des flux de type <code>TcpStream</code>). Un seul
<em>flux</em> repr√©sente une connexion entre le client et le serveur. Une <em>connexion</em>
est le nom qui d√©signe le processus complet de requ√™te et de r√©ponse, durant
lequel le client se connecte au serveur, le serveur g√©n√®re une r√©ponse puis le
serveur ferme la connexion. Ainsi, <code>TcpStream</code> va se lire lui-m√™me pour voir ce
que le client a envoy√© et nous permettre ensuite d'√©crire notre r√©ponse dans le
flux. De mani√®re g√©n√©rale, cette boucle <code>for</code> traitera l'une apr√®s l'autre
chaque connexion dans l'ordre et produira une s√©rie de flux que nous devrons
g√©rer.</p>
<!--
For now, our handling of the stream consists of calling `unwrap` to terminate
our program if the stream has any errors; if there aren‚Äôt any errors, the
program prints a message. We‚Äôll add more functionality for the success case in
the next listing. The reason we might receive errors from the `incoming` method
when a client connects to the server is that we‚Äôre not actually iterating over
connections. Instead, we‚Äôre iterating over *connection attempts*. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.
-->
<p>Pour l'instant, notre gestion des flux consiste √† appeler <code>unwrap</code> pour arr√™ter
notre programme si le flux rencontre une erreur¬†; s'il n'y a pas d'erreurs, le
programme affiche un message. Nous ajouterons davantage de fonctionnalit√©s en
cas de succ√®s dans le prochain encart. La raison pour laquelle nous pourrions
recevoir des erreurs de la m√©thode <code>incoming</code> lorsqu'un client se connecte au
serveur est qu'en r√©alit√© nous n'it√©rons pas sur les connexions. En effet, nous
it√©rons sur des <em>tentatives de connexion</em>. La connexion peut √©chouer pour de
nombreuses raisons, beaucoup d'entre elles sont sp√©cifiques au syst√®me
d'exploitation. Par exemple, de nombreux syst√®mes d'exploitation ont une limite
sur le nombre de connexions ouvertes simultan√©ment qu'ils peuvent supporter¬†;
les tentatives de nouvelles connexions une fois ce nombre d√©pass√© produiront une
erreur jusqu'√† ce que certaines des connexions soient ferm√©es.</p>
<!--
Let‚Äôs try running this code! Invoke `cargo run` in the terminal and then load
*127.0.0.1:7878* in a web browser. The browser should show an error message
like ‚ÄúConnection reset,‚Äù because the server isn‚Äôt currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!
-->
<p>Essayons d'ex√©cuter ce code¬†! Saisissez <code>cargo run</code> dans le terminal et ensuite
ouvrez <em>127.0.0.1:7878</em> dans un navigateur web. Le navigateur devrait afficher
un message d'erreur tel que ‚ÄúLa connexion a √©t√© r√©initialis√©e‚Äù, car le serveur ne
renvoie pas de donn√©es pour le moment. Mais si vous regardez le terminal, vous
devriez voir quelques messages qui se sont affich√©s lorsque le navigateur s'est
connect√© au serveur¬†!</p>
<!--
```text
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```
-->
<pre><code class="language-text">     Running `target/debug/salutations`
Connexion √©tablie¬†!
Connexion √©tablie¬†!
Connexion √©tablie¬†!
</code></pre>
<!--
Sometimes, you‚Äôll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the *favicon.ico* icon that appears in the
browser tab.
-->
<p>Des fois, vous pourriez voir plusieurs messages s'afficher pour une seule
requ√™te du navigateur¬†; la raison √† cela est peut-√™tre que le navigateur fait
une requ√™te pour la page ainsi que des requ√™tes pour d'autres ressources, comme
l'icone <em>favicon.ico</em> qui s'affiche dans l'onglet du navigateur.</p>
<!--
It could also be that the browser is trying to connect to the server multiple
times because the server isn‚Äôt responding with any data. When `stream` goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the `drop` implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we‚Äôve successfully gotten a handle to a TCP connection!
-->
<p>Peut-√™tre que le navigateur essaie aussi de se connecter plusieurs fois au
serveur car le serveur ne renvoie aucune donn√©e dans sa r√©ponse. Lorsque <code>flux</code>
sort de la port√©e et est nettoy√© √† la fin de la boucle, la connexion est ferm√©e
car cela est impl√©ment√© dans le <code>drop</code>. Les navigateurs r√©agissent √† ces
connexions ferm√©es en r√©-essayant, car le probl√®me peut √™tre temporaire. La
partie importante est que nous avons obtenu avec succ√®s un manipulateur de
connexion TCP¬†!</p>
<!--
Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you‚Äôre done running a particular version of the code. Then restart `cargo
run` after you‚Äôve made each set of code changes to make sure you‚Äôre running the
newest code.
-->
<p>Pensez √† arr√™ter le programme en appuyant sur
<span class="keystroke">ctrl-c</span> lorsque vous avez fini d'ex√©cuter une
version donn√©e du code. Relancez ensuite <code>cargo run</code> apr√®s avoir appliqu√© une
s√©rie de modifications afin d'√™tre s√ªr que vous ex√©cutez bien la toute derni√®re
version du code.</p>
<!--
### Reading the Request
-->
<h3 id="lire-la-requ√™te"><a class="header" href="#lire-la-requ√™te">Lire la requ√™te</a></h3>
<!--
Let‚Äôs implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we‚Äôll start a new function for processing connections. In
this new `handle_connection` function, we‚Äôll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.
-->
<p>Commen√ßons √† impl√©menter la fonctionnalit√© permettant de lire la requ√™te du
navigateur ! Pour s√©parer les parties o√π nous obtenons une connexion de celle
o√π nous agissons avec la connexion, nous allons cr√©er une nouvelle fonction
pour traiter les connexions. Dans cette nouvelle fonction <code>gestion_connexion</code>,
nous allons lire des donn√©es provenant du flux TCP et les afficher afin que
nous puissions voir les donn√©es envoy√©es par le navigateur. Changez le code
pour qu'il ressemble √† l'encart 20-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        gestion_connexion(flux);
    }
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    println!(&quot;Requ√™te¬†: {}&quot;, String::from_utf8_lossy(&amp;tampon[..]));
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-2: Reading from the `TcpStream` and printing
the data</span>
-->
<p><span class="caption">Encart 20-2¬†: lecture du <code>TcpStream</code> et affichage des
donn√©es</span></p>
<!--
We bring `std::io::prelude` into scope to get access to certain traits that let
us read from and write to the stream. In the `for` loop in the `main` function,
instead of printing a message that says we made a connection, we now call the
new `handle_connection` function and pass the `stream` to it.
-->
<p>Nous avons import√© <code>std::io::prelude</code> dans la port√©e pour acc√©der √† certains
traits qui nous permettent de lire et d'√©crire dans le flux. Dans la boucle
<code>for</code> de la fonction <code>main</code>, au lieu d'afficher un message qui dit que nous
avons √©tabli une connexion, nous faisons maintenant appel √† <code>gestion_connexion</code>
et nous lui passons le <code>flux</code>.</p>
<!--
In the `handle_connection` function, we‚Äôve made the `stream` parameter mutable.
The reason is that the `TcpStream` instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be `mut` because its
internal state might change; usually, we think of ‚Äúreading‚Äù as not needing
mutation, but in this case we need the `mut` keyword.
-->
<p>Dans la fonction <code>gestion_connexion</code>, nous avons fait en sorte que le param√®tre
<code>flux</code> soit mutable. La raison √† cela est que l'instance de <code>TcpStream</code> garde
en m√©moire interne le suivi des donn√©es qu'il nous a retourn√©es. Il peut lire
plus de donn√©es que nous en avons demand√©es et les conserver pour la prochaine
fois que nous en redemanderons. Il doit donc √™tre <code>mut</code> car son √©tat interne
doit pouvoir changer¬†; d'habitude, nous n'avons pas besoin que la ‚Äúlecture‚Äù
n√©cessite d'√™tre mutable, mais dans ce cas nous avons besoin du mot-cl√© <code>mut</code>.</p>
<!--
Next, we need to actually read from the stream. We do this in two steps:
first, we declare a `buffer` on the stack to hold the data that is read in.
We‚Äôve made the buffer 1024 bytes in size, which is big enough to hold the
data of a basic request and sufficient for our purposes in this chapter. If
we wanted to handle requests of an arbitrary size, buffer management would
need to be more complicated; we‚Äôll keep it simple for now. We pass the buffer
to `stream.read`, which will read bytes from the `TcpStream` and put them in
the buffer.
-->
<p>Ensuite, nous devons lire les donn√©es du flux. Nous faisons cela en deux
temps¬†: d'abord, nous d√©clarons un <code>tampon</code> sur la pile pour y stocker les
donn√©es qui seront lues. Nous avons fait en sorte que le tampon fasse 1024
octets, ce qui est suffisamment grand pour stocker les donn√©es d'une requ√™te
basique, ce qui est suffisant pour nos besoins dans ce chapitre. Si nous
avions voulu g√©rer des requ√™tes de taille arbitraire, cette gestion du tampon
aurait √©t√© plus complexe ; nous allons la garder simpliste pour l'instant.
Nous envoyons le tampon dans <code>flux.read</code> qui va lire les octets provenant du
<code>TcpStream</code> et les ajouter dans le tampon.</p>
<!--
Second, we convert the bytes in the buffer to a string and print that string.
The `String::from_utf8_lossy` function takes a `&[u8]` and produces a `String`
from it. The ‚Äúlossy‚Äù part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with `ÔøΩ`, the `U+FFFD REPLACEMENT CHARACTER`. You might see replacement
characters for characters in the buffer that aren‚Äôt filled by request data.
-->
<p>Ensuite, nous convertissons les octets pr√©sents dans le tampon en cha√Ænes de
caract√®res et nous affichons cette cha√Æne de caract√®res. La fonction
<code>String::from_utf8_lossy</code> prend en param√®tre un <code>&amp;[u8]</code> et le transforme en une
<code>String</code>. La partie ‚Äúlossy‚Äù du nom indique le comportement de cette fonction
lorsqu'elle rencontre une s√©quence UTF-8 invalide¬†: elle va remplacer la
s√©quence invalide par <code>ÔøΩ</code>, le caract√®re <code>U+FFFD REPLACEMENT CHARACTER</code>. Vous
devriez voir ces caract√®res de remplacement √† la place des caract√®res du
tampon qui n'ont pas √©t√© renseign√©s par des donn√©es de requ√™te.</p>
<!--
Let‚Äôs try this code! Start the program and make a request in a web browser
again. Note that we‚Äôll still get an error page in the browser, but our
program‚Äôs output in the terminal will now look similar to this:
-->
<p>Essayons ce code¬†! D√©marrez le programme et faites √† nouveau une requ√™te dans
un navigateur web. Notez que nous obtenons toujours une page d'erreur dans le
navigateur web, mais que la sortie de notre programme dans le terminal devrait
ressembler √† ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/salutations`
Requ√™te¬†: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
</code></pre>
<!--
Depending on your browser, you might get slightly different output. Now that
we‚Äôre printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after `Request: GET`. If the
repeated connections are all requesting */*, we know the browser is trying to
fetch */* repeatedly because it‚Äôs not getting a response from our program.
-->
<p>En fonction de votre navigateur, vous pourriez voir une sortie l√©g√®rement
diff√©rente. Maintenant que nous affichons les donn√©es des requ√™tes, nous
pouvons constater pourquoi nous obtenons plusieurs
connexions pour un seul chargement de page dans le navigateur web en analysant
le chemin apr√®s le <code>Requ√™te¬†: GET</code>. Si les connexions r√©p√©t√©es sont toutes vers
<em>/</em>, nous pouvons constater que le navigateur essaye d'obtenir <em>/</em> √† r√©p√©tition
car il n'obtient pas de r√©ponse de la part de notre programme.</p>
<!--
Let‚Äôs break down this request data to understand what the browser is asking of
our program.
-->
<p>D√©composons les donn√©es de cette requ√™te pour comprendre ce que le navigateur
demande √† notre programme.</p>
<!--
### A Closer Look at an HTTP Request
-->
<h3 id="une-analyse-plus-pouss√©e-dune-requ√™te-http"><a class="header" href="#une-analyse-plus-pouss√©e-dune-requ√™te-http">Une analyse plus pouss√©e d'une requ√™te HTTP</a></h3>
<!--
HTTP is a text-based protocol, and a request takes this format:
-->
<p>HTTP est un protocole bas√© sur du texte, et une requ√™te doit suivre cette
forme¬†:</p>
<!--
```text
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">M√©thode URI-Demand√©e Version-HTTP CRLF
ent√™tes CRLF
corps-du-message
</code></pre>
<!--
The first line is the *request line* that holds information about what the
client is requesting. The first part of the request line indicates the *method*
being used, such as `GET` or `POST`, which describes how the client is making
this request. Our client used a `GET` request.
-->
<p>La premi√®re ligne est la <em>ligne de requ√™te</em> qui contient les informations sur
ce que demande le client. La premi√®re partie de la ligne de requ√™te indique la
<em>m√©thode</em> utilis√©e, comme <code>GET</code> ou <code>POST</code>, qui d√©crit comment le client fait sa
requ√™te. Notre client a utilis√© une requ√™te <code>GET</code>.</p>
<!--
The next part of the request line is */*, which indicates the *Uniform Resource
Identifier* *(URI)* the client is requesting: a URI is almost, but not quite,
the same as a *Uniform Resource Locator* *(URL)*. The difference between URIs
and URLs isn‚Äôt important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.
-->
<p>La partie suivante de la ligne de requ√™te est <em>/</em>, qui indique <em>l'URI</em>
<em>(Uniform Resource Identifier)</em> que demande le client¬†: une URI est presque,
mais pas compl√®tement, la m√™me chose qu'une <em>URL</em> <em>(Uniform Resource Locator)</em>.
La diff√©rence entre les URI et les URL n'est pas tr√®s importante pour nous
dans ce chapitre, mais la sp√©cification de HTTP utilise le terme URI,
donc, ici, nous pouvons simplement lire URL l√† o√π URI est √©crit.</p>
<!--
The last part is the HTTP version the client uses, and then the request line
ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,
which are terms from the typewriter days!) The CRLF sequence can also be
written as `\r\n`, where `\r` is a carriage return and `\n` is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than `\r\n`.
-->
<p>La derni√®re partie est la version HTTP que le client utilise, puis la
ligne de requ√™te termine avec une <em>s√©quence CRLF</em> (CRLF signifie
<em>Carriage Return, retour chariot</em>, et <em>Line Feed, saut de ligne</em> qui sont des
termes qui remontent √† l'√©poque des machines √† √©crire¬†!). La s√©quence CRLF peut
aussi √™tre √©crite <code>\r\n</code>, dans laquelle <code>\r</code> est un retour chariot et <code>\n</code> est
un saut de ligne. La s√©quence CRLF s√©pare la ligne de requ√™te du reste des
donn√©es de la requ√™te. Notez toutefois que lorsqu'un CRLF est affich√©, nous
voyons une nouvelle ligne plut√¥t qu'un <code>\r\n</code>.</p>
<!--
Looking at the request line data we received from running our program so far,
we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the
version.
-->
<p>D'apr√®s la ligne de requ√™te que nous avons re√ßue apr√®s avoir ex√©cut√© notre
programme pr√©c√©demment, nous constatons que la m√©thode est <code>GET</code>, <em>/</em> est l'URI
demand√©e et <code>HTTP/1.1</code> est la version.</p>
<!--
After the request line, the remaining lines starting from `Host:` onward are
headers. `GET` requests have no body.
-->
<p>Apr√®s la ligne de requ√™te, les lignes suivant celle o√π nous avons <code>Host:</code> sont
des ent√™tes. Les requ√™tes <code>GET</code> n'ont pas de corps.</p>
<!--
Try making a request from a different browser or asking for a different
address, such as *127.0.0.1:7878/test*, to see how the request data changes.
-->
<p>Essayez de faire une requ√™te dans un navigateur diff√©rent ou de demander une
adresse diff√©rente, telle que <em>127.0.0.1:7878/test</em>, afin d'observer comment les
donn√©es de requ√™te changent.</p>
<!--
Now that we know what the browser is asking for, let‚Äôs send back some data!
-->
<p>Maintenant que nous savons ce que demande le navigateur, envoyons-lui quelques
donn√©es¬†!</p>
<!--
### Writing a Response
-->
<h3 id="ecrire-une-r√©ponse"><a class="header" href="#ecrire-une-r√©ponse">Ecrire une r√©ponse</a></h3>
<!--
Now we‚Äôll implement sending data in response to a client request. Responses
have the following format:
-->
<p>Maintenant, nous allons impl√©menter l'envoi d'une r√©ponse √† une requ√™te client. Les
r√©ponses suivent le format suivant¬†:</p>
<!--
```text
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">Version-HTTP Code-Statut Phrase-De-Raison CRLF
ent√™tes CRLF
corps-message
</code></pre>
<!--
The first line is a *status line* that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.
-->
<p>La premi√®re ligne est une <em>ligne de statut</em> qui contient la version HTTP
utilis√©e dans la r√©ponse, un code num√©rique de statut qui r√©sume le r√©sultat
de la requ√™te et une phrase de raison qui fournit une description textuelle du
code de statut. Apr√®s la s√©quence CRLF viennent tous les ent√™tes, une autre
s√©quence CRLF et enfin le corps de la r√©ponse.</p>
<!--
Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:
-->
<p>Voici un exemple de r√©ponse qui utilise HTTP version 1.1, a un code de
statut de 200, une phrase de raison √† OK, pas d'ent√™tes, et pas de corps¬†:</p>
<!--
```text
HTTP/1.1 200 OK\r\n\r\n
```
-->
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<!--
The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let‚Äôs write this to the stream as our response to a
successful request! From the `handle_connection` function, remove the
`println!` that was printing the request data and replace it with the code in
Listing 20-3.
-->
<p>Le code de statut 200 est la r√©ponse standard de succ√®s. Le texte est une toute
petite r√©ponse HTTP de succ√®s. Ecrivons ceci dans le flux de notre r√©ponse √†
une requ√™te avec succ√®s¬†! Dans la fonction <code>gestion_connexion</code>, enlevez le
<code>println!</code> qui affiche les donn√©es de requ√™te et remplacez-le par le code de
l'encart 20-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    let reponse = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span>
-->
<p><span class="caption">Encart 20-3¬†: √©criture d'une toute petite r√©ponse HTTP de
r√©ussite dans le flux</span></p>
<!--
The first new line defines the `response` variable that holds the success
message‚Äôs data. Then we call `as_bytes` on our `response` to convert the string
data to bytes. The `write` method on `stream` takes a `&[u8]` and sends those
bytes directly down the connection.
-->
<p>La premi√®re ligne d√©finit la variable <code>reponse</code> qui contient les donn√©es du
message de r√©ussite. Ensuite, nous faisons appel √† <code>as_bytes</code> sur notre
<code>reponse</code> pour convertir la cha√Æne de caract√®res en octets. La m√©thode <code>write</code>
sur le <code>flux</code> prend en argument un <code>&amp;[u8]</code> et envoie ces octets directement
dans la connexion.</p>
<!--
Because the `write` operation could fail, we use `unwrap` on any error result
as before. Again, in a real application you would add error handling here.
Finally, `flush` will wait and prevent the program from continuing until all
the bytes are written to the connection; `TcpStream` contains an internal
buffer to minimize calls to the underlying operating system.
-->
<p>Comme l'op√©ration <code>write</code> peut √©chouer, nous utilisons <code>unwrap</code> sur toutes les
erreurs, comme pr√©c√©demment. Encore une fois, dans un v√©ritable application,
vous devriez g√©rer les cas d'erreur ici. Enfin, <code>flush</code> va attendre et emp√™cher
le programme de continuer √† s'ex√©cuter jusqu'√† ce que tous les octets soient
√©crits dans la connexion¬†; <code>TcpStream</code> contient un tampon interne pour r√©duire
les appels au syst√®me d'exploitation concern√©.</p>
<!--
With these changes, let‚Äôs run our code and make a request. We‚Äôre no longer
printing any data to the terminal, so we won‚Äôt see any output other than the
output from Cargo. When you load *127.0.0.1:7878* in a web browser, you should
get a blank page instead of an error. You‚Äôve just hand-coded an HTTP request
and response!
-->
<p>Avec ces modifications, ex√©cutons √† nouveau notre code et lan√ßons une requ√™te
dans le navigateur. Nous n'affichons plus les donn√©es dans le terminal, donc
nous ne voyons plus aucune sortie autre que celle de Cargo. Lorsque vous
chargez <em>127.0.0.1:7878</em> dans un navigateur web, vous devriez obtenir une page
blanche plut√¥t qu'une erreur. Vous venez de coder en dur une r√©ponse √† une
requ√™te HTTP¬†!</p>
<!--
### Returning Real HTML
-->
<h3 id="retourner-du-vrai-html"><a class="header" href="#retourner-du-vrai-html">Retourner du vrai HTML</a></h3>
<!--
Let‚Äôs implement the functionality for returning more than a blank page. Create
a new file, *hello.html*, in the root of your project directory, not in the
*src* directory. You can input any HTML you want; Listing 20-4 shows one
possibility.
-->
<p>Impl√©mentons la fonctionnalit√© permettant de retourner plus qu'une simple page
blanche. Cr√©ez un nouveau fichier, <em>hello.html</em>, √† la racine de votre dossier
de projet, et pas dans le dossier <em>src</em>. Vous pouvez ajouter le HTML que vous
souhaitez¬†; l'encart 20-4 vous montre une possibilit√©.</p>
<!--
<span class="filename">Filename: hello.html</span>
-->
<p><span class="filename">Fichier¬†: hello.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1 id="hello"><a class="header" href="#hello">Hello!</a></h1>
    <p>Hi from Rust</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Salutations¬†!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Salut¬†!&lt;/h1&gt;
    &lt;p&gt;Bonjour de la part de Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-4: A sample HTML file to return in a
response</span>
-->
<p><span class="caption">Encart 20-4¬†: un exemple de fichier HTML √† retourner dans
une r√©ponse</span></p>
<!--
This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we‚Äôll modify `handle_connection` as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.
-->
<p>Ceci est un document HTML5 minimal avec des ent√™tes et un peu de texte. Pour
retourner ceci √† partir d'un serveur lorsqu'une requ√™te est re√ßue, nous allons
modifier <code>gestion_connexion</code> comme propos√© dans l'encart 20-5 pour lire le
fichier HTML, l'ajouter dans la r√©ponse comme faisant partie de son corps, et
l'envoyer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
use std::fs;
// --snip--

# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let contents = fs::read_to_string("hello.html").unwrap();

    let response = format!(
        "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// -- partie masqu√©e ici --

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let reponse = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-5: Sending the contents of *hello.html* as the
body of the response</span>
-->
<p><span class="caption">Encart 20-5¬†: envoi du contenu de <em>hello.html</em> dans
le corps de la r√©ponse</span></p>
<!--
We‚Äôve added a line at the top to bring the standard library‚Äôs filesystem module
into scope. The code for reading the contents of a file to a string should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.
-->
<p>Nous avons ajout√© une ligne en haut pour importer le module de syst√®me de
fichiers de la biblioth√®que standard. Le code pour lire le contenu d'un fichier
dans une <code>String</code> devrait vous √™tre familier¬†; nous l'avons utilis√© dans le
chapitre 12 lorsque nous lisions le contenu d'un fichier pour notre projet
d'entr√©e/sortie, dans l'encart 12-4.</p>
<!--
Next, we use `format!` to add the file‚Äôs contents as the body of the success
response. To ensure a valid HTTP response, we add the `Content-Length` header
which is set to the size of our response body, in this case the size of `hello.html`.
-->
<p>Ensuite, nous avons utilis√© <code>format!</code> pour ajouter le contenu du fichier comme
√©tant le corps de la r√©ponse avec succ√®s. Pour garantir que ce soit une r√©ponse
HTTP valide, nous avons ajout√© l'ent√™te <code>Content-Length</code> qui d√©finit la taille
du corps de notre r√©ponse, qui dans ce cas est la taille de <code>hello.html</code>.</p>
<!--
Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; you
should see your HTML rendered!
-->
<p>Ex√©cutez ce code avec <code>cargo run</code> et ouvrez <em>127.0.0.1:7878</em> dans votre
navigateur web¬†; vous devriez voir le r√©sultat de votre HTML¬†!</p>
<!--
Currently, we‚Äôre ignoring the request data in `buffer` and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
*127.0.0.1:7878/something-else* in your browser, you‚Äôll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to */*.
-->
<p>Pour le moment, nous ignorons les donn√©es de la requ√™te pr√©sentes dans
<code>tampon</code> et nous renvoyons sans conditions le contenu du fichier HTML. Cela
signifie que si vous essayez de demander <em>127.0.0.1:7878/autre-chose</em> dans
votre navigateur web, vous obtiendrez la m√™me r√©ponse HTML. Notre serveur est
tr√®s limit√©, et ne correspond pas √† ce que font la plupart des serveurs web.
Nous souhaitons d√©sormais personnaliser nos r√©ponses en fonction de la requ√™te
et ne renvoyer le fichier HTML que pour une requ√™te bien format√©e faite √† <em>/</em>.</p>
<!--
### Validating the Request and Selectively Responding
-->
<h3 id="valider-la-requ√™te-et-r√©pondre-de-mani√®re-s√©lective"><a class="header" href="#valider-la-requ√™te-et-r√©pondre-de-mani√®re-s√©lective">Valider la requ√™te et r√©pondre de mani√®re s√©lective</a></h3>
<!--
Right now, our web server will return the HTML in the file no matter what the
client requested. Let‚Äôs add functionality to check that the browser is
requesting */* before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify `handle_connection`,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for */* looks like and adds `if` and
`else` blocks to treat requests differently.
-->
<p>Jusqu'√† pr√©sent, notre serveur web retourne le HTML du fichier peu
importe ce que demande le client. Ajoutons une fonctionnalit√© pour v√©rifier que
le navigateur demande bien <em>/</em> avant de retourner le fichier HTML et retournons
une erreur si le navigateur demande autre chose. Pour cela, nous devons
modifier <code>gestion_connexion</code> comme dans l'encart 20-6. Ce nouveau code compare le
contenu de la requ√™te que nous recevons √† la requ√™te que nous attendrions pour
<em>/</em> et ajoute des blocs <code>if</code> et <code>else</code> pour traiter les requ√™tes de mani√®re diff√©renci√©e.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";

    if buffer.starts_with(get) {
        let contents = fs::read_to_string("hello.html").unwrap();

        let response = format!(
            "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici --

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if tampon.starts_with(get) {
        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let reponse = format!(
            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
            contenu.len(),
            contenu
        );

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    } else {
        // autres requ√™tes
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-6: Matching the request and handling requests
to */* differently from other requests</span>
-->
<p><span class="caption">Encart 20-6¬†: d√©tection et gestion des requ√™tes vers <em>/</em>
de mani√®re diff√©renci√©e des autres requ√™tes</span></p>
<!--
First, we hardcode the data corresponding to the */* request into the `get`
variable. Because we‚Äôre reading raw bytes into the buffer, we transform `get`
into a byte string by adding the `b""` byte string syntax at the start of the
content data. Then we check whether `buffer` starts with the bytes in `get`. If
it does, it means we‚Äôve received a well-formed request to */*, which is the
success case we‚Äôll handle in the `if` block that returns the contents of our
HTML file.
-->
<p>D'abord, nous codons en dur les donn√©es correspondant √† la requ√™te <em>/</em> dans la
variable <code>get</code>. Comme nous lisons des octets bruts provenant du tampon, nous
transformons <code>get</code> en une cha√Æne d'octets en ajoutant la syntaxe de cha√Æne
d'octets <code>b&quot;&quot;</code> au d√©but des donn√©es du contenu. Ensuite, nous v√©rifions que le
<code>tampon</code> commence par les m√™mes octets que ceux pr√©sents dans <code>get</code>. Si c'est
le cas, cela signifie que nous avons re√ßu une requ√™te vers <em>/</em> correctement
format√©e, qui est le cas de succ√®s que nous allons g√©rer dans le bloc <code>if</code> qui
retourne le contenu de notre fichier HTML.</p>
<!--
If `buffer` does *not* start with the bytes in `get`, it means we‚Äôve received
some other request. We‚Äôll add code to the `else` block in a moment to respond
to all other requests.
-->
<p>Si <code>tampon</code> ne <em>commence pas</em> avec les octets pr√©sents dans <code>get</code>, cela
signifie que nous avons re√ßu une autre requ√™te. Nous allons bient√¥t ajouter du
code au bloc <code>else</code> pour r√©pondre √† toutes ces autres requ√™tes.</p>
<!--
Run this code now and request *127.0.0.1:7878*; you should get the HTML in
*hello.html*. If you make any other request, such as
*127.0.0.1:7878/something-else*, you‚Äôll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.
-->
<p>Ex√©cutez ce code maintenant et demandez <em>127.0.0.1:7878</em>¬†; vous devriez obtenir
le HTML de <em>hello.html</em>. Si vous faites n'importe quelle autre requ√™te,
comme <em>127.0.0.1:7878/autre-chose</em>, vous allez obtenir une erreur de connexion
comme celle que vous avez vue lorsque vous ex√©cutiez le code l'encart 20-1 et de
l'encart 20-2.</p>
<!--
Now let‚Äôs add the code in Listing 20-7 to the `else` block to return a response
with the status code 404, which signals that the content for the request was
not found. We‚Äôll also return some HTML for a page to render in the browser
indicating the response to the end user.
-->
<p>Maintenant ajoutons le code de l'encart 20-7 au bloc <code>else</code> pour retourner une
r√©ponse avec le code de statut 404, qui signale que le contenu demand√© par
cette requ√™te n'a pas √©t√© trouv√©. Nous allons aussi retourner du HTML pour qu'une
page s'affiche dans le navigateur, indiquant la r√©ponse √† l'utilisateur final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
#     if buffer.starts_with(get) {
#         let contents = fs::read_to_string("hello.html").unwrap();
# 
#         let response = format!(
#             "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
#             contents.len(),
#             contents
#         );
# 
#         stream.write(response.as_bytes()).unwrap();
#         stream.flush().unwrap();
    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();

        let response = format!(
            "{}\r\nContent-Length: {}\r\n\r\n{}",
            status_line,
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    if tampon.starts_with(get) {
</span><span class="boring">        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">        let reponse = format!(
</span><span class="boring">            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">            contenu.len(),
</span><span class="boring">            contenu
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">        flux.flush().unwrap();
</span>    // -- partie masqu√©e ici --
    } else {
        let ligne_statut = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contenu = fs::read_to_string(&quot;404.html&quot;).unwrap();

        let reponse = format!(
            &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
            ligne_statut,
            contenu.len(),
            contenu
        );

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than */* was requested</span>
-->
<p><span class="caption">Encart 20-7¬†: r√©pondre un code de statut 404 et une page
d'erreur lorsqu'autre chose que <em>/</em> a √©t√© demand√©</span></p>
<!--
Here, our response has a status line with status code 404 and the reason
phrase `NOT FOUND`. The body of the response will be the HTML in the file
*404.html*. You‚Äôll need to create a *404.html* file next to *hello.html* for
the error page; again feel free to use any HTML you want or use the example
HTML in Listing 20-8.
-->
<p>Ici notre r√©ponse poss√®de une ligne de statut avec le code de statut 404 et la
phrase de raison <code>NOT FOUND</code>. Le corps de la r√©ponse sera le HTML pr√©sent dans
le fichier <em>404.html</em>. Nous aurons besoin de cr√©er un fichier <code>404.html</code> au
m√™me endroit que <em>hello.html</em> pour la page d'erreur; de nouveau, n'h√©sitez pas
√† utiliser le HTML que vous souhaitez ou, √† d√©faut, utilisez le HTML d'exemple
pr√©sent dans l'encart 20-8.</p>
<!--
<span class="filename">Filename: 404.html</span>
-->
<p><span class="filename">Fichier¬†: 404.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1 id="oops"><a class="header" href="#oops">Oops!</a></h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Salutations¬†!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oups¬†!&lt;/h1&gt;
    &lt;p&gt;D√©sol√©, je ne conna√Æt pas ce que vous demandez.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span>
-->
<p><span class="caption">Encart 20-8¬†: contenu d'exemple pour la page √† renvoyer
avec les r√©ponses 404</span></p>
<!--
With these changes, run your server again. Requesting *127.0.0.1:7878*
should return the contents of *hello.html*, and any other request, like
*127.0.0.1:7878/foo*, should return the error HTML from *404.html*.
-->
<p>Une fois ces modifications appliqu√©es, ex√©cutez √† nouveau votre serveur. Les
requ√™tes vers <em>127.0.0.1:7878</em> devraient retourner le contenu de
<em>hello.html</em> et toutes les autres requ√™tes, telle que
<em>127.0.0.1:7878/autre-chose</em>, devraient retourner le HTML d'erreur pr√©sent dans
<em>404.html</em>.</p>
<!--
### A Touch of Refactoring
-->
<h3 id="un-peu-de-remaniement"><a class="header" href="#un-peu-de-remaniement">Un peu de remaniement</a></h3>
<!--
At the moment the `if` and `else` blocks have a lot of repetition: they‚Äôre both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let‚Äôs make the code more
concise by pulling out those differences into separate `if` and `else` lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large `if` and `else` blocks.
-->
<p>Pour l'instant, les blocs <code>if</code> et <code>else</code> contiennent beaucoup de code r√©p√©t√©¬†:
ils lisent tous les deux des fichiers et √©crivent le contenu de ces fichiers
dans le flux. La seule diff√©rence entre eux sont la ligne de statut et le nom
du fichier. Rendons le code plus concis en isolant ces diff√©rences dans des
lignes <code>if</code> et <code>else</code> qui vont assigner les valeurs de la ligne de statut et du
nom de fichier √† des variables¬†; nous pourrons ensuite utiliser ces variables
sans avoir √† nous pr√©occuper du contexte dans le code qui va lire le fichier et
√©crire la r√©ponse. L'encart 20-9 montre le code r√©sultant apr√®s remplacement des
gros blocs <code>if</code> et <code>else</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici--

fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masqu√©e ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span>    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        ligne_statut,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-9: Refactoring the `if` and `else` blocks to
contain only the code that differs between the two cases</span>
-->
<p><span class="caption">Encart 20-9¬†: remaniement des blocs <code>if</code> et <code>else</code> pour
qu'ils contiennent uniquement le code qui diff√©rencie les deux cas</span></p>
<!--
Now the `if` and `else` blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to `status_line` and `filename` using a pattern in the `let`
statement, as discussed in Chapter 18.
-->
<p>Maintenant que les blocs <code>if</code> et <code>else</code> retournent uniquement les valeurs
correctes pour la ligne de statut et le nom du fichier dans un tuple, nous
pouvons utiliser la d√©structuration pour assigner ces deux valeurs √†
<code>ligne_statut</code> et <code>nom_fichier</code> en utilisant un motif dans l'instruction <code>let</code>,
comme nous l'avons vu dans le chapitre 18.</p>
<!--
The previously duplicated code is now outside the `if` and `else` blocks and
uses the `status_line` and `filename` variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.
-->
<p>Le code pr√©c√©dent qui √©tait en double se trouve maintenant √† l'ext√©rieur des
blocs <code>if</code> et <code>else</code> et utilise les variables <code>ligne_statut</code> et <code>nom_fichier</code>.
Cela permet de mettre en √©vidence plus facilement les diff√©rences entre les
deux cas, et cela signifie que nous n'avons qu'un seul endroit du code √†
modifier si nous souhaitons changer le fonctionnement de lecture du fichier et
d'√©criture de la r√©ponse. Le comportement du code de l'encart 20-9 devrait √™tre
identique √† celui de l'encart 20-8.</p>
<!--
Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.
-->
<p>Super¬†! Nous avons maintenant un serveur web simple qui tient dans environ 40
lignes de code, qui r√©pond √† une requ√™te pr√©cise par une page de contenu et
r√©pond √† toutes les autres avec une r√©ponse 404.</p>
<!--
Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let‚Äôs examine how that can be a problem by simulating some
slow requests. Then we‚Äôll fix it so our server can handle multiple requests at
once.
-->
<p>Actuellement, notre serveur fonctionne dans une seule t√¢che, ce qui signifie
qu'il ne peut r√©pondre qu'√† une seule requ√™te √† la fois. Examinons maintenant
√† quel point cela peut √™tre un probl√®me en simulant des r√©ponses lentes √† des
requ√™tes. Ensuite, nous corrigerons notre serveur pour qu'il puisse g√©rer
plusieurs requ√™tes √† la fois.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Turning Our Single-Threaded Server into a Multithreaded Server
-->
<h2 id="transformer-notre-serveur-monot√¢che-en-serveur-multit√¢ches"><a class="header" href="#transformer-notre-serveur-monot√¢che-en-serveur-multit√¢ches">Transformer notre serveur monot√¢che en serveur multit√¢ches</a></h2>
<!--
Right now, the server will process each request in turn, meaning it won‚Äôt
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We‚Äôll need to fix
this, but first, we‚Äôll look at the problem in action.
-->
<p>Pour le moment, le serveur va traiter chaque requ√™te l'une apr√®s l'autre, ce qui
signifie qu'il ne traitera pas une deuxi√®me connexion tant que la premi√®re
n'a pas fini d'√™tre trait√©e. Si le serveur re√ßoit encore plus de requ√™tes,
cette ex√©cution en s√©rie sera de moins en moins adapt√©e. Si le serveur
re√ßoit une requ√™te qui prend longtemps √† traiter, les demandes suivantes
devront attendre que la longue requ√™te √† traiter soit termin√©e, m√™me si les
nouvelles requ√™tes peuvent √™tre trait√©es rapidement. Nous devons corriger cela,
mais d'abord, observons le probl√®me se produire pour de vrai.</p>
<!--
### Simulating a Slow Request in the Current Server Implementation
-->
<h3 id="simuler-une-longue-requ√™te-√†-traiter-avec-limpl√©mentation-actuelle-du-serveur"><a class="header" href="#simuler-une-longue-requ√™te-√†-traiter-avec-limpl√©mentation-actuelle-du-serveur">Simuler une longue requ√™te √† traiter avec l'impl√©mentation actuelle du serveur</a></h3>
<!--
We‚Äôll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to */sleep* with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.
-->
<p>Nous allons voir comment une requ√™te longue √† traiter peut affecter le
traitement des autres requ√™tes avec l'impl√©mentation actuelle de notre serveur.
L'encart 20-10 rajoute le traitement d'une requ√™te pour <em>/pause</em> qui va simuler
une longue r√©ponse qui va faire en sorte que le serveur soit en pause pendant 5
secondes avant de pouvoir r√©pondre √† nouveau.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
use std::thread;
use std::time::Duration;
// --snip--
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    // --snip--
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!(
#         "{}\r\nContent-Length: {}\r\n\r\n{}",
#         status_line,
#         contents.len(),
#         contents
#     );
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span>use std::thread;
use std::time::Duration;
// -- partie masqu√©e ici--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masqu√©e ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span>    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;

    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if tampon.starts_with(pause) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    // -- partie masqu√©e ici--
<span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        ligne_statut,
</span><span class="boring">        contenu.len(),
</span><span class="boring">        contenu
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 20-10: Simulating a slow request by recognizing
*/sleep* and sleeping for 5 seconds</span>
-->
<p><span class="caption">Encart 20-10 : simulation d'une requ√™te provoquant un
long traitement en d√©tectant <em>/pause</em> et en faisant une pause de 5
secondes</span></p>
<!--
This code is a bit messy, but it‚Äôs good enough for simulation purposes. We
created a second request `sleep`, whose data our server recognizes. We added an
`else if` after the `if` block to check for the request to */sleep*. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.
-->
<p>Ce code est peu brouillon, mais est suffisant pour nos besoins de simulation.
Nous avons cr√©√© une deuxi√®me possibilit√© de requ√™te <code>pause</code> avec des donn√©es que
notre serveur peut reconna√Ætre. Nous avons ajout√© un <code>else if</code> apr√®s le bloc <code>if</code>
pour tester les requ√™tes destin√©es √† <em>/pause</em>. Lorsque cette requ√™te est re√ßue, le
serveur va se mettre en pause pendant 5 secondes avant de g√©n√©rer la page HTML
de succ√®s.</p>
<!--
You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!
-->
<p>Vous pouvez constater √† quel point notre serveur est primitif¬†: une
biblioth√®que digne de ce nom devrait g√©rer la d√©tection de diff√©rents types de
requ√™tes de mani√®re bien moins verbeuse¬†!</p>
<!--
Start the server using `cargo run`. Then open two browser windows: one for
*http://127.0.0.1:7878/* and the other for *http://127.0.0.1:7878/sleep*. If
you enter the */* URI a few times, as before, you‚Äôll see it respond quickly.
But if you enter */sleep* and then load */*, you‚Äôll see that */* waits until
`sleep` has slept for its full 5 seconds before loading.
-->
<p>D√©marrez le serveur en utilisant <code>cargo run</code>. Ouvrez ensuite deux fen√™tres de
navigateur web¬†: une pour <em>http://127.0.0.1:7878/</em> et l'autre pour
<em>http://127.0.0.1:7878/pause</em>. Si vous demandez l'URI <em>/</em> plusieurs fois, comme
vous l'avez fait pr√©c√©demment, vous constaterez que le serveur r√©pond
rapidement. Mais lorsque vous saisirez <em>/pause</em> et que vous chargerez ensuite
<em>/</em>, vous constaterez que <em>/</em> attend que <code>pause</code> ait fini sa pause de 5
secondes avant de se charger.</p>
<!--
There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we‚Äôll implement is
a thread pool.
-->
<p>Il y a plusieurs mani√®res de changer le fonctionnement de notre serveur web
pour √©viter d'accumuler des requ√™tes apr√®s une requ√™te dont le traitement est
long¬†; celle que nous allons impl√©menter est un groupe de t√¢ches.</p>
<!--
### Improving Throughput with a Thread Pool
-->
<h3 id="am√©liorer-le-d√©bit-avec-un-groupe-de-t√¢ches"><a class="header" href="#am√©liorer-le-d√©bit-avec-un-groupe-de-t√¢ches">Am√©liorer le d√©bit avec un groupe de t√¢ches</a></h3>
<!--
A *thread pool* is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it‚Äôs returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.
-->
<p>Un <em>groupe de t√¢ches</em> est un groupe constitu√© de t√¢ches qui ont √©t√© cr√©√©es et
qui attendent des missions. Lorsque le programme re√ßoit une nouvelle mission,
il assigne une des t√¢ches du groupe pour cette mission, et cette t√¢che va
traiter la mission. Les t√¢ches restantes dans le groupe restent disponibles
pour traiter d'autres missions qui peuvent arriver pendant que la premi√®re
t√¢che est en cours de traitement. Lorsque la premi√®re t√¢che en a fini avec sa
mission, elle retourne dans le groupe de t√¢ches inactives, pr√™te √† g√©rer une
nouvelle t√¢che. Un groupe de t√¢ches vous permet de traiter plusieurs connexions
en simultan√©, ce qui augmente le d√©bit de votre serveur.</p>
<!--
We‚Äôll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server‚Äôs resources and grinding
the processing of requests to a halt.
-->
<p>Nous allons limiter le nombre de t√¢ches dans le groupe √† un petit nombre pour
nous prot√©ger d'attaques par d√©ni de service (Denial of Service, DoS)¬†; si
notre programme cr√©ait une nouvelle t√¢che √† chaque requ√™te qu'il re√ßoit,
quelqu'un qui ferait 10 millions de requ√™tes √† notre serveur pourrait faire des
ravages en utilisant toutes les ressources de notre serveur et bloquer ainsi le
traitement de toute nouvelle requ√™te.</p>
<!--
Rather than spawning unlimited threads, we‚Äôll have a fixed number of threads
waiting in the pool. As requests come in, they‚Äôll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
`N` requests concurrently, where `N` is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we‚Äôve increased the number of long-running requests we can
handle before reaching that point.
-->
<p>Plut√¥t que de g√©n√©rer des t√¢ches en quantit√© illimit√©e, nous allons faire en
sorte qu'il y ait un nombre fixe de t√¢ches qui seront en attente dans le
groupe. Lorsqu'une requ√™te arrive, une t√¢che sera choisie dans le groupe pour
proc√©der au traitement. Le groupe g√®rera une file d'attente pour les requ√™tes
entrantes. Chaque t√¢che dans le groupe va r√©cup√©rer une requ√™te dans cette
liste d'attente, la traiter puis demander une autre requ√™te
√† la file d'attente. Avec ce fonctionnement, nous pouvons traiter <code>N</code> requ√™tes
en concurrence, o√π <code>N</code> est le nombre de t√¢ches. Si toutes les t√¢ches r√©pondent
chacune √† une requ√™te longue √† traiter, les requ√™tes suivantes vont se stocker
dans la file d'attente, mais nous aurons quand m√™me augment√© le nombre de requ√™tes
longues que nous pouvons traiter avant d'en arriver l√†.</p>
<!--
This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you‚Äôre interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.
-->
<p>Cette technique n'est qu'une des nombreuses mani√®res d'am√©liorer le d√©bit d'un
serveur web. D'autres options que vous devriez envisager sont le mod√®le
fork/join et le mod√®le d'entr√©e-sortie asynchrone monot√¢che. Si vous √™tes
int√©ress√©s par ce sujet, vous pouvez aussi en apprendre plus sur ces autres
solutions et essayer de les impl√©menter en Rust¬†; avec un langage bas niveau
comme Rust, toutes les options restent possibles.</p>
<!--
Before we begin implementing a thread pool, let‚Äôs talk about what using the
pool should look like. When you‚Äôre trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it‚Äôs
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.
-->
<p>Avant que nous ne commencions l'impl√©mentation du groupe de t√¢ches, parlons de
l'utilisation du groupe. Lorsque vous essayez de concevoir du code, commencer
par √©crire l'interface client peut vous aider √† vous guider dans la conception.
Ecrivez l'API du code afin qu'il soit structur√© de la mani√®re dont vous
souhaitez l'appeler¬†; puis impl√©mentez ensuite la fonctionnalit√© au sein de
cette structure, plut√¥t que d'impl√©menter la fonctionnalit√© puis de concevoir
l'API publique.</p>
<!--
Similar to how we used test-driven development in the project in Chapter 12,
we‚Äôll use compiler-driven development here. We‚Äôll write the code that calls the
functions we want, and then we‚Äôll look at errors from the compiler to determine
what we should change next to get the code to work.
-->
<p>De la m√™me mani√®re que nous avons utilis√© le d√©veloppement pilot√© par les tests
dans le projet du chapitre 12, nous allons utiliser ici le d√©veloppement
orient√© par le compilateur. Nous allons √©crire le code qui appelle les
fonctions que nous souhaitons, et ensuite nous analyserons les erreurs du
compilateur pour d√©terminer ce qu'il faut ensuite corriger pour que le code
fonctionne.</p>
<!--
#### Code Structure If We Could Spawn a Thread for Each Request
-->
<h4 id="la-structure-du-code-si-nous-pouvions-cr√©er-une-t√¢che-pour-chaque-requ√™te"><a class="header" href="#la-structure-du-code-si-nous-pouvions-cr√©er-une-t√¢che-pour-chaque-requ√™te">La structure du code si nous pouvions cr√©er une t√¢che pour chaque requ√™te</a></h4>
<!--
First, let‚Äôs explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn‚Äôt our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to `main` to spawn a
new thread to handle each stream within the `for` loop.
-->
<p>Pour commencer, voyons √† quoi ressemblerait notre code s'il cr√©ait une nouvelle
t√¢che pour chaque connexion. Comme nous l'avons √©voqu√© pr√©c√©demment, cela ne
sera pas notre solution finale √† cause des probl√®mes li√©s √† la cr√©ation
potentielle d'un nombre illimit√© de t√¢ches, mais c'est un d√©but. L'encart 20-11
montre les changements √† apporter au <code>main</code> pour cr√©er une nouvelle t√¢che pour
g√©rer chaque flux avec une boucle <code>for</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!(
#         "{}\r\nContent-Length: {}\r\n\r\n{}",
#         status_line,
#         contents.len(),
#         contents
#     );
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        thread::spawn(|| {
            gestion_connexion(flux);
        });
    }
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        ligne_statut,
</span><span class="boring">        contenu.len(),
</span><span class="boring">        contenu
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-11: Spawning a new thread for each
stream</span>
-->
<p><span class="caption">Encart 20-11¬†: cr√©ation d'une nouvelle t√¢che pour chaque
flux</span></p>
<!--
As you learned in Chapter 16, `thread::spawn` will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
*/sleep* in your browser, then */* in two more browser tabs, you‚Äôll indeed see
that the requests to */* don‚Äôt have to wait for */sleep* to finish. But as we
mentioned, this will eventually overwhelm the system because you‚Äôd be making
new threads without any limit.
-->
<p>Comme vous l'avez appris au chapitre 16, <code>thread::spawn</code> va cr√©er une nouvelle
t√¢che puis ex√©cuter dans cette nouvelle t√¢che le code pr√©sent dans la
fermeture. Si vous ex√©cutez ce code et chargez <em>/pause</em> dans votre navigateur,
et que vous ouvrez <em>/</em> dans deux nouveaux onglets, vous constaterez en effet
que les requ√™tes vers <em>/</em> n'aurons pas √† attendre que <em>/pause</em> se finisse. Mais
comme nous l'avons mentionn√©, cela peut potentiellement surcharger le syst√®me
si vous cr√©ez des nouvelles t√¢ches sans aucune limite.</p>
<!--
#### Creating a Similar Interface for a Finite Number of Threads
-->
<h4 id="cr√©er-une-interface-similaire-pour-un-nombre-fini-de-t√¢ches"><a class="header" href="#cr√©er-une-interface-similaire-pour-un-nombre-fini-de-t√¢ches">Cr√©er une interface similaire pour un nombre fini de t√¢ches</a></h4>
<!--
We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn‚Äôt require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a `ThreadPool`
struct we want to use instead of `thread::spawn`.
-->
<p>Nous souhaitons faire en sorte que notre groupe de t√¢ches fonctionne de la m√™me
mani√®re, donc passer des t√¢ches √† un groupe de t√¢ches ne devrait pas
n√©cessiter de gros changements au code qui utilise notre API. L'encart 20-12
montre une interface possible pour une structure <code>GroupeTaches</code> que nous
souhaitons utiliser √† la place de <code>thread::spawn</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!(
#         "{}\r\nContent-Length: {}\r\n\r\n{}",
#         status_line,
#         contents.len(),
#         contents
#     );
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        ligne_statut,
</span><span class="boring">        contenu.len(),
</span><span class="boring">        contenu
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-12: Our ideal `ThreadPool` interface</span>
-->
<p><span class="caption">Encart 20-12¬†: Notre interface id√©ale <code>GroupeTaches</code>
</span></p>
<!--
We use `ThreadPool::new` to create a new thread pool with a configurable number
of threads, in this case four. Then, in the `for` loop, `pool.execute` has a
similar interface as `thread::spawn` in that it takes a closure the pool should
run for each stream. We need to implement `pool.execute` so it takes the
closure and gives it to a thread in the pool to run. This code won‚Äôt yet
compile, but we‚Äôll try so the compiler can guide us in how to fix it.
-->
<p>Nous avons utilis√© <code>GroupeTaches::new</code> pour cr√©er un nouveau groupe de t√¢ches
avec un nombre configurable de t√¢ches, dans notre cas, quatre. Ensuite, dans
la boucle <code>for</code>, <code>groupe.executer</code> a une interface similaire √† <code>thread::spawn</code>
qui prend une fermeture que le groupe devra ex√©cuter pour chaque flux. Nous
devons impl√©menter <code>groupe.executer</code> pour qu'il prenne la fermeture et la donne
√† une t√¢che dans le groupe pour qu'elle l'ex√©cute. Ce code ne se compile pas
encore, mais nous allons faire comme si c'√©tait le cas pour que le compilateur
puisse nous guider dans la r√©solution des probl√®mes.</p>
<!--
#### Building the `ThreadPool` Struct Using Compiler Driven Development
-->
<h4 id="construire-la-structure-groupetaches-en-utilisant-le-d√©veloppement-orient√©-par-le-compilateur"><a class="header" href="#construire-la-structure-groupetaches-en-utilisant-le-d√©veloppement-orient√©-par-le-compilateur">Construire la structure <code>GroupeTaches</code> en utilisant le d√©veloppement orient√© par le compilateur</a></h4>
<!--
Make the changes in Listing 20-12 to *src/main.rs*, and then let‚Äôs use the
compiler errors from `cargo check` to drive our development. Here is the first
error we get:
-->
<p>Faites les changements de l'encart 20-12 dans votre <em>src/main.rs</em>, et utilisez
ensuite les erreurs du compilateur lors du <code>cargo check</code> pour orienter votre
d√©veloppement. Voici la premi√®re erreur que nous obtenons¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  -- > src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0433]: failed to resolve: use of undeclared type `GroupeTaches`
  --&gt; src/main.rs:10:16
   |
10 |     let groupe = GroupeTaches::new(4);
   |                  ^^^^^^^^^^^^ use of undeclared type `GroupeTaches`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<!--
Great! This error tells us we need a `ThreadPool` type or module, so we‚Äôll
build one now. Our `ThreadPool` implementation will be independent of the kind
of work our web server is doing. So, let‚Äôs switch the `hello` crate from a
binary crate to a library crate to hold our `ThreadPool` implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.
-->
<p>Bien¬†! Cette erreur nous informe que nous avons besoin d'un type ou d'un module
qui s'appelle <code>GroupeTaches</code>, donc nous allons le cr√©er. Notre impl√©mentation
de <code>GroupeTaches</code> sera ind√©pendante du type de travail qu'accomplira notre
serveur web. Donc, transformons la crate binaire <code>salutations</code> en crate de
biblioth√®que pour y impl√©menter notre <code>GroupeTaches</code>. Apr√®s l'avoir chang√© en
crate de biblioth√®que, nous pourrons utiliser ensuite cette biblioth√®que de
groupe de t√¢ches dans n'importe quel projet o√π nous aurons besoin d'un groupe
de t√¢ches, et pas seulement pour servir des requ√™tes web.</p>
<!--
Create a *src/lib.rs* that contains the following, which is the simplest
definition of a `ThreadPool` struct that we can have for now:
-->
<p>Cr√©ez un <em>src/lib.rs</em> qui contient ce qui suit et qui est la d√©finition la plus
simple d'une structure <code>GroupeTaches</code> que nous pouvons avoir pour le
moment¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct ThreadPool;
```
-->
<pre><code class="language-rust noplayground">pub struct GroupeTaches;
</code></pre>
<!--
Then create a new directory, *src/bin*, and move the binary crate rooted in
*src/main.rs* into *src/bin/main.rs*. Doing so will make the library crate the
primary crate in the *hello* directory; we can still run the binary in
*src/bin/main.rs* using `cargo run`. After moving the *main.rs* file, edit it
to bring the library crate in and bring `ThreadPool` into scope by adding the
following code to the top of *src/bin/main.rs*:
-->
<p>Cr√©ez ensuite un nouveau dossier, <em>src/bin</em>, et d√©placez-y la crate binaire
<em>src/main.rs</em>  qui sera donc d√©sormais <em>src/bin/main.rs</em>. Ceci va faire que la
crate de biblioth√®que sera la crate principale dans le dossier <em>salutations</em>¬†;
nous pouvons quand m√™me continuer √† ex√©cuter le binaire dans <em>src/bin/main.rs</em>
en utilisant <code>cargo run</code>. Apr√®s avoir d√©plac√© le fichier <em>main.rs</em>, modifiez-le
pour importer la crate de biblioth√®que et importer <code>GroupeTaches</code> dans la
port√©e en ajoutant le code suivant en haut de <em>src/bin/main.rs</em>¬†:</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/bin/main.rs</span></p>
<!--
```rust,ignore
use hello::ThreadPool;
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
#     let pool = ThreadPool::new(4);
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         pool.execute(|| {
#             handle_connection(stream);
#         });
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!(
#         "{}\r\nContent-Length: {}\r\n\r\n{}",
#         status_line,
#         contents.len(),
#         contents
#     );
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore">use salutations::GroupeTaches;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let groupe = GroupeTaches::new(4);
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        groupe.executer(|| {
</span><span class="boring">            gestion_connexion(flux);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        ligne_statut,
</span><span class="boring">        contenu.len(),
</span><span class="boring">        contenu
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
This code still won‚Äôt work, but let‚Äôs check it again to get the next error that
we need to address:
-->
<p>Ce code ne fonctionne toujours pas, mais v√©rifions-le √† nouveau pour obtenir
l'erreur que nous devons maintenant r√©soudre¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  -- > src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no function or associated item named `new` found for struct `GroupeTaches` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let groupe = GroupeTaches::new(4);
   |                                ^^^ function or associated item not found in `GroupeTaches`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<!--
This error indicates that next we need to create an associated function named
`new` for `ThreadPool`. We also know that `new` needs to have one parameter
that can accept `4` as an argument and should return a `ThreadPool` instance.
Let‚Äôs implement the simplest `new` function that will have those
characteristics:
-->
<p>Cette erreur indique que nous devons ensuite cr√©er une fonction associ√©e <code>new</code>
pour <code>GroupeTaches</code>. Nous savons aussi que <code>new</code> n√©cessite d'avoir un param√®tre
qui peut accepter <code>4</code> comme argument et doit retourner une instance de
<code>GroupeTaches</code>. Impl√©mentons la fonction <code>new</code> la plus simple possible qui aura
ces caract√©ristiques¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
```
-->
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
</code></pre>
<!--
We chose `usize` as the type of the `size` parameter, because we know that a
negative number of threads doesn‚Äôt make any sense. We also know we‚Äôll use this
4 as the number of elements in a collection of threads, which is what the
`usize` type is for, as discussed in the [‚ÄúInteger Types‚Äù][integer-types]<!--
ignore -- > section of Chapter 3.
-->
<p>Nous avons choisi <code>usize</code> comme type du param√®tre <code>taille</code>, car nous savons
qu'un nombre n√©gatif de t√¢ches n'a pas de sens. Nous savons √©galement que nous
allons utiliser ce 4 comme √©tant le nombre d'√©l√©ments dans une collection de
t√¢ches, ce qui est √† quoi sert le type <code>usize</code>, comme nous l'avons vu dans la section
<a href="ch03-02-data-types.html">‚ÄúTypes de nombres entiers‚Äù</a><!-- ignore --> du chapitre 3.</p>
<!--
Let‚Äôs check the code again:
-->
<p>V√©rifions √† nouveau le code¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  -- > src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no method named `executer` found for struct `GroupeTaches` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         groupe.executer(|| {
   |                ^^^^^^^^ method not found in `GroupeTaches`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<!--
Now the error occurs because we don‚Äôt have an `execute` method on `ThreadPool`.
Recall from the [‚ÄúCreating a Similar Interface for a Finite Number of
Threads‚Äù](#creating-a-similar-interface-for-a-finite-number-of-threads)<!--
ignore -- > section that we decided our thread pool should have an interface
similar to `thread::spawn`. In addition, we‚Äôll implement the `execute` function
so it takes the closure it‚Äôs given and gives it to an idle thread in the pool
to run.
-->
<p>D√©sormais, nous obtenons une erreur car nous n'avons pas impl√©ment√© la m√©thode
<code>executer</code> sur <code>GroupeTaches</code>. Souvenez-vous que nous avions d√©cid√© dans la
section <a href="ch20-02-multithreaded.html#cr%C3%A9er-une-interface-similaire-pour-un-nombre-fini-de-t%C3%A2ches">‚ÄúCr√©er une interface similaire pour un nombre fini de
t√¢ches‚Äù</a><!--
ignore --> que notre groupe de t√¢ches devrait avoir une interface similaire √†
<code>thread::spawn</code>. C'est pourquoi nous allons impl√©menter la fonction <code>executer</code>
pour qu'elle prenne en argument la fermeture qu'on lui donne et qu'elle la passe
√† une t√¢che inactive du groupe pour qu'elle l'ex√©cute.</p>
<!--
We‚Äôll define the `execute` method on `ThreadPool` to take a closure as a
parameter. Recall from the [‚ÄúStoring Closures Using Generic Parameters and the
`Fn` Traits‚Äù][storing-closures-using-generic-parameters-and-the-fn-traits]<!--
ignore -- > section in Chapter 13 that we can take closures as parameters with
three different traits: `Fn`, `FnMut`, and `FnOnce`. We need to decide which
kind of closure to use here. We know we‚Äôll end up doing something similar to
the standard library `thread::spawn` implementation, so we can look at what
bounds the signature of `thread::spawn` has on its parameter. The documentation
shows us the following:
-->
<p>Nous allons d√©finir la m√©thode <code>executer</code> sur <code>GroupeTaches</code> pour prendre en
param√®tre une fermeture. Souvenez-vous que nous avions vu dans <a href="ch13-01-closures.html">une section du
chapitre 13</a><!--
ignore --> que nous pouvions prendre en param√®tre les fermetures avec trois
types de traits diff√©rents¬†: <code>Fn</code>, <code>FnMut</code>, et <code>FnOnce</code>. Nous devons d√©cider
quel genre de fermeture nous allons utiliser ici. Nous savons que nous allons
faire quelque chose de sensiblement identique √† l'impl√©mentation du
<code>thread::spawn</code> de la biblioth√®que standard, donc nous pouvons nous inspirer de
ce qui lie la signature de <code>thread::spawn</code> √† son param√®tre. La documentation
nous donne ceci¬†:</p>
<!--
```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```
-->
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<!--
The `F` type parameter is the one we‚Äôre concerned with here; the `T` type
parameter is related to the return value, and we‚Äôre not concerned with that. We
can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is probably
what we want as well, because we‚Äôll eventually pass the argument we get in
`execute` to `spawn`. We can be further confident that `FnOnce` is the trait we
want to use because the thread for running a request will only execute that
request‚Äôs closure one time, which matches the `Once` in `FnOnce`.
-->
<p>Le param√®tre de type <code>F</code> est celui qui nous int√©resse ici¬†; le param√®tre de
type <code>T</code> est li√© √† la valeur de retour, et ceci ne nous int√©resse pas ici.
Nous pouvons constater que <code>spawn</code> utilise le trait <code>FnOnce</code> li√© √† <code>F</code>.
C'est probablement ce dont nous avons besoin, parce que nous allons s√ªrement
passer cet argument dans le <code>execute</code> de <code>spawn</code>. Nous pouvons aussi √™tre s√ªr
que <code>FnOnce</code> est le trait dont nous avons besoin car la t√¢che qui va traiter une
requ√™te ne va le faire qu'une seule fois, ce qui
correspond √† la partie <code>Once</code> dans <code>FnOnce</code>.</p>
<!--
The `F` type parameter also has the trait bound `Send` and the lifetime bound
`'static`, which are useful in our situation: we need `Send` to transfer the
closure from one thread to another and `'static` because we don‚Äôt know how long
the thread will take to execute. Let‚Äôs create an `execute` method on
`ThreadPool` that will take a generic parameter of type `F` with these bounds:
-->
<p>Le param√®tre de type <code>F</code> a aussi le trait li√© <code>Send</code> et la dur√©e de vie li√©e
<code>'static</code>, qui sont utiles dans notre situation¬†: nous avons besoin de <code>Send</code>
pour transf√©rer la fermeture d'une t√¢che vers une autre et de <code>'static</code> car nous
ne connaissons pas la dur√©e d'ex√©cution de la t√¢che. Cr√©ons donc une m√©thode
<code>executer</code> sur <code>GroupeTaches</code> qui va utiliser un param√®tre g√©n√©rique de type <code>F</code>
avec les liens suivants¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct ThreadPool;
# 
impl ThreadPool {
    // --snip--
#     pub fn new(size: usize) -> ThreadPool {
#         ThreadPool
#     }
# 
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct GroupeTaches;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masqu√©e ici--
<span class="boring">    pub fn new(size: usize) -&gt; GroupeTaches {
</span><span class="boring">        GroupeTaches
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
</code></pre>
<!--
We still use the `()` after `FnOnce` because this `FnOnce` represents a closure
that takes no parameters and returns the unit type `()`. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.
-->
<p>Nous utilisons toujours le <code>()</code> apr√®s <code>FnOne</code> car ce <code>FnOnce</code> repr√©sente une
fermeture qui ne prend pas de param√®tres et retourne le type unit√© <code>()</code>.
Exactement comme les d√©finitions de fonctions, le type de retour peut √™tre omis
de la signature, mais m√™me si elle ne contient pas de param√®tre, nous avons
tout de m√™me besoin des parenth√®ses.</p>
<!--
Again, this is the simplest implementation of the `execute` method: it does
nothing, but we‚Äôre trying only to make our code compile. Let‚Äôs check it again:
-->
<p>A nouveau, c'est l'impl√©mentation la plus simpliste de la m√©thode <code>executer</code>¬†:
elle ne fait rien, mais nous essayons seulement de faire en sorte que notre
code se compile. V√©rifions-le √† nouveau¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<!--
It compiles! But note that if you try `cargo run` and make a request in the
browser, you‚Äôll see the errors in the browser that we saw at the beginning of
the chapter. Our library isn‚Äôt actually calling the closure passed to `execute`
yet!
-->
<p>Cela se compile¬†! Mais remarquez que si vous lancez <code>cargo run</code> et faites la
requ√™te dans votre navigateur web, vous verrez l'erreur dans le navigateur que
nous avions tout au d√©but du chapitre. Notre biblioth√®que n'ex√©cute pas encore
la fermeture envoy√©e √† <code>executer</code>¬†!</p>
<!--
> Note: A saying you might hear about languages with strict compilers, such as
> Haskell and Rust, is ‚Äúif the code compiles, it works.‚Äù But this saying is not
> universally true. Our project compiles, but it does absolutely nothing! If we
> were building a real, complete project, this would be a good time to start
> writing unit tests to check that the code compiles *and* has the behavior we
> want.
-->
<blockquote>
<p>Remarque¬†: un dicton que vous avez probablement d√©j√† entendu √† propos des
compilateurs stricts, comme Haskell et Rust, est que ‚Äúsi le code se compile,
il fonctionne‚Äù. Mais ce dicton n'est pas toujours vrai. Notre projet se
compile, mais il ne fait absolument rien¬†! Si nous construisions un vrai
projet, complexe, il serait bon de commencer √† √©crire des tests unitaires pour
v√©rifier que ce code compile <em>et</em> qu'il suit le comportement que nous
souhaitons.</p>
</blockquote>
<!--
#### Validating the Number of Threads in `new`
-->
<h4 id="valider-le-nombre-de-t√¢ches-envoy√©-√†-new"><a class="header" href="#valider-le-nombre-de-t√¢ches-envoy√©-√†-new">Valider le nombre de t√¢ches envoy√© √† <code>new</code></a></h4>
<!--
We aren‚Äôt doing anything with the parameters to `new` and `execute`. Let‚Äôs
implement the bodies of these functions with the behavior we want. To start,
let‚Äôs think about `new`. Earlier we chose an unsigned type for the `size`
parameter, because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid `usize`. We‚Äôll add code to check that `size` is greater than zero before
we return a `ThreadPool` instance and have the program panic if it receives a
zero by using the `assert!` macro, as shown in Listing 20-13.
-->
<p>Nous ne faisons rien avec les param√®tres pass√©s √† <code>new</code> et <code>executer</code>.
Impl√©mentons le corps de ces fonctions avec le comportement que nous
souhaitons. Pour commencer, r√©fl√©chissons √† <code>new</code>. Pr√©c√©demment, nous avions
choisi un type sans signe pour le param√®tre <code>taille</code>, car un groupe avec un
nombre n√©gatif de t√¢ches n'a pas de sens. Cependant, un groupe avec aucune
t√¢che n'a pas non plus de sens, alors que z√©ro est une valeur parfaitement
valide pour <code>usize</code>. Nous allons ajouter du code pour v√©rifier que <code>taille</code> est
plus grand que z√©ro avant de retourner une instance de <code>GroupeTaches</code> et faire
en sorte que le programme panique s'il re√ßoit un z√©ro, en utilisant la macro
<code>assert!</code> comme dans l'encart 20-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Filename¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct ThreadPool;
# 
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct GroupeTaches;
</span><span class="boring">
</span>impl GroupeTaches {
    /// Cr√©e un nouveau GroupeTaches.
    ///
    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
    ///
    /// # Panics
    ///
    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        GroupeTaches
    }

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 20-13: Implementing `ThreadPool::new` to panic if
`size` is zero</span>
-->
<p><span class="caption">Encart 20-13¬†: impl√©mentation de <code>GroupeTaches::new</code> qui
devrait paniquer si <code>taille</code> vaut z√©ro</span></p>
<!--
We‚Äôve added some documentation for our `ThreadPool` with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running `cargo doc --open` and clicking the `ThreadPool` struct to see what
the generated docs for `new` look like!
-->
<p>Nous avons ajout√© un peu de documentation pour notre <code>GroupeTaches</code> avec des
commentaires de documentation. Remarquez que nous avons suivi les pratiques de
bonne documentation en ajoutant une section qui liste les situations pour
lesquelles notre fonction peut paniquer, comme nous l'avons vu dans le
chapitre 14. Essayez de lancer <code>cargo doc --open</code> et de cliquer sur la structure
<code>GroupeTaches</code> pour voir √† quoi ressemble la documentation g√©n√©r√©e pour <code>new</code>¬†!</p>
<!--
Instead of adding the `assert!` macro as we‚Äôve done here, we could make `new`
return a `Result` like we did with `Config::new` in the I/O project in Listing
12-9. But we‚Äôve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you‚Äôre feeling
ambitious, try to write a version of `new` with the following signature to
compare both versions:
-->
<p>Au lieu d'ajouter la macro <code>assert!</code> comme nous venons de le faire, nous
aurions pu faire en sorte que <code>new</code> retourne un <code>Result</code> comme nous l'avions
fait avec <code>Config::new</code> dans le projet d'entr√©e/sortie dans l'encart 12-9. Mais
nous avons d√©cid√© que dans le cas pr√©sent, la cr√©ation d'un groupe de t√¢ches
sans aucune t√¢che devait √™tre une erreur irr√©cup√©rable. Si vous en sentez
l'envie, essayez d'√©crire une version de <code>new</code> avec la signature suivante, pour
comparer les deux versions¬†:</p>
<!--
```rust,ignore
pub fn new(size: usize) -> Result<ThreadPool, PoolCreationError> {
```
-->
<pre><code class="language-rust ignore">pub fn new(taille: usize) -&gt; Result&lt;GroupeTaches, ErreurGroupeTaches&gt; {
</code></pre>
<!--
#### Creating Space to Store the Threads
-->
<h4 id="cr√©er-lespace-de-rangement-des-t√¢ches"><a class="header" href="#cr√©er-lespace-de-rangement-des-t√¢ches">Cr√©er l'espace de rangement des t√¢ches</a></h4>
<!--
Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the `ThreadPool` struct
before returning it. But how do we ‚Äústore‚Äù a thread? Let‚Äôs take another look at
the `thread::spawn` signature:
-->
<p>Maintenant que nous avons une mani√®re de savoir si nous avons un nombre valide
de t√¢ches √† stocker dans le groupe, nous pouvons cr√©er ces t√¢ches et les stocker
dans la structure <code>GroupeTaches</code> avant de la retourner. Mais comment ‚Äústocker‚Äù
une t√¢che¬†? Regardons √† nouveau la signature de <code>thread::spawn</code>¬†:</p>
<!--
```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```
-->
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<!--
The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that the
closure returns. Let‚Äôs try using `JoinHandle` too and see what happens. In our
case, the closures we‚Äôre passing to the thread pool will handle the connection
and not return anything, so `T` will be the unit type `()`.
-->
<p>La fonction <code>spawn</code> retourne un <code>JoinHandle&lt;T&gt;</code>, o√π <code>T</code> est le type que retourne
notre fermeture. Essayons d'utiliser nous aussi <code>JoinHandle</code> pour voir ce qu'il
va se passer. Dans notre cas, les fermetures que nous passons dans le groupe de
t√¢ches vont traiter les connexions mais ne vont rien retourner, donc <code>T</code> sera le
type unit√©, <code>()</code>.</p>
<!--
The code in Listing 20-14 will compile but doesn‚Äôt create any threads yet.
We‚Äôve changed the definition of `ThreadPool` to hold a vector of
`thread::JoinHandle<()>` instances, initialized the vector with a capacity of
`size`, set up a `for` loop that will run some code to create the threads, and
returned a `ThreadPool` instance containing them.
-->
<p>Le code de l'encart 20-14 va se compiler mais ne va pas encore cr√©er de t√¢ches
pour le moment. Nous avons chang√© la d√©finition de <code>GroupeTaches</code> pour qu'elle
poss√®de un vecteur d'instances <code>thread::JoinHandle&lt;()&gt;</code>, nous avons initialis√©
le vecteur avec une capacit√© de la valeur de <code>taille</code>, mis en place une boucle
<code>for</code> qui va ex√©cuter du code pour cr√©er les t√¢ches puis nous avons retourn√© une
instance de <code>GroupeTaches</code> qui les contient.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,not_desired_behavior
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
```
-->
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct GroupeTaches {
    taches: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl GroupeTaches {
    // -- partie masqu√©e ici --
<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let mut taches = Vec::with_capacity(taille);

        for _ in 0..taille {
            // on cr√©e quelques t√¢ches ici et on les stocke dans le vecteur
        }

        GroupeTaches { taches }
    }

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 20-14: Creating a vector for `ThreadPool` to hold
the threads</span>
-->
<p><span class="caption">Encart 20-14¬†: cr√©ation d'un vecteur pour <code>GroupeTaches</code>
pour stocker les t√¢ches</span></p>
<!--
We‚Äôve brought `std::thread` into scope in the library crate, because we‚Äôre
using `thread::JoinHandle` as the type of the items in the vector in
`ThreadPool`.
-->
<p>Nous avons import√© <code>std::thread</code> dans la port√©e de la crate de biblioth√®que, car
nous utilisons <code>thread::JoinHandle</code> comme √©tant le type des √©l√©ments du vecteur
dans <code>GroupeTaches</code>.</p>
<!--
Once a valid size is received, our `ThreadPool` creates a new vector that can
hold `size` items. We haven‚Äôt used the `with_capacity` function in this book
yet, which performs the same task as `Vec::new` but with an important
difference: it preallocates space in the vector. Because we know we need to
store `size` elements in the vector, doing this allocation up front is slightly
more efficient than using `Vec::new`, which resizes itself as elements are
inserted.
-->
<p>Une fois qu'une taille valide est re√ßue, notre <code>GroupeTaches</code> cr√©e un nouveau
vecteur qui peut stocker <code>taille</code> √©l√©ments. Nous n'avons pas encore utilis√© la
fonction <code>with_capacity</code> dans ce livre, qui fait la m√™me chose que <code>Vec::new</code>
mais avec une grosse diff√©rence¬†: elle pr√©-alloue l'espace dans le vecteur.
Comme nous savons que nous avons besoin de stocker <code>taille</code> √©l√©ments dans le
vecteur, faire cette allocation en amont est bien plus efficace que d'utiliser
<code>Vec::new</code> qui va se redimensionner lorsque des √©l√©ments lui seront ajout√©s.</p>
<!--
When you run `cargo check` again, you‚Äôll get a few more warnings, but it should
succeed.
-->
<p>Lorsque vous lancez √† nouveau <code>cargo check</code>, vous devriez avoir quelques
avertissements en plus, mais cela devrait √™tre un succ√®s.</p>
<!-- markdownlint-disable -->
<!--
#### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a Thread
-->
<!-- markdownlint-enable -->
<h4 id="une-structure-operateur-charg√©e-denvoyer-le-code-de-groupetaches-√†-une-t√¢che"><a class="header" href="#une-structure-operateur-charg√©e-denvoyer-le-code-de-groupetaches-√†-une-t√¢che">Une structure <code>Operateur</code> charg√©e d'envoyer le code de <code>GroupeTaches</code> √† une t√¢che</a></h4>
<!--
We left a comment in the `for` loop in Listing 20-14 regarding the creation of
threads. Here, we‚Äôll look at how we actually create threads. The standard
library provides `thread::spawn` as a way to create threads, and
`thread::spawn` expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them *wait* for code that we‚Äôll send later. The standard library‚Äôs
implementation of threads doesn‚Äôt include any way to do that; we have to
implement it manually.
-->
<p>Nous avions laiss√© un commentaire dans la boucle <code>for</code> dans l'encart 20-14 qui
concernait la cr√©ation des t√¢ches. Maintenant, nous allons voir comment cr√©er
ces t√¢ches. La biblioth√®que standard fournit un moyen de cr√©er des t√¢ches avec
<code>thread::spawn</code> √† qui il faut passer le code que la t√¢che doit ex√©cuter d√®s
qu'elle est cr√©√©e. Cependant, dans notre cas, nous souhaitons cr√©er des t√¢ches
et faire en sorte qu'elles <em>attendent</em> du code que nous leur enverrons plus
tard. L'impl√©mentation des t√¢ches de la biblioth√®que standard n'offre aucun
moyen de faire ceci¬†; nous devons donc impl√©menter cela nous-m√™me.</p>
<!--
We‚Äôll implement this behavior by introducing a new data structure between the
`ThreadPool` and the threads that will manage this new behavior. We‚Äôll call
this data structure `Worker`, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they‚Äôre responsible
for taking those orders and filling them.
-->
<p>Nous allons impl√©menter ce comportement en introduisant une nouvelle structure
de donn√©es entre le <code>GroupeTaches</code> et les t√¢ches qui va g√©rer ce nouveau
comportement. Nous allons appeler cette structure <code>Operateur</code>, nom qui lui est
traditionnellement donn√© avec <code>Worker</code> dans les impl√©mentations de groupe de
t√¢ches. Imaginez des personnes qui travaillent dans la cuisine d'un restaurant¬†:
les op√©rateurs attendent les commandes des clients puis sont charg√©s de prendre
en charge ces commandes et d'y r√©pondre.</p>
<!--
Instead of storing a vector of `JoinHandle<()>` instances in the thread pool,
we‚Äôll store instances of the `Worker` struct. Each `Worker` will store a single
`JoinHandle<()>` instance. Then we‚Äôll implement a method on `Worker` that will
take a closure of code to run and send it to the already running thread for
execution. We‚Äôll also give each worker an `id` so we can distinguish between
the different workers in the pool when logging or debugging.
-->
<p>Au lieu de stocker un vecteur d'instances <code>JoinHandle&lt;()&gt;</code> dans le groupe de
t√¢ches, nous allons stocker des instances de structure <code>Operateur</code>. Chaque
<code>Operateur</code> va stocker une seule instance de <code>JoinHandle&lt;()&gt;</code>. Ensuite nous
impl√©menterons une m√©thode sur <code>Operateur</code> qui va prendre en argument une
fermeture de code √† ex√©cuter et l'envoyer √† la t√¢che qui fonctionne d√©j√† pour
ex√©cution. Nous allons aussi donner √† chacun des op√©rateurs un identifiant <code>id</code>
afin que nous puissions distinguer les diff√©rents op√©rateurs dans le groupe
dans les journaux ou lors de d√©bogages.</p>
<!--
Let‚Äôs make the following changes to what happens when we create a `ThreadPool`.
We‚Äôll implement the code that sends the closure to the thread after we have
`Worker` set up in this way:
-->
<p>Appliquons ces changements √† l'endroit o√π nous cr√©ons un <code>GroupeTaches</code>. Nous
allons impl√©menter le code de <code>Operateur</code> qui envoie la fermeture √† la t√¢che
en suivant ces √©tapes¬†:</p>
<!--
1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`.
2. Change `ThreadPool` to hold a vector of `Worker` instances.
3. Define a `Worker::new` function that takes an `id` number and returns a
   `Worker` instance that holds the `id` and a thread spawned with an empty
   closure.
4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create
   a new `Worker` with that `id`, and store the worker in the vector.
-->
<ol>
<li>D√©finir une structure <code>Operateur</code> qui poss√®de un <code>id</code> et un <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Modifier le <code>GroupeTaches</code> afin qu'il poss√®de un vecteur d'instances de
<code>Operateur</code>.</li>
<li>D√©finir une fonction <code>Operateur::new</code> qui prend en argument un num√©ro d'<code>id</code>
et retourne une instance de <code>Operateur</code> qui contient l' <code>id</code> et une t√¢che
cr√©√©e avec une fermeture vide.</li>
<li>Dans <code>GroupeTaches::new</code>, utiliser le compteur de la boucle <code>for</code> pour
g√©n√©rer un <code>id</code>, cr√©er un nouveau <code>Operateur</code> avec cet <code>id</code> et stocker
l'op√©rateur dans le vecteur.</li>
</ol>
<!--
If you‚Äôre up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.
-->
<p>Si vous vous sentez pr√™t(e) √† relever le d√©fi, essayez de faire ces changements
de votre c√¥t√© avant de regarder le code de l'encart 20-15.</p>
<!--
Ready? Here is Listing 20-15 with one way to make the preceding modifications.
-->
<p>Vous √™tes pr√™t(e)¬†? Voici l'encart 20-15 qui propose une solution pour proc√©der
aux changements list√©s pr√©c√©demment.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::thread;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
}

impl GroupeTaches {
    // -- partie masqu√©e ici --
<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id));
        }

        GroupeTaches { operateurs }
    }
    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Operateur {
    id: usize,
    tache: thread::JoinHandle&lt;()&gt;,
}

impl Operateur {
    fn new(id: usize) -&gt; Operateur {
        let tache = thread::spawn(|| {});

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-15: Modifying `ThreadPool` to hold `Worker`
instances instead of holding threads directly</span>
-->
<p><span class="caption">Encart 20-15¬†: modification de <code>GroupeTaches</code> pour
stocker des instances de <code>Operateur</code> plut√¥t que de stocker directement des
t√¢ches</span></p>
<!--
We‚Äôve changed the name of the field on `ThreadPool` from `threads` to `workers`
because it‚Äôs now holding `Worker` instances instead of `JoinHandle<()>`
instances. We use the counter in the `for` loop as an argument to
`Worker::new`, and we store each new `Worker` in the vector named `workers`.
-->
<p>Nous avons chang√© le nom du champ <code>taches</code> de <code>GroupeTaches</code> en <code>operateurs</code>
car il stocke maintenant des instances de <code>Operateur</code> plut√¥t que des instances
de <code>JoinHandle&lt;()&gt;</code>. Nous utilisons le compteur de la boucle <code>for</code> comme argument
de <code>Operateur::new</code> et nous stockons chacun des nouveaux <code>Operateur</code> dans le
vecteur <code>operateurs</code>.</p>
<!--
External code (like our server in *src/bin/main.rs*) doesn‚Äôt need to know the
implementation details regarding using a `Worker` struct within `ThreadPool`,
so we make the `Worker` struct and its `new` function private. The
`Worker::new` function uses the `id` we give it and stores a `JoinHandle<()>`
instance that is created by spawning a new thread using an empty closure.
-->
<p>Le code externe (comme celui de notre serveur dans <em>src/bin/main.rs</em>) n'a pas
besoin de conna√Ætre les d√©tails de l'impl√©mentation qui utilise une structure
<code>Operateur</code> dans <code>GroupeTaches</code>, donc nous faisons en sorte que la structure
<code>Operateur</code> et sa fonction <code>new</code> soient priv√©es. La fonction <code>Operateur::new</code>
utilise l' <code>id</code> que nous lui donnons et stocke une instance de <code>JoinHandle&lt;()&gt;</code>
qui est cr√©√©e en instanciant une nouvelle t√¢che utilisant une fermeture vide.</p>
<!--
This code will compile and will store the number of `Worker` instances we
specified as an argument to `ThreadPool::new`. But we‚Äôre *still* not processing
the closure that we get in `execute`. Let‚Äôs look at how to do that next.
-->
<p>Ce code va se compiler et stocker le nombre d'instances de <code>Operateur</code> que nous
avons renseign√© en argument de <code>GroupeTaches::new</code>. Mais nous n'ex√©cutons
<em>toujours pas</em> la fermeture que nous obtenons de <code>executer</code>. Voyons maintenant
comment faire cela.</p>
<!--
#### Sending Requests to Threads via Channels
-->
<h4 id="envoyer-des-requ√™tes-√†-des-t√¢ches-via-des-canaux"><a class="header" href="#envoyer-des-requ√™tes-√†-des-t√¢ches-via-des-canaux">Envoyer des requ√™tes √† des t√¢ches via des canaux</a></h4>
<!--
Now we‚Äôll tackle the problem that the closures given to `thread::spawn` do
absolutely nothing. Currently, we get the closure we want to execute in the
`execute` method. But we need to give `thread::spawn` a closure to run when we
create each `Worker` during the creation of the `ThreadPool`.
-->
<p>Maintenant nous allons nous attaquer au probl√®me qui fait que les fermetures
pass√©es √† <code>thread::spawn</code> ne font absolument rien. Actuellement, nous obtenons
la fermeture que nous souhaitons ex√©cuter dans la m√©thode <code>executer</code>. Mais nous
avons besoin de donner une fermeture √† <code>thread::spawn</code> √† ex√©cuter
lorsque nous cr√©ons chaque <code>Operateur</code> lors de la cr√©ation de <code>GroupeTaches</code>.</p>
<!--
We want the `Worker` structs that we just created to fetch code to run from a
queue held in the `ThreadPool` and send that code to its thread to run.
-->
<p>Nous souhaitons que les structures <code>Operateur</code> que nous venons de cr√©er
r√©cup√®rent du code √† ex√©cuter dans une liste d'attente pr√©sente dans le
<code>GroupeTaches</code> et renvoient ce code √† leur t√¢che pour l'ex√©cuter.</p>
<!--
In Chapter 16, you learned about *channels*‚Äîa simple way to communicate between
two threads‚Äîthat would be perfect for this use case. We‚Äôll use a channel to
function as the queue of jobs, and `execute` will send a job from the
`ThreadPool` to the `Worker` instances, which will send the job to its thread.
Here is the plan:
-->
<p>Dans le chapitre 16, vous avez appris les <em>canaux</em> (une mani√®re simple de
communiquer entre deux t√¢ches) qui seront parfaits pour ce cas d'emploi. Nous
allons utiliser un canal pour les fonctions pour cr√©er la liste d'attente des
missions, et <code>executer</code> devrait envoyer une mission de <code>GroupeTaches</code> vers les
instances <code>Operateur</code>, qui vont passer la mission √† leurs t√¢ches. Voici le
plan¬†:</p>
<!--
1. The `ThreadPool` will create a channel and hold on to the sending side of
   the channel.
2. Each `Worker` will hold on to the receiving side of the channel.
3. We‚Äôll create a new `Job` struct that will hold the closures we want to send
   down the channel.
4. The `execute` method will send the job it wants to execute down the sending
   side of the channel.
5. In its thread, the `Worker` will loop over its receiving side of the channel
   and execute the closures of any jobs it receives.
-->
<ol>
<li>Le <code>GroupeTaches</code> va cr√©er un canal et se connecter √† la partie √©mettrice de
ce canal.</li>
<li>Chaque <code>Operateur</code> va se connecter √† la partie r√©ceptrice du canal.</li>
<li>Nous allons cr√©er une nouvelle structure <code>Mission</code> qui va stocker les
fermetures que nous souhaitons envoyer dans le canal.</li>
<li>La m√©thode <code>executer</code> va envoyer la mission qu'elle souhaite executer √† la
partie √©mettrice du canal.</li>
<li>Dans sa propre t√¢che, l' <code>Operateur</code> va v√©rifier en permanence la partie
r√©ceptrice du canal et ex√©cuter les fermetures des missions qu'il va
recevoir.</li>
</ol>
<!--
Let‚Äôs start by creating a channel in `ThreadPool::new` and holding the sending
side in the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct
doesn‚Äôt hold anything for now but will be the type of item we‚Äôre sending down
the channel.
-->
<p>Commen√ßons par cr√©er un canal dans <code>GroupeTaches::new</code> et stocker la partie
√©mettrice dans l'instance de <code>GroupeTaches</code>, comme dans l'encart 20-16. La
structure <code>Mission</code> ne contient rien pour le moment mais sera le type
d'√©l√©ments que nous enverrons dans le canal.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize) -> Worker {
#         let thread = thread::spawn(|| {});
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::thread;
</span>// -- partie masqu√©e ici --
use std::sync::mpsc;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Mission&gt;,
}

struct Mission;

impl GroupeTaches {
    // -- partie masqu√©e ici --
<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id));
        }

        GroupeTaches { operateurs, envoi }
    }
    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-16: Modifying `ThreadPool` to store the
sending end of a channel that sends `Job` instances</span>
-->
<p><span class="caption">Encart 20-16¬†: modification de <code>GroupeTaches</code> pour
stocker la partie √©mettrice du canal qui √©met des instances de <code>Mission</code></span></p>
<!--
In `ThreadPool::new`, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.
-->
<p>Dans <code>GroupeTaches::new</code>, nous cr√©ons notre nouveau canal et faisons en sorte
que le groupe stocke la partie √©mettrice. Cela devrait pouvoir se compiler, mais
il subsiste des avertissements.</p>
<!--
Let‚Äôs try passing a receiving end of the channel into each worker as the thread
pool creates the channel. We know we want to use the receiving end in the
thread that the workers spawn, so we‚Äôll reference the `receiver` parameter in
the closure. The code in Listing 20-17 won‚Äôt quite compile yet.
-->
<p>Essayons de donner la partie r√©ceptrice du canal √† chacun des op√©rateurs
lorsque le groupe de t√¢ches cr√©e le canal. Nous savons que nous voulons
utiliser la partie r√©ceptrice dans la t√¢che que l'op√©rateur utilise, donc nous
allons cr√©er une r√©f√©rence vers le param√®tre <code>reception</code> dans la fermeture. Le
code de l'encart 20-17 ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# struct Job;
# 
impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

// --snip--

# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Mission;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masqu√©e ici --
<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, reception));
        }

        GroupeTaches { operateurs, envoi }
    }
    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// -- partie masqu√©e ici --

<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: mpsc::Receiver&lt;Mission&gt;) -&gt; Operateur {
        let tache = thread::spawn(|| {
            reception;
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span>
-->
<p><span class="caption">Encart 20-17¬†: envoi de la partie r√©ceptrice du canal aux
op√©rateurs</span></p>
<!--
We‚Äôve made some small and straightforward changes: we pass the receiving end of
the channel into `Worker::new`, and then we use it inside the closure.
-->
<p>Nous avons juste fait de petites modifications simples¬†: nous envoyons la partie
r√©ceptrice du canal dans <code>Operateur::new</code> puis nous l'utilisons dans la
fermeture.</p>
<!--
When we try to check this code, we get this error:
-->
<p>Lorsque nous essayons de v√©rifier ce code, nous obtenons cette erreur¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  -- > src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0382]: use of moved value: `reception`
  --&gt; src/lib.rs:27:42
   |
22 |         let (envoi, reception) = mpsc::channel();
   |                     --------- move occurs because `reception` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             operateurs.push(Worker::new(id, reception));
   |                                             ^^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<!--
The code is trying to pass `receiver` to multiple `Worker` instances. This
won‚Äôt work, as you‚Äôll recall from Chapter 16: the channel implementation that
Rust provides is multiple *producer*, single *consumer*. This means we can‚Äôt
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single `receiver` among all the workers.
-->
<p>Le code essaye d'envoyer <code>reception</code> dans plusieurs instances de <code>Operateur</code>.
Ceci ne fonctionne pas, comme vous l'avez appris au chapitre 16¬†:
l'impl√©mentation du canal que fournit Rust est du type plusieurs <em>producteurs</em>,
un seul <em>consommateur</em>. Cela signifie que nous ne pouvons pas simplement cloner
la partie r√©ceptrice du canal pour corriger ce code. M√™me si nous aurions pu le
faire, ce n'est pas la solution que nous souhaitons utiliser¬†; nous voulons
plut√¥t distribuer les missions entre les t√¢ches en partageant la m√™me r√©ception
entre tous les op√©rateurs.</p>
<!--
Additionally, taking a job off the channel queue involves mutating the
`receiver`, so the threads need a safe way to share and modify `receiver`;
otherwise, we might get race conditions (as covered in Chapter 16).
-->
<p>De plus, obtenir une mission de la file d'attente du canal implique de modifier
la <code>reception</code>, donc les t√¢ches ont besoin d'une m√©thode s√©curis√©e pour
partager et modifier <code>reception</code>¬†; autrement, nous risquons de nous trouver
dans des situations de concurrence (comme nous l'avons vu dans le chapitre 16).</p>
<!--
Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own the
receiver, and `Mutex` will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.
-->
<p>Souvenez-vous des pointeurs intelligents con√ßus pour les √©changes entre les
t√¢ches que nous avons vus au chapitre 16¬†: pour partager la possession entre
plusieurs t√¢ches et permettre aux t√¢ches de modifier la valeur, nous avons besoin
d'utiliser <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Le type <code>Arc</code> va permettre √† plusieurs op√©rateurs
de poss√©der la r√©ception tandis que <code>Mutex</code> va s'assurer qu'un seul
op√©rateur obtienne une mission dans la r√©ception √† un moment donn√©. L'encart 20-18
montre les changements que nous devons apporter.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::sync::mpsc;
# use std::thread;
use std::sync::Arc;
use std::sync::Mutex;
// --snip--

# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# struct Job;
# 
impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

// --snip--

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#             receiver;
#         });
# 
#         Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span>use std::sync::Arc;
use std::sync::Mutex;
// -- partie masqu√©e ici --

<span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Mission;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masqu√©e ici --
<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let reception = Arc::new(Mutex::new(reception));

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
        }

        GroupeTaches { operateurs, envoi }
    }

    // -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// -- partie masqu√©e ici --

<span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masqu√©e ici --
<span class="boring">        let tache = thread::spawn(|| {
</span><span class="boring">            reception;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 20-18: Sharing the receiving end of the channel
among the workers using `Arc` and `Mutex`</span>
-->
<p><span class="caption">Encart 20-18¬†: partage de la partie r√©ceptrice du canal
entre les op√©rateurs en utilisant <code>Arc</code> et <code>Mutex</code></span></p>
<!--
In `ThreadPool::new`, we put the receiving end of the channel in an `Arc` and a
`Mutex`. For each new worker, we clone the `Arc` to bump the reference count so
the workers can share ownership of the receiving end.
-->
<p>Dans <code>GroupeTaches::new</code>, nous installons la partie r√©ceptrice du canal dans un
<code>Arc</code> et un <code>Mutex</code>. Pour chaque nouvel op√©rateur, nous clonons le <code>Arc</code> pour
augmenter le compteur de r√©f√©rences afin que les op√©rateurs puissent se
partager la possession de la partie r√©ceptrice.</p>
<!--
With these changes, the code compiles! We‚Äôre getting there!
-->
<p>Gr√¢ce √† ces changements, le code se compile¬†! Nous touchons au but¬†!</p>
<!--
#### Implementing the `execute` Method
-->
<h4 id="impl√©menter-la-m√©thode-executer"><a class="header" href="#impl√©menter-la-m√©thode-executer">Impl√©menter la m√©thode <code>executer</code></a></h4>
<!--
Let‚Äôs finally implement the `execute` method on `ThreadPool`. We‚Äôll also change
`Job` from a struct to a type alias for a trait object that holds the type of
closure that `execute` receives. As discussed in the [‚ÄúCreating Type Synonyms
with Type Aliases‚Äù][creating-type-synonyms-with-type-aliases]<!-- ignore -- >
section of Chapter 19, type aliases allow us to make long types shorter. Look
at Listing 20-19.
-->
<p>Finissons en impl√©mentant la m√©thode <code>executer</code> de <code>GroupeTaches</code>. Nous allons
√©galement modifier la structure <code>Mission</code> pour la transformer en un alias de
type pour un objet trait qui contiendra le type de fermeture que <code>executer</code>
recevra. Comme nous l'avons vu dans
<a href="ch19-04-advanced-types.html">une section du chapitre 19</a><!--
ignore -->, les alias de type nous permettent de raccourcir les types un peu
trop longs. Voyez cela dans l'encart 20-19.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(|| {
#             receiver;
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici --

type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl GroupeTaches {
    // -- partie masqu√©e ici --
<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span>
    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(mission).unwrap();
    }
}

// -- partie masqu√©e ici --
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(|| {
</span><span class="boring">            reception;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-19: Creating a `Job` type alias for a `Box`
that holds each closure and then sending the job down the channel</span>
-->
<p><span class="caption">Encart 20-19¬†: cr√©ation d'un alias de type <code>Mission</code>
pour une <code>Box</code> qui contient chaque fermeture et qui transportera la mission
dans le canal</span></p>
<!--
After creating a new `Job` instance using the closure we get in `execute`, we
send that job down the sending end of the channel. We‚Äôre calling `unwrap` on
`send` for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can‚Äôt stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use `unwrap` is that we know the failure case won‚Äôt happen, but the
compiler doesn‚Äôt know that.
-->
<p>Apr√®s avoir cr√©√© une nouvelle instance <code>Mission</code> en utilisant la fermeture que
nous obtenons dans <code>executer</code>, nous envoyons cette mission dans le canal via la
partie √©mettrice. Nous utilisons <code>unwrap</code> sur <code>send</code> pour les cas o√π l'envoi
√©choue. Cela peut arriver si, par exemple, nous stoppons l'ex√©cution de toutes
les t√¢ches, ce qui signifiera que les parties r√©ceptrices auront finis de
recevoir des nouveaux messages. Pour le moment, nous ne pouvons pas stopper
l'ex√©cution de nos t√¢ches¬†: nos t√¢ches continuerons √† s'ex√©cuter aussi
longtemps que le groupe existe. La raison pour laquelle nous utilisons <code>unwrap</code>
est que nous savons que le cas d'√©chec ne va pas se produire, mais le
compilateur ne le sait pas.</p>
<!--
But we‚Äôre not quite done yet! In the worker, our closure being passed to
`thread::spawn` still only *references* the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let‚Äôs make the change
shown in Listing 20-20 to `Worker::new`.
-->
<p>Mais nous n'avons pas encore tout √† fait fini¬†! Dans l'op√©rateur, notre
fermeture envoy√©e √† <code>thread::spawn</code> ne fait que <em>r√©f√©rencer</em> la partie
r√©ception du canal. Au lieu de √ßa, nous avons besoin que la fermeture boucle √†
l'infini, demandant une mission √† la partie r√©ceptrice du canal et l'ex√©cutant
quand elle en obtient une. Appliquons les changements montr√©s dans l'encart
20-20 √† <code>Operateur::new</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {} got a job; executing.", id);

            job();
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masqu√©e ici --

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let mission = reception.lock().unwrap().recv().unwrap();

            println!(&quot;L'op√©rateur {} a obtenu une mission¬†; il l'ex√©cute.&quot;, id);

            mission();
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker‚Äôs thread</span>
-->
<p><span class="caption">Encart 20-20¬†: r√©ception et ex√©cution des missions dans
la t√¢che de l'op√©rateur</span></p>
<!--
Here, we first call `lock` on the `receiver` to acquire the mutex, and then we
call `unwrap` to panic on any errors. Acquiring a lock might fail if the mutex
is in a *poisoned* state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
`unwrap` to have this thread panic is the correct action to take. Feel free to
change this `unwrap` to an `expect` with an error message that is meaningful to
you.
-->
<p>Ici, nous faisons d'abord appel √† <code>lock</code> sur <code>reception</code> pour obtenir le mutex,
puis nous faisons appel √† <code>unwrap</code> pour paniquer d√®s qu'il y a une
erreur. L'acquisition d'un verrou peut √©chouer si le mutex est dans un √©tat
<em>empoisonn√©</em>, ce qui peut arriver si d'autres t√¢ches ont paniqu√© pendant
qu'elles avaient le verrou au lieu de le rendre. Dans cette situation, l'appel
√† <code>unwrap</code> fera paniquer la t√¢che, ce qui est la bonne chose √† faire. Vous
pouvez aussi changer ce <code>unwrap</code> en un <code>expect</code> avec un message d'erreur qui
sera plus explicite pour vous.</p>
<!--
If we get the lock on the mutex, we call `recv` to receive a `Job` from the
channel. A final `unwrap` moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the `send` method returns `Err` if the receiving side shuts down.
-->
<p>Si nous obtenons le verrou du mutex, nous faisons appel √† <code>recv</code> pour recevoir
une <code>Mission</code> provenant du canal. Un <code>unwrap</code> final s'occupe lui aussi des cas
d'erreurs qui peuvent se produire si la t√¢che qui est connect√©e √† la partie √©mettrice
du canal se termine, de la m√™me mani√®re que la m√©thode <code>send</code> enverrait <code>Err</code>
si la partie r√©ceptrice se fermerait.</p>
<!--
The call to `recv` blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The `Mutex<T>` ensures that only one
`Worker` thread at a time is trying to request a job.
-->
<p>L'appel √† <code>recv</code> bloque l'ex√©cution, donc s'il n'y a pas encore de mission, la
t√¢che courante va attendre jusqu'√† ce qu'une mission soit disponible. Le
<code>Mutex&lt;T&gt;</code> s'assure qu'une seule t√¢che d'<code>Operateur</code> essaie d'obtenir une mission
√† un instant donn√©.</p>
<!--
Our thread pool is now in a working state! Give it a `cargo run` and make some
requests:
-->
<p>Notre groupe de t√¢ches est d√©sormais en √©tat de fonctionner¬†! Faites un
<code>cargo run</code> et faites quelques requ√™tes¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-- >
-->
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 -- > src/lib.rs:7:5
  |
7 |     workers: Vec<Worker>,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  -- > src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  -- > src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: 3 warnings emitted

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
warning: field is never read: `operateurs`
 -- &gt; src/lib.rs:7:5
  |
7 |     operateurs: Vec&lt;Operateur&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  -- &gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `tache`
  -- &gt; src/lib.rs:49:5
   |
49 |     tache: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: 3 warnings emitted

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
L'op√©rateur 0 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 2 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 1 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 3 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 0 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 2 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 1 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 3 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 0 a obtenu une mission¬†; il l'ex√©cute.
L'op√©rateur 2 a obtenu une mission¬†; il l'ex√©cute.
</code></pre>
<!--
Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won‚Äôt get
overloaded if the server receives a lot of requests. If we make a request to
*/sleep*, the server will be able to serve other requests by having another
thread run them.
-->
<p>Parfait¬†! Nous avons maintenant un groupe de t√¢ches qui ex√©cute des connexions
de mani√®re asynchrone. Il n'y a jamais plus de quatre t√¢ches qui sont cr√©√©es,
donc notre syst√®me ne sera pas surcharg√© si le serveur re√ßoit beaucoup de
requ√™tes. Si nous faisons une requ√™te vers <em>/pause</em>, le serveur sera toujours
capable de servir les autres requ√™tes gr√¢ce aux autres t√¢ches qui pourront les
ex√©cuter.</p>
<!--
> Note: if you open */sleep* in multiple browser windows simultaneously, they
> might load one at a time in 5 second intervals. Some web browsers execute
> multiple instances of the same request sequentially for caching reasons. This
> limitation is not caused by our web server.
-->
<blockquote>
<p>Remarque¬†: si vous ouvrez <em>/pause</em> dans plusieurs fen√™tres de navigation en
simultan√©, elles peuvent parfois √™tre charg√©es une par une avec 5 secondes
d'intervalle. Certains navigateurs web ex√©cutent plusieurs instances de la
m√™me requ√™te de mani√®re s√©quentielle pour des raisons de mise en cache. Cette
limitation n'est pas imputable √† notre serveur web.</p>
</blockquote>
<!--
After learning about the `while let` loop in Chapter 18, you might be wondering
why we didn‚Äôt write the worker thread code as shown in Listing 20-21.
-->
<p>Ayant appris la boucle <code>while let</code> dans le chapitre 18, vous pourriez
vous demander pourquoi nous n'avons pas √©crit le code des t√¢ches des op√©rateurs
comme dans l'encart 20-21.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,not_desired_behavior
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {} got a job; executing.", id);

                job();
            }
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// -- partie masqu√©e ici --

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || {
            while let Ok(mission) = reception.lock().unwrap().recv() {
                println!(&quot;L'op√©rateur {} a obtenu une mission¬†; il l'ex√©cute.&quot;, id);

                mission();
            }
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-21: An alternative implementation of
`Worker::new` using `while let`</span>
-->
<p><span class="caption">Encart 20-21¬†: une impl√©mentation alternative de
<code>Operateur::new</code> qui utilise <code>while let</code></span></p>
<!--
This code compiles and runs but doesn‚Äôt result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the `Mutex` struct has no public
`unlock` method because the ownership of the lock is based on the lifetime of
the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock`
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a `Mutex` cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don‚Äôt think carefully about the lifetime of the
`MutexGuard<T>`.
-->
<p>Ce code se compile et s'ex√©cute mais ne se produit pas le comportement des
t√¢ches que nous souhaitons¬†: une requ√™te lente √† traiter va continuer √† mettre
en attente de traitement les autres requ√™tes. La raison √† cela est subtile¬†: la
structure <code>Mutex</code> n'a pas de m√©thode publique <code>unlock</code> car la propri√©t√© du
verrou se base sur la dur√©e de vie du <code>MutexGuard&lt;T&gt;</code> au sein du
<code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> que retourne la m√©thode <code>lock</code>. A la compilation,
le v√©rificateur d'emprunt peut ensuite v√©rifier la r√®gle qui dit qu'une
ressource gard√©e par un <code>Mutex</code> ne peut √™tre accessible que si nous avons ce
verrou. Mais cette impl√©mentation peut aussi conduire √† ce que nous gardions le
verrou plus longtemps que pr√©vu si nous ne r√©fl√©chissons pas avec attention √†
la dur√©e de vie du <code>MutexGuard&lt;T&gt;</code>.</p>
<!--
The code in Listing 20-20 that uses `let job =
receiver.lock().unwrap().recv().unwrap();` works because with `let`, any
temporary values used in the expression on the right hand side of the equals
sign are immediately dropped when the `let` statement ends. However, `while
let` (and `if let` and `match`) does not drop temporary values until the end of
the associated block. In Listing 20-21, the lock remains held for the duration
of the call to `job()`, meaning other workers cannot receive jobs.
-->
<p>Le code de l'encart 20-20 qui utilise <code>let mission = reception.lock().unwrap().recv().unwrap();</code> fonctionne, car avec <code>let</code>, toute
valeur temporaire utilis√©e dans la partie droite du signe √©gal est lib√©r√©e
imm√©diatement lorsque l'instruction <code>let</code> se termine. Cependant, <code>while let</code> (
ainsi que <code>if let</code> et <code>match</code>) ne lib√®rent pas les valeurs temporaires avant la
fin du bloc associ√©. Dans l'encart 20-21, le verrou continue √† √™tre maintenu
pendant toute la dur√©e de l'appel √† <code>mission()</code>, ce qui veut dire que les
autres op√©rateurs ne peuvent pas recevoir de t√¢ches.</p>
<!--
[creating-type-synonyms-with-type-aliases]:
ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases
[integer-types]: ch03-02-data-types.html#integer-types
[storing-closures-using-generic-parameters-and-the-fn-traits]:
ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Graceful Shutdown and Cleanup
-->
<h2 id="arr√™t-propre-et-nettoyage"><a class="header" href="#arr√™t-propre-et-nettoyage">Arr√™t propre et nettoyage</a></h2>
<!--
The code in Listing 20-20 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the `workers`,
`id`, and `thread` fields that we‚Äôre not using in a direct way that reminds us
we‚Äôre not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they‚Äôre in the middle of
serving a request.
-->
<p>Le code de l'encart 20-20 r√©pond aux requ√™tes de mani√®re asynchrone gr√¢ce √†
l'utilisation du groupe de t√¢ches, comme nous l'esp√©rions. Nous avons quelques
avertissements sur les champs <code>operateurs</code>, <code>id</code> et <code>t√¢che</code> que nous
n'utilisons pas directement et qui nous rappellent que nous ne nettoyons rien.
Lorsque nous arr√™tons brutalement la t√¢che principale en appuyant sur
<span class="keystroke">ctrl-c</span>, toutes les autres t√¢ches sont √©galement
imm√©diatement stopp√©es, m√™me si elles sont en train de servir une requ√™te.</p>
<!--
Now we‚Äôll implement the `Drop` trait to call `join` on each of the threads in
the pool so they can finish the requests they‚Äôre working on before closing.
Then we‚Äôll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, we‚Äôll modify our server to
accept only two requests before gracefully shutting down its thread pool.
-->
<p>Maintenant, nous allons impl√©menter le trait <code>Drop</code> afin d'appeler <code>join</code> sur chacune
des t√¢ches du groupe afin qu'elles puissent finir les requ√™tes qu'elles
sont en train de traiter avant de s'arr√™ter. Ensuite, nous allons impl√©menter un
moyen de demander aux t√¢ches d'arr√™ter d'accepter de nouvelles requ√™tes et de
s'arr√™ter. Pour voir ce code en action, nous allons modifier notre serveur
pour n'accepter que deux requ√™tes avant d'arr√™ter proprement son groupe de
t√¢ches.</p>
<!--
### Implementing the `Drop` Trait on `ThreadPool`
-->
<h3 id="impl√©menter-le-trait-drop-sur-groupetaches"><a class="header" href="#impl√©menter-le-trait-drop-sur-groupetaches">Impl√©menter le trait <code>Drop</code> sur <code>GroupeTaches</code></a></h3>
<!--
Let‚Äôs start with implementing `Drop` on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-22 shows a first attempt at a `Drop` implementation; this code won‚Äôt
quite work yet.
-->
<p>Commen√ßons par impl√©menter <code>Drop</code> sur notre groupe de t√¢ches. Lorsque le groupe
est nettoy√©, nos t√¢ches doivent toutes faire appel √† <code>join</code> pour s'assurer
qu'elles finissent leur travail. L'encart 20-22 montre une premi√®re tentative
d'impl√©mentation de <code>Drop</code>¬†; ce code ne fonctionne pas encore tout √† fait.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);

            operateur.tache.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'op√©rateur {} a re√ßu une mission ; il l'ex√©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-22: Joining each thread when the thread pool
goes out of scope</span>
-->
<p><span class="caption">Encart 20-22¬†: utilisation de <code>join</code> sur chaque t√¢che
lorsque le groupe de t√¢ches sort de la port√©e</span></p>
<!--
First, we loop through each of the thread pool `workers`. We use `&mut` for
this because `self` is a mutable reference, and we also need to be able to
mutate `worker`. For each worker, we print a message saying that this
particular worker is shutting down, and then we call `join` on that worker‚Äôs
thread. If the call to `join` fails, we use `unwrap` to make Rust panic and go
into an ungraceful shutdown.
-->
<p>D'abord, nous faisons une boucle sur tous les <code>operateurs</code> du groupe de t√¢ches.
Pour ce faire, nous utilisons <code>&amp;mut</code> car <code>self</code> n'est qu'une r√©f√©rence mutable
du groupe de t√¢ches mais nous aurons √©galement besoin de pouvoir muter chaque
<code>operateur</code>. Pour chaque op√©rateur, nous affichons un message qui indique qu'il
s'arr√™te puis nous faisons appel √† <code>join</code> sur la t√¢che de cet op√©rateur. Si
l'appel √† <code>join</code> √©choue, nous utilisons <code>unwrap</code> pour faire paniquer Rust et
ainsi proc√©der √† un arr√™t brutal.</p>
<!--
Here is the error we get when we compile this code:
-->
<p>Voici l'erreur que nous obtenons lorsque nous compilons ce code¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  -- > src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ move occurs because `worker.thread` has type `JoinHandle<()>`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0507]: cannot move out of `operateur.tache` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             operateur.tache.join().unwrap();
   |             ^^^^^^^^^^^^^^^ move occurs because `operateur.tache` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
</code></pre>
<!--
The error tells us we can‚Äôt call `join` because we only have a mutable borrow
of each `worker` and `join` takes ownership of its argument. To solve this
issue, we need to move the thread out of the `Worker` instance that owns
`thread` so `join` can consume the thread. We did this in Listing 17-15: if
`Worker` holds an `Option<thread::JoinHandle<()>>` instead, we can call the
`take` method on the `Option` to move the value out of the `Some` variant and
leave a `None` variant in its place. In other words, a `Worker` that is running
will have a `Some` variant in `thread`, and when we want to clean up a
`Worker`, we‚Äôll replace `Some` with `None` so the `Worker` doesn‚Äôt have a
thread to run.
-->
<p>L'erreur nous informe que nous ne pouvons pas faire appel √† <code>join</code> car nous
avons seulement fait un emprunt mutable pour chacun des <code>operateur</code> alors que
<code>join</code> prend possession de son argument. Pour r√©soudre ce probl√®me, nous devons
sortir la <code>tache</code> de l'instance de <code>Operateur</code> qui la poss√®de afin que <code>join</code>
puisse la consommer. Nous faisons ceci dans l'encart 17-15¬†: comme <code>Operateur</code>
contient d√©sormais un <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, nous pouvons utiliser
la m√©thode <code>take</code> sur <code>Option</code> pour sortir la valeur de la variante <code>Some</code> et
y mettre √† la place une variante <code>None</code>. Autrement dit, un <code>Operateur</code> qui est
en cours d'ex√©cution aura une variante <code>Some</code> dans <code>tache</code>, et lorsque nous
souhaiterons nettoyer <code>Operateur</code>, nous remplacerons <code>Some</code> par <code>None</code> afin que
<code>Operateur</code> n'ait pas de t√¢che √† ex√©cuter.</p>
<!--
So we know we want to update the definition of `Worker` like this:
-->
<p>Donc nous savons que nous voulons modifier la d√©finition de <code>Operateur</code> comme
ceci¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             worker.thread.join().unwrap();
#         }
#     }
# }
# 
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            operateur.tache.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Operateur {
    id: usize,
    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'op√©rateur {} a re√ßu une mission ; il l'ex√©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Now let‚Äôs lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:
-->
<p>Maintenant, aidons-nous du compilateur pour trouver les autres endroits qui ont
besoin de changer. En v√©rifiant ce code, nous obtenons deux erreurs¬†:</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  -- > src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option<JoinHandle<()>>`

error[E0308]: mismatched types
  -- > src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option<JoinHandle<()>>`
            found struct `JoinHandle<_>`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, Some(thread) }
   |                      +++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             operateur.tache.join().unwrap();
   |                             ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Operateur { id, tache }
   |                         ^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Operateur { id, Some(tache) }
   |                         +++++     +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
</code></pre>
<!--
Let‚Äôs address the second error, which points to the code at the end of
`Worker::new`; we need to wrap the `thread` value in `Some` when we create a
new `Worker`. Make the following changes to fix this error:
-->
<p>Corrigeons la seconde erreur, qui se situe dans le code √† la fin de
<code>Operateur::new</code>¬†: nous devons int√©grer la valeur de <code>tache</code> dans un <code>Some</code>
lorsque nous cr√©ons un nouvel <code>Operateur</code>. Faites les changements suivants pour
corriger cette erreur¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             worker.thread.join().unwrap();
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--

#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            operateur.tache.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masqu√©e ici --

<span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'op√©rateur {} a re√ßu une mission ; il l'ex√©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span>        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
The first error is in our `Drop` implementation. We mentioned earlier that we
intended to call `take` on the `Option` value to move `thread` out of `worker`.
The following changes will do so:
-->
<p>La premi√®re erreur se situe dans notre impl√©mentation de <code>Drop</code>. Nous avions
mentionn√© plus t√¥t que nous voulions faire appel √† <code>take</code> sur la valeur de
<code>Option</code> pour d√©placer <code>tache</code> en dehors de <code>operateur</code>. Voici les changements
√† apporter pour ceci¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'op√©rateur {} a re√ßu une mission ; il l'ex√©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
As discussed in Chapter 17, the `take` method on `Option` takes the `Some`
variant out and leaves `None` in its place. We‚Äôre using `if let` to destructure
the `Some` and get the thread; then we call `join` on the thread. If a worker‚Äôs
thread is already `None`, we know that worker has already had its thread
cleaned up, so nothing happens in that case.
-->
<p>Comme nous l'avons vu au chapitre 17, la m√©thode <code>take</code> sur <code>Option</code> sort la
variante <code>Some</code> et laisse un <code>None</code> √† la place. Nous utilisons <code>if let</code> pour
destructurer le <code>Some</code> et obtenir la t√¢che¬†; ensuite nous faisons appel √† <code>join</code>
sur cette t√¢che. Si la t√¢che d'un op√©rateur est d√©j√† un <code>None</code>, nous savons
qu'il a d√©j√† nettoy√© sa t√¢che et que dans ce cas nous n'avons rien √† faire.</p>
<!--
### Signaling to the Threads to Stop Listening for Jobs
-->
<h3 id="demander-aux-t√¢ches-darr√™ter-dattendre-des-missions"><a class="header" href="#demander-aux-t√¢ches-darr√™ter-dattendre-des-missions">Demander aux t√¢ches d'arr√™ter d'attendre des missions</a></h3>
<!--
With all the changes we‚Äôve made, our code compiles without any warnings. But
the bad news is this code doesn‚Äôt function the way we want it to yet. The key
is the logic in the closures run by the threads of the `Worker` instances: at
the moment, we call `join`, but that won‚Äôt shut down the threads because they
`loop` forever looking for jobs. If we try to drop our `ThreadPool` with our
current implementation of `drop`, the main thread will block forever waiting
for the first thread to finish.
-->
<p>Avec tous ces changements, notre code se compile d√©sormais sans aucun
avertissement. Mais la mauvaise nouvelle est que pour l'instant ce code ne
fonctionne comme nous le souhaitons. La cause se situe dans la logique des
fermetures qui sont ex√©cut√©es par les t√¢ches des instances de <code>Operateur</code>¬†:
pour le moment, nous faisons appel √† <code>join</code>, mais cela ne va pas arr√™ter les
t√¢ches car elles font une boucle infinie avec <code>loop</code> pour attendre des
missions. Si nous essayons de nettoyer notre <code>GroupeTaches</code> avec
l'impl√©mentation actuelle de <code>drop</code>, la t√¢che principale va se bloquer pour
toujours en attendant en vain que la premi√®re t√¢che se termine.</p>
<!--
To fix this problem, we‚Äôll modify the threads so they listen for either a `Job`
to run or a signal that they should stop listening and exit the infinite loop.
Instead of `Job` instances, our channel will send one of these two enum
variants.
-->
<p>Pour corriger ce probl√®me, nous allons modifier les t√¢ches pour qu'elles
attendent soit une <code>Mission</code> √† ex√©cuter, soit le signal qui leur dit qu'elles
doivent arr√™ter d'attendre des missions et sortir de la boucle infinie. Notre
canal va envoyer une de ces deux variantes d'√©num√©ration au lieu d'instances de
<code>Mission</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
enum Message {
    NewJob(Job),
    Terminate,
}
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             if let Some(thread) = worker.thread.take() {
#                 thread.join().unwrap();
#             }
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>enum Message {
    NouvelleMission(Mission),
    Extinction,
}
<span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            if let Some(tache) = operateur.tache.take() {
</span><span class="boring">                tache.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'op√©rateur {} a re√ßu une mission ; il l'ex√©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This `Message` enum will either be a `NewJob` variant that holds the `Job` the
thread should run, or it will be a `Terminate` variant that will cause the
thread to exit its loop and stop.
-->
<p>Cette √©num√©ration <code>Message</code> aura pour valeurs une variante <code>NouvelleMission</code>
qui contiendra la <code>Mission</code> que la t√¢che devra ex√©cuter, ou la variante
<code>Extinction</code> qui va faire en sorte que la t√¢che sorte de sa boucle et se
termine.</p>
<!--
We need to adjust the channel to use values of type `Message` rather than type
`Job`, as shown in Listing 20-23.
-->
<p>Nous devons corriger le canal pour utiliser les valeurs du type <code>Message</code>
√† la place du type <code>Mission</code>, comme dans l'encart 20-23.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

// --snip--

# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# enum Message {
#     NewJob(Job),
#     Terminate,
# }
# 
impl ThreadPool {
    // --snip--

#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             if let Some(thread) = worker.thread.take() {
#                 thread.join().unwrap();
#             }
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("Worker {} got a job; executing.", id);

                    job();
                }
                Message::Terminate => {
                    println!("Worker {} was told to terminate.", id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span>pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Message&gt;,
}

// -- partie masqu√©e ici --

<span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NouvelleMission(Mission),
</span><span class="boring">    Extinction,
</span><span class="boring">}
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masqu√©e ici --

<span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
    }
}

// -- partie masqu√©e ici --

<span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            if let Some(tache) = operateur.tache.take() {
</span><span class="boring">                tache.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let message = reception.lock().unwrap().recv().unwrap();

            match message {
                Message::NouvelleMission(mission) =&gt; {
                    println!(&quot;L'op√©rateur {} a re√ßu une mission¬†; il l'ex√©cute.&quot;, id);

                    mission();
                }
                Message::Extinction =&gt; {
                    println!(&quot;L'op√©rateur {} a re√ßu l'instruction d'arr√™t.&quot;, id);

                    break;
                }
            }
        });

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-23: Sending and receiving `Message` values and
exiting the loop if a `Worker` receives `Message::Terminate`</span>
-->
<p><span class="caption">Encart 20-23¬†: envoi et r√©ception de valeurs de <code>Message</code>
et sortie de la boucle si un <code>Operateur</code> re√ßoit <code>Message:Extinction</code></span></p>
<!--
To incorporate the `Message` enum, we need to change `Job` to `Message` in two
places: the definition of `ThreadPool` and the signature of `Worker::new`. The
`execute` method of `ThreadPool` needs to send jobs wrapped in the
`Message::NewJob` variant. Then, in `Worker::new` where a `Message` is received
from the channel, the job will be processed if the `NewJob` variant is
received, and the thread will break out of the loop if the `Terminate` variant
is received.
-->
<p>Pour int√©grer l'√©num√©ration <code>Message</code>, nous devons changer <code>Mission</code> par
<code>Message</code> √† deux endroits¬†: dans la d√©finition de <code>GroupeTaches</code> et dans la
signature de <code>Operateur::new</code>. La m√©thode <code>executer</code> de <code>GroupeTaches</code> doit
envoyer des missions encapsul√©es dans des variantes de
<code>Message::NouvelleTache</code>. Ensuite, dans <code>Operateur::new</code> o√π nous recevons des
<code>Message</code> du canal, la mission sera trait√©e si la variante <code>NouvelleTache</code> est
re√ßue, ou bien la t√¢che arr√™tera la boucle si la variante <code>Extinction</code> est
re√ßue.</p>
<!--
With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-20. But we‚Äôll get a warning because we aren‚Äôt
creating any messages of the `Terminate` variety. Let‚Äôs fix this warning by
changing our `Drop` implementation to look like Listing 20-24.
-->
<p>Gr√¢ce √† ces changements, le code va se compiler et continuer de fonctionner de
la m√™me mani√®re qu'il le faisait apr√®s l'encart 20-20. Mais nous allons obtenir
un avertissement car nous ne cr√©ons aucun message de la variante <code>Extinction</code>.
Corrigeons cet avertissement en modifiant notre impl√©mentation de <code>Drop</code>
pour qu'elle ressemble √† l'encart 20-24.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Message>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# enum Message {
#     NewJob(Job),
#     Terminate,
# }
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(Message::NewJob(job)).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        println!("Sending terminate message to all workers.");

        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!("Shutting down all workers.");

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let message = receiver.lock().unwrap().recv().unwrap();
# 
#             match message {
#                 Message::NewJob(job) => {
#                     println!("Worker {} got a job; executing.", id);
# 
#                     job();
#                 }
#                 Message::Terminate => {
#                     println!("Worker {} was told to terminate.", id);
# 
#                     break;
#                 }
#             }
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NouvelleMission(Mission),
</span><span class="boring">    Extinction,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Cr√©e un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        println!(&quot;Envoi du message d'extinction √† tous les op√©rateurs.&quot;);

        for _ in &amp;self.operateurs {
            self.envoi.send(Message::Extinction).unwrap();
        }

        println!(&quot;Arr√™t de tous les op√©rateurs.&quot;);

        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let message = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            match message {
</span><span class="boring">                Message::NouvelleMission(mission) =&gt; {
</span><span class="boring">                    println!(&quot;L'op√©rateur {} a re√ßu une mission¬†; il l'ex√©cute.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    mission();
</span><span class="boring">                }
</span><span class="boring">                Message::Extinction =&gt; {
</span><span class="boring">                    println!(&quot;L'op√©rateur {} a re√ßu l'instruction d'arr√™t.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-24: Sending `Message::Terminate` to the
workers before calling `join` on each worker thread</span>
-->
<p><span class="caption">Encart 20-24¬†: envoi de <code>Message::Extinction</code> aux
op√©rateurs avant de d'appeler <code>join</code> sur toutes les t√¢ches de ces
op√©rateurs</span></p>
<!--
We‚Äôre now iterating over the workers twice: once to send one `Terminate`
message for each worker and once to call `join` on each worker‚Äôs thread. If we
tried to send a message and `join` immediately in the same loop, we couldn‚Äôt
guarantee that the worker in the current iteration would be the one to get the
message from the channel.
-->
<p>Nous it√©rons deux fois sur les op√©rateurs¬†: une fois pour envoyer un message
<code>Extinction</code> pour chaque op√©rateur, et une seconde fois pour utiliser <code>join</code>
sur leur t√¢che. Si nous avions essay√© d'envoyer le message et d'utiliser
imm√©diatement <code>join</code> dans la m√™me boucle, nous n'aurions pas pu garantir que
l'op√©rateur de l'it√©ration en cours serait celui qui obtiendrait le message
envoy√© dans le canal.</p>
<!--
To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and `join`
called on the first worker‚Äôs thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!
-->
<p>Pour mieux comprendre pourquoi nous avons besoin de deux boucles distinctes,
imaginez un sc√©nario avec deux op√©rateurs. Si nous avions utilis√© une seule
boucle pour it√©rer sur chacun des op√©rateurs, dans la premi√®re it√©ration un
message d'extinction aurait √©t√© envoy√© dans le canal et <code>join</code> aurait √©t√©
utilis√© sur la t√¢che du premier op√©rateur. Si ce premier op√©rateur √©tait occup√©
√† traiter une requ√™te √† ce moment-l√†, le second op√©rateur aurait alors r√©cup√©r√©
le message d'extinction dans le canal et se serait arr√™t√©. Nous serions alors
rest√©s √† attendre que le premier op√©rateur s'arr√™te, mais cela ne se serait
jamais produit car c'est la seconde t√¢che qui aurait obtenu le message
d'extinction. Nous serions alors dans une situation d'interblocage¬†!</p>
<!--
To prevent this scenario, we first put all of our `Terminate` messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before `join` is called on its thread.
-->
<p>Pour √©viter ce sc√©nario, nous allons commencer par √©mettre tous nos messages
<code>Extinction</code> dans le canal en utilisant une boucle¬†; puis nous utilisons <code>join</code>
sur toutes les t√¢ches dans une seconde boucle. Chaque op√©rateur va arr√™ter de
recevoir de nouvelles requ√™tes du canal d√®s qu'il aura re√ßu le message
d'extinction. Donc, nous sommes maintenant assur√©s que si nous envoyons autant
de messages d'extinction qu'il y a d'op√©rateurs, chaque op√©rateur
recevra un message d'extinction avant que <code>join</code> ne soit utilis√© sur leur
t√¢che.</p>
<!--
To see this code in action, let‚Äôs modify `main` to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-25.
-->
<p>Pour observer ce code en action, modifions notre <code>main</code> pour accepter
uniquement deux requ√™tes avant d'arr√™ter proprement le serveur, comme dans
l'encart 20-25.</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/bin/main.rs</span></p>
<!--
```rust,ignore
# use hello::ThreadPool;
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!(
#         "{}\r\nContent-Length: {}\r\n\r\n{}",
#         status_line,
#         contents.len(),
#         contents
#     );
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use salutations::GroupeTaches;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming().take(2) {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }

    println!(&quot;Arr√™t complet.&quot;);
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        ligne_statut,
</span><span class="boring">        contenu.len(),
</span><span class="boring">        contenu
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-25: Shut down the server after serving two
requests by exiting the loop</span>
-->
<p><span class="caption">Encart 20-25¬†: arr√™t du serveur apr√®s avoir servi deux
requ√™tes en sortant de la boucle</span></p>
<!--
You wouldn‚Äôt want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.
-->
<p>Dans la r√©alit√© on ne voudrait pas qu'un serveur web s'arr√™te apr√®s avoir servi
seulement deux requ√™tes. Ce code sert uniquement √† montrer que l'arr√™t et le
nettoyage s'effectuent bien proprement.</p>
<!--
The `take` method is defined in the `Iterator` trait and limits the iteration
to the first two items at most. The `ThreadPool` will go out of scope at the
end of `main`, and the `drop` implementation will run.
-->
<p>La m√©thode <code>take</code> est d√©finie dans le trait <code>Iterator</code> et limite l'it√©ration
aux deux premiers √©l√©ments au maximum. Le <code>GroupeTaches</code> va sortir de la port√©e
√† la fin du <code>main</code> et l'impl√©mentation de <code>drop</code> va s'ex√©cuter.</p>
<!--
Start the server with `cargo run`, and make three requests. The third request
should error, and in your terminal you should see output similar to this:
-->
<p>D√©marrez le serveur avec <code>cargo run</code> et faites trois requ√™tes. La troisi√®me
requ√™te devrait renvoyer une erreur tandis que dans votre terminal vous devriez
avoir une sortie similaire √† ceci¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-- >
-->
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
L'op√©rateur 0 a re√ßu une mission¬†; il l'ex√©cute.
L'op√©rateur 3 a re√ßu une mission¬†; il l'ex√©cute.
Arr√™t.
Envoi du message d'extinction √† tous les op√©rateurs.
Arr√™t de tous les op√©rateurs.
Arr√™t de l'op√©rateur 0
L'op√©rateur 1 a re√ßu l'instruction d'arr√™t.
L'op√©rateur 2 a re√ßu l'instruction d'arr√™t.
L'op√©rateur 0 a re√ßu l'instruction d'arr√™t.
L'op√©rateur 3 a re√ßu l'instruction d'arr√™t.
Arr√™t de l'op√©rateur 1
Arr√™t de l'op√©rateur 2
Arr√™t de l'op√©rateur 3
</code></pre>
<!--
You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the `ThreadPool` goes out of scope at the end of `main`, its
`Drop` implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls `join` to shut down each worker thread.
-->
<p>Vous pourriez avoir un ordre diff√©rent entre les op√©rateurs et les messages
affich√©s. Nous pouvons constater la fa√ßon dont ce code fonctionne gr√¢ce aux
messages¬†: les op√©rateurs 0 et 3 obtiennent les deux premi√®res requ√™tes puis, √†
la troisi√®me requ√™te, le serveur arr√™te d'accepter des connexions. Lorsque
le <code>GroupeTaches</code> sort de la port√©e √† la fin du <code>main</code>, son impl√©mentation de
<code>Drop</code> entre en action et le groupe demande √† tous les op√©rateurs de
s'arr√™ter. Chaque op√©rateur va afficher un message lorsqu'il recevra le message
d'extinction puis le groupe de t√¢che utilisera <code>join</code> pour arr√™ter
la t√¢che de chaque op√©rateur.</p>
<!--
Notice one interesting aspect of this particular execution: the `ThreadPool`
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.
-->
<p>Remarquez un aspect int√©ressant sp√©cifique √† cette ex√©cution¬†: le
<code>GroupeTaches</code> a envoy√© les messages d'extinction dans le canal, et avant que
tous les op√©rateurs aient re√ßu les messages, nous avons essay√© d'utiliser
<code>join</code> sur l'op√©rateur 0. L'op√©rateur 0 n'avait pas encore re√ßu le message
d'extinction, donc la t√¢che principale a attendu que l'op√©rateur 0 finisse.
Pendant ce temps, tous les autres op√©rateurs ont re√ßu les messages
d'extinction. Lorsque l'op√©rateur 0 a fini, la t√¢che principale a attendu que
les autres op√©rateurs se terminent. A ce stade, ils avaient alors tous re√ßu le
message d'extinction et √©taient en mesure de s'arr√™ter.</p>
<!--
Congrats! We‚Äôve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We‚Äôre able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.
-->
<p>F√©licitations¬†! Nous avons maintenant termin√© notre projet¬†; nous avons un
serveur web basique qui utilise un groupe de t√¢ches pour r√©pondre de mani√®re
asynchrone. Nous pouvons demander un arr√™t propre du serveur qui va nettoyer
toutes les t√¢ches du groupe.</p>
<!--
Here‚Äôs the full code for reference:
-->
<p>Voici le code complet afin que vous puissiez vous y r√©f√©rer¬†:</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/bin/main.rs</span></p>
<!--
```rust,ignore
use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><code class="language-rust ignore">use salutations::GroupeTaches;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;

    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if tampon.starts_with(pause) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        ligne_statut,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

enum Message {
    NewJob(Job),
    Terminate,
}

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        println!("Sending terminate message to all workers.");

        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!("Shutting down all workers.");

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("Worker {} got a job; executing.", id);

                    job();
                }
                Message::Terminate => {
                    println!("Worker {} was told to terminate.", id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Message&gt;,
}

type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;

enum Message {
    NouvelleMission(Mission),
    Extinction,
}

impl GroupeTaches {
    /// Cr√©e un nouveau GroupeTaches.
    ///
    /// La taille est le nom de t√¢ches pr√©sentes dans le groupe.
    ///
    /// # Panics
    ///
    /// La fonction `new` devrait paniquer si la taille vaut z√©ro.
    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let reception = Arc::new(Mutex::new(reception));

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
        }

        GroupeTaches { operateurs, envoi }
    }

    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
    }
}

impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        println!(&quot;Envoi du message d'extinction √† tous les op√©rateurs.&quot;);

        for _ in &amp;self.operateurs {
            self.envoi.send(Message::Extinction).unwrap();
        }

        println!(&quot;Arr√™t de tous les op√©rateurs.&quot;);

        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arr√™t de l'op√©rateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}

struct Operateur {
    id: usize,
    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let message = reception.lock().unwrap().recv().unwrap();

            match message {
                Message::NouvelleMission(mission) =&gt; {
                    println!(&quot;L'op√©rateur {} a re√ßu une mission ; il l'ex√©cute.&quot;, id);

                    mission();
                }
                Message::Extinction =&gt; {
                    println!(&quot;L'op√©rateur {} a re√ßu l'instruction d'arr√™t.&quot;, id);

                    break;
                }
            }
        });

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
We could do more here! If you want to continue enhancing this project, here are
some ideas:
-->
<p>Nous aurions pu faire bien plus¬†! Si vous souhaitez continuer √†
am√©liorer ce projet, voici quelques id√©es¬†:</p>
<!--
* Add more documentation to `ThreadPool` and its public methods.
* Add tests of the library‚Äôs functionality.
* Change calls to `unwrap` to more robust error handling.
* Use `ThreadPool` to perform some task other than serving web requests.
* Find a thread pool crate on [crates.io](https://crates.io/) and implement a
  similar web server using the crate instead. Then compare its API and
  robustness to the thread pool we implemented.
-->
<ul>
<li>Ajouter de la documentation √† <code>GroupeTaches</code> et aux m√©thodes publiques.</li>
<li>Ajouter des tests sur les fonctionnalit√©s de la biblioth√®que.</li>
<li>Remplacer les appels √† <code>unwrap</code> pour fournir une meilleure gestion des erreurs.</li>
<li>Utiliser <code>GroupeTaches</code> pour ex√©cuter d'autres t√¢ches que de r√©pondre √† des
requ√™tes web.</li>
<li>Trouver une crate de groupe de t√¢ches <em>(NdT¬†: thread pool)</em> sur
<a href="https://crates.io/">crates.io</a> et impl√©menter un serveur web similaire en
l'utilisant. Comparer ensuite son API et sa robustesse au
groupe de t√¢ches que nous avons impl√©ment√©.</li>
</ul>
<!--
## Summary
-->
<h2 id="r√©sum√©-19"><a class="header" href="#r√©sum√©-19">R√©sum√©</a></h2>
<!--
Well done! You‚Äôve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You‚Äôre now ready to implement your own Rust
projects and help with other peoples‚Äô projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.
-->
<p>Bravo¬†! Vous √™tes arriv√© √† la fin du livre¬†! Nous tenons √† vous remercier
chaleureusement de nous avoir accompagn√© pendant cette pr√©sentation de Rust.
Vous √™tes maintenant fin pr√™t(e) √† cr√©er vos propres projets Rust et aider les
projets des autres d√©veloppeurs. Rappelez-vous qu'il existe une communaut√©
accueillante de Rustac√©s qui adorerait vous aider √† relever tous les d√©fis que vous
rencontrerez dans votre aventure avec Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Appendix
-->
<h1 id="annexes"><a class="header" href="#annexes">Annexes</a></h1>
<!--
The following sections contain reference material you may find useful in your
Rust journey.
-->
<p>Les sections suivantes contiennent des informations de r√©f√©rence que vous pourriez
trouver utile pour votre exploration de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix A: Keywords
-->
<h2 id="annexe-a--les-mots-cl√©s"><a class="header" href="#annexe-a--les-mots-cl√©s">Annexe A¬†: les mots-cl√©s</a></h2>
<!--
The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as we‚Äôll discuss in the ‚Äú[Raw
Identifiers][raw-identifiers]<!-- ignore -- >‚Äù section), including names of
functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.
-->
<p>La liste suivante contient des mots-cl√©s r√©serv√©s qui sont actuellement
utilis√©s dans le langage Rust ou qui pourraient l'√™tre √† l'avenir. De ce fait, 
ils ne peuvent pas √™tre utilis√©s comme identificateurs (sauf comme identificateurs bruts, ce que
nous allons voir dans la section
‚Äú<a href="appendix-01-keywords.html#les-identificateurs-bruts">les identificateurs bruts</a><!-- ignore -->‚Äù), y compris pour les
noms de fonctions, de variables, de param√®tres, de champs de structures, de
modules, de crates, de constantes, de macros, de valeurs statiques, d'attributs,
de types, de traits ou de dur√©es de vie.</p>
<!--
[raw-identifiers]: #raw-identifiers
-->
<!--
### Keywords Currently in Use
-->
<h3 id="les-mots-cl√©s-actuellement-utilis√©s"><a class="header" href="#les-mots-cl√©s-actuellement-utilis√©s">Les mots-cl√©s actuellement utilis√©s</a></h3>
<!--
The following keywords currently have the functionality described.
-->
<p>Les mots-cl√©s suivants ont actuellement la fonction d√©crite.</p>
<!--
* `as` - perform primitive casting, disambiguate the specific trait containing
  an item, or rename items in `use` and `extern crate` statements
* `async` -  return a `Future` instead of blocking the current thread
* `await` - suspend execution until the result of a `Future` is ready
* `break` - exit a loop immediately
* `const` - define constant items or constant raw pointers
* `continue` - continue to the next loop iteration
* `crate` - link an external crate or a macro variable representing the crate in
  which the macro is defined
* `dyn` - dynamic dispatch to a trait object
* `else` - fallback for `if` and `if let` control flow constructs
* `enum` - define an enumeration
* `extern` - link an external crate, function, or variable
* `false` - Boolean false literal
* `fn` - define a function or the function pointer type
* `for` - loop over items from an iterator, implement a trait, or specify a
  higher-ranked lifetime
* `if` - branch based on the result of a conditional expression
* `impl` - implement inherent or trait functionality
* `in` - part of `for` loop syntax
* `let` - bind a variable
* `loop` - loop unconditionally
* `match` - match a value to patterns
* `mod` - define a module
* `move` - make a closure take ownership of all its captures
* `mut` - denote mutability in references, raw pointers, or pattern bindings
* `pub` - denote public visibility in struct fields, `impl` blocks, or modules
* `ref` - bind by reference
* `return` - return from function
* `Self` - a type alias for the type we are defining or implementing
* `self` - method subject or current module
* `static` - global variable or lifetime lasting the entire program execution
* `struct` - define a structure
* `super` - parent module of the current module
* `trait` - define a trait
* `true` - Boolean true literal
* `type` - define a type alias or associated type
* `union` - define a [union] and is only a keyword when used in a union declaration
* `unsafe` - denote unsafe code, functions, traits, or implementations
* `use` - bring symbols into scope
* `where` - denote clauses that constrain a type
* `while` - loop conditionally based on the result of an expression
-->
<ul>
<li><code>as</code> - effectue une transformation de type primitive, pr√©cise le trait qui contient un
√©l√©ment ou renomme des √©l√©ments dans les instructions <code>use</code> et <code>extern crate</code></li>
<li><code>async</code> - retourne un <code>Future</code> plut√¥t que de bloquer la t√¢che en cours</li>
<li><code>await</code> - met en pause l'ex√©cution jusqu'√† ce que le r√©sultat d'un <code>Future</code>
soit disponible</li>
<li><code>break</code> - sort imm√©diatement d'une boucle</li>
<li><code>const</code> - d√©finit des √©l√©ments constants ou des pointeurs bruts constants</li>
<li><code>continue</code> - passe directement √† la prochaine it√©ration de la boucle en cours</li>
<li><code>crate</code> - cr√©e un lien vers une crate externe ou une variable de macro qui
repr√©sente la crate dans laquelle la macro est d√©finie</li>
<li><code>dyn</code> - utilisation dynamique d'un objet trait</li>
<li><code>else</code> - une branche de repli pour les structures de contr√¥le de flux <code>if</code>
et <code>if let</code></li>
<li><code>enum</code> - d√©finit une √©num√©ration</li>
<li><code>extern</code> - cr√©e un lien vers une crate, une fonction ou une variable externe</li>
<li><code>false</code> - le litt√©ral qui vaut ‚Äúfaux‚Äù pour un bool√©en</li>
<li><code>fn</code> - d√©finit une fonction ou le type pointeur de fonction</li>
<li><code>for</code> - cr√©e une boucle sur les √©l√©ments d'un it√©rateur, impl√©mente un trait,
ou renseigne une dur√©e de vie de niveau sup√©rieur</li>
<li><code>if</code> - une branche li√©e au r√©sultat d'une expression conditionnelle</li>
<li><code>impl</code> - impl√©mente des fonctionnalit√©s propres √† un √©l√©ment ou √† un trait</li>
<li><code>in</code> - fait partie de la syntaxe de la boucle <code>for</code></li>
<li><code>let</code> - lie une valeur √† une variable</li>
<li><code>loop</code> - fait une boucle sans condition (th√©oriquement infinie)</li>
<li><code>match</code> - compare une valeur √† des motifs</li>
<li><code>mod</code> - d√©finit un module</li>
<li><code>move</code> - fait en sorte qu'une fermeture prenne possession de tout ce qu'elle
utilise</li>
<li><code>mut</code> - autorise la mutabilit√© sur des r√©f√©rences, des pointeurs bruts ou des
√©l√©ments issus de motifs</li>
<li><code>pub</code> - autorise la visibilit√© publique sur des champs de structures, des
blocs <code>impl</code> ou des modules</li>
<li><code>ref</code> - lie une valeur avec une r√©f√©rence</li>
<li><code>return</code> - retourne une valeur depuis une fonction</li>
<li><code>Self</code> - un alias de type pour le type que nous d√©finissons ou impl√©mentons</li>
<li><code>self</code> - d√©signe le sujet d'une m√©thode ou du module courant</li>
<li><code>static</code> - une variable globale ou une dur√©e de vie qui persiste tout au long de
l'ex√©cution du programme</li>
<li><code>struct</code> - d√©finit une structure</li>
<li><code>super</code> - le module parent du module courant</li>
<li><code>trait</code> - d√©finit un trait</li>
<li><code>true</code> - le litt√©ral qui vaut ‚Äúvrai‚Äù pour un bool√©en</li>
<li><code>type</code> - d√©finit un alias de type ou un type associ√©</li>
<li><code>union</code> - d√©finit une <a href="https://doc.rust-lang.org/reference/items/unions.html">union</a> mais n'est un mot-cl√© que lorsqu'il est utilis√©
dans la d√©claration d'une union</li>
<li><code>unsafe</code> - autorise du code, des fonctions, des traits ou des impl√©mentations
non s√©curis√©es</li>
<li><code>use</code> - importe des √©l√©ments dans la port√©e</li>
<li><code>where</code> - indique des conditions pour contraindre un type</li>
<li><code>while</code> - cr√©e une boucle en fonction des r√©sultats d'une expression</li>
</ul>
<!--
[union]: ../reference/items/unions.html
-->
<!--
### Keywords Reserved for Future Use
-->
<h3 id="les-mots-cl√©s-r√©serv√©s-pour-une-utilisation-future"><a class="header" href="#les-mots-cl√©s-r√©serv√©s-pour-une-utilisation-future">Les mots-cl√©s r√©serv√©s pour une utilisation future</a></h3>
<!--
The following keywords do not have any functionality but are reserved by Rust
for potential future use.
-->
<p>Les mots-cl√©s suivants n'offrent actuellement aucune fonctionnalit√© mais sont
r√©serv√©s par Rust pour une potentielle utilisation future.</p>
<!--
* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`
-->
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<!--
### Raw Identifiers
-->
<h3 id="les-identificateurs-bruts"><a class="header" href="#les-identificateurs-bruts">Les identificateurs bruts</a></h3>
<!--
*Raw identifiers* are the syntax that lets you use keywords where they wouldn‚Äôt
normally be allowed. You use a raw identifier by prefixing a keyword with `r#`.
-->
<p>Un <em>identificateur brut</em> est une syntaxe qui vous permet d'utiliser des
mots-cl√©s l√† o√π ils ne devraient pas pouvoir l'√™tre. Vous pouvez utiliser un
identificateur brut en faisant pr√©c√©der un mot-cl√© par un <code>r#</code>.</p>
<!--
For example, `match` is a keyword. If you try to compile the following function
that uses `match` as its name:
-->
<p>Par exemple, <code>match</code> est un mot-cl√©. Si vous essayez de compiler la fonction
suivante qui utilise <code>match</code> comme nom¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
    botte_de_foin.contains(aiguille)
}
</code></pre>
<!--
you‚Äôll get this error:
-->
<p>‚Ä¶ vous allez obtenir l'erreur suivante¬†:</p>
<!--
```text
error: expected identifier, found keyword `match`
 -- > src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```
-->
<pre><code class="language-text">error: expected identifier, found keyword `match`
 -- &gt; src/main.rs:4:4
  |
4 | fn match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<!--
The error shows that you can‚Äôt use the keyword `match` as the function
identifier. To use `match` as a function name, you need to use the raw
identifier syntax, like this:
-->
<p>L'erreur montre que vous ne pouvez pas utiliser le mot-cl√© <code>match</code> comme
identificateur de la fonction. Pour utiliser <code>match</code> comme nom de fonction, vous
devez utiliser la syntaxe d'identificateur brut, comme ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn r#match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
    botte_de_foin.contains(aiguille)
}

fn main() {
    assert!(r#match(&quot;rem&quot;, &quot;lorem ipsum&quot;));
}
</code></pre></pre>
<!--
This code will compile without any errors. Note the `r#` prefix on the function
name in its definition as well as where the function is called in `main`.
-->
<p>Ce code va se compiler sans erreur. Remarquez le pr√©fixe <code>r#</code> sur le nom de la
fonction dans sa d√©finition mais aussi lorsque cette fonction est appel√©e dans
<code>main</code>.</p>
<!--
Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, `try` isn‚Äôt a keyword in the 2015 edition but is in the 2018
edition. If you depend on a library that‚Äôs written using the 2015 edition and
has a `try` function, you‚Äôll need to use the raw identifier syntax, `r#try` in
this case, to call that function from your 2018 edition code. See [Appendix
E][appendix-e]<!-- ignore -- > for more information on editions.
-->
<p>Les identificateurs bruts vous permettent d'utiliser n'importe quel mot de votre choix
comme identificateur, m√™me si ce mot est un mot-cl√© r√©serv√©. De plus,
les identificateurs bruts vous permettent d'utiliser des biblioth√®ques √©crites
dans des √©ditions de Rust diff√©rentes de celle qu'utilise votre crate. Par
exemple, <code>try</code> n'est pas un mot-cl√© dans l'√©dition 2015, mais il l'est dans
l'√©dition 2018. Si vous d√©pendez d'une biblioth√®que qui √©tait √©crite avec
l'√©dition 2015 et qui avait une fonction <code>try</code>, vous allez avoir besoin dans ce cas
d'utiliser la syntaxe d'identificateur brut <code>r#try</code> pour faire
appel √† cette fonction √† partir de code √©crit avec l'√©dition 2018. Voir
<a href="appendix-05-editions.html">l'annexe E</a><!-- ignore --> pour en savoir plus sur les √©ditions.</p>
<!--
[appendix-e]: appendix-05-editions.html
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fra√Æche-"><a class="header" href="#-attention-peinture-fra√Æche-">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/223">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix B: Operators and Symbols
-->
<h2 id="annexe-b--les-op√©rateurs-et-les-symboles"><a class="header" href="#annexe-b--les-op√©rateurs-et-les-symboles">Annexe B¬†: les op√©rateurs et les symboles</a></h2>
<!--
This appendix contains a glossary of Rust‚Äôs syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.
-->
<p>Cette annexe contient un glossaire de syntaxes Rust, comprenant les op√©rateurs
et les autres symboles qui s'utilisent tout seuls ou alors dans le cadre de
chemins, de g√©n√©riques, de traits li√©s, de macros, d'attributs, de commentaires,
de tuples, de crochets ou d'accolades.</p>
<!--
### Operators
-->
<h3 id="op√©rateurs"><a class="header" href="#op√©rateurs">Op√©rateurs</a></h3>
<!--
Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.
-->
<p>Le tableau B-1 contient une liste d'op√©rateurs en Rust, un exemple de comment
l'op√©rateur devrait √™tre utilis√© dans ce contexte, une petite explication, et si
cet op√©rateur est surchargeable. Si un op√©rateur est surchargeable, le trait
concern√© √† utiliser pour la surcharge est indiqu√©.</p>
<!--
<span class="caption">Table B-1: Operators</span>
-->
<p><span class="caption">Tableau B-1¬†: les op√©rateurs</span></p>
<!--
| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!` | `!expr` | Bitwise or logical complement | `Not` |
| `!=` | `var != expr` | Nonequality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Borrow | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&` | `expr && expr` | Short-circuiting logical AND | |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*` | `*expr` | Dereference | |
| `*` | `*const type`, `*mut type` | Raw pointer | |
| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,` | `expr, expr` | Argument and element separator | |
| `-` | `- expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type | |
| `.` | `expr.ident` | Member access | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | |
| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | |
| `..` | `..expr` | Struct literal update syntax | |
| `..` | `variant(x, ..)`, `struct_type { x, .. }` | ‚ÄúAnd the rest‚Äù pattern binding | |
| `...` | `expr...expr` | In a pattern: inclusive range pattern | |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Constraints | |
| `:` | `ident: expr` | Struct field initializer | |
| `:` | `'a: loop {...}` | Loop label | |
| `;` | `expr;` | Statement and item terminator | |
| `;` | `[...; len]` | Part of fixed-size array syntax | |
| `<<` | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax | |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>` | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@` | `ident @ pat` | Pattern binding | |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| <code>&vert;</code> | <code>pat &vert; pat</code> | Pattern alternatives | |
| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` |
| <code>&vert;=</code> | <code>var &vert;= expr</code> | Bitwise OR and assignment | `BitOrAssign` |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-circuiting logical OR | |
| `?` | `expr?` | Error propagation | |
-->
<table><thead><tr><th>Op√©rateur</th><th>Exemple</th><th>Explication</th><th>Surchargeable ?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Identificateur de macro</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>N√©gation binaire ou logique</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Comparaison de non-√©galit√©</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Reste arithm√©tique</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Reste arithm√©tique et assignation</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Emprunt</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Type de pointeur emprunt√©</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>ET binaire</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>ET binaire et assignation</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>ET logique</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Multiplication arithm√©tique</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Multiplication arithm√©tique et assignation</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>D√©r√©f√©rencement</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Pointeur brut</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Contrainte de type compos√©</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Addition arithm√©tique</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Addition arithm√©tique et assignation</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>S√©parateur d'arguments et d'√©l√©ments</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>N√©gation arithm√©tique</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Soustraction arithm√©tique</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Soustraction arithm√©tique et assignation</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Type de retour de fonction et de fermeture</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Acc√®s √† un membre</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Litt√©ral d'intervalle d'exclusion</td><td></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Litt√©ral d'intervalle d'inclusion</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Syntaxe de mise √† jour de lit√©raux de structure</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Motif ‚Äúainsi que la suite‚Äù</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>Dans un motif¬†: motif d'intervalle inclusif</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Division arithm√©tique</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Division arithm√©tique et assignation</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Contrainte</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Initialisateur de champ de structure</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Une identification de boucle</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Fin d'√©l√©ment et d'instruction</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Syntaxe d√©signant une partie d'un tableau √† taille finie</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>D√©calage √† gauche</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>D√©calage √† gauche et assignation</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Comparaison &quot;inf√©rieur √†&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Comparaison &quot;inf√©rieur ou √©gal √†&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignation ou √©quivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Comparaison d'√©galit√©</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Syntaxe d'une partie d'une branche correspondante</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Comparaison &quot;sup√©rieur √†&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Comparaison &quot;sup√©rieur ou √©gal √†&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>D√©calage √† droite</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>D√©calage √† droite et assignation</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Cr√©ation d'un identificateur √† partir du motif</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>OU exclusif binaire</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>OU exclusif binaire et assignation</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Alternatives √† un motif</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>OU binaire</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>OU binaire et assignation</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>OU logique</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Propagation d'erreur</td><td></td></tr>
</tbody></table>
<!--
### Non-operator Symbols
-->
<h3 id="les-symboles-non-op√©rateurs"><a class="header" href="#les-symboles-non-op√©rateurs">Les symboles non-op√©rateurs</a></h3>
<!--
The following list contains all non-letters that don‚Äôt function as operators;
that is, they don‚Äôt behave like a function or method call.
-->
<p>La liste suivante contient tout ce qui n'est pas une lettre et qui ne fonctionne
pas comme un op√©rateur¬†; autrement dit tout ce qui ne se comporte pas comme un
appel de fonction ou de m√©thode.</p>
<!--
Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.
-->
<p>Le tableau B-2 montre des symboles qui s'utilisent tout seuls et qui sont
valables dans plusieurs situations.</p>
<!--
<span class="caption">Table B-2: Stand-Alone Syntax</span>
-->
<p><span class="caption">Tableau B-2¬†: syntaxes autonomes</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| <code>&vert;...&vert; expr</code> | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | ‚ÄúIgnored‚Äù pattern binding; also used to make integer literals readable |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Nom d'une dur√©e de vie ou nom boucle</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Nombre litt√©ral d'un type sp√©cifique</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Cha√Æne de caract√®re litt√©rale</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Cha√Æne de caract√®res brute litt√©rale, les caract√®res d'√©chappement ne sont pas trait√©s</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Cha√Æne d'octet litt√©ral¬†; construit un <code>[u8]</code> au lieu d'une cha√Æne de caract√®res</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Cha√Æne d'octets brute litt√©rale, combinaison de la cha√Æne d'octets brute et de la cha√Æne d'octets litt√©rale</td></tr>
<tr><td><code>'...'</code></td><td>Caract√®re litt√©ral</td></tr>
<tr><td><code>b'...'</code></td><td>Octet ASCII litt√©ral</td></tr>
<tr><td><code>|...| expr</code></td><td>Une fermeture</td></tr>
<tr><td><code>!</code></td><td>Le type ‚Äújamais&quot;, toujours vide pour les fonctions divergentes</td></tr>
<tr><td><code>_</code></td><td>Le motif ‚Äúignor√©&quot;¬†; aussi utilis√© pour rendre lisibles les nombres entiers litt√©raux</td></tr>
</tbody></table>
<!--
Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.
-->
<p>Le tableau B-3 montre des symboles qui s'utilisent dans le contexte d'un chemin
dans une structure de modules pour obtenir un √©l√©ment.</p>
<!--
<span class="caption">Table B-3: Path-Related Syntax</span>
-->
<p><span class="caption">Tableau B-3¬†: syntaxes utilis√©s pour les chemins</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which it‚Äôs defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Chemin d'un espace de nom</td></tr>
<tr><td><code>::path</code></td><td>Chemin relatif √† la crate racine (c'est √† dire un chemin explicitement absolu)</td></tr>
<tr><td><code>self::path</code></td><td>Chemin relatif au module courant (c'est √† dire un chemin explicitement relatif)</td></tr>
<tr><td><code>super::path</code></td><td>Chemin relatif au parent du module courant</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Des constantes, fonctions et types associ√©es</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Un √©l√©ment associ√© pour un type qui ne peut pas √™tre directement nomm√© (par exemple, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Clarifier l'appel d'une m√©thode en nommant le trait qui le d√©finit</td></tr>
<tr><td><code>type::method(...)</code></td><td>Clarifier l'appel d'une fonction en nommant le type pour laquelle elle est d√©finie</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Clarifier l'appel d'une m√©thode en nommant le trait et le type</td></tr>
</tbody></table>
<!--
Table B-4 shows symbols that appear in the context of using generic type
parameters.
-->
<p>Le tableau B-4 montre des symboles qui apparaissent dans le contexte
d'utilisation de param√®tres de type g√©n√©riques.</p>
<!--
<span class="caption">Table B-4: Generics</span>
-->
<p><span class="caption">Tableau B-4¬†: g√©n√©riques</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Pr√©cise des param√®tres sur un type g√©n√©rique utilis√© dans un type (par exemple, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Pr√©cise des param√®tres sur un type g√©n√©rique, une fonction, ou une m√©thode dans une expression¬†; parfois appel√© turbofish (par exemple, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>D√©finit une fonction g√©n√©rique</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>D√©finit une structure g√©n√©rique</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>D√©finit une √©num√©ration g√©n√©rique</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>D√©finit une impl√©mentation g√©n√©rique</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Augmente la dur√©e de vie</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Un type g√©n√©rique sur lequel un ou plusieurs types associ√©s ont des affectations sp√©cifiques (par exemple, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<!--
Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.
-->
<p>Le tableau B-5 montre des symboles qui s'utilisent pour contraindre des
param√®tres de type g√©n√©riques avec des traits li√©s.</p>
<!--
<span class="caption">Table B-5: Trait Bound Constraints</span>
-->
<p><span class="caption">Tableau B-5¬†: contraintes de trait li√©</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T : 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Param√®tre g√©n√©rique <code>T</code> contraint aux types qui impl√©mentent <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Type g√©n√©rique <code>T</code> doit vivre aussi longtemps que la dur√©e de vie <code>'a</code> (ce qui signifie que le type ne peut pas contenir temporairement de r√©f√©rences avec une dur√©e de vie plus petite que <code>'a</code>)</td></tr>
<tr><td><code>T : 'static</code></td><td>Type g√©n√©rique <code>T</code> qui ne contient pas d'autres r√©f√©rences emprunt√©es autres que des <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>La dur√©e de vie g√©n√©rique <code>'b</code> doit vivre aussi longtemps que <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Permet aux param√®tres de type g√©n√©riques d'√™tre de type √† taille dynamique</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Contrainte de type compos√©</td></tr>
</tbody></table>
<!--
Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.
-->
<p>Le tableau B-6 montre des symboles qui s'utilisent lors de l'appel ou de la
d√©finition de macros et pour sp√©cifier des attributs sur un √©l√©ment.</p>
<!--
<span class="caption">Table B-6: Macros and Attributes</span>
-->
<p><span class="caption">Tableau B-6¬†: macros et attributs</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(‚Ä¶)‚Ä¶` | Macro repetition |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Attribut externe</td></tr>
<tr><td><code>#![meta]</code></td><td>Attribut interne</td></tr>
<tr><td><code>$ident</code></td><td>Substitution de macro</td></tr>
<tr><td><code>$ident:kind</code></td><td>Capture de macro</td></tr>
<tr><td><code>$(‚Ä¶)‚Ä¶</code></td><td>R√©p√©tition de macro</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Appel d'une macro</td></tr>
</tbody></table>
<!--
Table B-7 shows symbols that create comments.
-->
<p>Le tableau B-7 montre des symboles pour cr√©er des commentaires.</p>
<!--
<span class="caption">Table B-7: Comments</span>
-->
<p><span class="caption">Tableau B-7¬†: commentaires</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Ligne comment√©e</td></tr>
<tr><td><code>//!</code></td><td>Commentaire de documentation sur l'√©l√©ment contenant actuel</td></tr>
<tr><td><code>///</code></td><td>Commentaire de documentation sur l'√©l√©ment suivant ce commentaire</td></tr>
<tr><td><code>/*...*/</code></td><td>Bloc de commentaire</td></tr>
<tr><td><code>/*!...*/</code></td><td>Bloc de commentaire de documentation sur l'√©l√©ment contenant actuel</td></tr>
<tr><td><code>/**...*/</code></td><td>Bloc de commentaire de documentation sur l'√©l√©ment suivant ce commentaire</td></tr>
</tbody></table>
<!--
Table B-8 shows symbols that appear in the context of using tuples.
-->
<p>Le tableau B-8 montre des symboles utilis√©s avec les tuples.</p>
<!--
<span class="caption">Table B-8: Tuples</span>
-->
<p><span class="caption">Tableau B-8¬†: les tuples</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Un tuple vide (aussi appel√© unitaire), √† la fois un type et un lit√©ral</td></tr>
<tr><td><code>(expr)</code></td><td>Une expression entre parenth√®ses</td></tr>
<tr><td><code>(expr,)</code></td><td>Un tuple d'un seul √©lement qui est une expression</td></tr>
<tr><td><code>(type,)</code></td><td>Un tuple d'un seul √©lement qui est un type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Une expression dans un tuple</td></tr>
<tr><td><code>(type, ...)</code></td><td>Un type dans un tuple</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Une expression d'appel √† une fonction¬†; aussi utilis√© pour initialiser une structure tuple ou une variante d'√©num√©ration tuple</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Utilisation d'indices sur un tuple</td></tr>
</tbody></table>
<!--
Table B-9 shows the contexts in which curly braces are used.
-->
<p>Le tableau B-9 montre les contextes d'utilisation des accolades.</p>
<!--
<span class="caption">Table B-9: Curly Brackets</span>
-->
<p><span class="caption">Tableau B-9¬†: accolades</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Bloc d'expression</td></tr>
<tr><td><code>Type {...}</code></td><td>Un litt√©ral de <code>struct</code></td></tr>
</tbody></table>
<!--
Table B-10 shows the contexts in which square brackets are used.
-->
<p>Le tableau B-10 montre les contextes d'utilisation des crochets.</p>
<!--
<span class="caption">Table B-10: Square Brackets</span>
-->
<p><span class="caption">Tableau B-10¬†: crochets</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the ‚Äúindex‚Äù |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Un litt√©ral de tableau</td></tr>
<tr><td><code>[expr; len]</code></td><td>Un litt√©ral de tableau qui contient <code>len</code> copies de <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Un type de tableau qui contient <code>len</code> instances de <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Une collection index√©e. C'est surchargeable (via <code>Index</code> et <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Une collection index√©e qui se comporte comme une slice de collection, gr√¢ce √† l'utilisation de <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, ou de <code>RangeFull</code> comme ‚Äúindice‚Äù</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fra√Æche--1"><a class="header" href="#-attention-peinture-fra√Æche--1">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/224">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix C: Derivable Traits
-->
<h2 id="annexe-c--les-traits-d√©rivables"><a class="header" href="#annexe-c--les-traits-d√©rivables">Annexe C¬†: les traits d√©rivables</a></h2>
<!--
In various places in the book, we‚Äôve discussed the `derive` attribute, which
you can apply to a struct or enum definition. The `derive` attribute generates
code that will implement a trait with its own default implementation on the
type you‚Äôve annotated with the `derive` syntax.
-->
<p>Dans de nombreux endroits du livre, nous avons vu l'attribut <code>derive</code>, que vous
pouvez appliquer √† une d√©finition de structure ou d'√©num√©ration. L'attribut
<code>derive</code> g√©n√®re du code qui va impl√©menter un trait avec sa propre
impl√©mentation par d√©faut sur le type que vous avez annot√© avec la syntaxe
<code>derive</code>.</p>
<!--
In this appendix, we provide a reference of all the traits in the standard
library that you can use with `derive`. Each section covers:
-->
<p>Dans cette annexe, nous allons produire une r√©f√©rence de tous les traits de la
biblioth√®que standard que vous pouvez utiliser avec <code>derive</code>. Chaque section
va donner¬†:</p>
<!--
* What operators and methods deriving this trait will enable
* What the implementation of the trait provided by `derive` does
* What implementing the trait signifies about the type
* The conditions in which you‚Äôre allowed or not allowed to implement the trait
* Examples of operations that require the trait
-->
<ul>
<li>Quels op√©rateurs et m√©thodes seront activ√©s en d√©rivant de ce trait</li>
<li>Ce que fait l'impl√©mentation du trait appliqu√© par le <code>derive</code></li>
<li>Ce que l'impl√©mentation du trait implique sur le type concern√©</li>
<li>Les conditions dans lesquelles vous pouvez ou non impl√©menter le trait</li>
<li>Des exemples d'op√©rations qui n√©cessitent que le trait soit impl√©ment√©</li>
</ul>
<!--
If you want different behavior from that provided by the `derive` attribute,
consult the [standard library documentation](../std/index.html)<!-- ignore -- >
for each trait for details of how to manually implement them.
-->
<p>Si vous souhaitez appliquer un comportement diff√©rent de celui fourni par
l'attribut <code>derive</code>, consultez <a href="https://doc.rust-lang.org/std/index.html">la documentation de la biblioth√®que
standard</a><!-- ignore --> pour le trait
concern√© afin d'en savoir plus sur son impl√©mentation manuelle.</p>
<!--
The rest of the traits defined in the standard library can‚Äôt be implemented on
your types using `derive`. These traits don‚Äôt have sensible default behavior,
so it‚Äôs up to you to implement them in the way that makes sense for what you‚Äôre
trying to accomplish.
-->
<p>Le reste des traits d√©finis dans la biblioth√®que standard ne peuvent pas √™tre
impl√©ment√©s sur des types en utilisant <code>derive</code>. Ces traits n'ont pas de
comportement logique par d√©faut, donc c'est √† vous de les impl√©menter de la
fa√ßon la plus appropri√©e pour ce que vous souhaitez accomplir.</p>
<!--
An example of a trait that can‚Äôt be derived is `Display`, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn‚Äôt have this insight, so
it can‚Äôt provide appropriate default behavior for you.
-->
<p>Un exemple de trait qui ne peut pas √™tre d√©riv√© est <code>Display</code>, qui permet de
formater la donn√©e pour les utilisateurs finaux. Vous devez toujours r√©fl√©chir
au formatage du type le plus appropri√© pour un utilisateur final. Quelles
parties d'un type un utilisateur final devrait pouvoir voir¬†? Sous quelle forme
les donn√©es devraient √™tre les plus int√©ressantes pour eux¬†? Le compilateur de
Rust n'a pas cette intuition, donc il ne peut pas fournir un comportement par
d√©faut √† votre place.</p>
<!--
The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement `derive` for their own traits, making the list of
traits you can use `derive` with truly open-ended. Implementing `derive`
involves using a procedural macro, which is covered in the
[‚ÄúMacros‚Äù][macros]<!-- ignore -- > section of Chapter 19.
-->
<p>La liste des traits d√©rivables fournis dans cette annexe n'est pas exhaustive¬†:
les biblioth√®ques peuvent impl√©menter <code>derive</code> pour leurs propres traits,
√©tendant potentiellement √† l'infini la liste de traits que vous pouvez utiliser
avec <code>derive</code>. L'impl√©mentation de <code>derive</code> implique l'utilisation d'une macro
proc√©durale, que nous avons vu dans <a href="ch19-06-macros.html">une section</a><!-- ignore --> du
chapitre 19.</p>
<!--
### `Debug` for Programmer Output
-->
<h3 id="debug-pour-laffichage-au-d√©veloppeur"><a class="header" href="#debug-pour-laffichage-au-d√©veloppeur"><code>Debug</code> pour l'affichage au d√©veloppeur</a></h3>
<!--
The `Debug` trait enables debug formatting in format strings, which you
indicate by adding `:?` within `{}` placeholders.
-->
<p>Le trait <code>Debug</code> permet le formatage de d√©boguage pour mettre en forme en tant
que cha√Ænes de caract√®res, que vous pouvez utiliser en ajoutant <code>:?</code> dans un
espace r√©serv√© <code>{}</code>.</p>
<!--
The `Debug` trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program‚Äôs execution.
-->
<p>Le trait <code>Debug</code> vous permet d'afficher des instances d'un type pour des besoins
de d√©boguage, afin que vous et les autres d√©veloppeurs qui utilisent votre type
puissent inspecter une de ses instances √† un endroit pr√©cis de l'ex√©cution du
programme.</p>
<!--
The `Debug` trait is required, for example, in use of the `assert_eq!` macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren‚Äôt equal.
-->
<p>Le trait <code>Debug</code> est n√©cessaire, par exemple, pour l'utilisation de la macro
<code>assert_eq!</code>. Cette macro affiche les valeurs des instances pass√©es en argument
dans le cas o√π l'affirmation √©choue afin que le d√©veloppeur puisse voir pourquoi
les deux instances ne sont pas √©gales.</p>
<!--
### `PartialEq` and `Eq` for Equality Comparisons
-->
<h3 id="partialeq-et-eq-pour-comparer-l√©galit√©"><a class="header" href="#partialeq-et-eq-pour-comparer-l√©galit√©"><code>PartialEq</code> et <code>Eq</code> pour comparer l'√©galit√©</a></h3>
<!--
The `PartialEq` trait allows you to compare instances of a type to check for
equality and enables use of the `==` and `!=` operators.
-->
<p>Le trait <code>PartialEq</code> vous permet de comparer des instances d'un type pour
v√©rifier leur √©galit√© et permet l'utilisation des op√©rateurs <code>==</code> et <code>!=</code>.</p>
<!--
Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived on
structs, two instances are equal only if *all* fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.
-->
<p>L'application de <code>derive</code> avec <code>PartialEq</code> impl√©mente la m√©thode <code>eq</code>. Lorsque
<code>PartialEq</code> est d√©riv√© sur une structure, deux instances ne peuvent √™tre √©gales
seulement si <em>tous</em> leurs champs sont √©gaux, et les instances ne sont pas √©gales
si un des champs n'est pas √©gal. Lorsque ce trait est d√©riv√© sur une
√©num√©ration, chaque variante est √©gale √† elle-m√™me et n'est pas √©gale aux autres
variantes.</p>
<!--
The `PartialEq` trait is required, for example, with the use of the
`assert_eq!` macro, which needs to be able to compare two instances of a type
for equality.
-->
<p>Le trait <code>Eq</code> est n√©cessaire, par exemple, pour utiliser la macro <code>assert_eq!</code>,
qui n√©cessite de pouvoir comparer l'√©galit√© de deux instances d'un type.</p>
<!--
The `Eq` trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The `Eq` trait can only be
applied to types that also implement `PartialEq`, although not all types that
implement `PartialEq` can implement `Eq`. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (`NaN`) value are not equal to each other.
-->
<p>Le trait <code>Eq</code> n'a pas de m√©thode. Son r√¥le est de signaler que pour chaque
valeur du type annot√©, la valeur est √©gale √† elle-m√™me. Le trait <code>Eq</code> peut
seulement √™tre appliqu√© sur des types qui impl√©mentent <code>PartialEq</code>, bien que
tous les types qui impl√©mentent <code>PartialEq</code> ne puissent pas impl√©menter <code>Eq</code>. Un
exemple de ceci sont les types de nombres √† virgule flottante¬†: l'impl√©mentation
des nombres √† virgule flottante stipule que deux instances ayant la valeur
‚Äúnot-a-number‚Äù (<code>NaN</code>, c'est-√†-dire ‚Äúceci n'est pas un nombre‚Äù) ne sont pas
√©gales entre elles.</p>
<!--
An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the
`HashMap<K, V>` can tell whether two keys are the same.
-->
<p>Par exemple, <code>Eq</code> est n√©cessaire est pour les cl√©s dans un <code>HashMap&lt;K, V&gt;</code> afin
que le <code>HashMap&lt;K, V&gt;</code> puisse d√©terminer si deux cl√©s sont identiques.</p>
<!--
### `PartialOrd` and `Ord` for Ordering Comparisons
-->
<h3 id="partialord-et-ord-pour-comparer-les-ordres-de-grandeur"><a class="header" href="#partialord-et-ord-pour-comparer-les-ordres-de-grandeur"><code>PartialOrd</code> et <code>Ord</code> pour comparer les ordres de grandeur</a></h3>
<!--
The `PartialOrd` trait allows you to compare instances of a type for sorting
purposes. A type that implements `PartialOrd` can be used with the `<`, `>`,
`<=`, and `>=` operators. You can only apply the `PartialOrd` trait to types
that also implement `PartialEq`.
-->
<p>Le trait <code>PartialOrd</code> vous permet de comparer des instances d'un type pour
pouvoir les trier. Un type qui impl√©mente <code>PartialOrd</code> peut √™tre utilis√© avec
les op√©rateurs <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, et <code>&gt;=</code>. Vous pouvez appliquer uniquement le
trait <code>PartialOrd</code> aux types qui impl√©mentent aussi <code>PartialEq</code>.</p>
<!--
Deriving `PartialOrd` implements the `partial_cmp` method, which returns an
`Option<Ordering>` that will be `None` when the values given don‚Äôt produce an
ordering. An example of a value that doesn‚Äôt produce an ordering, even though
most values of that type can be compared, is the not-a-number (`NaN`) floating
point value. Calling `partial_cmp` with any floating point number and the `NaN`
floating point value will return `None`.
-->
<p>L'application de <code>derive</code> avec <code>PartialOrd</code> impl√©mente la m√©thode <code>partial_cmp</code>,
qui retourne un <code>Option&lt;Ordering&gt;</code> qui vaudra <code>None</code> lorsque les valeurs
fournies ne fournissent pas un ordre. Un exemple de valeur qui ne produit pas
d'ordre, m√™me si la plupart des valeurs de ce type peuvent √™tre compar√©es, est
la valeur ‚Äúnot-a-number‚Äù (<code>NaN</code>) des virgules flottantes. L'appel √†
<code>partial_cmp</code> entre n'importe quel nombre √† virgule flottante et la valeur <code>NaN</code>
de virgule flottante va retourner <code>None</code>.</p>
<!--
When derived on structs, `PartialOrd` compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.
-->
<p>Lorsqu'il est d√©riv√© sur une structure, <code>PartialOrd</code> compare deux instances en
comparant les valeurs de chaque champ dans l'ordre dans lequel les champs
apparaissent dans la d√©finition de la structure. Lorsqu'il est d√©riv√© sur des
√©num√©rations, les variantes de l'√©num√©ration d√©clar√©es plus t√¥t dans la
d√©finition de l'√©num√©ration sont consid√©r√©es inf√©rieures aux variantes d√©clar√©es
ensuite.</p>
<!--
The `PartialOrd` trait is required, for example, for the `gen_range` method
from the `rand` crate that generates a random value in the range specified by a
low value and a high value.
-->
<p>Le trait <code>PartialOrd</code> est n√©cessaire, par exemple, pour la m√©thode <code>gen_range</code>
de la crate <code>rand</code> qui g√©n√®re une valeur al√©atoire dans l'intervalle contrainte
par une valeur minimale et une valeur maximale.</p>
<!--
The `Ord` trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The `Ord` trait implements the `cmp` method,
which returns an `Ordering` rather than an `Option<Ordering>` because a valid
ordering will always be possible. You can only apply the `Ord` trait to types
that also implement `PartialOrd` and `Eq` (and `Eq` requires `PartialEq`). When
derived on structs and enums, `cmp` behaves the same way as the derived
implementation for `partial_cmp` does with `PartialOrd`.
-->
<p>Le trait <code>Ord</code> vous permet de savoir si un ordre valide existe toujours entre
deux valeurs du type annot√©. Le trait <code>Ord</code> impl√©mente la m√©thode <code>cmp</code>, qui
retourne un <code>Ordering</code> plut√¥t qu'une <code>Option&lt;Ordering&gt;</code> car un ordre valide sera
toujours possible. Vous pouvez appliquer le trait <code>Ord</code> uniquement sur les types
qui impl√©mentent aussi <code>PartialOrd</code> et <code>Eq</code> (et <code>Eq</code> n√©cessite <code>PartialEq</code>).
Lorsqu'il est d√©riv√© sur des structures et des √©num√©rations, <code>cmp</code> se comporte
de la m√™me mani√®re que l'impl√©mentation de <code>partial_cmp</code> d√©riv√©e de
<code>PartialOrd</code>.</p>
<!--
An example of when `Ord` is required is when storing values in a `BTreeSet<T>`,
a data structure that stores data based on the sort order of the values.
-->
<p>Par exemple, <code>Ord</code> doit √™tre impl√©ment√© sur le type de valeurs que nous stockons
dans un <code>BTreeSet&lt;T&gt;</code>, qui est une structure de donn√©e qui stocke des donn√©es en
fonction de l'ordre de tri de ces valeurs.</p>
<!--
### `Clone` and `Copy` for Duplicating Values
-->
<h3 id="clone-et-copy-pour-dupliquer-des-valeurs"><a class="header" href="#clone-et-copy-pour-dupliquer-des-valeurs"><code>Clone</code> et <code>Copy</code> pour dupliquer des valeurs</a></h3>
<!--
The `Clone` trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the [‚ÄúWays Variables and Data Interact:
Clone‚Äù][ways-variables-and-data-interact-clone]<!-- ignore -- > section in
Chapter 4 for more information on `Clone`.
-->
<p>Le trait <code>Clone</code> vous permet de cr√©er explicitement une copie profonde d'une
valeur, et le processus de duplication peut impliquer l'ex√©cution d'un code
arbitraire pour copier les donn√©es stock√©es dans le tas. Rendez-vous √† la
section <a href="ch04-01-what-is-ownership.html#les-interactions-entre-les-variables-et-les-donn%C3%A9es--le-d%C3%A9placement">‚ÄúLes interactions entre les variables et les donn√©es : le
d√©placement‚Äù</a><!-- ignore --> du
chapitre 4 pour plus d'informations sur <code>Clone</code>.</p>
<!--
Deriving `Clone` implements the `clone` method, which when implemented for the
whole type, calls `clone` on each of the parts of the type. This means all the
fields or values in the type must also implement `Clone` to derive `Clone`.
-->
<p>Utiliser <code>derive</code> avec <code>Clone</code> impl√©mente la m√©thode <code>clone</code>, qui, lorsqu'elle
est impl√©ment√©e sur tout le type, fait appel √† <code>clone</code> sur chaque constituant du
type. Cela signifie que tous les champs ou les valeurs dans le type doivent
aussi impl√©menter <code>Clone</code> pour d√©river de <code>Clone</code>.</p>
<!--
An example of when `Clone` is required is when calling the `to_vec` method on a
slice. The slice doesn‚Äôt own the type instances it contains, but the vector
returned from `to_vec` will need to own its instances, so `to_vec` calls
`clone` on each item. Thus, the type stored in the slice must implement `Clone`.
-->
<p><code>Clone</code> est par exemple n√©cessaire lorsque nous appelons la m√©thode <code>to_vec</code> sur
une slice. La slice ne prend pas possession des instances du type qu'il
contient, mais le vecteur retourn√© par <code>to_vec</code> va avoir besoin de prendre
possession de ses instances, donc <code>to_vec</code> fait appel √† <code>clone</code> sur chaque
√©l√©ment. C'est pourquoi le type stock√© dans la slice doit impl√©menter <code>Clone</code>.</p>
<!--
The `Copy` trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the [‚ÄúStack-Only Data:
Copy‚Äù][stack-only-data-copy]<!-- ignore -- > section in Chapter 4 for more
information on `Copy`.
-->
<p>Le trait <code>Copy</code> vous permet de dupliquer une valeur en copiant uniquement les
√©l√©ments stock√©s sur la pile¬†; il n'est pas n√©cessaire d'avoir de code
arbitraire. Rendez-vous √† la section <a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">‚ÄúDonn√©es uniquement sur la pile : la
copie‚Äù</a><!-- ignore --> du chapitre 4 pour plus
d'informations sur <code>Copy</code>.</p>
<!--
The `Copy` trait doesn‚Äôt define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.
-->
<p>Le trait <code>Copy</code> ne d√©finit pas de m√©thode, volontairement pour emp√™cher les
d√©veloppeurs de surcharger ces m√©thodes et ainsi violer l'affirmation qu'aucun
code arbitraire est ex√©cut√© √† la copie. Ainsi, tous les d√©veloppeurs peuvent
compter sur le fait qu'une copie de valeur est tr√®s rapide.</p>
<!--
You can derive `Copy` on any type whose parts all implement `Copy`. You can
only apply the `Copy` trait to types that also implement `Clone`, because a
type that implements `Copy` has a trivial implementation of `Clone` that
performs the same task as `Copy`.
-->
<p>Vous pouvez utiliser <code>derive</code> avec <code>Copy</code> sur n'importe quel type constitu√©
d'√©l√©ments qui impl√©mentent aussi <code>Copy</code>. Vous ne pouvez appliquer le trait
<code>Copy</code> que sur des types qui impl√©mentent aussi <code>Clone</code>, car un type qui
impl√©mente <code>Copy</code> a aussi une impl√©mentation triviale de <code>Clone</code> qui proc√®de
aux m√™mes actions que <code>Copy</code>.</p>
<!--
The `Copy` trait is rarely required; types that implement `Copy` have
optimizations available, meaning you don‚Äôt have to call `clone`, which makes
the code more concise.
-->
<p>Le trait <code>Copy</code> est rarement n√©cessaire¬†; les types qui impl√©mentent <code>Copy</code>
peuvent √™tre optimis√©s, ce qui veut dire que vous n'avez pas √† appeler <code>clone</code>,
ce qui rend le code plus concis.</p>
<!--
Everything possible with `Copy` you can also accomplish with `Clone`, but the
code might be slower or have to use `clone` in places.
-->
<p>Tout ce que vous pouvez accomplir avec <code>Copy</code>, vous pouvez le faire avec
<code>Clone</code>, mais le code risque d'√™tre plus lent ou doit parfois utiliser <code>clone</code>.</p>
<!--
### `Hash` for Mapping a Value to a Value of Fixed Size
-->
<h3 id="hash-pour-faire-correspondre-une-valeur-avec-une-valeur-de-taille-fixe"><a class="header" href="#hash-pour-faire-correspondre-une-valeur-avec-une-valeur-de-taille-fixe"><code>Hash</code> pour faire correspondre une valeur avec une valeur de taille fixe</a></h3>
<!--
The `Hash` trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
`Hash` implements the `hash` method. The derived implementation of the `hash`
method combines the result of calling `hash` on each of the parts of the type,
meaning all fields or values must also implement `Hash` to derive `Hash`.
-->
<p>Le trait <code>Hash</code> vous permet d'obtenir une valeur √† taille fixe en utilisant une
fonction de hachage sur une instance d'un type d'une taille quelconque. Utiliser
<code>derive</code> avec <code>Hash</code> impl√©mente la m√©thode <code>hash</code>. L'impl√©mentation d√©rive de la
m√©thode <code>hash</code> combine le r√©sultat de l'appel de <code>hash</code> sur chaque √©l√©ment du
type, ce qui signifie que tous ses champs ou valeurs doivent aussi impl√©menter
<code>Hash</code> pour pouvoir lui appliquer le trait <code>Hash</code>.</p>
<!--
An example of when `Hash` is required is in storing keys in a `HashMap<K, V>`
to store data efficiently.
-->
<p>Pour stocker des cl√©s efficacement dans un <code>HashMap&lt;K, V&gt;</code>, les cl√©s doivent
n√©cessairement impl√©menter <code>Hash</code>.</p>
<!--
### `Default` for Default Values
-->
<h3 id="default-pour-des-valeurs-par-d√©faut"><a class="header" href="#default-pour-des-valeurs-par-d√©faut"><code>Default</code> pour des valeurs par d√©faut</a></h3>
<!--
The `Default` trait allows you to create a default value for a type. Deriving
`Default` implements the `default` function. The derived implementation of the
`default` function calls the `default` function on each part of the type,
meaning all fields or values in the type must also implement `Default` to
derive `Default`.
-->
<p>Le trait <code>Default</code> vous permet de cr√©er une valeur par d√©faut pour un type.
Impl√©menter <code>Default</code> avec <code>derive</code> ajoute la fonction <code>default</code>. Cette fonction
<code>default</code> fait elle-m√™me appel √† la fonction <code>default</code> sur chaque √©l√©ment du
type, ce qui signifie que tous les champs ou les valeurs dans le type doit aussi
impl√©menter <code>Default</code> pour que ce type puisse d√©river de <code>Default</code>.</p>
<!-- markdownlint-disable -->
<!--
The `Default::default` function is commonly used in combination with the struct
update syntax discussed in the [‚ÄúCreating Instances From Other Instances With
Struct Update
Syntax‚Äù][creating-instances-from-other-instances-with-struct-update-syntax]<!-- ignore -- >
section in Chapter 5. You can customize a few fields of a struct and then
set and use a default value for the rest of the fields by using
`..Default::default()`.
-->
<p>La fonction <code>Default::default</code> est couramment utilis√© en association avec la
syntaxe de modification de structures que nous avons vu dans la section <a href="ch05-01-defining-structs.html#cr%C3%A9er-des-instances-%C3%A0-partir-dautres-instances-avec-la-syntaxe-de-mise-%C3%A0-jour-de-structure">‚ÄúCr√©er
des instances √† partir d'autres instances avec la syntaxe de mise √† jour de
structure‚Äù</a><!-- ignore -->
du chapitre 5. Vous pouvez personnaliser quelques champs d'une structure et
ensuite d√©finir et utiliser une valeur par d√©faut pour le reste des champs en
utilisant <code>..Default::default()</code>.</p>
<!--
The `Default` trait is required when you use the method `unwrap_or_default` on
`Option<T>` instances, for example. If the `Option<T>` is `None`, the method
`unwrap_or_default` will return the result of `Default::default` for the type
`T` stored in the `Option<T>`.
-->
<p>Le trait <code>Default</code> est n√©cessaire lorsque vous utilisez la m√©thode
<code>unwrap_or_default</code> sur les instances de <code>Option&lt;T&gt;</code>, par exemple. Si le
<code>Option&lt;T&gt;</code> vaut <code>None</code>, la m√©thode <code>unwrap_or_default</code> va retourner le r√©sultat
de <code>Default::default</code> sur le type <code>T</code> provenant du <code>Option&lt;T&gt;</code>.</p>
<!--
[creating-instances-from-other-instances-with-struct-update-syntax]:
ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[ways-variables-and-data-interact-clone]:
ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fra√Æche--2"><a class="header" href="#-attention-peinture-fra√Æche--2">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/225">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix D - Useful Development Tools
-->
<h2 id="annexe-d---des-outils-de-d√©veloppement-utiles"><a class="header" href="#annexe-d---des-outils-de-d√©veloppement-utiles">Annexe D - Des outils de d√©veloppement utiles</a></h2>
<!--
In this appendix, we talk about some useful development tools that the Rust
project provides. We‚Äôll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.
-->
<p>Dans cette annexe, nous allons d√©couvrir quelques outils de d√©veloppement utiles
que propose le projet Rust. Nous allons voir le formatage automatique, des
moyens rapides pour corriger des avertissements, un analyseur statique, et
l'int√©gration avec un IDE.</p>
<!--
### Automatic Formatting with `rustfmt`
-->
<h3 id="le-formatage-automatique-avec-rustfmt"><a class="header" href="#le-formatage-automatique-avec-rustfmt">Le formatage automatique avec <code>rustfmt</code></a></h3>
<!--
The `rustfmt` tool¬†reformats your code according to the community code style.
Many collaborative projects use `rustfmt` to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.
-->
<p>L'outil <code>rustfmt</code> reformate votre code suivant le style de code de la
communaut√©. De nombreux projets collaboratifs utilisent <code>rustfmt</code> pour √©viter
des d√©saccords sur le style √† utiliser lorsqu'ils √©crivent du code Rust¬†: tout le
monde formate leur code en utilisant l'outil.</p>
<!--
To install `rustfmt`, enter the following:
-->
<p>Pour installer <code>rustfmt</code>, saisissez ceci¬†:</p>
<!--
```console
$ rustup component add rustfmt
```
-->
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<!--
This command gives you `rustfmt` and `cargo-fmt`, similar to how Rust gives you
both `rustc` and `cargo`. To format any Cargo project, enter the following:
-->
<p>Cette commande vous offre <code>rustfmt</code> et <code>cargo-fmt</code>, de la m√™me mani√®re que Rust
vous installe <code>rustc</code> et <code>cargo</code>. Pour formater un projet Cargo, saisissez
ceci¬†:</p>
<!--
```console
$ cargo fmt
```
-->
<pre><code class="language-console">$ cargo fmt
</code></pre>
<!--
Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on `rustfmt`, see [its documentation][rustfmt].
-->
<p>L'ex√©cution de cette commande reformate tout le code Rust dans la crate
courante. Cela va uniquement changer le style de code, pas sa s√©mantique. Pour
plus d'informations sur <code>rustfmt</code>, voyez <a href="https://github.com/rust-lang/rustfmt">sa documentation</a>.</p>
<!--
[rustfmt]: https://github.com/rust-lang/rustfmt
-->
<!--
### Fix Your Code with `rustfix`
-->
<h3 id="corriger-votre-code-avec-rustfix"><a class="header" href="#corriger-votre-code-avec-rustfix">Corriger votre code avec <code>rustfix</code></a></h3>
<!--
The rustfix tool is included with Rust installations and can automatically fix
some compiler warnings. If you‚Äôve written code in Rust, you‚Äôve probably seen
compiler warnings. For example, consider this code:
-->
<p>L'outil rustfix est inclus lors de l'installation de Rust et peut
automatiquement corriger certains avertissements de compilateur. Si vous avez
d√©j√† √©crit du code en Rust, vous avez probablement vu des avertissements du
compilateur. Par exemple, avec le code suivant¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fait_quelquechose() {}

fn main() {
    for i in 0..100 {
        fait_quelquechose();
    }
}
</code></pre></pre>
<!--
Here, we‚Äôre calling the `do_something` function 100 times, but we never use the
variable `i` in the body of the `for` loop. Rust warns us about that:
-->
<p>Ici, nous appelons la fonction <code>fait_quelquechose</code> 100 fois, mais nous
n'utilisons jamais la variable <code>i</code> dans le corps de la boucle <code>for</code>. Rust nous
avertit de cela¬†:</p>
<!--
```console
$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 -- > src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling mon_programme v0.1.0 (file:///projects/mon_programme)
warning: unused variable: `i`
 -- &gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<!--
The warning suggests that we use `_i` as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the `rustfix` tool by running the command `cargo
fix`:
-->
<p>L'avertissement indique que nous devrions utiliser <code>_i</code> comme nom √† sa place¬†:
le tiret bas indique que nous avons l'intention de ne pas utiliser cette
variable. Nous pouvons appliquer automatiquement cette suggestion en utilisant
l'outil <code>rustfix</code> en lan√ßant la commande <code>cargo fix</code>¬†:</p>
<!--
```console
$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```
-->
<pre><code class="language-console">$ cargo fix
    Checking mon_programme v0.1.0 (file:///projects/mon_programme)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
When we look at *src/main.rs* again, we‚Äôll see that `cargo fix` has changed the
code:
-->
<p>Lorsque nous regardons √† nouveau <em>src/main.rs</em>, nous pouvons constater que
<code>cargo fix</code> a chang√© le code¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fait_quelquechose() {}

fn main() {
    for _i in 0..100 {
        fait_quelquechose();
    }
}
</code></pre></pre>
<!--
The `for` loop variable is now named `_i`, and the warning no longer appears.
-->
<p>La variable de la boucle <code>for</code> s'appelle maintenant <code>_i</code>, et l'avertissement ne
s'affiche plus.</p>
<!--
You can also use the `cargo fix` command to transition your code between
different Rust editions. Editions are covered in Appendix E.
-->
<p>Vous pouvez aussi utiliser la commande <code>cargo fix</code> pour corriger votre code
entre diff√©rentes √©ditions de Rust. Les √©ditions sont abord√©es √† l'annexe E.</p>
<!--
### More Lints with Clippy
-->
<h3 id="une-analyse-statique-plus-compl√®te-avec-clippy"><a class="header" href="#une-analyse-statique-plus-compl√®te-avec-clippy">Une analyse statique plus compl√®te avec Clippy</a></h3>
<!--
The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.
-->
<p>L'outil Clippy est une collection d'analyses statiques pour analyser votre code
afin que vous puissiez d√©busquer certaines erreurs courantes et ainsi am√©liorer
votre code.</p>
<!--
To install Clippy, enter the following:
-->
<p>Pour installer Clippy, saisissez ceci¬†:</p>
<!--
```console
$ rustup component add clippy
```
-->
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<!--
To run Clippy‚Äôs lints on any Cargo project, enter the following:
-->
<p>Pour lancer l'analyse statique de Clippy sur un projet Cargo, saisissez ceci¬†:</p>
<!--
```console
$ cargo clippy
```
-->
<pre><code class="language-console">$ cargo clippy
</code></pre>
<!--
For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:
-->
<p>Par exemple, imaginons que vous √©crivez un programme qui utilise une
approximation d'une constante math√©matique, comme pi, comme le fait ce
programme¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;l'aire du cercle vaut {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
Running `cargo clippy` on this project results in this error:
-->
<p>L'ex√©cution de <code>cargo clippy</code> sur ce projet va afficher cette erreur¬†:</p>
<!--
```text
error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 -- > src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
```
-->
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 -- &gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<!--
This error lets you know that Rust has this constant defined more precisely and
that your program would be more correct if you used the constant instead. You
would then change your code to use the `PI` constant. The following code
doesn‚Äôt result in any errors or warnings from Clippy:
-->
<p>Cette erreur vous fais savoir que Rust a cette constante qui est d√©finie plus
pr√©cis√©ment et que votre programme serait plus pertinent si vous utilisiez √† la
place la constante. Vous changeriez alors votre code pour utiliser la constante
<code>PI</code>. Le code suivant ne donne pas d'erreur ou d'avertissement avec Clippy¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;l'aire du cercle vaut {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
For more information on Clippy, see [its documentation][clippy].
-->
<p>Pour en savoir plus Clippy, voyez <a href="https://github.com/rust-lang/rust-clippy">sa documentation</a>.</p>
<!--
[clippy]: https://github.com/rust-lang/rust-clippy
-->
<!--
### IDE Integration Using the Rust Language Server
-->
<h3 id="lint√©gration-aux-ide-en-utilisant-le-rust-language-server"><a class="header" href="#lint√©gration-aux-ide-en-utilisant-le-rust-language-server">L'int√©gration aux IDE en utilisant le Rust Language Server</a></h3>
<!--
To help IDE integration, the Rust project distributes the *Rust Language
Server* (`rls`). This tool speaks the [Language Server
Protocol][lsp], which is a specification for IDEs and programming
languages to communicate with each other. Different clients can use the `rls`,
such as [the Rust plug-in for Visual Studio Code][vscode].
-->
<p>Pour aider l'int√©gration aux IDE, le projet Rust distribue le
<em>Rust Language Server</em> (<code>rls</code>). Cet outil suit le
<a href="http://langserver.org/">Language Server Protocol</a>, qui est une sp√©cification entre les IDE et les
langages pour communiquer entre eux. Diff√©rents clients peuvent utiliser le
<code>rls</code>, comme <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">le plug-in Rust pour Visual Studio Code</a>.</p>
<!--
[lsp]: http://langserver.org/
[vscode]: https://marketplace.visualstudio.com/items?itemName=rust-lang.rust
-->
<!--
To install the `rls`, enter the following:
-->
<p>Pour installer le <code>rls</code>, saisissez ceci¬†:</p>
<!--
```console
$ rustup component add rls
```
-->
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<!--
Then install the language server support in your particular IDE; you‚Äôll gain
abilities such as autocompletion, jump to definition, and inline errors.
-->
<p>Installez ensuite le syst√®me du <em>language server</em> dans votre IDE¬†; vous devriez
obtenir des capacit√©s suppl√©mentaires comme l'auto-compl√©tion, pouvoir se rendre
√† la d√©finition de l'√©l√©ment, et la mise en valeur d'erreurs sur la ligne
concern√©e.</p>
<!--
For more information on the `rls`, see [its documentation][rls].
-->
<p>Pour plus d'information sur <code>rls</code>, rendez-vous <a href="https://github.com/rust-lang/rls">√† sa documentation</a>.</p>
<!--
[rls]: https://github.com/rust-lang/rls
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fra√Æche--3"><a class="header" href="#-attention-peinture-fra√Æche--3">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/226">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix E - Editions
-->
<h2 id="annexe-e---les-√©ditions"><a class="header" href="#annexe-e---les-√©ditions">Annexe E - Les √©ditions</a></h2>
<!--
In Chapter 1, you saw that `cargo new` adds a bit of metadata to your
*Cargo.toml* file about an edition. This appendix talks about what that means!
-->
<p>Au chapitre 1, vous avez constat√© que <code>cargo new</code> ajoutait une petite m√©tadonn√©e
√† propos d'une √©dition dans votre fichier <em>Cargo.toml</em>. Cette annexe vous
explique ce que cela signifie¬†!</p>
<!--
The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, ‚ÄúWow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!‚Äù
-->
<p>Le langage Rust et son compilateur suivent un cycle de publication de six
semaines, ce qui signifie que leurs utilisateurs suivent un flux constant de
nouvelles fonctionnalit√©s. Les autres langages de programmation publient moins
souvent des changements mais qui sont plus gros¬†; Rust a fait le choix de
publier des petits changements plus fr√©quemment. Au bout d'un certain moment,
tous ces petits changements s'accumulent. Mais de mise √† jour en mise √† jour, il
devient difficile de regarder en arri√®re et de dire¬†: ‚ÄúOuah, Rust a beaucoup
chang√© entre Rust 1.10 et Rust 1.31‚Äù.</p>
<!--
Every two or three years, the Rust team produces a new Rust *edition*. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.
-->
<p>Tous les deux ou trois ans, l'√©quipe Rust produit une nouvelle <em>√©dition</em> de
Rust. Chaque √©dition rassemble des fonctionnalit√©s qui ont converg√© en un
ensemble clair, avec une documentation et des outils compl√®tement √† jour. Les
nouvelles √©ditions sont livr√©es comme faisant partie du cycle habituel de
publication toutes les six semaines.</p>
<!--
Editions serve different purposes for different people:
-->
<p>Les √©ditions apportent diff√©rentes choses pour diff√©rentes personnes¬†:</p>
<!--
* For active Rust users, a new edition brings together incremental changes into
  an easy-to-understand package.
* For non-users, a new edition signals that some major advancements have
  landed, which might make Rust worth another look.
* For those developing Rust, a new edition provides a rallying point for the
  project as a whole.
-->
<ul>
<li>Pour les utilisateurs actifs de Rust, une nouvelle √©dition regroupe les
diff√©rents changements progressifs dans un ensemble clair.</li>
<li>Pour ceux qui n'utilisent pas Rust, une nouvelle √©dition signale la livraison
d'avanc√©es majeures, qui pourrait √™tre le signal que Rust m√©riterait un
nouveau coup d'≈ìil.</li>
<li>Pour ceux qui d√©veloppent Rust, une nouvelle √©dition est un point de
ralliement pour l'ensemble du projet.</li>
</ul>
<!--
At the time of this writing, two Rust editions are available: Rust 2015 and
Rust 2018. This book is written using Rust 2018 edition idioms.
-->
<p>Au moment de cette √©criture, deux √©ditions de Rust sont disponibles¬†: Rust 2015
et Rust 2018. Ce livre est √©crit selon les termes de l'√©dition Rust 2018.</p>
<!--
The `edition` key in *Cargo.toml* indicates which edition the compiler should
use for your code. If the key doesn‚Äôt exist, Rust uses `2015` as the edition
value for backward compatibility reasons.
-->
<p>La cl√© <code>edition</code> dans <em>Cargo.toml</em> indique quelle √©dition le compilateur doit
utiliser dans votre code. Si la cl√© n'existe pas, Rust utilise <code>2015</code> comme
valeur de l'√©dition, pour des raisons de r√©tro-compatibilit√©.</p>
<!--
Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.
-->
<p>Chaque projet peut opter pour une autre √©dition que l'√©dition 2015 par d√©faut.
Les √©ditions peuvent impliquer des changements incompatibles, comme
l'introduction d'un nouveau mot-cl√© qui rentre en conflit avec des
identificateurs (noms de variables, de fonctions, ...) utilis√©s dans le code.
Cependant, √† moins que vous ne d√©cidiez d'opter pour ces changements, votre code
va continuer √† se compiler m√™me si vous augmentez la version du compilateur Rust
que vous utilisez.</p>
<!--
All Rust compiler versions support any edition that existed prior to that
compiler‚Äôs release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you‚Äôre using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.
-->
<p>Toutes les versions du compilateur Rust supporte toutes les √©ditions qui ont
exist√© avant la publication courante du compilateur, et ils peuvent lier
ensemble les crates de n'importe quelle √©dition support√©e. Les changements de
chaque √©dition changent uniquement la fa√ßon dont le compilateur interpr√®te
initialement le code. Par cons√©quent, si vous utilisez Rust 2015 et qu'une de
vos d√©pendances utilise Rust 2018, votre programme va se compiler et √™tre
capable d'utiliser cette d√©pendance. La situation inverse, dans laquelle votre
projet utilise Rust 2018 et qu'une d√©pendance utilise Rust 2015, va aussi
fonctionner.</p>
<!--
To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.
-->
<p>En clair¬†: la plupart des fonctionnalit√©s seront disponibles sur toutes les
versions. Les d√©veloppeurs qui utilisent n'importe quelle √©dition de Rust vont
continuer √† constater des am√©liorations au fur et √† mesure que des nouvelles
√©ditions stables sont publi√©es. Cependant, dans certains cas, principalement
lorsque des nouveaux mot-cl√©s serons rajout√©s, certaines nouvelles
fonctionnalit√©s ne seront disponibles que dans les nouvelles √©ditions. Vous
aurez alors besoin de changer d'√©dition si vous souhaitez profiter des avantages
de ces fonctionnalit√©s.</p>
<!--
For more details, the [*Edition
Guide*](https://doc.rust-lang.org/stable/edition-guide/) is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via `cargo fix`.
-->
<p>Pour en savoir plus, le
<a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> est un livre
complet sur les √©ditions, qui √©num√®re les diff√©rences entre les √©ditions et qui
explique comment mettre √† jour automatiquement votre code vers une nouvelle
√©dition via <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fra√Æche--4"><a class="header" href="#-attention-peinture-fra√Æche--4">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/227">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix F: Translations of the Book
-->
<h2 id="annexe-f--les-traductions-de-ce-livre"><a class="header" href="#annexe-f--les-traductions-de-ce-livre">Annexe F¬†: les traductions de ce livre</a></h2>
<!--
For resources in languages other than English. Most are still in progress; see
[the Translations label][label] to help or let us know about a new translation!
-->
<p>Voici des ressources dans d'autres langages qu'en Fran√ßais. Certaines sont
toujours en cours de construction¬†; consultez <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">le drapeau Translation</a>
pour les aider, ou nous informer de la cr√©ation d'une nouvelle traduction¬†!</p>
<!--
[label]: https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations
-->
<!--
- [Portugu√™s](https://github.com/rust-br/rust-book-pt-br) (BR)
- [Portugu√™s](https://github.com/nunojesus/rust-book-pt-pt) (PT)
- [ÁÆÄ‰Ωì‰∏≠Êñá](https://github.com/KaiserY/trpl-zh-cn)
- [–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞](https://github.com/pavloslav/rust-book-uk-ua)
- [Espa√±ol](https://github.com/thecodix/book), [alternate](https://github.com/ManRR/rust-book-es)
- [Italiano](https://github.com/AgeOfWar/rust-book-it)
- [–†—É—Å—Å–∫–∏–π](https://github.com/rust-lang-ru/book)
- [ÌïúÍµ≠Ïñ¥](https://github.com/rinthel/rust-lang-book-ko)
- [Êó•Êú¨Ë™û](https://github.com/rust-lang-ja/book-ja)
- [Fran√ßais](https://github.com/Jimskapt/rust-book-fr)
- [Polski](https://github.com/paytchoo/book-pl)
- [◊¢◊ë◊®◊ô◊™](https://github.com/idanmel/rust-book-heb)
- [Cebuano](https://github.com/agentzero1/book)
- [Tagalog](https://github.com/josephace135/book)
- [Esperanto](https://github.com/psychoslave/Rust-libro)
- [ŒµŒªŒªŒ∑ŒΩŒπŒ∫ŒÆ](https://github.com/TChatzigiannakis/rust-book-greek)
- [Svenska](https://github.com/sebras/book)
- [Farsi](https://github.com/pomokhtari/rust-book-fa)
- [Deutsch](https://github.com/rust-lang-de/rustbook-de)
- [Turkish](https://github.com/RustDili/dokuman/tree/master/ceviriler), [online](https://rustdili.github.io/)
-->
<ul>
<li><a href="https://github.com/rust-lang/book">English</a></li>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Portugu√™s</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Portugu√™s</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">ÁÆÄ‰Ωì‰∏≠Êñá</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</a></li>
<li><a href="https://github.com/thecodix/book">Espa√±ol</a>, <a href="https://github.com/ManRR/rust-book-es">alternative</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">–†—É—Å—Å–∫–∏–π</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">ÌïúÍµ≠Ïñ¥</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">Êó•Êú¨Ë™û</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">◊¢◊ë◊®◊ô◊™</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ŒµŒªŒªŒ∑ŒΩŒπŒ∫ŒÆ</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/RustDili/dokuman/tree/master/ceviriler">Turkish</a>, <a href="https://rustdili.github.io/">online</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fra√Æche--5"><a class="header" href="#-attention-peinture-fra√Æche--5">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/228">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix G - How Rust is Made and ‚ÄúNightly Rust‚Äù
-->
<h2 id="annexe-g---comment-rust-est-construit-et-nightly-rust"><a class="header" href="#annexe-g---comment-rust-est-construit-et-nightly-rust">Annexe G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></h2>
<!--
This appendix is about how Rust is made and how that affects you as a Rust
developer.
-->
<p>Cette annexe va expliquer comment Rust est construit et comment cela vous
impacte en tant que d√©veloppeur Rust.</p>
<!--
### Stability Without Stagnation
-->
<h3 id="la-stabilit√©-sans-stagnation"><a class="header" href="#la-stabilit√©-sans-stagnation">La stabilit√© sans stagnation</a></h3>
<!--
As a language, Rust cares a *lot* about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can‚Äôt
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.
-->
<p>En tant que langage, Rust se soucie <em>beaucoup</em> de la stabilit√© de votre code.
Nous voulons que Rust soit une solide fondation sur laquelle vous pouvez
construire, et si les choses changent constamment, cela serait impossible. En
m√™me temps, si nous ne pouvions pas exp√©rimenter de nouvelles fonctionnalit√©s,
nous ne pourrions pas d√©couvrir les d√©fauts importants avant leur publication,
ce qui serait trop tard pour changer les choses.</p>
<!--
Our solution to this problem is what we call ‚Äústability without stagnation‚Äù,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.
-->
<p>Notre solution √† ce probl√®me est ce que nous appelons la ‚Äústabilit√© sans
stagnation‚Äù, et notre ligne directrice est la suivante¬†: vous ne devriez jamais
craindre de passer √† nouvelle version de Rust stable. Chaque mise √† jour devrait
√™tre facile, et devrait aussi vous apporter de nouvelles fonctionnalit√©s, moins
de bogues et un temps de compilation plus rapide.</p>
<!--
### Choo, Choo! Release Channels and Riding the Trains
-->
<h3 id="les-canaux-de-diffusion-et-sauter-dans-le-train"><a class="header" href="#les-canaux-de-diffusion-et-sauter-dans-le-train">Les canaux de diffusion et sauter dans le train</a></h3>
<!--
Rust development operates on a *train schedule*. That is, all development is
done on the `master` branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three *release channels* for Rust:
-->
<p>Le d√©veloppement de Rust suit un <em>planning ferroviaire</em>. Ce que cela veut dire,
c'est que tout le d√©veloppement est fait sur la branche <code>master</code> du d√©p√¥t de
Rust. Les publications suivent le mod√®le de trains de publication de programmes,
qui a √©t√© popularis√© par Cisco IOS et d'autres projets logiciels. Il y a trois
<em>canaux de diffusion</em> pour Rust¬†:</p>
<!--
* Nightly
* Beta
* Stable
-->
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<!--
Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.
-->
<p>La plupart des d√©veloppeurs Rust utilisent principalement le canal stable, mais
ceux qui souhaitent essayer les nouvelles fonctionnalit√©s exp√©rimentales
utilisent nightly ou beta.</p>
<!--
Here‚Äôs an example of how the development and release process works: let‚Äôs
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the `master`
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:
-->
<p>Voici un exemple du fonctionnement du processus de d√©veloppement et de
publication¬†: supposons que l'√©quipe de Rust travaille sur la publication de
Rust 1.5. Cette publication a √©t√© faite en d√©cembre 2015, et nous permet de nous
appuyer sur des num√©ros de version r√©alistes. Une nouvelle fonctionnalit√© a √©t√©
ajout√©e √† Rust¬†: un nouveau commit est arriv√© sur la branche <code>master</code>. Chaque
nuit, une nouvelle version nightly de Rust est produite. Chaque jour voit une
nouvelle publication, et ces publications sont cr√©√©es automatiquement par
l'infrastructure de publication. Ainsi, les publications ressemblent √† ceci, une
fois par nuit¬†:</p>
<!--
```text
nightly: * - - * - - *
```
-->
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<!--
Every six weeks, it‚Äôs time to prepare a new release! The `beta` branch of the
Rust repository branches off from the `master` branch used by nightly. Now,
there are two releases:
-->
<p>Tous les six semaines, c'est le moment de pr√©parer une nouvelle publication¬†! La
branche <code>beta</code> du d√©p√¥t Rust est alors d√©riv√©e de la branche <code>master</code> utilis√©e
par nightly. Ainsi, il y a deux canaux de publications¬†:</p>
<!--
```text
nightly: * - - * - - *
                     |
beta:                *
```
-->
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there‚Äôs still a nightly release every night:
-->
<p>La plupart des utilisateurs Rust n'utilisent pas activement les publications en
beta, mais les tests en beta sur leur syst√®me d'Int√©gration Continue aident √†
d√©couvrir des potentielles r√©gressions. Pendant ce temps, il continue √† avoir
une publication nightly chaque nuit¬†:</p>
<!--
```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Let‚Äôs say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to `master`, so that nightly is fixed, and then the fix is backported to the
`beta` branch, and a new release of beta is produced:
-->
<p>Imaginons qu'une r√©gression soit trouv√©e. C'est alors une bonne chose que nous
ayons du temps pour tester la publication beta avant que la r√©gression se
retrouve dans une publication stable¬†! La correction est alors appliqu√©e sur
<code>master</code>, ainsi nightly est corrig√©, et ensuite la correction est report√©e sur
la branche <code>beta</code>, et une nouvelle publication de beta est produite¬†:</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<!--
Six weeks after the first beta was created, it‚Äôs time for a stable release! The
`stable` branch is produced from the `beta` branch:
-->
<p>Six semaines apr√®s que la premi√®re beta soit cr√©√©e, c'est le moment de publier
une version stable¬†! La branche <code>stable</code> est produite √† partir de la branche
<code>beta</code>¬†:</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<!--
Hooray! Rust 1.5 is done! However, we‚Äôve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the *next* version of Rust, 1.6.
So after `stable` branches off of `beta`, the next version of `beta` branches
off of `nightly` again:
-->
<p>Youpi¬†! Rust 1.5 est sorti¬†! Cependant, nous avons oubli√© quelque chose¬†: comme
les six semaines sont pass√©es, nous devons aussi publier une nouvelle beta de la
version <em>suivante</em> de Rust, la 1.6. Donc apr√®s que la branche <code>stable</code> soit
d√©riv√©e de la <code>beta</code>, la prochaine version de la branche <code>beta</code> doit √† nouveau
√™tre d√©riv√©e de nightly¬†:</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<!--
This is called the ‚Äútrain model‚Äù because every six weeks, a release ‚Äúleaves the
station‚Äù, but still has to take a journey through the beta channel before it
arrives as a stable release.
-->
<p>C'est appel√© le ‚Äúmod√®le ferroviaire‚Äù car toutes les six semaines, une nouvelle
publication ‚Äúquitte la gare‚Äù, mais doit encore voyager dans la voie de la
beta avant d'arriver en gare de la publication stable.</p>
<!--
Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it‚Äôs six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there‚Äôs no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.
-->
<p>Rust publie r√©guli√®rement toutes les six semaines, r√©gl√©e comme une montre. Si
vous savez la date d'une publication Rust, vous savez la date de la suivante¬†:
elle aura toujours lieu six semaines plus tard. Un des avantages d'avoir des
publications planifi√©es toutes les six semaines est que le train suivant arrive
rapidement apr√®s. Si une fonctionnalit√© n'est pas int√©gr√©e √† une publication, il
n'y a pas √† s'inqui√©ter¬†: une autre arrive bient√¥t¬†! Cela aide √† r√©duire la
pression pour faire passer en toute discr√©tion des fonctionnalit√©s
√©ventuellement inachev√©es √† l'approche de la date limite de diffusion.</p>
<!--
Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it‚Äôs easy to upgrade to: if a beta release doesn‚Äôt
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
`rustc` is still a piece of software, and bugs do exist.
-->
<p>Gr√¢ce √† ce processus, vous pouvez toujours d√©couvrir la prochaine compilation de
Rust et constater par vous-m√™me qu'il est facile de mettre √† jour¬†: si une
publication en beta ne fonctionne pas comme pr√©vu, vous pouvez signaler cela √†
l'√©quipe et cela sera corrig√© avant que la prochaine publication stable soit
produite¬†! La d√©gradation d'une version b√™ta est plut√¥t rare, mais <code>rustc</code> reste
un logiciel, et les bogues peuvent exister malgr√© tout.</p>
<!--
### Unstable Features
-->
<h3 id="les-fonctionnalit√©s-instables"><a class="header" href="#les-fonctionnalit√©s-instables">Les fonctionnalit√©s instables</a></h3>
<!--
There‚Äôs one more catch with this release model: unstable features. Rust uses a
technique called ‚Äúfeature flags‚Äù to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
`master`, and therefore, in nightly, but behind a *feature flag*. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.
-->
<p>Il reste une surprise avec ce mod√®le de publication¬†: les fonctionnalit√©s
instables. Rust utilise une technique qui s'appelle les ‚Äúdrapeaux de
fonctionnalit√©s‚Äù pour d√©terminer quelles fonctionnalit√©s sont activ√©es dans une
publication donn√©e. Si une nouvelle fonctionnalit√© est en d√©veloppement actif,
elle va atterrir sur <code>master</code>, et ainsi, dans nightly, mais derri√®re un <em>drapeau
de fonctionnalit√©s</em>. Si vous, en tant qu'utilisateur, souhaitez essayer la
fonctionnalit√© en cours de d√©veloppement, vous pouvez, mais vous devez utiliser
une publication nightly de Rust et annoter votre code source avec le drapeau
appropri√© pour l'activer.</p>
<!--
If you‚Äôre using a beta or stable release of Rust, you can‚Äôt use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won‚Äôt break. Stability without stagnation.
-->
<p>Si vous utilisez une publication beta ou stable de Rust, vous ne pouvez pas
utiliser de drapeaux de fonctionnalit√©s. C'est la cl√© qui permet d'obtenir une
utilisation pratique avec les nouvelles fonctionnalit√©s avant que nous les
d√©clarions stables pour toujours. Ceux qui souhaitent activer ces
fonctionnalit√©s exp√©rimentales peuvent le faire, et ceux qui souhaitent avoir
une exp√©rience plus solide peuvent s'en tenir au canal stable et leur code ne
sera pas cass√©. C'est la stabilit√© sans stagnation.</p>
<!--
This book only contains information about stable features, as in-progress
features are still changing, and surely they‚Äôll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.
-->
<p>Ce livre contient uniquement des informations sur des fonctionnalit√©s stables,
car les fonctionnalit√©s en cours de d√©veloppement sont toujours en train de
changer, et elles seront s√ªrement diff√©rentes entre le moment o√π ce livre sera
√©crit et lorsqu'elles seront activ√©es dans les compilations stables. Vous pouvez
trouver la documentation pour les fonctionnalit√©s uniquement pour nightly en
ligne.</p>
<!--
### Rustup and the Role of Rust Nightly
-->
<h3 id="rustup-et-le-role-de-rust-nightly"><a class="header" href="#rustup-et-le-role-de-rust-nightly">Rustup et le role de Rust nightly</a></h3>
<!--
Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you‚Äôll have stable Rust installed. To
install nightly, for example:
-->
<p>Rustup facilite les changements entre les diff√©rents canaux de publication de
Rust, de mani√®re globale ou par projet. Par d√©faut, vous avez Rust stable
d'install√©. Pour installer nightly, vous pouvez saisir, par exemple¬†:</p>
<!--
```console
$ rustup toolchain install nightly
```
-->
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<!--
You can see all of the *toolchains* (releases of Rust and associated
components) you have installed with `rustup` as well. Here‚Äôs an example on one
of your authors‚Äô Windows computer:
-->
<p>Vous pouvez aussi voir avec <code>rustup</code> toutes les <em>toolchains</em> (les publications
de Rust et leurs composants associ√©s) que vous avez d'install√©es. Voici un
exemple d'un ordinateur sous Windows d'un des auteurs du livre¬†:</p>
<!--
```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```
-->
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<!--
As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use `rustup override` in that project‚Äôs directory to set the
nightly toolchain as the one `rustup` should use when you‚Äôre in that directory:
-->
<p>Comme vous pouvez le constater, la toolchain stable est celle par d√©faut. La
plupart des utilisateurs Rust utilisent celle qui est stable la plupart du
temps. Il est possible que vous souhaitiez utiliser celle qui est stable la
plupart du temps, mais que vous souhaitiez utiliser nightly sur un projet
particulier, car parce que vous vous int√©ressez √† une fonctionnalit√©
exp√©rimentale. Pour pouvoir faire cela, vous pouvez utiliser <code>rustup override</code>
dans le dossier de ce projet pour r√©gler <code>rustup</code> pour qu'il utilise la
toolchain nightly lorsque vous vous trouvez dans ce dossier¬†:</p>
<!--
```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```
-->
<pre><code class="language-console">$ cd ~/projets/necessite-nightly
$ rustup override set nightly
</code></pre>
<!--
Now, every time you call `rustc` or `cargo` inside of
*~/projects/needs-nightly*, `rustup` will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!
-->
<p>Maintenant, √† chaque fois que vous faites appel √† <code>rustc</code> ou <code>cargo</code> √†
l'int√©rieur de <em>~/projets/necessite-nightly</em>, <code>rustup</code> va s'assurer que vous
utilisez Rust nightly, plut√¥t que votre Rust stable par d√©faut. C'est tr√®s utile
lorsque vous avez beaucoup de projets Rust¬†!</p>
<!--
### The RFC Process and Teams
-->
<h3 id="le-processus-de-rfc-et-les-√©quipes"><a class="header" href="#le-processus-de-rfc-et-les-√©quipes">Le processus de RFC et les √©quipes</a></h3>
<!--
So how do you learn about these new features? Rust‚Äôs development model follows
a *Request For Comments (RFC) process*. If you‚Äôd like an improvement in Rust,
you can write up a proposal, called an RFC.
-->
<p>Donc, comment en apprendre plus ces nouvelles fonctionnalit√©s¬†? Le mod√®le de
d√©veloppement de Rust suit le <em>processus de Request For Comments (RFC)</em>. Si vous
souhaitez avoir une am√©lioration de Rust, vous pouvez r√©diger une proposition,
qu'on appelle une RFC.</p>
<!--
Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There‚Äôs
a full list of the teams [on Rust‚Äôs
website](https://www.rust-lang.org/governance), which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there‚Äôs consensus to accept or reject the feature.
-->
<p>N'importe qui peut √©crire de RFC pour am√©liorer Rust, et les propositions sont
examin√©es et d√©battues par l'√©quipe de Rust, qui est compos√©e de nombreuses
sous-√©quipes sp√©cialis√©es dans diff√©rents domaines. Voici une liste compl√®te des
√©quipes <a href="https://www.rust-lang.org/governance">sur le site web de Rust</a>, qui
comprend des √©quipes pour chaque aspect du projet¬†: la conception du langage,
l'impl√©mentation du compilateur, de l'infrastructure, de la documentation, et
plus encore. L'√©quipe appropri√©e lit la proposition et les commentaires, √©crit
quelques commentaires la concernant, et finalement, un consensus se cr√©e pour
accepter ou rejeter la fonctionnalit√©.</p>
<!--
If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the `master` branch behind a feature gate, as we discussed
in the [‚ÄúUnstable Features‚Äù](#unstable-features)<!-- ignore -- > section.
-->
<p>Si la fonctionnalit√© est accept√©e, un ticket est ouvert sur le d√©p√¥t de Rust, et
quelqu'un peut l'impl√©menter. La personne qui l'impl√©mente ne peut pas √™tre
celle qui a propos√© la fonctionnalit√©¬†! Lorsque l'impl√©mentation est pr√™te, elle
atterrit sur la branche <code>master</code> derri√®re un drapeau de fonctionnalit√©, comme
nous l'avons vu dans la section <a href="appendix-07-nightly-rust.html#les-fonctionnalit%C3%A9s-instables">‚ÄúLes fonctionnalit√©s
instables‚Äù</a><!-- ignore -->.</p>
<!--
After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it‚Äôs
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.
-->
<p>Au bout d'un moment, une fois que les d√©veloppeurs Rust qui utilisent les
publications nightly ont pu tester la nouvelle fonctionnalit√©, les membres de
l'√©quipe vont discuter de la fonctionnalit√©, de voir comment elle a
fonctionn√© sur nightly, et vont d√©cider si elle doit √™tre publi√©e sur Rust
stable ou non. Si la d√©cision est d'avancer, le drapeau de fonctionnalit√© est
enlev√©, et la fonctionnalit√© est maintenant consid√©r√©e comme stable¬†! Elle saute
alors dans le train en direction d'une nouvelle publication stable de Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
