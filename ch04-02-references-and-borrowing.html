<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les r√©f√©rences et l&#x27;emprunt - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html" class="active"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## References and Borrowing
-->
<h2 id="les-r√©f√©rences-et-lemprunt"><a class="header" href="#les-r√©f√©rences-et-lemprunt">Les r√©f√©rences et l'emprunt</a></h2>
<!--
The issue with the tuple code in Listing 4-5 is that we have to return the
`String` to the calling function so we can still use the `String` after the
call to `calculate_length`, because the `String` was moved into
`calculate_length`. Instead, we can provide a reference to the `String` value.
A *reference* is like a pointer in that it‚Äôs an address we can follow to access
data stored at that address that is owned by some other variable. Unlike a
pointer, a reference is guaranteed to point to a valid value of a particular
type. Here is how you would define and use a `calculate_length` function that
has a reference to an object as a parameter instead of taking ownership of the
value:
-->
<p>La difficult√© avec le code du tuple √† la fin de la section pr√©c√©dente est que
nous avons besoin de retourner la <code>String</code> au code appelant pour qu'il puisse
continuer √† utiliser la <code>String</code> apr√®s l'appel √† <code>calculer_taille</code>, car la
<code>String</code> a √©t√© d√©plac√©e dans <code>calculer_taille</code>. √Ä la place, nous pouvons
fournir une r√©f√©rence √† la valeur de la String. Une <em>r√©f√©rence</em> est comme un
pointeur dans le sens o√π c'est une adresse que nous pouvons suivre pour acc√©der
√† la donn√©e stock√©e √† cette adresse qui est poss√©d√©e par une autre variable.
Mais contrairement aux pointeurs, une r√©f√©rence garantit de pointer vers une
valeur en vigueur, d'un type bien d√©termin√©. Voici comment d√©finir et utiliser
une fonction <code>calculer_taille</code> qui prend une <em>r√©f√©rence</em> √† un objet en
param√®tre plut√¥t que de prendre possession de la valeur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
}

fn calculer_taille(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!--
First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass `&s1` into
`calculate_length` and, in its definition, we take `&String` rather than
`String`. These ampersands represent *references*, and they allow you to refer
to some value without taking ownership of it. Figure 4-5 depicts this concept.
-->
<p>Premi√®rement, on peut observer que tout le code des <em>tuples</em> dans la
d√©claration des variables et dans la valeur de retour de la fonction a √©t√©
enlev√©. Deuxi√®mement, remarquez que nous passons <code>&amp;s1</code> √† <code>calculer_taille</code>, et
que dans sa d√©finition, nous utilisons <code>&amp;String</code> plut√¥t que <code>String</code>. Ces
esperluettes repr√©sentent les <em>r√©f√©rences</em>, et elles permettent de vous r√©f√©rer
√† une valeur sans en prendre possession. L'illustration 4-5 illustre ce
concept.</p>
<!-- markdownlint-disable -->
<!--
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img alt="&String s qui pointe vers la String s1" src="img/trpl04-05.svg"
class="center" /></p>
<!--
<span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String
s1`</span>
-->
<p><span class="caption">Illustration 4-5¬†: Un sch√©ma de la <code>&amp;String s</code> qui pointe
vers la <code>String s1</code></span></p>
<!--
> Note: The opposite of referencing by using `&` is *dereferencing*, which is
> accomplished with the dereference operator, `*`. We‚Äôll see some uses of the
> dereference operator in Chapter 8 and discuss details of dereferencing in
> Chapter 15.
-->
<blockquote>
<p>Remarque¬†: l'oppos√© de la cr√©ation de r√©f√©rences avec <code>&amp;</code> est le
<em>d√©r√©f√©rencement</em>, qui s'effectue avec l'op√©rateur de d√©r√©f√©rencement, <code>*</code>.
Nous allons voir quelques utilisations de l'op√©rateur de d√©r√©f√©rencement dans
le chapitre 8 et nous aborderons les d√©tails du d√©r√©f√©rencement dans le
chapitre 15.</p>
</blockquote>
<!--
Let‚Äôs take a closer look at the function call here:
-->
<p>Regardons de plus pr√®s l'appel √† la fonction¬†:</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
# fn calculate_length(s: &String) -> usize {
#     s.len()
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculer_taille(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<!--
The `&s1` syntax lets us create a reference that *refers* to the value of `s1`
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference stops being used.
-->
<p>La syntaxe <code>&amp;s1</code> nous permet de cr√©er une r√©f√©rence qui se <em>r√©f√®re</em> √† la valeur
de <code>s1</code> mais n'en prend pas possession. Et comme elle ne la poss√®de pas, la
valeur vers laquelle elle pointe ne sera pas lib√©r√©e quand cette r√©f√©rence
ne sera plus utilis√©e.</p>
<!--
Likewise, the signature of the function uses `&` to indicate that the type of
the parameter `s` is a reference. Let‚Äôs add some explanatory annotations:
-->
<p>De la m√™me mani√®re, la signature de la fonction utilise <code>&amp;</code> pour indiquer que
le type du param√®tre <code>s</code> est une r√©f√©rence. Ajoutons quelques commentaires
explicatifs¬†:</p>
<!--
```rust
# fn main() {
#     let s1 = String::from("hello");
# 
#     let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let long = calculer_taille(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculer_taille(s: &amp;String) -&gt; usize { // s est une r√©f√©rence √† une String
  s.len()
} // Ici, s sort de la port√©e. Mais comme elle ne prend pas possession de ce
  // √† quoi elle fait r√©f√©rence, il ne se passe rien.
</code></pre></pre>
<!--
The scope in which the variable `s` is valid is the same as any function
parameter‚Äôs scope, but the value pointed to by the reference is not dropped
when `s` stops being used because `s` doesn‚Äôt have ownership. When functions
have references as parameters instead of the actual values, we won‚Äôt need to
return the values in order to give back ownership, because we never had
ownership.
-->
<p>La port√©e dans laquelle la variable <code>s</code> est en vigueur est la m√™me que toute
port√©e d'un param√®tre de fonction, mais la valeur point√©e par la r√©f√©rence
n'est pas lib√©r√©e quand <code>s</code> n'est plus utilis√©, car <code>s</code> n'en prends pas
possession. Lorsque les fonctions ont des r√©f√©rences en param√®tres au lieu des
valeurs r√©elles, nous n'avons pas besoin de retourner les valeurs pour les
rendre, car nous n'en avons jamais pris possession.</p>
<!--
We call the action of creating a reference *borrowing*. As in real life, if a
person owns something, you can borrow it from them. When you‚Äôre done, you have
to give it back. You don‚Äôt own it.
-->
<p>Nous appelons <em>l'emprunt</em> l'action de cr√©er une r√©f√©rence. Comme dans la vie
r√©elle, quand un objet appartient √† quelqu'un, vous pouvez le lui emprunter. Et
quand vous avez fini, vous devez le lui rendre. Vous ne le poss√©dez pas.</p>
<!--
So what happens if we try to modify something we‚Äôre borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn‚Äôt work!
-->
<p>Donc qu'est-ce qui se passe si nous essayons de modifier quelque chose que nous
empruntons¬†? Essayez le code dans l'encart 4-6. Attention, spoiler¬†: cela ne
fonctionne pas¬†!</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    changer(&amp;s);
}

fn changer(texte: &amp;String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 4-6: Attempting to modify a borrowed value</span>
-->
<p><span class="caption">Entr√©e 4-6¬†: Tentative de modification d'une valeur
emprunt√©e.</span></p>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 -- > src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*texte` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn changer(texte: &amp;String) {
  |                   ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     texte.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ `texte` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Just as variables are immutable by default, so are references. We‚Äôre not
allowed to modify something we have a reference to.
-->
<p>Comme les variables sont immuables par d√©faut, les r√©f√©rences le sont aussi.
Nous ne sommes pas autoris√©s √† modifier une chose quand nous avons une r√©f√©rence
vers elle.</p>
<!--
### Mutable References
-->
<h3 id="les-r√©f√©rences-mutables"><a class="header" href="#les-r√©f√©rences-mutables">Les r√©f√©rences mutables</a></h3>
<!--
We can fix the code from Listing 4-6 to allow us to modify a borrowed value
with just a few small tweaks that use, instead, a *mutable reference*:
-->
<p>Nous pouvons r√©soudre le code de l'encart 4-6 pour nous permettre de modifier
une valeur emprunt√©e avec quelques petites modification qui utilisent plut√¥t
une <em>r√©f√©rence mutable</em>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    changer(&amp;mut s);
}

fn changer(texte: &amp;mut String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!--
First, we change `s` to be `mut`. Then we create a mutable reference with `&mut
s` where we call the `change` function, and update the function signature to
accept a mutable reference with `some_string: &mut String`. This makes it very
clear that the `change` function will mutate the value it borrows.
-->
<p>D'abord, nous pr√©cisons que <code>s</code> est <code>mut</code>. Ensuite, nous avons cr√©√© une
r√©f√©rence mutable avec <code>&amp;mut s</code> o√π nous appelons la fonction <code>change</code> et nous
avons modifi√© la signature pour accepter de prendre une r√©f√©rence mutable avec
<code>texte: &amp;mut String</code>. Cela pr√©cise clairement que la fonction <code>change</code> va faire
muter la valeur qu'elle emprunte.</p>
<!--
Mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data at a time. This code that attempts to
create two mutable references to `s` will fail:
-->
<p>Les r√©f√©rences mutables ont une grosse contrainte¬†: vous ne pouvez avoir
qu'une seule r√©f√©rence mutable pour chaque donn√©e au m√™me moment. Le code
suivant qui va tenter de cr√©er deux r√©f√©rences mutables √† <code>s</code> va √©chouer¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 -- > src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
This error says that this code is invalid because we cannot borrow `s` as
mutable more than once at a time. The first mutable borrow is in `r1` and must
last until it‚Äôs used in the `println!`, but between the creation of that
mutable reference and its usage, we tried to create another mutable reference
in `r2` that borrows the same data as `r1`.
-->
<p>Cette erreur nous explique que ce code est invalide car nous ne pouvons pas
emprunter <code>s</code> de mani√®re mutable plus d'une fois au m√™me moment. Le premier
emprunt mutable est dans <code>r1</code> et doit perdurer jusqu'√† ce qu'il soit utilis√©
dans le <code>println!</code>, mais pourtant entre la cr√©ation de cette r√©f√©rence mutable
et son utilisation, nous avons essay√© de cr√©er une autre r√©f√©rence mutable dans
<code>r2</code> qui emprunte la m√™me donn√©e que dans <code>r1</code>.</p>
<!--
The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It‚Äôs something
that new Rustaceans struggle with, because most languages let you mutate
whenever you‚Äôd like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A *data race* is similar to a race
condition and happens when these three behaviors occur:
-->
<p>La limitation qui emp√™che d'avoir plusieurs r√©f√©rences mutables vers la m√™me
donn√©e au m√™me moment autorise les mutations, mais de mani√®re tr√®s contr√¥l√©e.
C'est quelque chose que les nouveaux Rustac√©s ont du mal √† surmonter, car la
plupart des langages vous permettent de modifier les donn√©es quand vous le
voulez. L'avantage d'avoir cette contrainte est que Rust peut emp√™cher les
acc√®s concurrents au moment de la compilation. Un <em>acc√®s concurrent</em> est une
situation de concurrence qui se produit lorsque ces trois facteurs se
combinent¬†:</p>
<!--
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* There‚Äôs no mechanism being used to synchronize access to the data.
-->
<ul>
<li>Deux pointeurs ou plus acc√®dent √† la m√™me donn√©e au m√™me moment.</li>
<li>Au moins un des pointeurs est utilis√© pour √©crire dans cette donn√©e.</li>
<li>On n'utilise aucun m√©canisme pour synchroniser l'acc√®s aux donn√©es.</li>
</ul>
<!--
Data races cause undefined behavior and can be difficult to diagnose and fix
when you‚Äôre trying to track them down at runtime; Rust prevents this problem
by refusing to compile code with data races!
-->
<p>L'acc√®s concurrent provoque des comportements ind√©finis et rend difficile le
diagnostic et la r√©solution de probl√®mes lorsque vous essayez de les reproduire
au moment de l'ex√©cution¬†; Rust √©vite ce probl√®me en refusant de compiler du
code avec des acc√®s concurrents¬†!</p>
<!--
As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not *simultaneous* ones:
-->
<p>Comme d'habitude, nous pouvons utiliser des accolades pour cr√©er une nouvelle
port√©e, pour nous permettre d'avoir plusieurs r√©f√©rences mutables, mais pas
<em>en m√™me temps</em>¬†:</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 sort de la port√©e ici, donc nous pouvons cr√©er une nouvelle r√©f√©rence
      // sans probl√®mes.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<!--
Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:
-->
<p>Rust impose une r√®gle similaire pour combiner les r√©f√©rences immuables et
mutables. Ce code va mener √† une erreur¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans probl√®me
    let r2 = &amp;s; // sans probl√®me
    let r3 = &amp;mut s; // GROS PROBLEME
    
    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // sans probl√®me
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // sans probl√®me
6 |     let r3 = &amp;mut s; // GROS PROBLEME
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Whew! We *also* cannot have a mutable reference while we have an immutable one
to the same value. Users of an immutable reference don‚Äôt expect the value to
suddenly change out from under them! However, multiple immutable references are
allowed because no one who is just reading the data has the ability to affect
anyone else‚Äôs reading of the data.
-->
<p>Ouah¬†! Nous ne pouvons pas <em>non plus</em> avoir une r√©f√©rence mutable pendant que
nous en avons une autre immuable vers la m√™me valeur. Les utilisateurs d'une
r√©f√©rence immuable ne s'attendent pas √† ce que sa valeur change soudainement¬†!
Cependant, l'utilisation de plusieurs r√©f√©rences immuables ne pose pas de
probl√®me, car simplement lire une donn√©e ne va pas affecter la lecture de la
donn√©e par les autres.</p>
<!--
Note that a reference‚Äôs scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references, the `println!`,
occurs before the mutable reference is introduced:
-->
<p>Notez bien que la port√©e d'une r√©f√©rence commence d√®s qu'elle est introduite et
se poursuit jusqu'au dernier endroit o√π cette r√©f√©rence est utilis√©e. Par
exemple, le code suivant va se compiler car la derni√®re utilisation de la
r√©f√©rence immuable, le <code>println!</code>, est situ√©e avant l'introduction de la
r√©f√©rence mutable¬†:</p>
<!--
```rust,edition2021
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans probl√®me
    let r2 = &amp;s; // sans probl√®me
    println!(&quot;{} et {}&quot;, r1, r2);
    //les variables r1 et r2 ne seront plus utilis√©s √† partir d'ici
    
    let r3 = &amp;mut s; // sans probl√®me
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<!--
The scopes of the immutable references `r1` and `r2` end after the `println!`
where they are last used, which is before the mutable reference `r3` is
created. These scopes don‚Äôt overlap, so this code is allowed. The ability of
the compiler to tell that a reference is no longer being used at a point before
the end of the scope is called *Non-Lexical Lifetimes* (NLL for short), and you
can read more about it in [The Edition Guide][nll].
-->
<p>Les port√©es des r√©f√©rences immuables <code>r1</code> et <code>r2</code> se terminent apr√®s le
<code>println!</code> o√π elles sont utilis√©es pour la derni√®re fois, c'est-√†-dire avant que
la r√©f√©rence mutable <code>r3</code> soit cr√©√©e. Ces port√©es ne se chevauchent pas, donc ce
code est autoris√©. La capacit√© du compilateur √† dire si une r√©f√©rence n'est plus
utilis√©e √† un endroit avant la fin de la port√©e s'appelle en Anglais les
<em>Non-Lexical Lifetimes</em> (ou NLL), et vous pouvez en apprendre plus dans le
<a href="https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">Guide de l'√©dition</a>.</p>
<!--
Even though borrowing errors may be frustrating at times, remember that it‚Äôs
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you don‚Äôt
have to track down why your data isn‚Äôt what you thought it was.
-->
<p>M√™me si ces erreurs d'emprunt peuvent parfois √™tre frustrantes, n'oubliez pas
que le compilateur de Rust nous signale un bogue potentiel en avance (au moment
de la compilation plut√¥t que l'ex√©cution) et vous montre o√π se situe exactement
le probl√®me. Ainsi, vous n'avez pas √† chercher pourquoi vos donn√©es ne
correspondent pas √† ce que vous pensiez qu'elles devraient √™tre.</p>
<!--
### Dangling References
-->
<h3 id="les-r√©f√©rences-pendouillantes"><a class="header" href="#les-r√©f√©rences-pendouillantes">Les r√©f√©rences pendouillantes</a></h3>
<!--
In languages with pointers, it‚Äôs easy to erroneously create a *dangling
pointer*--a pointer that references a location in memory that may have been
given to someone else--by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.
-->
<p>Avec les langages qui utilisent les pointeurs, il est facile de cr√©er par erreur
un <em>pointeur pendouillant</em> (<em>dangling pointer</em>), qui est un pointeur qui pointe
vers un emplacement m√©moire qui a √©t√© donn√© √† quelqu'un d'autre, en lib√©rant de
la m√©moire tout en conservant un pointeur vers cette m√©moire. En revanche, avec
Rust, le compilateur garantit que les r√©f√©rences ne seront jamais des r√©f√©rences
pendouillantes¬†: si nous avons une r√©f√©rence vers une donn√©e, le compilateur va
s'assurer que cette donn√©e ne va pas sortir de la port√©e avant que la r√©f√©rence
vers cette donn√©e en soit elle-m√™me sortie.</p>
<!--
Let‚Äôs try to create a dangling reference to see how Rust prevents them with a
compile-time error:
-->
<p>Essayons de cr√©er une r√©f√©rence pendouillante pour voir comment Rust va les
emp√™cher via une erreur au moment de la compilation¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_vers_rien = pendouille();
}

fn pendouille() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!--
Here‚Äôs the error:
-->
<p>Voici l'erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 -- > src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn pendouille() -&gt; &amp;String {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn pendouille() -&gt; &amp;'static String {
  |                    ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
This error message refers to a feature we haven‚Äôt covered yet: lifetimes. We‚Äôll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:
-->
<p>Ce message d'erreur fait r√©f√©rence √† une fonctionnalit√© que nous n'avons pas
encore vue¬†: les <em>dur√©es de vie</em>. Nous aborderons les dur√©es de vie dans le
chapitre 10. Mais, si vous mettez de c√¥t√© les parties qui parlent de dur√©es de
vie, le message explique pourquoi le code pose probl√®me¬†:</p>
<!--
```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
```
-->
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Ce qui peut se traduire par¬†:</p>
<pre><code class="language-text">Le type de retour de cette fonction contient une valeur emprunt√©e, mais il n'y a
plus aucune valeur qui peut √™tre emprunt√©e.
</code></pre>
<!--
Let‚Äôs take a closer look at exactly what‚Äôs happening at each stage of our
`dangle` code:
-->
<p>Regardons de plus pr√®s ce qui se passe exactement √† chaque √©tape de notre code
de <code>pendouille</code>¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let reference_to_nothing = dangle();
# }
# 
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_vers_rien = pendouille();
</span><span class="boring">}
</span><span class="boring">
</span>fn pendouille() -&gt; &amp;String { // pendouille retourne une r√©f√©rence vers une String

  let s = String::from(&quot;hello&quot;); // s est une nouvelle String

  &amp;s // nous retournons une r√©f√©rence vers la String, s
} // Ici, s sort de la port√©e, et est lib√©r√©. Sa m√©moire dispara√Æt.
  // Attention, danger¬†!
</code></pre>
<!--
Because `s` is created inside `dangle`, when the code of `dangle` is finished,
`s` will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid `String`. That‚Äôs no good! Rust
won‚Äôt let us do this.
-->
<p>Comme <code>s</code> est cr√©√© dans <code>pendouille</code>, lorsque le code de <code>pendouille</code> est
termin√©, la variable <code>s</code> sera d√©sallou√©e. Mais nous avons essay√© de retourner
une r√©f√©rence vers elle. Cela veut dire que cette r√©f√©rence va pointer vers une
<code>String</code> invalide. Ce n'est pas bon ! Rust ne nous laissera pas faire cela.</p>
<!--
The solution here is to return the `String` directly:
-->
<p>Ici la solution est de renvoyer la <code>String</code> directement¬†:</p>
<!--
```rust
# fn main() {
#     let string = no_dangle();
# }
# 
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = ne_pendouille_pas();
</span><span class="boring">}
</span><span class="boring">
</span>fn ne_pendouille_pas() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<!--
This works without any problems. Ownership is moved out, and nothing is
deallocated.
-->
<p>Cela fonctionne sans probl√®me. La possession est transf√©r√©e √† la valeur de
retour de la fonction, et rien n'est d√©sallou√©.</p>
<!--
### The Rules of References
-->
<h3 id="les-r√®gles-de-r√©f√©rencement"><a class="header" href="#les-r√®gles-de-r√©f√©rencement">Les r√®gles de r√©f√©rencement</a></h3>
<!--
Let‚Äôs recap what we‚Äôve discussed about references:
-->
<p>R√©capitulons ce que nous avons vu √† propos des r√©f√©rences¬†:</p>
<!--
* At any given time, you can have *either* one mutable reference *or* any
  number of immutable references.
* References must always be valid.
-->
<ul>
<li>√Ä un instant donn√©, vous pouvez avoir <em>soit</em> une r√©f√©rence mutable, <em>soit</em> un
nombre quelconque de r√©f√©rences immuables.</li>
<li>Les r√©f√©rences doivent toujours √™tre en vigueur.</li>
</ul>
<!--
Next, we‚Äôll look at a different kind of reference: slices.
-->
<p>Ensuite, nous aborderons un autre type de r√©f√©rence¬†: les <em>slices</em>.</p>
<!--
[nll]: https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-01-what-is-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch04-03-slices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-01-what-is-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch04-03-slices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
