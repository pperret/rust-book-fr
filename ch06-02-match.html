<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>La structure de contr√¥le match - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html" class="active"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
<a id="the-match-control-flow-operator"></a>
## The `match` Control Flow Construct
-->
<p><a id="la-structure-de-contr√¥le-match"></a></p>
<h2 id="la-structure-de-contr√¥le-de-flux-match"><a class="header" href="#la-structure-de-contr√¥le-de-flux-match">La structure de contr√¥le de flux <code>match</code></a></h2>
<!--
Rust has an extremely powerful control flow construct called `match` that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rust a une structure de contr√¥le de flux tr√®s puissante appel√©e <code>match</code> qui vous
permet de comparer une valeur avec une s√©rie de motifs et d'ex√©cuter du code en
fonction du motif qui correspond. Les motifs peuvent √™tre constitu√©s de valeurs
litt√©rales, de noms de variables, de jokers, parmi tant d'autres¬†; le
chapitre 18 va couvrir tous les diff√©rents types de motifs et ce qu'ils font. Ce
qui fait la puissance de <code>match</code> est l'expressivit√© des motifs et le fait que le
compilateur v√©rifie que tous les cas possibles sont bien g√©r√©s.</p>
<!--
Think of a `match` expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value ‚Äúfits,‚Äù
the value falls into the associated code block to be used during execution.
Speaking of coins, let‚Äôs use them as an example using `match`! We can write a
function that takes an unknown United States coin and, in a similar way as the
counting machine, determines which coin it is and return its value in cents, as
shown here in Listing 6-3.
-->
<p>Consid√©rez l'expression <code>match</code> comme une machine √† trier les pi√®ces de
monnaie¬†: les pi√®ces descendent le long d'une piste avec des trous de tailles
diff√©rentes, et chaque pi√®ce tombe dans le premier trou √† sa taille qu'elle
rencontre. De mani√®re similaire, les valeurs parcourent tous les motifs dans un
<code>match</code>, et au premier motif auquel la valeur ‚Äúcorrespond‚Äù, la valeur va
descendre dans le bloc de code correspondant afin d'√™tre utilis√©e pendant son
ex√©cution. En parlant des pi√®ces, utilisons-les avec un exemple qui utilise
<code>match</code>¬†! Nous pouvons √©crire une fonction qui prend en param√®tre une pi√®ce
inconnue des √âtats-Unis d'Am√©rique et qui peut, de la m√™me mani√®re qu'une
machine √† trier, d√©terminer quelle pi√®ce c'est et retourner sa valeur en
centimes, comme ci-dessous dans l'encart 6-3.</p>
<!--
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum PieceUs {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; 1,
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns</span>
-->
<p><span class="caption">Encart 6-3¬†: Une √©num√©ration et une expression <code>match</code> qui
trie les variantes de l'√©num√©ration dans ses motifs</span></p>
<!--
Let‚Äôs break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but there‚Äôs a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can return any type. The type of `coin` in this example is the `Coin`
enum that we defined on the first line.
-->
<p>D√©composons le <code>match</code> dans la fonction <code>valeur_en_centimes</code>. En premier lieu,
nous utilisons le mot-cl√© <code>match</code> suivi par une expression, qui dans notre cas
est la valeur de <code>piece</code>. Cela ressemble beaucoup √† une expression utilis√©e avec
<code>if</code>, mais il y a une grosse diff√©rence¬†: avec <code>if</code>, l'expression doit retourner
une valeur bool√©enne, mais ici, elle retourne n'importe quel type. Dans cet
exemple, <code>piece</code> est de type <code>PieceUs</code>, qui est l'√©num√©ration que nous avons
d√©finie √† la premi√®re ligne.</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>Ensuite, nous avons les branches du <code>match</code>. Une branche a deux parties¬†: un
motif et du code. La premi√®re branche a ici pour motif la valeur
<code>PieceUs::Penny</code> et ensuite l'op√©rateur <code>=&gt;</code> qui s√©pare le motif et le code √†
ex√©cuter. Le code dans ce cas est uniquement la valeur <code>1</code>. Chaque branche est
s√©par√©e de la suivante par une virgule.</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn‚Äôt match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>Lorsqu'une expression <code>match</code> est ex√©cut√©e, elle compare la valeur de <code>piece</code>
avec le motif de chaque branche, dans l'ordre. Si un motif correspond √† la
valeur, le code correspondant √† ce motif est alors ex√©cut√©. Si ce motif ne
correspond pas √† la valeur, l'ex√©cution passe √† la prochaine branche, un peu
comme dans une machine de tri de pi√®ces. Nous pouvons avoir autant de branches
que n√©cessaire¬†: dans l'encart 6-3, notre <code>match</code> a quatre branches.</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>Le code correspondant √† chaque branche est une expression, et la valeur qui
r√©sulte de l'expression dans la branche correspondante est la valeur qui sera
retourn√©e par l'expression <code>match</code>.</p>
<!--
We don‚Äôt typically use curly brackets if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you must use curly brackets. For example, the
following code prints ‚ÄúLucky penny!‚Äù every time the method is called with a
`Coin::Penny`, but still returns the last value of the block, `1`:
-->
<p>Habituellement, nous n'utilisons pas les accolades si le code de la branche
correspondante est court, comme c'est le cas dans l'encart 6-3 o√π chaque
branche retourne simplement une valeur. Si vous voulez ex√©cuter plusieurs
lignes de code dans une branche d'un <code>match</code>, vous devez utiliser les
accolades. Par exemple, le code suivant va afficher ‚ÄúUn centime
porte-bonheur¬†!‚Äù √† chaque fois que la m√©thode est appel√©e avec une valeur
<code>PieceUs::Penny</code>, mais va continuer √† retourner la derni√®re valeur du
bloc, <code>1</code>¬†:</p>
<!--
```rust
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter,
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; {
            println!(&quot;Un centime porte-bonheur¬†!&quot;);
            1
        }
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3 id="des-motifs-reli√©s-√†-des-valeurs"><a class="header" href="#des-motifs-reli√©s-√†-des-valeurs">Des motifs reli√©s √† des valeurs</a></h3>
<!--
Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>Une autre fonctionnalit√© int√©ressante des branches de <code>match</code> est qu'elles
peuvent se lier aux valeurs qui correspondent au motif. C'est ainsi que nous
pouvons extraire des valeurs d'une variante d'√©num√©ration.</p>
<!--
As an example, let‚Äôs change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which we‚Äôve done here in Listing 6-4.
-->
<p>En guise d'exemple, changeons une de nos variantes d'√©num√©ration pour stocker
une donn√©e √† l'int√©rieur. Entre 1999 et 2008, les √âtats-Unis d'Am√©rique ont
frapp√© un c√¥t√© des <em>quarters</em> (pi√®ces de 25 centimes) avec des dessins
diff√©rents pour chacun des 50 √âtats. Les autres pi√®ces n'ont pas eu de dessins
d'√âtats, donc seul le <em>quarter</em> a cette valeur en plus. Nous pouvons ajouter
cette information √† notre <code>enum</code> en changeant la variante <code>Quarter</code> pour y
ajouter une valeur <code>EtatUs</code> qui y sera stock√©e √† l'int√©rieur, comme nous
l'avons fait dans l'encart 6-4.</p>
<!--
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // pour pouvoir afficher l'√âtat
enum EtatUs {
    Alabama,
    Alaska,
    // -- partie masqu√©e ici --
}

enum PieceUs {
    Penny,
    Nickel,
    Dime,
    Quarter(EtatUs),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">Encart 6-4¬†: Une √©num√©ration <code>PieceUs</code> dans laquelle la
variante <code>Quarter</code> stocke en plus une valeur de type <code>EtatUs</code></span></p>
<!--
Let‚Äôs imagine that a friend is trying to collect all 50 state quarters. While
we sort our loose change by coin type, we‚Äôll also call out the name of the
state associated with each quarter so if it‚Äôs one our friend doesn‚Äôt have, they
can add it to their collection.
-->
<p>Imaginons qu'un de vos amis essaye de collectionner tous les <em>quarters</em> des 50
√âtats. Pendant que nous trions notre monnaie en vrac par type de pi√®ce, nous
mentionnerons aussi le nom de l'√âtat correspondant √† chaque <em>quarter</em> de sorte
que si notre ami ne l'a pas, il puisse l'ajouter √† sa collection.</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarter‚Äôs state. Then we can use `state` in the code for that arm, like so:
-->
<p>Dans l'expression <code>match</code> de ce code, nous avons ajout√© une variable <code>etat</code> au
motif qui correspond √† la variante <code>PieceUs::Quarter</code>. Quand on aura une
correspondance <code>PieceUs::Quarter</code>, la variable <code>etat</code> sera li√©e √† la valeur de
l'√âtat de cette pi√®ce. Ensuite, nous pourrons utiliser <code>etat</code> dans le code de
cette branche, comme ceci¬†:</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
# 
# fn main() {
#     value_in_cents(Coin::Quarter(UsState::Alaska));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masqu√©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; 1,
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter(etat) =&gt; {
            println!(&quot;Il s'agit d'un quarter de l'√âtat de {:?}¬†!&quot;, etat);
            25
        },
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    valeur_en_centimes(PieceUs::Quarter(EtatUs::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p>Si nous appelons <code>valeur_en_centimes(PieceUs::Quarter(EtatUs::Alaska))</code>, <code>piece</code>
vaudra <code>PieceUs::Quarter(EtatUs::Alaska)</code>. Quand nous comparons cette valeur
avec toutes les branches du <code>match</code>, aucune d'entre elles ne correspondra
jusqu'√† ce qu'on arrive √† <code>PieceUs::Quarter(etat)</code>. √Ä partir de ce moment, la
variable <code>etat</code> aura la valeur <code>EtatUs::Alaska</code>. Nous pouvons alors utiliser
cette variable dans l'expression <code>println!</code>, ce qui nous permet d'afficher la
valeur de l'√âtat √† l'int√©rieur de la variante <code>Quarter</code> de l'√©num√©ration
<code>PieceUs</code>.</p>
<!--
### Matching with `Option<T>`
-->
<h3 id="utiliser-match-avec-optiont"><a class="header" href="#utiliser-match-avec-optiont">Utiliser <code>match</code> avec <code>Option&lt;T&gt;</code></a></h3>
<!--
In the previous section, we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, we‚Äôll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>Dans la section pr√©c√©dente, nous voulions obtenir la valeur interne <code>T</code> dans le
cas de <code>Some</code> lorsqu'on utilisait <code>Option&lt;T&gt;</code>¬†; nous pouvons aussi g√©rer les
<code>Option&lt;T&gt;</code> en utilisant <code>match</code> comme nous l'avons fait avec l'√©num√©ration
<code>PieceUs</code>¬†! Au lieu de comparer des pi√®ces, nous allons comparer les variantes
de <code>Option&lt;T&gt;</code>, mais la fa√ßon d'utiliser l'expression <code>match</code> reste la m√™me.</p>
<!--
Let‚Äôs say we want to write a function that takes an `Option<i32>` and, if
there‚Äôs a value inside, adds 1 to that value. If there isn‚Äôt a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p>Disons que nous voulons √©crire une fonction qui prend une <code>Option&lt;i32&gt;</code> et qui,
s'il y a une valeur √† l'int√©rieur, ajoute 1 √† cette valeur. S'il n'y a pas de
valeur √† l'int√©rieur, la fonction retournera la valeur <code>None</code> et ne va rien
faire de plus.</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p>Cette fonction est tr√®s facile √† √©crire, gr√¢ce √† <code>match</code>, et ressemblera √†
l'encart 6-5.</p>
<!--
```rust
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let cinq = Some(5);
    let six = plus_un(cinq);
    let none = plus_un(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">Encart 6-5¬†: Une fonction qui utilise une expression
<code>match</code> sur une <code>Option&lt;i32&gt;</code></span></p>
<!--
Let‚Äôs examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p>Examinons la premi√®re ex√©cution de <code>plus_un</code> en d√©tail. Lorsque nous appelons
<code>plus_un(cinq)</code>, la variable <code>x</code> dans le corps de <code>plus_un</code> aura la valeur
<code>Some(5)</code>. Ensuite, nous comparons cela √† chaque branche du <code>match</code>.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
The `Some(5)` value doesn‚Äôt match the pattern `None`, so we continue to the
next arm.
-->
<p>La valeur <code>Some(5)</code> ne correspond pas au motif <code>None</code>, donc nous continuons √† la
branche suivante.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
#             None => None,
            Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add 1 to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<p>Est-ce que <code>Some(5)</code> correspond au motif <code>Some(i)</code>¬†? Bien s√ªr¬†! Nous avons la
m√™me variante. Le <code>i</code> va prendre la valeur contenue dans le <code>Some</code>, donc <code>i</code>
prend la valeur <code>5</code>. Le code dans la branche du <code>match</code> est ex√©cut√©, donc nous
ajoutons 1 √† la valeur de <code>i</code> et nous cr√©ons une nouvelle valeur <code>Some</code> avec
notre r√©sultat <code>6</code> √† l'int√©rieur.</p>
<!--
Now let‚Äôs consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>Maintenant, regardons le second appel √† <code>plus_un</code> dans l'encart 6-5, o√π <code>x</code> vaut
<code>None</code>. Nous entrons dans le <code>match</code> et nous le comparons √† la premi√®re branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
It matches! There‚Äôs no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>Cela correspond¬†! Il n'y a pas de valeur √† additionner, donc le programme
s'arr√™te et retourne la valeur <code>None</code> qui est dans le c√¥t√© droit du <code>=&gt;</code>. Comme
la premi√®re branche correspond, les autres branches ne sont pas compar√©es.</p>
<!--
Combining `match` and enums is useful in many situations. You‚Äôll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. It‚Äôs a bit tricky at first, but
once you get used to it, you‚Äôll wish you had it in all languages. It‚Äôs
consistently a user favorite.
-->
<p>La combinaison de <code>match</code> et des √©num√©rations est utile dans de nombreuses
situations. Vous allez revoir de nombreuses fois ce sch√©ma dans du code Rust¬†:
utiliser <code>match</code> sur une √©num√©ration, r√©cup√©rer la valeur qu'elle renferme, et
ex√©cuter du code en fonction de sa valeur. C'est un peu d√©licat au d√©but, mais
une fois que vous vous y √™tes habitu√©, vous regretterez de ne pas l'avoir dans
les autres langages. Cela devient toujours l'outil pr√©f√©r√© de ses utilisateurs.</p>
<!--
### Matches Are Exhaustive
-->
<h3 id="les-match-sont-toujours-exhaustifs"><a class="header" href="#les-match-sont-toujours-exhaustifs">Les <code>match</code> sont toujours exhaustifs</a></h3>
<!--
There‚Äôs one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and won‚Äôt compile:
-->
<p>Il y a un autre point de <code>match</code> que nous devons aborder. Examinez cette version
de notre fonction <code>plus_un</code> qui a un bogue et ne va pas se compiler¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
We didn‚Äôt handle the `None` case, so this code will cause a bug. Luckily, it‚Äôs
a bug Rust knows how to catch. If we try to compile this code, we‚Äôll get this
error:
-->
<p>Nous n'avons pas g√©r√© le cas du <code>None</code>, donc ce code va g√©n√©rer un bogue.
Heureusement, c'est un bogue que Rust sait g√©rer. Si nous essayons de compiler
ce code, nous allons obtenir cette erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   -- > src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<!--
Rust knows that we didn‚Äôt cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier impossible.
-->
<p>Rust sait que nous n'avons pas couvert toutes les possibilit√©s et sait m√™me quel
motif nous avons oubli√©¬†! Les <code>match</code> de Rust sont <em>exhaustifs</em>¬†: nous devons
traiter toutes les possibilit√©s afin que le code soit valide. C'est notamment le
cas avec <code>Option&lt;T&gt;</code>¬†: quand Rust nous emp√™che d'oublier de g√©rer explicitement
le cas de <code>None</code>, il nous prot√®ge d'une situation o√π nous supposons que nous
avons une valeur alors que nous pourrions avoir null, ce qui rend impossible
l'erreur √† un milliard de dollars que nous avons vue pr√©c√©demment.</p>
<!--
### Catch-all Patterns and the `_` Placeholder
-->
<h3 id="les-motifs-g√©n√©riques-et-le-motif-_"><a class="header" href="#les-motifs-g√©n√©riques-et-le-motif-_">Les motifs g√©n√©riques et le motif <code>_</code></a></h3>
<!--
Using enums, we can also take special actions for a few particular values, but
for all other values take one default action. Imagine we‚Äôre implementing a game
where, if you roll a 3 on a dice roll, your player doesn‚Äôt move, but instead
gets a new fancy hat. If you roll a 7, your player loses a fancy hat. For all
other values, your player moves that number of spaces on the game board. Here‚Äôs
a `match` that implements that logic, with the result of the dice roll
hardcoded rather than a random value, and all other logic represented by
functions without bodies because actually implementing them is out of scope for
this example:
-->
<p>En utilisant les √©num√©rations, nous pouvons aussi appliquer des actions
sp√©ciales pour certaines valeurs pr√©cises, mais une action par d√©faut pour
toutes les autres valeurs. Imaginons que nous impl√©mentons un jeu dans lequel,
si vous obtenez une valeur de 3 sur un lanc√© de d√©, votre joueur ne se d√©place
pas, mais √† la place il obtient un nouveau chapeau fataisie. Si vous obtenez
un 7, votre joueur perd son chapeau fantaisie. Pour toutes les autres valeurs,
votre joueur se d√©place de ce nombre de cases sur le plateau du jeu. Voici un
<code>match</code> qui impl√©mente cette logique, avec le r√©sultat du lanc√© de d√© cod√© en
dur plut√¥t qu'issu d'une g√©n√©ration al√©atoire, et toute la logique des autres
fonctions sont des corps vides car leur impl√©mentation n'est pas le sujet de
cet exemple¬†:</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        autre =&gt; deplace_joueur(autre),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
    fn deplace_joueur(nombre_cases: u8) {}
<span class="boring">}
</span></code></pre></pre>
<!--
For the first two arms, the patterns are the literal values 3 and 7. For the
last arm that covers every other possible value, the pattern is the variable
we‚Äôve chosen to name `other`. The code that runs for the `other` arm uses the
variable by passing it to the `move_player` function.
-->
<p>Dans les deux premi√®res branches, les motifs sont les valeurs lit√©rales 3 et 7.
La derni√®re branche couvre toutes les autres valeurs possibles, le motif est la
variable <code>autre</code>. Le code qui s'ex√©cute pour la branche <code>autre</code> utilise la
variable en la passant dans la fonction <code>deplacer_joueur</code>.</p>
<!--
This code compiles, even though we haven‚Äôt listed all the possible values a
`u8` can have, because the last pattern will match all values not specifically
listed. This catch-all pattern meets the requirement that `match` must be
exhaustive. Note that we have to put the catch-all arm last because the
patterns are evaluated in order. Rust will warn us if we add arms after a
catch-all because those later arms would never match!
-->
<p>Ce code se compile, m√™me si nous n'avons pas list√© toutes les valeurs possibles
qu'un <code>u8</code> puisse avoir, car le dernier motif va correspondre √† toutes les
valeurs qui ne sont pas sp√©cifiquement list√©s. Ce motif g√©n√©rique r√©pond √† la
condition qu'un <code>match</code> doive √™tre exhaustif. Notez que nous devons placer la
branche avec le motif g√©n√©rique en tout dernier, car les motifs sont √©valu√©s
dans l'ordre. Rust va nous pr√©venir si nous ajoutons des branches apr√®s un motif
g√©n√©rique car toutes ces autres branches ne seront jamais v√©rifi√©es¬†!</p>
<!--
Rust also has a pattern we can use when we don‚Äôt want to use the value in the
catch-all pattern: `_`, which is a special pattern that matches any value and
does not bind to that value. This tells Rust we aren‚Äôt going to use the value,
so Rust won‚Äôt warn us about an unused variable.
-->
<p>Rust a aussi un motif que nous pouvons utiliser lorsque nous n'avons pas besoin
d'utiliser la valeur dans le motif g√©n√©rique¬†: <code>_</code>, qui est un motif sp√©cial
qui v√©rifie n'importe quelle valeur et ne r√©cup√®re pas cette valeur. Ceci
indique √† Rust que nous n'allons pas utiliser la valeur, donc Rust ne va pas
nous pr√©venir qu'il y a une variable non utilis√©e.</p>
<!--
Let‚Äôs change the rules of the game to be that if you roll anything other than
a 3 or a 7, you must roll again. We don‚Äôt need to use the value in that case,
so we can change our code to use `_` instead of the variable named `other`:
-->
<p>Changeons les r√®gles du jeu pour que si nous obtenions autre chose qu'un 3 ou
un 7, nous jetions √† nouveau le d√©. Nous n'avons pas besoin d'utiliser la valeur
dans ce cas, donc nous pouvons changer notre code pour utiliser <code>_</code> au lieu de
la variable <code>autre</code>¬†:</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        _ =&gt; relancer(),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
    fn relancer() {}
<span class="boring">}
</span></code></pre></pre>
<!--
This example also meets the exhaustiveness requirement because we‚Äôre explicitly
ignoring all other values in the last arm; we haven‚Äôt forgotten anything.
-->
<p>Cet exemple r√©pond bien aux crit√®res d'exhaustivit√© car nous ignorons
explicitement toutes les autres valeurs dans la derni√®re branche¬†; nous n'avons
rien oubli√©.</p>
<!--
If we change the rules of the game one more time, so that nothing else happens
on your turn if you roll anything other than a 3 or a 7, we can express that
by using the unit value (the empty tuple type we mentioned in [‚ÄúThe Tuple
Type‚Äù][tuples]<!-- ignore -- > section) as the code that goes with the `_` arm:
-->
<p>Si nous changeons √† nouveau les r√®gles du jeu, afin que rien se passe si vous
obtenez autre chose qu'un 3 ou un 7, nous pouvons exprimer cela en utilisant la
valeur unit√© (le type tuple vide que nous avons cit√© dans <a href="ch03-02-data-types.html">une section
pr√©c√©dente</a><!-- ignore -->) dans le code de la branche <code>_</code>¬†:</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        _ =&gt; (),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
<span class="boring">}
</span></code></pre></pre>
<!--
Here, we‚Äôre telling Rust explicitly that we aren‚Äôt going to use any other value
that doesn‚Äôt match a pattern in an earlier arm, and we don‚Äôt want to run any
code in this case.
-->
<p>Ici, nous indiquons explicitement √† Rust que nous n'allons pas utiliser d'autres
valeurs qui ne correspondent pas √† un motif des branches ant√©rieures, et nous ne
voulons lancer aucun code dans ce cas.</p>
<!--
There‚Äôs more about patterns and matching that we‚Äôll cover in [Chapter
18][ch18-00-patterns]<!-- ignore -- >. For now, we‚Äôre going to move on to the
`if let` syntax, which can be useful in situations where the `match` expression
is a bit wordy.
-->
<p>Il existe aussi d'autres motifs que nous allons voir dans le
<a href="ch18-00-patterns.html">chapitre 18</a><!-- ignore -->. Pour l'instant, nous allons voir
l'autre syntaxe <code>if let</code>, qui peut se rendre utile dans des cas o√π l'expression
<code>match</code> est trop verbeuse.</p>
<!--
[tuples]: ch03-02-data-types.html#the-tuple-type
[ch18-00-patterns]: ch18-00-patterns.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
