<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html" class="active"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Developing the Library‚Äôs Functionality with Test-Driven Development
-->
<h2 id="d√©velopper-les-fonctionnalit√©s-de-la-biblioth√®que-avec-le-tdd"><a class="header" href="#d√©velopper-les-fonctionnalit√©s-de-la-biblioth√®que-avec-le-tdd">D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></h2>
<!--
Now that we‚Äôve extracted the logic into *src/lib.rs* and left the argument
collecting and error handling in *src/main.rs*, it‚Äôs much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line.
-->
<p>Maintenant que nous avons extrait la logique dans <em>src/lib.rs</em> et que nous
avons laiss√© la r√©cup√©ration des arguments et la gestion des erreurs dans
<em>src/main.rs</em>, il est bien plus facile d'√©crire les tests pour les
fonctionnalit√©s de base de notre code. Nous pouvons appeler les fonctions
directement avec diff√©rents arguments et v√©rifier les valeurs de retour sans
avoir √† appeler notre binaire dans la ligne de commande.</p>
<!--
In this section, we‚Äôll add the searching logic to the `minigrep` program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:
-->
<p>Dans cette section, nous allons ajouter la logique de recherche au programme
<code>minigrep</code> en utilisant le processus de d√©veloppement orient√© par les tests
(c'est le TDD¬†: <em>Test-Driven Development</em>). Cette technique de d√©veloppement
de logiciels suit ces trois √©tapes¬†:</p>
<!--
1. Write a test that fails and run it to make sure it fails for the reason you
   expect.
2. Write or modify just enough code to make the new test pass.
3. Refactor the code you just added or changed and make sure the tests
   continue to pass.
4. Repeat from step 1!
-->
<ol>
<li>Ecrire un test qui √©choue et lancez-le pour vous assurer qu'il va √©chouer
pour la raison que vous attendiez.</li>
<li>Ecrire ou modifier juste assez de code pour faire r√©ussir ce nouveau test.</li>
<li>Remanier le code que vous venez d'ajouter ou de changer pour vous assurer
que les tests continuent √† r√©ussir.</li>
<li>Recommencer √† l'√©tape 1¬†!</li>
</ol>
<!--
This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.
-->
<p>Ce processus n'est qu'une des diff√©rentes mani√®res d'√©crire des programmes,
mais le TDD peut aussi aider √† piloter sa conception. Ecrire les tests avant
d'√©crire le code qui fait r√©ussir les tests aide √† maintenir une haute
couverture de tests tout le long du processus.</p>
<!--
We‚Äôll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We‚Äôll add this functionality in a function called
`search`.
-->
<p>Nous allons exp√©rimenter cela avec l'impl√©mentation de la fonctionnalit√© qui va
rechercher la cha√Æne de caract√®res demand√©e dans le contenu du fichier et
g√©n√©rer une liste de lignes qui correspond √† cette recherche. Nous ajouterons
cette fonctionnalit√© dans une fonction <code>rechercher</code>.</p>
<!--
### Writing a Failing Test
-->
<h3 id="ecrire-un-test-qui-√©choue"><a class="header" href="#ecrire-un-test-qui-√©choue">Ecrire un test qui √©choue</a></h3>
<!--
Because we don‚Äôt need them anymore, let‚Äôs remove the `println!` statements from
*src/lib.rs* and *src/main.rs* that we used to check the program‚Äôs behavior.
Then, in *src/lib.rs*, we‚Äôll add a `tests` module with a test function, as we
did in [Chapter 11][ch11-anatomy]<!-- ignore -- >. The test function specifies
the behavior we want the `search` function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which won‚Äôt compile
yet.
-->
<p>Comme nous n'en avons plus besoin, enlevons les instructions <code>println!</code> de
<em>src/lib.rs</em> et <em>src/main.rs</em> que nous avions utilis√© pour v√©rifier le bon
comportement du programme. Ensuite, dans <em>src/lib.rs</em>, nous allons ajouter un
module <code>tests</code> avec une fonction de test, comme nous l'avions fait dans le
<a href="ch11-01-writing-tests.html">chapitre 11</a><!-- ignore -->. La fonction de test d√©finit le
comportement que nous voulons qu'ait la fonction <code>rechercher</code>¬†: elle va prendre
en arguments une recherche et le texte dans lequel rechercher, et elle va
retourner seulement les lignes du texte qui correspondent √† la recherche.
L'encart 12-15 montre ce test, qui ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_resultat() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
s√©curit√©, rapidit√©, productivit√©.
Obtenez les trois en m√™me temps.&quot;;

        assert_eq!(
            vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;],
            rechercher(recherche, contenu)
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-15: Creating a failing test for the `search`
function we wish we had</span>
-->
<p><span class="caption">Encart 12-15¬†: Cr√©ation d'un test qui √©choue pour la
fonction <code>rechercher</code> que nous souhaitons concevoir</span></p>
<!--
This test searches for the string `"duct"`. The text we‚Äôre searching is three
lines, only one of which contains `"duct"` (Note that the backslash after the
opening double quote tells Rust not to put a newline character at the beginning
of the contents of this string literal). We assert that the value returned from
the `search` function contains only the line we expect.
-->
<p>Ce test recherche la cha√Æne de caract√®res <code>&quot;duct&quot;</code>. Le texte dans lequel nous
recherchons fait trois lignes, et seulement une d'entre elles contient <code>&quot;duct&quot;</code>
(remarquez que l'antislash apr√®s la double-guillet ouvrante indique √† Rust de
ne pas ins√©rer un caract√®re de nouvelle ligne au d√©but du contenu de ce lit√©ral
de cha√Æne de caract√®re). Nous v√©rifions que la valeur retourn√©e par la fonction
<code>rechercher</code> contient seulement la ligne que nous avions pr√©vu.</p>
<!--
We aren‚Äôt able to run this test and watch it fail because the test doesn‚Äôt even
compile: the `search` function doesn‚Äôt exist yet! So now we‚Äôll add just enough
code to get the test to compile and run by adding a definition of the `search`
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn‚Äôt match a vector
containing the line `"safe, fast, productive."`
-->
<p>Nous ne pouvons pas encore ex√©cuter ce test et v√©rifier s'il √©choue car m√™me le
test ne peut pas se compiler¬†: la fonction <code>rechercher</code> n'existe pas encore¬†!
Donc pour le moment nous allons ajouter juste assez de code pour que le test
puisse compiler et s'ex√©cuter en ajoutant une d√©finition de la fonction
<code>rechercher</code> qui retourne un vecteur vide, comme dans l'encart 12-16. Ensuite
le test va compiler et √©chouer car un vecteur vide ne correspond pas au vecteur
qui contient la ligne <code>&quot;s√©curit√©, rapidit√©, productivit√©.&quot;</code></p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-16: Defining just enough of the `search`
function so our test will compile</span>
-->
<p><span class="caption">Encart 12-16¬†: D√©finition du strict minimum de la fonction
<code>rechercher</code> pour que notre test puisse compiler</span></p>
<!--
Notice that we need an explicit lifetime `'a` defined in the signature of
`search` and used with the `contents` argument and the return value. Recall in
[Chapter 10][ch10-lifetimes]<!-- ignore -- > that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument `contents` (rather than the
argument `query`).
-->
<p>Remarquez que nous avons besoin de pr√©ciser explicitement une dur√©e de vie <code>'a</code>
d√©finie dans la signature de <code>rechercher</code> et l'utiliser sur l'argument <code>contenu</code>
et la valeur de retour. Rappelez-vous que dans le
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> nous avions vu que le param√®tre
de dur√©e de vie indique quelle dur√©e de vie d'argument est connect√©e
√† la dur√©e de vie de la valeur de retour. Dans notre cas, nous indiquons que le
vecteur retourn√© devrait contenir des slices de cha√Ænes de caract√®res qui
proviennent des slices de l'argument <code>contenu</code> (et pas de l'argument
<code>recherche</code>).</p>
<!--
In other words, we tell Rust that the data returned by the `search` function
will live as long as the data passed into the `search` function in the
`contents` argument. This is important! The data referenced *by* a slice needs
to be valid for the reference to be valid; if the compiler assumes we‚Äôre making
string slices of `query` rather than `contents`, it will do its safety checking
incorrectly.
-->
<p>Autrement dit, nous disons √† Rust que les donn√©es retourn√©es par la fonction
<code>rechercher</code> vont vivre aussi longtemps que la donn√©e dans l'argument <code>contenu</code>
de la fonction <code>rechercher</code>. C'est tr√®s important¬†! Les donn√©es sur lesquelles
pointent les slices doivent toujours √™tre en vigueur pour que la r√©f√©rence
reste valide¬†; si le compilateur croit que nous cr√©ons des slices de
<code>recherche</code> plut√¥t que de <code>contenu</code>, ses v√©rifications de s√©curit√© seront
incorrectes.</p>
<!--
If we forget the lifetime annotations and try to compile this function, we‚Äôll
get this error:
-->
<p>Si nous oublions les annotations de dur√©e de vie et que nous essayons de
compiler cette fonction, nous allons obtenir cette erreur¬†:</p>
<!--
```console
$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  -- > src/lib.rs:28:51
   |
28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn rechercher(recherche: &amp;str, contenu: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                              ----           ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `recherche` or `contenu`
help: consider introducing a named lifetime parameter
   |
28 | pub fn rechercher&lt;'a&gt;(recherche: &amp;'a str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |                  ++++             ++            ++              ++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<!--
Rust can‚Äôt possibly know which of the two arguments we need, so we need to tell
it. Because `contents` is the argument that contains all of our text and we
want to return the parts of that text that match, we know `contents` is the
argument that should be connected to the return value using the lifetime syntax.
-->
<p>Rust ne peut pas deviner lequel des deux arguments nous allons utiliser, donc
nous devons lui dire. Comme <code>contenu</code> est l'argument qui contient tout notre
texte et que nous voulons retourner des extraits de ce texte qui correspondent √†
la recherche, nous savons que <code>contenu</code> est l'argument qui doit √™tre connect√© √†
la valeur de retour, en utilisant la syntaxe de dur√©e de vie.</p>
<!--
Other programming languages don‚Äôt require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the [‚ÄúValidating
References with Lifetimes‚Äù][validating-references-with-lifetimes]<!-- ignore
-- > section in Chapter 10.
-->
<p>Les autres langages de programmation n'ont pas besoin que vous connectiez les
arguments aux valeurs de retour dans la signature. Bien que cela puisse para√Ætre
√©trange, cela devient plus facile au fil du temps. Vous devriez peut-√™tre
comparer cet exemple √† la
<a href="ch10-03-lifetime-syntax.html">section 3 du chapitre 10</a><!-- ignore -->.</p>
<!--
Now let‚Äôs run the test:
-->
<p>Maintenant, ex√©cutons le test¬†:</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... FAILED

failures:

---- tests::un_resultat stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;s√©curit√©, rapidit√©, productivit√©.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_resultat

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Great, the test fails, exactly as we expected. Let‚Äôs get the test to pass!
-->
<p>Tr√®s bien, le test a √©chou√©, comme nous nous y attendions. Faisons maintenant en
sorte qu'il r√©ussisse¬†!</p>
<!--
### Writing Code to Pass the Test
-->
<h3 id="ecrire-du-code-pour-r√©ussir-au-test"><a class="header" href="#ecrire-du-code-pour-r√©ussir-au-test">Ecrire du code pour r√©ussir au test</a></h3>
<!--
Currently, our test is failing because we always return an empty vector. To fix
that and implement `search`, our program needs to follow these steps:
-->
<p>Pour le moment, notre test √©choue car nous retournons toujours un vecteur vide.
Pour corriger cela et impl√©menter <code>rechercher</code>, notre programme doit suivre les
√©tapes suivantes¬†:</p>
<!--
* Iterate through each line of the contents.
* Check whether the line contains our query string.
* If it does, add it to the list of values we‚Äôre returning.
* If it doesn‚Äôt, do nothing.
* Return the list of results that match.
-->
<ul>
<li>It√©rer sur chacune des lignes de <code>contenu</code>.</li>
<li>V√©rifier si la ligne contient la cha√Æne de caract√®res recherch√©e.</li>
<li>Si c'est le cas, l'ajouter √† la liste des valeurs que nous retournerons.</li>
<li>Si ce n'est pas le cas, ne rien faire.</li>
<li>Retourner la liste des r√©sultats qui ont √©t√© trouv√©s.</li>
</ul>
<!--
Let‚Äôs work through each step, starting with iterating through lines.
-->
<p>Travaillons sur chacune de ces √©tapes, en commen√ßant par l'it√©ration sur les
lignes.</p>
<!--
#### Iterating Through Lines with the `lines` Method
-->
<h4 id="it√©rer-sur-chacune-des-lignes-avec-la-m√©thode-lines"><a class="header" href="#it√©rer-sur-chacune-des-lignes-avec-la-m√©thode-lines">It√©rer sur chacune des lignes avec la m√©thode <code>lines</code></a></h4>
<!--
Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named `lines`, that works as shown in Listing 12-17. Note this
won‚Äôt compile yet.
-->
<p>Rust a une m√©thode tr√®s pratique pour g√©rer l'it√©ration ligne-par-ligne des
cha√Ænes de caract√®res, judicieusement appel√©e <code>lines</code>, qui fonctionne comme dans
l'encart 12-17. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        // faire quelquechose avec ligne ici
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-17: Iterating through each line in `contents`
</span>
-->
<p><span class="caption">Encart 12-17¬†: It√©ration sur chacune des lignes de
<code>contenu</code> </span></p>
<!-- markdownlint-disable -->
<!--
The `lines` method returns an iterator. We‚Äôll talk about iterators in depth in
[Chapter 13][ch13-iterators]<!-- ignore -- >, but recall that you saw this way of using an
iterator in [Listing 3-5][ch3-iter]<!-- ignore -- >, where we used a `for` loop
with an iterator to run some code on each item in a collection.
-->
<!-- markdownlint-restore -->
<p>La m√©thode <code>lines</code> retourne un it√©rateur. Nous verrons plus tard les it√©rateurs
dans le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, mais souvenez-vous que
vous avez vu cette fa√ßon d'utiliser un it√©rateur dans
<a href="ch03-05-control-flow.html">l'encart 3-5</a><!-- ignore -->, dans lequel nous avions utilis√© une
boucle <code>for</code> sur un it√©rateur pour ex√©cuter du code sur chaque √©l√©ment d'une
collection.</p>
<!--
#### Searching Each Line for the Query
-->
<h4 id="trouver-chaque-ligne-correspondante-√†-la-recherche"><a class="header" href="#trouver-chaque-ligne-correspondante-√†-la-recherche">Trouver chaque ligne correspondante √† la recherche</a></h4>
<!--
Next, we‚Äôll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note this still won‚Äôt compile yet.
-->
<p>Ensuite, nous allons v√©rifier que la ligne courante contient la cha√Æne de
caract√®res que nous recherchons. Heureusement, les cha√Ænes de caract√®res ont une
m√©thode <code>contains</code> assez pratique qui fait cela pour nous¬†! Ajoutez l'appel √†
la m√©thode <code>contains</code> dans la fonction <code>rechercher</code>, comme dans l'encart 12-18.
Notez qu'ici non plus nous ne pouvons pas encore compiler.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            // faire quelquechose avec la ligne ici
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in `query`</span>
-->
<p><span class="caption">Encart 12-18¬†: Ajout d'une fonctionnalit√© pour trouver
quelle ligne contient la cha√Æne de caract√®res <code>recherche</code></span></p>
<!--
#### Storing Matching Lines
-->
<h4 id="stocker-les-lignes-trouv√©es"><a class="header" href="#stocker-les-lignes-trouv√©es">Stocker les lignes trouv√©es</a></h4>
<!--
We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the `for` loop and call the `push` method
to store a `line` in the vector. After the `for` loop, we return the vector, as
shown in Listing 12-19.
-->
<p>Nous avons aussi besoin d'un moyen de stocker les lignes qui contiennent la
cha√Æne de caract√®res que nous recherchons. Pour cela, nous pouvons cr√©er un
vecteur mutable avant la boucle <code>for</code> et appeler la m√©thode <code>push</code> pour
enregistrer la <code>ligne</code> dans le vecteur. Apr√®s la boucle <code>for</code>, nous retournons
le vecteur, comme dans l'encart 12-19¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span>
-->
<p><span class="caption">Encart 12-19¬†: Enregistrement des lignes qui sont
trouv√©es afin que nous puissions les retourner</span></p>
<!--
Now the `search` function should return only the lines that contain `query`,
and our test should pass. Let‚Äôs run the test:
-->
<p>Maintenant, notre fonction <code>rechercher</code> retourne uniquement les lignes qui
contiennent <code>recherche</code>, et notre test devrait r√©ussir. Ex√©cutons le test¬†:</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Our test passed, so we know it works!
-->
<p>Notre test a r√©ussi, donc nous savons que cela fonctionne¬†!</p>
<!--
At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn‚Äôt too bad,
but it doesn‚Äôt take advantage of some useful features of iterators. We‚Äôll
return to this example in [Chapter 13][ch13-iterators]<!-- ignore -- >, where we‚Äôll
explore iterators in detail, and look at how to improve it.
-->
<p>Arriv√© √† ce stade, nous pourrions envisager des pistes de remaniement pour
l'impl√©mentation de la fonction de recherche tout en faisant en sorte que les
tests r√©ussissent toujours afin de conserver les m√™mes fonctionnalit√©s. Le code
de la fonction de recherche n'est pas mauvais, mais il ne profite pas de
quelques fonctionnalit√©s utiles des it√©rateurs. Nous retrouverons cet exemple dans
le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, dans lequel nous explorerons
les it√©rateurs en d√©tail, et ainsi d√©couvrir comment nous pourrions l'am√©liorer.</p>
<!--
#### Using the `search` Function in the `run` Function
-->
<h4 id="utiliser-la-fonction-rechercher-dans-la-fonction-run"><a class="header" href="#utiliser-la-fonction-rechercher-dans-la-fonction-run">Utiliser la fonction <code>rechercher</code> dans la fonction <code>run</code></a></h4>
<!--
Now that the `search` function is working and tested, we need to call `search`
from our `run` function. We need to pass the `config.query` value and the
`contents` that `run` reads from the file to the `search` function. Then `run`
will print each line returned from `search`:
-->
<p>Maintenant que la fonction <code>rechercher</code> fonctionne et est test√©e, nous devons
appeler <code>rechercher</code> dans notre fonction <code>run</code>. Nous devons passer √†
<code>rechercher</code> la valeur de <code>config.recherche</code>  et le <code>contenu</code> que <code>run</code> obtient
en lisant le fichier. Ensuite, <code>run</code> devra afficher chaque ligne retourn√©e par
<code>rechercher</code>¬†:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier¬†: src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &'static str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}
# 
# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
#     let mut results = Vec::new();
# 
#     for line in contents.lines() {
#         if line.contains(query) {
#             results.push(line);
#         }
#     }
# 
#     results
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">s√©curit√©, rapidit√©, productivit√©.
</span><span class="boring">Obtenez les trois en m√™me temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;s√©curit√©, rapidit√©, productivit√©.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We‚Äôre still using a `for` loop to return each line from `search` and print it.
-->
<p>Nous utilisons ici aussi une boucle <code>for</code> pour r√©cup√©rer chaque ligne provenant
de <code>rechercher</code> et l'afficher.</p>
<!--
Now the entire program should work! Let‚Äôs try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, ‚Äúfrog‚Äù:
-->
<p>Maintenant, l'int√©gralit√© du programme devrait fonctionner¬†! Essayons-le, pour
commencer avec un mot qui devrait retourner exactement une seule ligne du po√®me
d'Emily Dickinson, ‚Äúfrog‚Äù¬†:</p>
<!--
```console
$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```
-->
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!--
Cool! Now let‚Äôs try a word that will match multiple lines, like ‚Äúbody‚Äù:
-->
<p>Super¬†! Maintenant, essayons un mot qui devrait retourner plusieurs lignes,
comme ‚Äúbody‚Äù¬†:</p>
<!--
```console
$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
And finally, let‚Äôs make sure that we don‚Äôt get any lines when we search for a
word that isn‚Äôt anywhere in the poem, such as ‚Äúmonomorphization‚Äù:
-->
<p>Et enfin, assurons-nous que nous n'obtenons aucune ligne lorsque nous cherchons
un mot qui n'est nulle part dans le po√®me, comme ‚Äúmonomorphization‚Äù¬†:</p>
<!--
```console
$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```
-->
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!--
Excellent! We‚Äôve built our own mini version of a classic tool and learned a lot
about how to structure applications. We‚Äôve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.
-->
<p>Tr√®s bien¬†! Nous avons construit notre propre mini-version d'un outil classique
et nous avons beaucoup appris sur la fa√ßon de structurer nos applications. Nous
en avons aussi appris un peu sur les entr√©es et sorties des fichiers, les
dur√©es de vie, les tests et l'interpr√©tation de la ligne de commande.</p>
<!--
To round out this project, we‚Äôll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you‚Äôre writing command line programs.
-->
<p>Pour cl√¥turer ce projet, nous allons bri√®vement voir comment travailler avec les
variables d'environnement et comment √©crire sur la sortie standard des erreurs,
ce qui peut s'av√©rer utile lorsque vous √©crivez des programmes en ligne de
commande.</p>
<!--
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch12-05-working-with-environment-variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch12-05-working-with-environment-variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
