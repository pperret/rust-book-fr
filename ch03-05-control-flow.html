<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les structures de contr√¥le - Le langage de programmation Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html" class="active"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la visibilit√©</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irr√©cup√©rables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs r√©cup√©rables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types g√©n√©riques, les traits et les dur√©es de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de donn√©es g√©n√©riques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> D√©finir des comportements partag√©s avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment √©crire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> G√©rer l'ex√©cution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> R√©cup√©rer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilit√© interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'√©tat en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caract√©ristiques des langages orient√©s objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non s√©curis√© (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avanc√©s</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avanc√©es</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> D√©velopper un serveur web monot√¢che</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arr√™t propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - les mots-cl√©s</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Control Flow
-->
<h2 id="les-structures-de-contr√¥le"><a class="header" href="#les-structures-de-contr√¥le">Les structures de contr√¥le</a></h2>
<!--
The ability to run some code depending on if a condition is true, or run some
code repeatedly while a condition is true, are basic building blocks in most
programming languages. The most common constructs that let you control the flow
of execution of Rust code are `if` expressions and loops.
-->
<p>Pouvoir ex√©cuter ou non du code si une condition est v√©rifi√©e, ou ex√©cuter du
code de fa√ßon r√©p√©t√©e tant qu'une condition est v√©rifi√©e, sont des
constructions √©l√©mentaires dans la plupart des langages de programmation. Les
structures de contr√¥le les plus courantes en Rust sont les expressions <code>if</code> et
les boucles.</p>
<!--
### `if` Expressions
-->
<h3 id="les-expressions-if"><a class="header" href="#les-expressions-if">Les expressions <code>if</code></a></h3>
<!--
An `if` expression allows you to branch your code depending on conditions. You
provide a condition and then state, ‚ÄúIf this condition is met, run this block
of code. If the condition is not met, do not run this block of code.‚Äù
-->
<p>Une expression <code>if</code> vous permet de diviser votre code en fonction de conditions.
Vous pr√©cisez une condition et vous choisissez ensuite¬†: ‚ÄúSi cette condition est
remplie, alors ex√©cuter ce bloc de code. Si la condition n'est pas remplie,
ne pas ex√©cuter ce bloc de code.‚Äù</p>
<!--
Create a new project called *branches* in your *projects* directory to explore
the `if` expression. In the *src/main.rs* file, input the following:
-->
<p>Cr√©ez un nouveau projet appel√© <em>branches</em> dans votre dossier <em>projects</em> pour
d√©couvrir les expressions <code>if</code>. Dans le fichier <em>src/main.rs</em>, √©crivez ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre &lt; 5 {
        println!(&quot;La condition est v√©rifi√©e&quot;);
    } else {
        println!(&quot;La condition n'est pas v√©rifi√©e&quot;);
    }
}
</code></pre></pre>
<!--
All `if` expressions start with the keyword `if`, followed by a condition. In
this case, the condition checks whether or not the variable `number` has a
value less than 5. We place the block of code to execute if the condition is true
immediately after the condition inside curly brackets. Blocks of code
associated with the conditions in `if` expressions are sometimes called *arms*,
just like the arms in `match` expressions that we discussed in the [‚ÄúComparing
the Guess to the Secret Number‚Äù][comparing-the-guess-to-the-secret-number]<!--
ignore -- > section of Chapter 2.
-->
<p>Une expression <code>if</code> commence par le mot-cl√© <code>if</code>, suivi d'une condition.
Dans notre cas, la condition v√©rifie si oui ou non la variable <code>nombre</code> a une
valeur inf√©rieure √† 5. Nous ajoutons le bloc de code √† ex√©cuter si la condition
est v√©rifi√©e imm√©diatement apr√®s la condition entre des accolades. Les blocs de
code associ√©s √† une condition dans une expression <code>if</code> sont parfois appel√©s des
<em>branches</em>, exactement comme les branches dans les expressions <code>match</code> que nous
avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">‚ÄúComparer le nombre saisi au nombre
secret‚Äù</a><!-- ignore --> du
chapitre 2.</p>
<!--
Optionally, we can also include an `else` expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you don‚Äôt provide an `else` expression and
the condition is false, the program will just skip the `if` block and move on
to the next bit of code.
-->
<p>√âventuellement, vous pouvez aussi ajouter une expression <code>else</code>, ce que nous
avons fait ici, pour pr√©ciser un bloc alternatif de code qui sera ex√©cut√© dans
le cas o√π la condition est fausse (elle n'est pas v√©rifi√©e). Si
vous ne renseignez pas d'expression <code>else</code> et que la condition n'est pas
v√©rifi√©e, le programme va simplement sauter le bloc de <code>if</code> et passer au
prochain morceau de code.</p>
<!--
Try running this code; you should see the following output:
-->
<p>Essayez d'ex√©cuter ce code¬†; vous verrez ceci¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition est v√©rifi√©e
</code></pre>
<!--
Let‚Äôs try changing the value of `number` to a value that makes the condition
`false` to see what happens:
-->
<p>Essayons de changer la valeur de <code>nombre</code> pour une valeur qui rend la condition
non v√©rifi√©e pour voir ce qui se passe¬†:</p>
<!--
```rust,ignore
# fn main() {
    let number = 7;
# 
#     if number < 5 {
#         println!("condition was true");
#     } else {
#         println!("condition was false");
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let nombre = 7;
<span class="boring">
</span><span class="boring">    if nombre &lt; 5 {
</span><span class="boring">        println!(&quot;La condition est v√©rifi√©e&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;La condition n'est pas v√©rifi√©e&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the program again, and look at the output:
-->
<p>Ex√©cutez √† nouveau le programme, et regardez le r√©sultat¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition n'est pas v√©rifi√©e
</code></pre>
<!--
It‚Äôs also worth noting that the condition in this code *must* be a `bool`. If
the condition isn‚Äôt a `bool`, we‚Äôll get an error. For example, try running the
following code:
-->
<p>Il est aussi int√©ressant de noter que la condition dans ce code <em>doit</em> √™tre un
<code>bool</code>. Si la condition n'est pas un <code>bool</code>, nous aurons une erreur. Par
exemple, essayez d'ex√©cuter le code suivant¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombre = 3;

    if nombre {
        println!(&quot;Le nombre √©tait trois&quot;);
    }
}
</code></pre>
<!--
The `if` condition evaluates to a value of `3` this time, and Rust throws an
error:
-->
<p>La condition <code>if</code> vaut <code>3</code> cette fois, et Rust l√®ve une erreur¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 -- > src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if nombre {
  |        ^^^^^^ expected bool, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The error indicates that Rust expected a `bool` but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
`if` with a Boolean as its condition. If we want the `if` code block to run
only when a number is not equal to `0`, for example, we can change the `if`
expression to the following:
-->
<p>Cette erreur explique que Rust attendait un <code>bool</code> mais a obtenu un entier
<em>(integer)</em>. Contrairement √† des langages comme Ruby et JavaScript, Rust
ne va pas essayer de convertir automatiquement les types non bool√©ens en
bool√©ens. Vous devez √™tre pr√©cis et toujours fournir un bool√©en √† la condition
d'un <code>if</code>. Si nous voulons que le bloc de code du <code>if</code> soit ex√©cut√© quand le
nombre est diff√©rent de <code>0</code>, par exemple, nous pouvons changer l'expression <code>if</code>
par la suivante¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre != 0 {
        println!(&quot;Le nombre valait autre chose que z√©ro&quot;);
    }
}
</code></pre></pre>
<!--
Running this code will print `number was something other than zero`.
-->
<p>Ex√©cuter ce code va bien afficher <code>Le nombre valait autre chose que z√©ro</code>.</p>
<!--
#### Handling Multiple Conditions with `else if`
-->
<h4 id="g√©rer-plusieurs-conditions-avec-else-if"><a class="header" href="#g√©rer-plusieurs-conditions-avec-else-if">G√©rer plusieurs conditions avec <code>else if</code></a></h4>
<!--
You can use multiple conditions by combining `if` and `else` in an `else if`
expression. For example:
-->
<p>Vous pouvez utiliser plusieurs conditions en combinant <code>if</code> et <code>else</code> dans une
expression <code>else if</code>. Par exemple¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 6;

    if nombre % 4 == 0 {
        println!(&quot;Le nombre est divisible par 4&quot;);
    } else if nombre % 3 == 0 {
        println!(&quot;Le nombre est divisible par 3&quot;);
    } else if nombre % 2 == 0 {
        println!(&quot;Le nombre est divisible par 2&quot;);
    } else {
        println!(&quot;Le nombre n'est pas divisible par 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<!--
This program has four possible paths it can take. After running it, you should
see the following output:
-->
<p>Ce programme peut choisir entre quatre chemins diff√©rents. Apr√®s l'avoir
ex√©cut√©, vous devriez voir le r√©sultat suivant¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Le nombre est divisible par 3
</code></pre>
<!--
When this program executes, it checks each `if` expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we don‚Äôt see the output `number is divisible by 2`, nor do we
see the `number is not divisible by 4, 3, or 2` text from the `else` block.
That‚Äôs because Rust only executes the block for the first true condition, and
once it finds one, it doesn‚Äôt even check the rest.
-->
<p>Quand ce programme s'ex√©cute, il v√©rifie chaque expression <code>if</code> √† tour de r√¥le
et ex√©cute le premier bloc dont la condition est v√©rifi√©e. Notez que m√™me si 6
est divisible par 2, nous ne voyons pas le message <code>Le nombre est divisible par 2</code>, ni le message <code>Le nombre n'est pas divisible par 4, 3 ou 2</code> du bloc <code>else</code>.
C'est parce que Rust n'ex√©cute que le bloc de la premi√®re condition v√©rifi√©e,
et d√®s lors qu'il en a trouv√© une, il ne va pas chercher √† v√©rifier les
suivantes.</p>
<!--
Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.
-->
<p>Utiliser trop d'expressions <code>else if</code> peut encombrer votre code, donc si vous
en avez plus d'une, vous devriez envisager de remanier votre code. Le chapitre 6
pr√©sente une construction puissante appel√©e <code>match</code> pour de tels cas.</p>
<!--
#### Using `if` in a `let` Statement
-->
<h4 id="utiliser-if-dans-une-instruction-let"><a class="header" href="#utiliser-if-dans-une-instruction-let">Utiliser <code>if</code> dans une instruction <code>let</code></a></h4>
<!--
Because `if` is an expression, we can use it on the right side of a `let`
statement to assign the outcome to a variable, as in Listing 3-2.
-->
<p>Comme <code>if</code> est une expression, nous pouvons l'utiliser √† droite d'une
instruction <code>let</code> pour assigner le r√©sultat √† une variable, comme dans l'encart
3-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let nombre = if condition { 5 } else { 6 };

    println!(&quot;La valeur du nombre est¬†: {}&quot;, nombre);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span>
-->
<p><span class="caption">Encart 3-2¬†: assigner le r√©sultat d'une expression <code>if</code> √†
une variable</span></p>
<!--
The `number` variable will be bound to a value based on the outcome of the `if`
expression. Run this code to see what happens:
-->
<p>La variable <code>nombre</code> va avoir la valeur du r√©sultat de l'expression <code>if</code>.
Ex√©cutez ce code pour d√©couvrir ce qui va se passer¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
La valeur du nombre est¬†: 5
</code></pre>
<!--
Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole `if` expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the `if` must be
the same type; in Listing 3-2, the results of both the `if` arm and the `else`
arm were `i32` integers. If the types are mismatched, as in the following
example, we‚Äôll get an error:
-->
<p>Souvenez-vous que les blocs de code s'ex√©cutent jusqu'√† la derni√®re expression
qu'ils contiennent, et que les nombres tout seuls sont aussi des expressions.
Dans notre cas, la valeur de toute l'expression <code>if</code> d√©pend de quel bloc de code
elle va ex√©cuter. Cela veut dire que chaque valeur qui peut √™tre le r√©sultat de
chaque branche du <code>if</code> doivent √™tre du m√™me type¬†; dans l'encart 3-2, les
r√©sultats des branches <code>if</code> et <code>else</code> sont tous deux des entiers <code>i32</code>. Si
les types ne sont pas identiques, comme dans l'exemple suivant, nous allons
obtenir une erreur¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let nombre = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;La valeur du nombre est¬†: {}&quot;, nombre);
}
</code></pre>
<!--
When we try to compile this code, we‚Äôll get an error. The `if` and `else` arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons une erreur. Les
branches <code>if</code> et <code>else</code> ont des types de valeurs qui ne sont pas compatibles, et
Rust indique exactement o√π trouver le probl√®me dans le programme¬†:</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 -- > src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let nombre = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The expression in the `if` block evaluates to an integer, and the expression in
the `else` block evaluates to a string. This won‚Äôt work because variables must
have a single type, and Rust needs to know at compile time what type the
`number` variable is, definitively. Knowing the type of `number` lets the
compiler verify the type is valid everywhere we use `number`. Rust wouldn‚Äôt be
able to do that if the type of `number` was only determined at runtime; the
compiler would be more complex and would make fewer guarantees about the code
if it had to keep track of multiple hypothetical types for any variable.
-->
<p>L'expression dans le bloc <code>if</code> donne un entier, et l'expression dans le bloc
<code>else</code> donne une cha√Æne de caract√®res. Ceci ne fonctionne pas car les variables
doivent avoir un seul type, et Rust a besoin de savoir de quel type est la
variable <code>nombre</code> au moment de la compilation. Savoir le type de <code>nombre</code>
permet au compilateur de v√©rifier que le type est valable n'importe o√π nous
utilisons <code>nombre</code>. Rust ne serait pas capable de faire cela si le type de
<code>nombre</code> √©tait d√©termin√© uniquement √† l'ex√©cution¬†; car le compilateur
deviendrait plus complexe et nous donnerait moins de garanties sur le code s'il
devait prendre en compte tous les types hypoth√©tiques pour une variable.</p>
<!--
### Repetition with Loops
-->
<h3 id="les-r√©p√©titions-avec-les-boucles"><a class="header" href="#les-r√©p√©titions-avec-les-boucles">Les r√©p√©titions avec les boucles</a></h3>
<!--
It‚Äôs often useful to execute a block of code more than once. For this task,
Rust provides several *loops*, which will run through the code inside the loop
body to the end and then start immediately back at the beginning. To
experiment with loops, let‚Äôs make a new project called *loops*.
-->
<p>Il est parfois utile d'ex√©cuter un bloc de code plus d'une seule fois. Dans ce
but, Rust propose plusieurs types de <em>boucles</em>, qui parcourt le code √†
l'int√©rieur du corps de la boucle jusqu'√† la fin et recommence imm√©diatement du
d√©but. Pour tester les boucles, cr√©ons un nouveau projet appel√© <em>loops</em>.</p>
<!--
Rust has three kinds of loops: `loop`, `while`, and `for`. Let‚Äôs try each one.
-->
<p>Rust a trois types de boucles¬†: <code>loop</code>, <code>while</code>, et <code>for</code>. Essayons chacune
d'elles.</p>
<!--
#### Repeating Code with `loop`
-->
<h4 id="r√©p√©ter-du-code-avec-loop"><a class="header" href="#r√©p√©ter-du-code-avec-loop">R√©p√©ter du code avec <code>loop</code></a></h4>
<!--
The `loop` keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.
-->
<p>Le mot-cl√© <code>loop</code> demande √† Rust d'ex√©cuter un bloc de code encore et encore
jusqu'√† l'infini ou jusqu'√† ce que vous lui demandiez explicitement de
s'arr√™ter.</p>
<!--
As an example, change the *src/main.rs* file in your *loops* directory to look
like this:
-->
<p>Par exemple, changez le fichier <em>src/main.rs</em> dans votre dossier <em>loops</em> comme
ceci¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;√Ä nouveau¬†!&quot;);
    }
}
</code></pre>
<!--
When we run this program, we‚Äôll see `again!` printed over and over continuously
until we stop the program manually. Most terminals support the keyboard shortcut
<span class="keystroke">ctrl-c</span> to interrupt a program that is stuck in
a continual loop. Give it a try:
-->
<p>Quand nous ex√©cutons ce programme, nous voyons <code>√Ä nouveau¬†!</code> s'afficher encore
et encore en continu jusqu'√† ce qu'on arr√™te le programme manuellement. La
plupart des terminaux utilisent un raccourci clavier, <span class="keystroke">
ctrl-c</span>, pour arr√™ter un programme qui est bloqu√© dans une boucle infinie.
Essayons cela¬†:</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-- >
-->
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
√Ä nouveau¬†!
√Ä nouveau¬†!
√Ä nouveau¬†!
√Ä nouveau¬†!
^C√Ä nouveau¬†!
</code></pre>
<!--
The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word `again!` printed after the `^C`,
depending on where the code was in the loop when it received the interrupt
signal.
-->
<p>Le symbole <code>^C</code> repr√©sente le moment o√π vous avez appuy√© sur
<span class="keystroke">ctrl-c</span>. Vous devriez voir ou non le texte
<code>√Ä nouveau¬†!</code> apr√®s le <code>^C</code>, en fonction de l√† o√π la boucle en √©tait dans votre
code quand elle a re√ßu le signal d'arr√™t.</p>
<!--
Fortunately, Rust also provides a way to break out of a loop using code. You
can place the `break` keyword within the loop to tell the program when to stop
executing the loop. Recall that we did this in the guessing game in the
[‚ÄúQuitting After a Correct Guess‚Äù][quitting-after-a-correct-guess]<!-- ignore
-- > section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.
-->
<p>Heureusement, Rust fournit aussi un autre moyen de sortir d'une boucle en
utilisant du code. Vous pouvez ajouter le mot-cl√© <code>break</code> √† l'int√©rieur de la boucle
pour demander au programme d'arr√™ter la boucle. Souvenez-vous que nous avions
fait ceci dans le jeu de devinettes, dans la section <a href="ch02-00-guessing-game-tutorial.html#arr%C3%AAter-le-programme-apr%C3%A8s-avoir-gagn%C3%A9">‚ÄúArr√™ter le programme
apr√®s avoir gagn√©‚Äù</a><!-- ignore --> du chapitre 2
afin de quitter le programme quand l'utilisateur gagne le jeu en devinant le
bon nombre.</p>
<!--
We also used `continue` in the guessing game, which in a loop tells the program
to skip over any remaining code in this iteration of the loop and go to the
next iteration.
-->
<p>Nous avons √©galement <code>continue</code> dans le jeu du plus ou du moins, qui dans une
boucle demande au programme de sauter le code restant dans cette iteration de
la boucle et passer directement √† la prochaine it√©ration.</p>
<!--
If you have loops within loops, `break` and `continue` apply to the innermost
loop at that point. You can optionally specify a *loop label* on a loop that we
can then use with `break` or `continue` to specify that those keywords apply to
the labeled loop instead of the innermost loop. Here‚Äôs an example with two
nested loops:
-->
<p>Si vous avez des boucles imbriqu√©es dans d'autres boucles, <code>break</code> et <code>continue</code>
s'appliquent uniquement √† la boucle au plus bas niveau. Si vous en avez besoin,
vous pouvez associer une <em>etiquette de boucle</em> √† une boucle que nous pouvons
ensuite utiliser en association avec <code>break</code> ou <code>continue</code> pour pr√©ciser que
ces mot-cl√©s s'appliquent sur la boucle correspondant √† l'√©tiquette plut√¥t qu'√†
la boucle la plus proche possible. Voici un exemple avec deux boucles
imbriqu√©es¬†:</p>
<!--
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;
    'increment: loop {
        println!(&quot;compteur = {}&quot;, compteur);
        let mut restant = 10;

        loop {
            println!(&quot;restant = {}&quot;, restant);
            if restant == 9 {
                break;
            }
            if compteur == 2 {
                break 'increment;
            }
            restant -= 1;
        }

        compteur += 1;
    }
    println!(&quot;Fin du compteur = {}&quot;, compteur);
}
</code></pre></pre>
<!--
The outer loop has the label `'counting_up`, and it will count up from 0 to 2.
The inner loop without a label counts down from 10 to 9. The first `break` that
doesn‚Äôt specify a label will exit the inner loop only. The `break
'counting_up;` statement will exit the outer loop. This code prints:
-->
<p>La boucle la plus √† l'ext√©rieur a l'√©tiquette <code>increment</code>, et elle va
incr√©menter de 0 √† 2. La boucle √† l'int√©rieur n'a pas d'√©tiquette et va
d√©crementer de 10 √† 9. Le premier <code>break</code> qui ne pr√©cise pas d'√©tiquette va
arr√™ter uniquement la boucle interne. L'instruction <code>break 'increment;</code> va
arr√™ter la boucle la plus √† l'ext√©rieur. Ce code va afficher¬†:</p>
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
compteur = 0
restant = 10
restant = 9
compteur = 1
restant = 10
restant = 9
compteur = 2
restant = 10
Fin du compteur = 2
</code></pre>
<!--
#### Returning Values from Loops
-->
<h4 id="retourner-des-valeurs-dune-boucle"><a class="header" href="#retourner-des-valeurs-dune-boucle">Retourner des valeurs d'une boucle</a></h4>
<!--
One of the uses of a `loop` is to retry an operation you know might fail, such
as checking whether a thread has completed its job. You might also need to pass
the result of that operation out of the loop to the rest of your code. To do
this, you can add the value you want returned after the `break` expression you
use to stop the loop; that value will be returned out of the loop so you can
use it, as shown here:
-->
<p>L'une des utilisations d'une boucle <code>loop</code> est de r√©essayer une op√©ration qui
peut √©chouer, comme v√©rifier si une t√¢che a termin√© son travail. Vous aurez
aussi peut-√™tre besoin de passer le r√©sultat de l'op√©ration au reste de votre
code √† l'ext√©rieur de cette boucle. Pour ce faire, vous pouvez ajouter la
valeur que vous voulez retourner apr√®s l'expression <code>break</code> que vous utilisez
pour stopper la boucle¬†; cette valeur sera retourn√©e √† l'ext√©rieur de la boucle
pour que vous puissiez l'utiliser, comme ci-dessous¬†:</p>
<!--
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;

    let resultat = loop {
        compteur += 1;

        if compteur == 10 {
            break compteur * 2;
        }
    };

    println!(&quot;Le r√©sultat est {}&quot;, resultat);
}
</code></pre></pre>
<!--
Before the loop, we declare a variable named `counter` and initialize it to
`0`. Then we declare a variable named `result` to hold the value returned from
the loop. On every iteration of the loop, we add `1` to the `counter` variable,
and then check whether the counter is equal to `10`. When it is, we use the
`break` keyword with the value `counter * 2`. After the loop, we use a
semicolon to end the statement that assigns the value to `result`. Finally, we
print the value in `result`, which in this case is 20.
-->
<p>Avant la boucle, nous d√©clarons une variable avec le nom <code>compteur</code> et nous
l'initialisons √† <code>0</code>. Ensuite, nous d√©clarons une variable <code>resultat</code> pour
stocker la valeur retourn√©e de la boucle. √Ä chaque it√©ration de la boucle, nous
ajoutons <code>1</code> √† la variable <code>compteur</code>, et ensuite nous v√©rifions si le compteur
est √©gal √† <code>10</code>. Lorsque c'est le cas, nous utilisons le mot-cl√© <code>break</code> avec la
valeur <code>compteur * 2</code>. Apr√®s la boucle, nous utilisons un point-virgule pour
terminer l'instruction qui assigne la valeur √† <code>resultat</code>. Enfin, nous
affichons la valeur de <code>resultat</code>, qui est 20 dans ce cas-ci.</p>
<!--
#### Conditional Loops with `while`
-->
<h4 id="les-boucles-conditionnelles-avec-while"><a class="header" href="#les-boucles-conditionnelles-avec-while">Les boucles conditionnelles avec <code>while</code></a></h4>
<!--
A program will often need to evaluate a condition within a loop. While the
condition is true, the loop runs. When the condition ceases to be true, the
program calls `break`, stopping the loop. It‚Äôs possible to implement behavior
like this using a combination of `loop`, `if`, `else`, and `break`; you could
try that now in a program, if you‚Äôd like. However, this pattern is so common
that Rust has a built-in language construct for it, called a `while` loop. In
Listing 3-3, we use `while` to loop the program three times, counting down each
time, and then, after the loop, print a message and exit.
-->
<p>Un programme a souvent besoin d'√©valuer une condition dans une boucle.
Tant que la condition est vraie, la boucle tourne. Quand la condition arr√™te
d'√™tre vraie, le programme appelle <code>break</code>, ce qui arr√™te la boucle. Il est
possible d'impl√©menter un comportement comme celui-ci en combinant <code>loop</code>,
<code>if</code>, <code>else</code> et <code>break</code>¬†; vous pouvez essayer de le faire, si vous voulez.
Cependant, cette utilisation est si fr√©quente que Rust a une construction pour
cela, int√©gr√©e dans le langage, qui s'appelle une boucle <code>while</code>. Dans l'encart
3-3, nous utilisons <code>while</code>¬†pour boucler trois fois, en d√©cr√©mentant √† chaque
fois, et ensuite, apr√®s la boucle, il va afficher un message et se fermer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut nombre = 3;

    while nombre != 0 {
        println!(&quot;{}¬†!&quot;, nombre);

        nombre -= 1;
    }

    println!(&quot;D√âCOLLAGE¬†!!!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-3: Using a `while` loop to run code while a
condition holds true</span>
-->
<p><span class="caption">Encart 3-3: utiliser une boucle <code>while</code> pour ex√©cuter du
code tant qu'une condition est vraie</span></p>
<!--
This construct eliminates a lot of nesting that would be necessary if you used
`loop`, `if`, `else`, and `break`, and it‚Äôs clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.
-->
<p>Cette construction √©limine beaucoup d'imbrications qui seraient n√©cessaires si
vous utilisiez <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code>, et c'est aussi plus clair. Tant
que la condition est vraie, le code est ex√©cut√©¬†; sinon, il quitte la boucle.</p>
<!--
#### Looping Through a Collection with `for`
-->
<h4 id="boucler-dans-une-collection-avec-for"><a class="header" href="#boucler-dans-une-collection-avec-for">Boucler dans une collection avec <code>for</code></a></h4>
<!--
You can choose to use the `while` construct to loop over the elements of a
collection, such as an array. For example, the loop in Listing 3-4 prints each
element in the array `a`.
-->
<p>Vous pouvez choisir d'utiliser la construction <code>while</code> pour it√©rer sur les
√©l√©ments d'une collection, comme les tableaux. Par exemple, la boucle dans
l'encart 3-4 affiche chaque √©l√©ment pr√©sent dans le tableau <code>a</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;La valeur est¬†: {}&quot;, a[indice]);

        indice += 1;
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-4: Looping through each element of a collection
using a `while` loop</span>
-->
<p><span class="caption">Encart 3-4¬†: it√©ration sur les √©l√©ments d'une collection
en utilisant une boucle <code>while</code></span></p>
<!--
Here, the code counts up through the elements in the array. It starts at index
`0`, and then loops until it reaches the final index in the array (that is,
when `index < 5` is no longer true). Running this code will print every element
in the array:
-->
<p>Ici, le code parcourt le tableau √©l√©ment par √©l√©ment.
Il commence √† l'indice <code>0</code>, et ensuite boucle jusqu'√† ce qu'il atteigne l'indice
final du tableau (ce qui correspond au moment o√π la condition <code>index &lt; 5</code> n'est
plus vraie). Ex√©cuter ce code va afficher chaque √©l√©ment du tableau¬†:</p>
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
La valeur est¬†: 10
La valeur est¬†: 20
La valeur est¬†: 30
La valeur est¬†: 40
La valeur est¬†: 50
</code></pre>
<!--
All five array values appear in the terminal, as expected. Even though `index`
will reach a value of `5` at some point, the loop stops executing before trying
to fetch a sixth value from the array.
-->
<p>Les cinq valeurs du tableau s'affichent toutes dans le terminal, comme attendu.
M√™me si <code>indice</code> va atteindre la valeur <code>5</code> √† un moment, la boucle arr√™tera de
s'ex√©cuter avant d'essayer de r√©cup√©rer une sixi√®me valeur du tableau.</p>
<!--
However, this approach is error prone; we could cause the program to panic if
the index value or test condition are incorrect. For example, if you changed
the definition of the `a` array to have four elements but forgot to update the
condition to `while index < 4`, the code would panic. It‚Äôs also slow, because
the compiler adds runtime code to perform the conditional check of whether the
index is within the bounds of the array on every iteration through the loop.
-->
<p>Cependant, cette approche pousse √† l'erreur¬†; nous pourrions faire paniquer le
programme si la valeur de l'indice est trop grand ou que la condition du test
est incorrecte. Par exemple, si vous changez la d√©finition du tableau <code>a</code> pour
avoir quatre √©l√©ments, mais que nous oublions de modifier la condition dans
<code>while indice &lt; 4</code>, le code paniquera. De plus, c'est lent, car le compilateur
ajoute du code pour effectuer √† l'ex√©cution la v√©rification que l'indice est
compris dans les limites du tableau, et cela √† chaque it√©ration de la boucle.</p>
<!--
As a more concise alternative, you can use a `for` loop and execute some code
for each item in a collection. A `for` loop looks like the code in Listing 3-5.
-->
<p>Pour une alternative plus concise, vous pouvez utiliser une boucle <code>for</code> et
ex√©cuter du code pour chaque √©l√©ment dans une collection. Une boucle <code>for</code>
s'utilise comme dans le code de l'encart 3-5.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;La valeur est¬†: {}&quot;, element);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-5: Looping through each element of a collection
using a `for` loop</span>
-->
<p><span class="caption">Encart 3-5¬†: it√©rer sur chaque √©l√©ment d'une collection
en utilisant une boucle <code>for</code></span></p>
<!--
When we run this code, we‚Äôll see the same output as in Listing 3-4. More
importantly, we‚Äôve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.
-->
<p>Lorsque nous ex√©cutons ce code, nous obtenons les m√™mes messages que dans
l'encart 3-4. Mais ce qui est plus important, c'est que nous avons am√©lior√© la
s√©curit√© de notre code et √©limin√© le risque de bogues qui pourraient survenir
si on d√©passait la fin du tableau, ou si on n'allait pas jusqu'au bout
et qu'on ratait quelques √©l√©ments.</p>
<!--
Using the `for` loop, you wouldn‚Äôt need to remember to change any other code if
you changed the number of values in the array, as you would with the method
used in Listing 3-4.
-->
<p>En utilisant la boucle <code>for</code>, vous n'aurez pas √† vous rappeler de changer le
code si vous changez le nombre de valeurs dans le tableau, comme vous devriez
le faire dans la m√©thode utilis√©e dans l'encart 3-4.</p>
<!--
The safety and conciseness of `for` loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a `while` loop
in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that
would be to use a `Range`, provided by the standard library, which generates
all numbers in sequence starting from one number and ending before another
number.
-->
<p>La s√©curit√© et la concision de la boucle <code>for</code> en font la construction de boucle
la plus utilis√©e avec Rust. M√™me dans des situations dans lesquelles vous
voudriez ex√©cuter du code plusieurs fois, comme l'exemple du d√©compte qui
utilisait une boucle <code>while</code> dans l'encart 3-3, la plupart des Rustac√©s
utiliseraient une boucle <code>for</code>. Il faut pour cela utiliser un intervalle
<code>Range</code>, fourni par la biblioth√®que standard pour g√©n√©rer dans l'ordre tous les
nombres compris entre un certain nombre et un autre nombre.</p>
<!--
Here‚Äôs what the countdown would look like using a `for` loop and another method
we‚Äôve not yet talked about, `rev`, to reverse the range:
-->
<p>Voici ce que le d√©compte aurait donn√© en utilisant une boucle <code>for</code> et une autre
m√©thode que nous n'avons pas encore vue, <code>rev</code>, qui inverse l'intervalle¬†:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier¬†: src/main.rs</span></p>
<!--
```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    for nombre in (1..4).rev() {
        println!(&quot;{}¬†!&quot;, nombre);
    }
    println!(&quot;D√âCOLLAGE¬†!!!&quot;);
}
</code></pre></pre>
<!--
This code is a bit nicer, isn‚Äôt it?
-->
<p>Ce code est un peu plus sympa, non¬†?</p>
<!--
## Summary
-->
<h2 id="r√©sum√©"><a class="header" href="#r√©sum√©">R√©sum√©</a></h2>
<!--
You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, `if` expressions, and loops!
To practice with the concepts discussed in this chapter, try building
programs to do the following:
-->
<p>Vous y √™tes arriv√©¬†! C'√©tait un chapitre important¬†: vous avez appris les
variables, les types scalaires et compos√©s, les fonctions, les commentaires, les
expressions <code>if</code>, et les boucles¬†!
Pour pratiquer un peu les concepts abord√©s dans ce chapitre, voici quelques
programmes que vous pouvez essayer de cr√©er¬†:</p>
<!--
* Convert temperatures between Fahrenheit and Celsius.
* Generate the nth Fibonacci number.
* Print the lyrics to the Christmas carol ‚ÄúThe Twelve Days of Christmas,‚Äù
  taking advantage of the repetition in the song.
-->
<ul>
<li>Convertir des temp√©ratures entre les degr√©s Fahrenheit et Celsius.</li>
<li>G√©n√©rer le <em>n</em>-i√®me nombre de Fibonacci.</li>
<li>Afficher les paroles de la chanson de No√´l <em>The Twelve Days of Christmas</em> en
profitant de l'aspect r√©p√©titif de la chanson.</li>
</ul>
<!--
When you‚Äôre ready to move on, we‚Äôll talk about a concept in Rust that *doesn‚Äôt*
commonly exist in other programming languages: ownership.
-->
<p>Quand vous serez pr√™t √† aller plus loin, nous aborderons une notion de Rust
qui n'existe <em>pas</em> dans les autres langages de programmation¬†: la possession
<em>(ownership)</em>.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[quitting-after-a-correct-guess]:
ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-04-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-04-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch04-00-understanding-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
    </body>
</html>
